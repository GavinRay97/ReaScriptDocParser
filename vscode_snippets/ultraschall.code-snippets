{
    "ULTRASCHALL.DOCS_CONVERTPLAINTEXTTOHTML lua": {
        "prefix": "ultraschall.Docs_ConvertPlainTextToHTML",
        "scope": "lua",
        "description": "Converts a plaintext into HTML.\nConverts newlines to , Double Spaces to \u00a0\u00a0 and Tabs to\nreturns nil in case of an error\nRETURNS:\nhtml_text:the html-version of the text\n",
        "body": "ultraschall.Docs_ConvertPlainTextToHTML(${1:string String})$0"
    },
    "ULTRASCHALL.DOCS_REMOVEINDENT lua": {
        "prefix": "ultraschall.Docs_RemoveIndent",
        "scope": "lua",
        "description": "unindents an indented text from a US_DocBloc.\nThere are different styles of unindentation:\nas_typed - keeps the text, as it is\nminus_starts_line - will throw away everything from start of the line until(and including) the firt - in it\npreceding_spaces - will remove all spaces/tabs in the beginning of each line\ndefault - will take the indentation of the first line and apply it to each of the following lines\nthat means, indentation relative to the first line is kept\nreturns nil in case of an error\nPARAMETERS:\nString:the string, which shall be unindented\nindenttype:the type of indentation you want to remove\nRETURNS:\nunindented_text:the string, from which the indentation was removed\n",
        "body": "ultraschall.Docs_RemoveIndent(${1:string String},${2:string indenttype})$0"
    },
    "ULTRASCHALL.DOCS_GETALLUSDOCBLOCSFROMSTRING lua": {
        "prefix": "ultraschall.Docs_GetAllUSDocBlocsFromString",
        "scope": "lua",
        "description": "returns all US_DocBloc-elements from a string.\nreturns nil in case of an error\nPARAMETERS:\nString:a string, from which to retrieve the US_DocBlocs\nRETURNS:\nfound_usdocblocs:the individual US_DocBlocs found in the string\nall_found_usdocblocs:the individual US_DocBlocs found in the string\n",
        "body": "ultraschall.Docs_GetAllUSDocBlocsFromString(${1:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_SLUG lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Slug",
        "scope": "lua",
        "description": "returns the slug from an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the slug from\nRETURNS:\nslug:the slug, as stored in the USDocBloc\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Slug(${1:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_TITLE lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Title",
        "scope": "lua",
        "description": "returns the title from an US_DocBloc-element.\nThere can be multiple titles, e.g. in multiple languages\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the title from\nindex:the index of the title to get, starting with 1 for the first title\nRETURNS:\ntitle:the title, as stored in the USDocBloc\nspok_lang:the language, in which the title is stored\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Title(${1:string String},${2:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_DESCRIPTION lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Description",
        "scope": "lua",
        "description": "returns the description-text from an US_DocBloc-element.\nThere can be multiple descriptions, e.g. in multiple languages\nIt will remove automatically indentation(as requested by the description-tag of the US_DocBloc), if unindent_description==true.\nIf no indentation is requested by the description-tag, it will assume default(the indentation of the first line will be applied to all other lines).\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the description from\nunindent_description:true, will remove indentation as given in the description-tag; false, return the text as it is\nindex:the index of the description to get, starting with 1 for the first description\nRETURNS:\ndescription:the description-text found in the USDocBloc in the string\nmarkup_type:the markup-type the description is written in\nmarkup_version:the version of the markup-language, in which the description is written in\nindent:the indentation of the text; can be either\nlanguage:the language, in which the description is written in; \"\", if not set\nprog_lang:the programming-language, in which the description is written in; \", if not set\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Description(${1:string String},${2:boolean unindent_description},${3:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_TARGETDOCUMENT lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_TargetDocument",
        "scope": "lua",
        "description": "returns the target-document from an US_DocBloc-element.\nThe target-document is the document, into which the converted DocBloc shall be stored into.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the target-document-entry from\nRETURNS:\ntarget_document:the target-document, into which the converted US_DocBloc shall be stored into\n",
        "body": "ultraschall.Docs_GetUSDocBloc_TargetDocument(${1:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_SOURCEDOCUMENT lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_SourceDocument",
        "scope": "lua",
        "description": "returns the source-document from an US_DocBloc-element.\nThe source-document is the document, into which the converted DocBloc shall be stored into.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the source-document-entry from\nRETURNS:\nsource_document:the source-document, into which the converted US_DocBloc shall be stored into\n",
        "body": "ultraschall.Docs_GetUSDocBloc_SourceDocument(${1:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_CHAPTERCONTEXT lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_ChapterContext",
        "scope": "lua",
        "description": "returns the chapters and subchapters, in which the US_DocBloc shall be stored into\nA US_DocBloc can have multiple chapter-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the source-document-entry from\nindex:the index of the chapter-entries, starting with 1 for the first\nRETURNS:\ncount:the number of chapters found\nchapters:the chapternams as an array\nspok_lang:the language of the chapters; \"\", if no language is given\n",
        "body": "ultraschall.Docs_GetUSDocBloc_ChapterContext(${1:string String},${2:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_TAGS lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Tags",
        "scope": "lua",
        "description": "returns the tags of an US_DocBloc-entry\nA US_DocBloc can have multiple tag-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the tags-entry from\nindex:the index of the tags-entries, starting with 1 for the first\nRETURNS:\ncount:the number of tags found\ntags:the tags as an array\nspok_lang:the language of the tags; \"\" if no language is given\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Tags(${1:string String},${2:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_PARAMS lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Params",
        "scope": "lua",
        "description": "returns the parameters of an US_DocBloc-entry\nA US_DocBloc can have multiple parameter-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the parameter-entry from\nunindent_description:true, will remove indentation as given in the parameter-tag; false, return the text as it is\nindex:the index of the parameter-entries, starting with 1 for the first\nRETURNS:\nparmcount:the number of parameters found\nParams:all parameters found, as an array\nmarkuptype:the markuptype found; if no markuptype is given, it returns \"plaintext\"\nmarkupversion:the version of the markuptype found; \"\", if not given\nprog_lang:the programming-language used in these parameters; \"\", if not given\nspok_lang:the spoken-language used in these parameters; \"\", if not given\nindent:the type of indentation you want to remove\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Params(${1:string String},${2:boolean unindent_description},${3:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_RETVALS lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Retvals",
        "scope": "lua",
        "description": "returns the retvals of an US_DocBloc-entry\nA US_DocBloc can have multiple retvals-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the retvals-entry from\nunindent_description:true, will remove indentation as given in the retvals-tag; false, return the text as it is\nindex:the index of the retvals-entries, starting with 1 for the first\nRETURNS:\nretvalscount:the number of retvals found\nretvals:all retvals found, as an array\nmarkuptype:the markuptype found; if no markuptype is given, it returns \"plaintext\"\nmarkupversion:the version of the markuptype found; \"\", if not given\nprog_lang:the programming-language used in these retvals; \"\", if not given\nspok_lang:the spoken-language used in these retvals; \"\", if not given\nindent:the type of indentation you want to remove\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Retvals(${1:string String},${2:boolean unindent_description},${3:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_FUNCTIONCALL lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Functioncall",
        "scope": "lua",
        "description": "returns the functioncall-entries from an US_DocBloc-element\nThere can be multiple functioncall-entries, e.g. for multiple programming-languages\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the functioncall-entry from\nindex:the index of the functioncall, if there are multiple ones; beginning with 1\nRETURNS:\nfunctioncall:the functioncall, as stored in the USDocBloc\nprog_lang:the used programming language\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Functioncall(${1:string String},${2:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_REQUIRES lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_Requires",
        "scope": "lua",
        "description": "returns the requires-entries from an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the requires-entry from\nRETURNS:\ncount:the number of required elements found in the require-tag\nrequires:like requires, but the index is the required element, while the value is the versionnumber, e.g requires_alt[\"Reaper\"]=\"5.978\"\nrequires_alt:like requires, but the index is the required element, while the value is the versionnumber, e.g requires_alt[\"Reaper\"]=\"5.978\"\n",
        "body": "ultraschall.Docs_GetUSDocBloc_Requires(${1:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_PREVIOUSCHAPTER lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_PreviousChapter",
        "scope": "lua",
        "description": "returns the slug of the previous chapter of an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the slug of the previous chapter from\nRETURNS:\nprevious_chapter:the slug of the previous-chapter, as stored in the USDocBloc\n",
        "body": "ultraschall.Docs_GetUSDocBloc_PreviousChapter(${1:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_NEXTCHAPTER lua": {
        "prefix": "ultraschall.Docs_GetUSDocBloc_NextChapter",
        "scope": "lua",
        "description": "returns the slug of the next chapter of an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the slug of the next chapter from\nRETURNS:\nnext_chapter:the slug of the next-chapter, as stored in the USDocBloc\n",
        "body": "ultraschall.Docs_GetUSDocBloc_NextChapter(${1:string String})$0"
    },
    "ULTRASCHALL.COUNTPROJECTTABS lua": {
        "prefix": "ultraschall.CountProjectTabs",
        "scope": "lua",
        "description": "Counts the number of opened project tabs.\nRETURNS:\nnumber_of_projecttabs:the number of projecttabs currently opened\n",
        "body": "ultraschall.CountProjectTabs()$0"
    },
    "ULTRASCHALL.GETPROJECT_TABS lua": {
        "prefix": "ultraschall.GetProject_Tabs",
        "scope": "lua",
        "description": "Returns the ReaProject-objects, as well as the filenames of all opened project-tabs.\nRETURNS:\nnumber_of_projecttabs:the number of projecttabs currently opened\nprojecttablist:an array, that holds all ReaProjects as well as the projectfilenames\n",
        "body": "ultraschall.GetProject_Tabs()$0"
    },
    "ULTRASCHALL.GETAPIVERSION lua": {
        "prefix": "ultraschall.GetApiVersion",
        "scope": "lua",
        "description": "returns the version, release-date and if it's a beta-version plus the currently installed hotfix\nRETURNS:\nversionnumber:a number, that you can use for comparisons like, \"if requestedversion>versionnumber then\"\nmajorversion:the current Api-major-version\ndate:the release-date of the currently installed hotfix ($ResourceFolder/ultraschall_api/ultraschall_hotfixes.lua); XX_XXX_XXXX if no hotfix is installed currently\nsubversion:a subversion-number of a major-version\ntagline:the tagline of the current release\nbuildnumber:the build-number of the current release\n",
        "body": "ultraschall.GetApiVersion()$0"
    },
    "ULTRASCHALL.SUPPRESSERRORMESSAGES lua": {
        "prefix": "ultraschall.SuppressErrorMessages",
        "scope": "lua",
        "description": "Allows you to suppress error-messages.\nIf you pass true, all error messages will be suppressed, until you run the function again passing false.\nNote: You should supress error-messages only temprarily and \"unsuppress\" them again, after your critical stuff is finished.\nOtherwise, someone using your functions will have no error-messages to debug with.\nReturns false, if parameter isn't boolean. Unlike most other function, this will never create an error-message!\nPARAMETERS:\nflag:true, suppress error-messages; false, don't suppress error-messages\nRETURNS:\nretval:true, setting was successful; false, you didn't pass a boolean as parameter\n",
        "body": "ultraschall.SuppressErrorMessages(${1:boolean flag})$0"
    },
    "ULTRASCHALL.ADDERRORMESSAGE lua": {
        "prefix": "ultraschall.AddErrorMessage",
        "scope": "lua",
        "description": "Adds a new errormessage to the Ultraschall-Api-Error-messagesystem. Returns the number of the errormessage.\nIntended for your own 3rd party-functions for the API, to give the user more feedback about errors than just a cryptic errorcode.\nreturns false in case of failure\nPARAMETERS:\nfunctionname:the function, where the error happened\nparametername:the parameter, that caused the problem\nerrormessage:a longer description of what cause the problem and a hint to a possible solution\nerrorcode:a number, that represents the error-message. Will be -1 by default, if not given.\nRETURNS:\nretval:true, if it worked; false if it didn't\nerrorcount:the number of the errormessage within the Ultraschall-Api-Error-messagesystem; nil, if errormessages are suppressed currently\n",
        "body": "ultraschall.AddErrorMessage(${1:string functionname},${2:string parametername},${3:string errormessage},${4:integer errorcode})$0"
    },
    "ULTRASCHALL.TOGGLEIDE_ERRORMESSAGES lua": {
        "prefix": "ultraschall.ToggleIDE_Errormessages",
        "scope": "lua",
        "description": "Toggles or sets, if the error-messaging system shall output it's errors to Reaper's IDE(true) or not(false).\nWhen set true, it will show the errormessages at the bottom of the IDE, as you are used by Reaper's own functions.\nPARAMETERS:\ntogglevalue:true, if errormessages shall be shown at the bottom of the IDE, false if not. If omitted, it toggles what was set before.\nRETURNS:\nretval:true, if errors will be shown at the bottom of the IDE; false, if not\n",
        "body": "ultraschall.ToggleIDE_Errormessages(${1:optional boolean togglevalue})$0"
    },
    "ULTRASCHALL.READERRORMESSAGE lua": {
        "prefix": "ultraschall.ReadErrorMessage",
        "scope": "lua",
        "description": "Reads an error-message within the Ultraschall-ErrorMessagesystem.\nReturns a boolean value, the functionname, the errormessage, the \"you've already read this message\"-status, the date and a timestamp of the creation of the errormessage.\nreturns false in case of failure\nPARAMETERS:\nerrornumber:the number of the error, beginning with 1. Use CountErrorMessages to get the current number of error-messages.\nRETURNS:\nretval:true, if it worked; false if it didn't\nerrcode:the errorcode of this message, as set by the function that created this errormessage; -1 is default value\nfunctionname:the name of the function, where the problem happened\nparmname:the parameter, that was used wrong by the programmer; \"\" if no parameter was involved in this error\nerrormessage:the message of the problem with a possible hint to a solution\nerr_creation_date:the date_time of when the error-message was created\nerr_creation_timestamp:the timestamp of when the error-message was created. Usually seconds, since system got started\n",
        "body": "ultraschall.ReadErrorMessage(${1:integer errornumber})$0"
    },
    "ULTRASCHALL.DELETEERRORMESSAGE lua": {
        "prefix": "ultraschall.DeleteErrorMessage",
        "scope": "lua",
        "description": "Deletes an error-message within the Ultraschall-ErrorMessagesystem.\nreturns false in case of failure\nPARAMETERS:\nerrornumber:the number of the error to delete, beginning with 1. Use CountErrorMessages to get the current number of error-messages.\nRETURNS:\nretval:true, if such an error exists; false if it didn't\n",
        "body": "ultraschall.DeleteErrorMessage(${1:integer errornumber})$0"
    },
    "ULTRASCHALL.GETLASTERRORMESSAGE lua": {
        "prefix": "ultraschall.GetLastErrorMessage",
        "scope": "lua",
        "description": "Reads the last error-message stored in the Ultraschall-ErrorMessagesystem.\nReturns a boolean value, the functionname, the errormessage, the date and a timestamp of the creation of the errormessage, the unread-status as well as the error-message-number.\nreturns false in case of failure\nRETURNS:\nretval:true, if it worked; false if it didn't\nerrcode:the errorcode of this message, as set by the function that created this errormessage; -1 is default value\nfunctionname:the name of the function, where the problem happened\nparmname:the parameter, that was used wrong by the programmer; \"\" if no parameter was involved in this error\nerrormessage:the message of the problem with a possible hint to a solution\nerr_creation_date:the date_time of when the error-message was created\nerr_creation_timestamp:the timestamp of when the error-message was created. Usually seconds, since system got started\nerrorcounter:the error-message-number within the Ultraschall-Error-Message-System\n",
        "body": "ultraschall.GetLastErrorMessage()$0"
    },
    "ULTRASCHALL.DELETELASTERRORMESSAGE lua": {
        "prefix": "ultraschall.DeleteLastErrorMessage",
        "scope": "lua",
        "description": "Deletes the last error-message and returns a boolean value.\nreturns false in case of failure\nRETURNS:\nretval:true, if it worked; false if it didn't\n",
        "body": "ultraschall.DeleteLastErrorMessage()$0"
    },
    "ULTRASCHALL.DELETEALLERRORMESSAGES lua": {
        "prefix": "ultraschall.DeleteAllErrorMessages",
        "scope": "lua",
        "description": "Deletes all error-messages and returns a boolean value.\nreturns false in case of failure\nRETURNS:\nretval:true, if it worked; false if it didn't\n",
        "body": "ultraschall.DeleteAllErrorMessages()$0"
    },
    "ULTRASCHALL.GETLASTERRORMESSAGE2 lua": {
        "prefix": "ultraschall.GetLastErrorMessage2",
        "scope": "lua",
        "description": "Returns an array with the last \"count\" errormessages. 1 for the last, 2 for the last 2, etc.\nSet setread to false, if you want to retain the unread status of the error-messages.\nreturns false in case of failure\nPARAMETERS:\ncount:the number of the last few errors, you want to get returned. Use CountErrorMessages to get the current number of error-messages.\nRETURNS:\nretval:true, if it worked; false if it didn't\nErrorMessages:an array, that contains all values for the chosen number of errormessages.\n",
        "body": "ultraschall.GetLastErrorMessage2(${1:integer count},${2:boolean setread})$0"
    },
    "ULTRASCHALL.COUNTERRORMESSAGES lua": {
        "prefix": "ultraschall.CountErrorMessages",
        "scope": "lua",
        "description": "Returns the current count of errormessages in the system available.\nRETURNS:\nerrorcounter:the number of errormessages currently available in the error-message-system. Includes read and unread ones.\n",
        "body": "ultraschall.CountErrorMessages()$0"
    },
    "ULTRASCHALL.SHOWLASTERRORMESSAGE lua": {
        "prefix": "ultraschall.ShowLastErrorMessage",
        "scope": "lua",
        "description": "Displays the last error message in a messagebox, if existing and unread.\n",
        "body": "ultraschall.ShowLastErrorMessage()$0"
    },
    "ULTRASCHALL.GETLASTERRORMESSAGE_FUNCNAME lua": {
        "prefix": "ultraschall.GetLastErrorMessage_Funcname",
        "scope": "lua",
        "description": "Returns the last errormessage, a certain function added to the Error-Messaging-System.\nSets read-state of the error-message to the date-time of accessing it.\nreturns -1 in case of error\nPARAMETERS:\nfunctionname:the name of the function, whose last error message you want to retrieve\nRETURNS:\nerrorindex:the index of the error within the Error-Messaging-System\nparametername:the parameter that produced the problem, or \"\" if no parameter was involved\nerrormessage:the errormessage\nerrorcode:the errorcode the error has\n",
        "body": "ultraschall.GetLastErrorMessage_Funcname(${1:string functionname})$0"
    },
    "ULTRASCHALL.COUNTERRORMESSAGE_FUNCNAME lua": {
        "prefix": "ultraschall.CountErrorMessage_Funcname",
        "scope": "lua",
        "description": "Returns the number of available errormessages for functionname, existing in the Error-Messaging-System.\nreturns -1 in case of error\nPARAMETERS:\nfunctionname:the name of the function, whose error messages you want to count\nRETURNS:\nnumber_of_errormessages:the number of errormessages functionname has left in the Error-Messaging-System\n",
        "body": "ultraschall.CountErrorMessage_Funcname(${1:string functionname})$0"
    },
    "ULTRASCHALL.GETERRORMESSAGE_FUNCNAME lua": {
        "prefix": "ultraschall.GetErrorMessage_Funcname",
        "scope": "lua",
        "description": "Returns a specific errormessage specified by index, functionname added to the Error-Messaging-System.\nSets read-state of the error-message to the date-time of accessing it.\nreturns -1 in case of error\nPARAMETERS:\nfunctionname:the name of the function, whose last error message you want to retrieve\nindex:the index of the error-message for functionname\nRETURNS:\nerrorindex:the index of the error within the Error-Messaging-System\nparametername:the parameter that produced the problem, or \"\" if no parameter was involved\nerrormessage:the errormessage\nerrorcode:the errorcode the error has\n",
        "body": "ultraschall.GetErrorMessage_Funcname(${1:string functionname},${2:integer index})$0"
    },
    "ULTRASCHALL.SHOWERRORMESSAGESINREASCRIPTCONSOLE lua": {
        "prefix": "ultraschall.ShowErrorMessagesInReascriptConsole",
        "scope": "lua",
        "description": "Sets, if errormessages shall be shown in the ReaScript-Console immediately, when they happen.\nWill show functionname, parametername, errorcode plus errormessage and the time the error has happened.\nPARAMETERS:\nstate:true, show error-messages in the ReaScript-Console when they happen; false, don't show errormessages\n",
        "body": "ultraschall.ShowErrorMessagesInReascriptConsole(${1:boolean state})$0"
    },
    "ULTRASCHALL.WINTERLYSNOWFLAKES lua": {
        "prefix": "ultraschall.WinterlySnowflakes",
        "scope": "lua",
        "description": "Exchanges the gfx.update()-function with a variant, that displays falling snowflakes everytime it is called.\nreturns -1 in case of error\nPARAMETERS:\ntoggle:true, toggles falling snow on; false, toggles falling snow off\nfalling_speed:the falling speed of the snowflakes, 1.3 is recommended\nnumber_snowflakes:the number of falling snowflakes at the same time on screen; 2000 is recommended\nRETURNS:\nretval:returns -1 in case of a'JS_Window_ListFind' n error; 1, in case of success\n",
        "body": "ultraschall.WinterlySnowflakes(${1:boolean toggle},${2:number falling_speed},${3:integer number_snowflakes})$0"
    },
    "ULTRASCHALL.CHECKACTIONCOMMANDIDFORMAT lua": {
        "prefix": "ultraschall.CheckActionCommandIDFormat",
        "scope": "lua",
        "description": "Checks, whether an action command id is a valid commandid(which is a number) or a valid _action_command_id (which is a string with an _underscore in the beginning).\nDoes not check, whether this action_command_id is a useable one, only if it's \"syntax\" is correct!\nreturns falsein case of an error\nPARAMETERS:\n:the ActionCommandID you want to check; either a number or an action_command_id with an underscore at the beginning\nRETURNS:\nretval:true, valid action_command_id; false, not a valid action_command_id\n",
        "body": "ultraschall.CheckActionCommandIDFormat(${1:action_command_id})$0"
    },
    "ULTRASCHALL.RUNCOMMAND lua": {
        "prefix": "ultraschall.RunCommand",
        "scope": "lua",
        "description": "runs a command by its ActionCommandID(instead of the CommandID-number)\nreturns -1 in case of error\nPARAMETERS:\nactioncommand_id:the ActionCommandID of the Command/Script/Action you want to run; must be either a number or the ActionCommandID beginning with an underscore _\nRETURNS:\nretval:-1, in case of error\n",
        "body": "ultraschall.RunCommand(${1:string actioncommand_id})$0"
    },
    "ULTRASCHALL.CONVERTSTRINGTOBITS lua": {
        "prefix": "ultraschall.ConvertStringToBits",
        "scope": "lua",
        "description": "converts a string into its bit-representation and returns that as a handy table\nreturns -1 in case of an error\nPARAMETERS:\nmessage:the string, which you want to convert into its bit representation\nRETURNS:\nnumber_of_bits:the number of bits in the string, -1, in case of an error\nbitarray:the individual bits as a handy table\n",
        "body": "ultraschall.ConvertStringToBits(${1:string message})$0"
    },
    "ULTRASCHALL.CONVERTBITSTOSTRING lua": {
        "prefix": "ultraschall.ConvertBitsToString",
        "scope": "lua",
        "description": "converts a table of bit-representation into a string\nEvery entry in the table must be either 0 or 1. If there are too few bits to fill up a byte, the missing bits will be seen as trailing 0-bits.\nreturns nil in case of an error\nPARAMETERS:\nbitarray:the individual bits in a table, which will be converted into a string-representation\nRETURNS:\nmessage:the converted bits as string-representation\n",
        "body": "ultraschall.ConvertBitsToString(${1:array bitarray})$0"
    },
    "ULTRASCHALL.DEPRECATED lua": {
        "prefix": "ultraschall.deprecated",
        "scope": "lua",
        "description": "If you have a 3rd-party function added to Ultraschall-API, which you want to deprecate, use this\nfunction to show a warning message, if that function is used.\nIt will be shown once when running the script, after (re-)start of Reaper.\nThat way, you can tell scripters, whether they need to update their scripts using newer/better functions.\nThis is probably shown first to the user, who knows that way a potential problem and can tell the scripter about that.\nIf there is a line \"Author: authorname\" in the file(as usual for ReaPack-compatible scripts), it will show the scripter's name in the dialog.\n",
        "body": "ultraschall.deprecated(${1:string functionname})$0"
    },
    "ULTRASCHALL.FLOATCOMPARE lua": {
        "prefix": "ultraschall.FloatCompare",
        "scope": "lua",
        "description": "Compares two floatvalues and allows to set the precision to copmare against.\nSo, if you want to compare 5.1 and 5.2, using precision=0.2 returns true(is equal), precision=0.1 returns false(isn't equal).\nReturns nil in case of failure.\nPARAMETERS:\na:the first float-number to compare\nb:the precision of the fraction, like 0.1 or 0.0063\nprecision:the precision of the fraction, like 0.1 or 0.0063\nRETURNS:\nretval:true, numbers are equal; false, numbers aren't equal\ndiff:the difference between numbers a and b\n",
        "body": "ultraschall.FloatCompare(${1:number a},${2:number b},${3:number precision})$0"
    },
    "ULTRASCHALL.ESCAPEMAGICCHARACTERS_STRING lua": {
        "prefix": "ultraschall.EscapeMagicCharacters_String",
        "scope": "lua",
        "description": "Escapes the magic characters(needed for pattern matching), so the string can be fed as is into string.match-functions.\nThat way, characters like . or - or * etc do not trigger pattern-matching behavior but are used as regular . or - or * etc.\nreturns nil in case of an error\nPARAMETERS:\nsourcestring:the string, whose magic characters you want to escape for future use\nRETURNS:\nescaped_string:the string with all magic characters escaped\n",
        "body": "ultraschall.EscapeMagicCharacters_String(${1:string sourcestring})$0"
    },
    "ULTRASCHALL.ACTIONSLIST_GETSELECTEDACTIONS lua": {
        "prefix": "ultraschall.ActionsList_GetSelectedActions",
        "scope": "lua",
        "description": "returns the selected entries from the actionlist, when opened.\nThe order of the tables of found actions, ActionCommandIDs and ToggleStates is the same in all of the three tables.\nThey also reflect the order of userselection in the ActionList itself from top to bottom of the ActionList.\nreturns -1 in case of an error\nRETURNS:\nnum_found_actions:the number of selected actions; -1, if not opened\nsectionID:the id of the section, from which the selected actions are from\nsectionName:the name of the selected section\nselected_actions:the texts of the found actions as a handy table\nCmdIDs:the ActionCommandIDs of the found actions as a handy table; all of them are strings, even the numbers, but can be converted using Reaper's own function reaper.NamedCommandLookup\nToggleStates:the current toggle-states of the selected actions; 1, on; 0, off; -1, no such toggle state available\n",
        "body": "ultraschall.ActionsList_GetSelectedActions()$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDEROUTPUTPATH lua": {
        "prefix": "ultraschall.GetProject_RenderOutputPath",
        "scope": "lua",
        "description": "returns the output-directory for rendered files of a project.\nDoesn't return the correct output-directory for queued-projects!\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename with path, whose renderoutput-directories you want to know\nRETURNS:\nrender_output_directory:the output-directory for projects\n",
        "body": "ultraschall.GetProject_RenderOutputPath(${1:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.RESOLVERENDERPATTERN lua": {
        "prefix": "ultraschall.ResolveRenderPattern",
        "scope": "lua",
        "description": "resolves a render-pattern into its render-filename(without extension).\nreturns nil in case of an error\nPARAMETERS:\nrender_pattern:the render-pattern, that you want to resolve into its render-filename\nRETURNS:\nresolved_renderpattern:the resolved renderpattern, that is used for a render-filename.\n",
        "body": "ultraschall.ResolveRenderPattern(${1:string render_pattern})$0"
    },
    "ULTRASCHALL.SETREASCRIPTCONSOLE_FONTSTYLE lua": {
        "prefix": "ultraschall.SetReaScriptConsole_FontStyle",
        "scope": "lua",
        "description": "If the ReaScript-console is opened, you can change the font-style of it.\nYou can choose between 19 different styles, with 3 being of fixed character length. It will change the next time you output text to the ReaScriptConsole.\nIf you close and reopen the Console, you need to set the font-style again!\nYou can only have one style active in the console!\nReturns false in case of an error\nRETURNS:\nretval:true, displaying was successful; false, displaying wasn't successful\n",
        "body": "ultraschall.SetReaScriptConsole_FontStyle(${1:integer style})$0"
    },
    "ULTRASCHALL.READSUBTITLES_VTT lua": {
        "prefix": "ultraschall.ReadSubtitles_VTT",
        "scope": "lua",
        "description": "parses a webvtt-subtitle-file and returns its contents as table\nreturns nil in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the webvtt-file\nRETURNS:\nKind:the type of the webvtt-file, like: captions\nLanguage:the language of the webvtt-file\nCaptions_Counter:the number of captions in the file\nCaptions:the Captions as a table of the format:\n",
        "body": "ultraschall.ReadSubtitles_VTT(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.GFX_DRAWTHICKROUNDRECT lua": {
        "prefix": "ultraschall.GFX_DrawThickRoundRect",
        "scope": "lua",
        "description": "draws a round-rectangle with a custom thickness.\nYou shouldn't redraw with it too often, as it eats many ressources\nreturns false in case of an error\nPARAMETERS:\nx:the x position of the rectangle\ny:the y position of the rectangle\nw:the width of the rectangle\nh:the thickness of the rectangle's edges\nthickness:the thickness of the rectangle's edges\nroundness:the angle of the rectangle's corners\nantialias:true, draw antialiased; false, simply draw aliased\nRETURNS:\nretval:true, drawing was successful; false, drawing wasn't successful\n",
        "body": "ultraschall.GFX_DrawThickRoundRect(${1:integer x},${2:integer y},${3:integer w},${4:integer h},${5:number thickness},${6:number roundness},${7:boolean antialias})$0"
    },
    "ULTRASCHALL.GFX_BLITFRAMEBUFFER lua": {
        "prefix": "ultraschall.GFX_BlitFramebuffer",
        "scope": "lua",
        "description": "blits a framebuffer at position 0,0. If the gfx-window is smaller than the contents of the framebuffer, it will resize it before blitting to window size, retaining the correct aspect-ratio.\nMostly intended for debugging-purposes, when you want to track, if a certain framebuffer contains, what you expect it to contain.\nreturns false in case of an error\nPARAMETERS:\nframebufferidx:the indexnumber of the framebuffer to blit; 0 to 1023; -1 is the displaying framebuffer\nshowidx:true, displays the id-number of the framebuffer in the top-left corner; false, does not display framebuffer-idx\nRETURNS:\nretval:true, drawing was successful; false, drawing wasn't successful\n",
        "body": "ultraschall.GFX_BlitFramebuffer(${1:integer framebufferidx},${2:optional boolean showidx})$0"
    },
    "ULTRASCHALL.GFX_INIT lua": {
        "prefix": "ultraschall.GFX_Init",
        "scope": "lua",
        "description": "Opens a new graphics window and returns its HWND-windowhandler object.\nPARAMETERS:\n\"name\":the name of the window, which will be shown in the title of the window\nwidth: the width of the window; minmum is 50\nheight: the height of the window; minimum is 16\ndockstate:&1=0, undocked; &1=1, docked\nxpos:x-position of the window in pixels; minimum is -80; nil, to center it horizontally\nypos:y-position of the window in pixels; minimum is -15; nil, to center it vertically\nRETURNS:\nretval: 1.0, if window is opened\nhwnd:the window-handler of the newly created window; can be used with JS_Window_xxx-functions of the JS-extension-plugin\n",
        "body": "ultraschall.GFX_Init(${1:string \"name\"},${2:optional integer width},${3:optional integer height},${4:optional integer dockstate},${5:optional integer xpos},${6:optional integer ypos})$0"
    },
    "ULTRASCHALL.GFX_GETWINDOWHWND lua": {
        "prefix": "ultraschall.GFX_GetWindowHWND",
        "scope": "lua",
        "description": "Returns the HWND of the currently opened gfx-window. You need to use ultraschall.GFX_Init(), otherwise\nit will contain the message \"Please, use ultraschall.GFX_Init() for window-creation, not gfx.init(!), to retrieve the HWND of the gfx-window.\"\nRETURNS:\nhwnd:the window-handler of the opened gfx-window; will contain a helpermessage, if you didn't use ultraschall.GFX_Init() for window creation.\n",
        "body": "ultraschall.GFX_GetWindowHWND()$0"
    },
    "ULTRASCHALL.GFX_GETMOUSECAP lua": {
        "prefix": "ultraschall.GFX_GetMouseCap",
        "scope": "lua",
        "description": "Checks mouseclick/wheel-behavior, since last time calling this function and returns it's state.\nAllows you to get click, doubleclick, dragging, including the appropriate coordinates and mousewheel-states.\nMuch more convenient, than fiddling around with gfx.mouse_cap\nNote: After doubleclicked, this will not return mouse-clicked-states, until the mouse-button is released. So any mouse-clicks during that can be only gotten from the retval mouse_cap.\nThis is to prevent automatic mouse-dragging after double-clicks.\nPARAMETERS:\ndoubleclick_wait:the timeframe, in which a second click is recognized as double-click, in defer-cycles. 30 is approximately 1 second; nil, will use 15(default)\ndrag_wait:the timeframe, after which a mouseclick without moving the mouse is recognized as dragging, in defer-cycles. 30 is approximately 1 second; nil, will use 5(default)\nRETURNS:\nclickstate:either \"\" for not clicked, \"CLK\" for clicked, \"DBLCLK\" for doubleclick or \"DRAG\" for dragging\nspecific_clickstate:either \"\" for not clicked, \"CLK\" for clicked, \"DBLCLK\" for doubleclick or \"DRAG\" for dragging\nmouse_cap:the mouse_cap, a bitfield of mouse and keyboard modifier states\nclick_x:the x position, when the mouse has been clicked the last time\nclick_y:the y position, when the mouse has been clicked the last time\ndrag_x:the x-position of the mouse-dragging-coordinate; is like click_x for non-dragging mousestates\ndrag_y:the y-position of the mouse-dragging-coordinate; is like click_y for non-dragging mousestates\nmouse_wheel:the mouse_wheel-delta, since the last time calling this function\nmouse_hwheel:the mouse_horizontal-wheel-delta, since the last time calling this function\n",
        "body": "ultraschall.GFX_GetMouseCap(${1:optional integer doubleclick_wait},${2:optional integer drag_wait})$0"
    },
    "ULTRASCHALL.GFX_SETFONT lua": {
        "prefix": "ultraschall.GFX_SetFont",
        "scope": "lua",
        "description": "Sets the font of the gfx-window.\nAs Mac and Windows have different visible font-sizes for the same font-size, this function adapts the font-size correctly(unlike Reaper's own native gfx.setfont-function).\nreturns false in case of an error\nPARAMETERS:\nfontindex:the font-id; idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font\nfont:the name of the font\nsize:the size of the font\nflagStr:a string, which holds the desired font-styles. You can combine multiple ones, up to 4.\n",
        "body": "ultraschall.GFX_SetFont(${1:integer fontindex},${2:string font},${3:integer size},${4:string flagStr})$0"
    },
    "ULTRASCHALL.GFX_BLITIMAGECENTERED lua": {
        "prefix": "ultraschall.GFX_BlitImageCentered",
        "scope": "lua",
        "description": "Blits a centered image at the position given by parameter x and y. That means, the center of the image will be at x and y.\nAll the rest basically works like the regular gfx.blit-function.\nreturns false in case of an error\nPARAMETERS:\nx:influences rotation\ny:influences rotation\nscale:the scale-factor; 1, for normal size; smaller or bigger than 1 make image smaller or bigger\nsrcx:the x-coordinate-offset in the source-image\nsrcy:the y-coordinate-offset in the source-image\nsrcw:the width-offset in the source-image\nsrch:the height-offset in the source-image\ndestx:the x-coordinate of the blitting destination\ndesty:the y-coordinate of the blitting destination\ndestw:the width of the blitting destination; may lead to stretched images\ndesth:the height of the blitting destination; may lead to stretched images\nrotxoffs:influences rotation\nrotyoffs:influences rotation\nRETURNS:\nretval:true, blitting was successful; false, blitting was unsuccessful\n",
        "body": "ultraschall.GFX_BlitImageCentered(${1:integer image},${2:integer x},${3:integer y},${4:number scale},${5:number rotate},${6:optional number srcx},${7:optional number srcy},${8:optional number srcw},${9:optional number srch},${10:optional integer destx},${11:optional integer desty},${12:optional integer destw},${13:optional integer desth},${14:optional integer rotxoffs},${15:optional integer rotyoffs})$0"
    },
    "ULTRASCHALL.GFX_GETDROPFILE lua": {
        "prefix": "ultraschall.GFX_GetDropFile",
        "scope": "lua",
        "description": "returns the files drag'n'dropped into a gfx-window, including the mouseposition within the gfx-window, where the files have been dropped.\nif changed==true, then the filelist is updated, otherwise this function returns the last dropped files again.\nNote: when the same files will be dropped, changed==true will also be dropped with only the mouse-position updated.\nThat way, dropping the same files in differen places is recognised by this function.\nCall repeatedly in every defer-cycle to get the latest files and coordinates.\nImportant: Don't use Reaper's own gfx.dropfile while using this, as this could intefere with this function.\nRETURNS:\nchanged:true, new files have been dropped since last time calling this function; false, no new files have been dropped\nnum_dropped_files:the number of dropped files; -1, if no files have beend dropped at all\ndropped_files:an array with all filenames+path of the dropped files\ndrop_mouseposition_x:the x-mouseposition within the gfx-window, where the files have been dropped; -10000, if no files have been dropped yet\ndrop_mouseposition_y:the y-mouseposition within the gfx-window, where the files have been dropped; -10000, if no files have been dropped yet\n",
        "body": "ultraschall.GFX_GetDropFile()$0"
    },
    "ULTRASCHALL.VID_VIDEOUISTATECOORDS2PIXELS lua": {
        "prefix": "ultraschall.VID_VideoUIStateCoords2Pixels",
        "scope": "lua",
        "description": "converts the ui_state-coordinates of the Video-Processor into pixel-coordinates within the Video Window\nYou should add x and y-position of the Video-Processor-window, to get the actual screen-coordinates.\nreturns nil in case of an error\nPARAMETERS:\nuistate_x:the x-coordinate, that the function ui_get_state within the videoprocessor returns\nuistate_y:the y-coordinate, that the function ui_get_state within the videoprocessor returns\nvideowindow_width:the current width of the Video Window\nvideowindow_height:the current height of the Video Window\nRETURNS:\nx_coordinate:the converted x-coordinate\ny_coordinate:the converted y-coordinate\n",
        "body": "ultraschall.VID_VideoUIStateCoords2Pixels(${1:number uistate_x},${2:number uistate_y},${3:integer videowindow_width},${4:integer videowindow_height})$0"
    },
    "ULTRASCHALL.VID_PIXELS2VIDEOUISTATECOORDS lua": {
        "prefix": "ultraschall.VID_Pixels2VideoUIStateCoords",
        "scope": "lua",
        "description": "converts the ui_state-coordinates of the Video-Processor into pixel-coordinates within the Video Window\nYou should add x and y-position of the Video-Processor-window, to get the actual screen-coordinates.\nreturns nil in case of an error\nPARAMETERS:\nx:the x-coordinate within the Video-Window\ny:the y-coordinate within the Video-Window\nvideowindow_width:the current width of the Video Window\nvideowindow_height:the current height of the Video Window\n",
        "body": "ultraschall.VID_Pixels2VideoUIStateCoords(${1:integer x},${2:integer y},${3:integer videowindow_width},${4:integer videowindow_height})$0"
    },
    "ULTRASCHALL.GETHWINPUTS_ALIASNAMES lua": {
        "prefix": "ultraschall.GetHWInputs_Aliasnames",
        "scope": "lua",
        "description": "Returns the aliasnames and their associated channels of the currently selected audio-device.\nThe returned table is of the format\ntable[index][1] - the name of the alias\ntable[index][2] - the hardware-input-channel, associated to this aliasname\nRETURNS:\nnumber_of_aliases:the number of aliases available\naliases:a table, that contains all alias-names and their associated Hardware-Input-channels\n",
        "body": "ultraschall.GetHWInputs_Aliasnames()$0"
    },
    "ULTRASCHALL.GETHWOUTPUTS_ALIASNAMES lua": {
        "prefix": "ultraschall.GetHWOutputs_Aliasnames",
        "scope": "lua",
        "description": "Returns the aliasnames and their associated channels of the currently selected audio-device.\nThe returned table is of the format\ntable[index][1] - the name of the alias\ntable[index][2] - the hardware-output-channel, associated to this aliasname\nRETURNS:\nnumber_of_aliases:the number of aliases available\naliases:a table, that contains all alias-names and their associated Hardware-Output-channels\n",
        "body": "ultraschall.GetHWOutputs_Aliasnames()$0"
    },
    "ULTRASCHALL.GETPROJECT_AUTOMATIONITEMSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_AutomationItemStateChunk",
        "scope": "lua",
        "description": "returns the idx'th automation-item from a ProjectStateChunk.\nIt's the entry <POOLEDENV\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the automation-item-statechunk; nil to use ProjectStateChunk\nidx:the number of the requested automation-item from the ProjectStateChunk with 1 for the first AutomItem.\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nAutomationItemStateChunk:the statechunk of the idx'th automation-item\n",
        "body": "ultraschall.GetProject_AutomationItemStateChunk(${1:string projectfilename_with_path},${2:integer idx},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_COUNTAUTOMATIONITEMS lua": {
        "prefix": "ultraschall.GetProject_CountAutomationItems",
        "scope": "lua",
        "description": "returns the number of automation-items available in a ProjectStateChunk.\nIt's the entry <POOLEDENV\nreturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the automation-item-count; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file; only used, when projectfilename_with_path=nil\nRETURNS:\nautomation_items_count:the number of automation-items\n",
        "body": "ultraschall.GetProject_CountAutomationItems(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.AUTOMATIONITEMS_GETALL lua": {
        "prefix": "ultraschall.AutomationItems_GetAll",
        "scope": "lua",
        "description": "Returns all automation items from the current project as a handy table\nThe format of the table is as follows:\nAutomationItems[automationitem_idx][\"Track\"] - the track, in which the automation item is located\nAutomationItems[automationitem_idx][\"EnvelopeObject\"] - the envelope, in which the automationitem is located\nAutomationItems[automationitem_idx][\"EnvelopeName\"] - the name of the envelope\nAutomationItems[automationitem_idx][\"AutomationItem_Index\"] - the index of the automation with EnvelopeObject\nAutomationItems[automationitem_idx][\"AutomationItem_PoolID\"] - the pool-Id of the automation item\nAutomationItems[automationitem_idx][\"AutomationItem_Position\"] - the position of the automation item in seconds\nAutomationItems[automationitem_idx][\"AutomationItem_Length\"] - the length of the automation item in seconds\nAutomationItems[automationitem_idx][\"AutomationItem_Startoffset\"] - the startoffset of the automation item in seconds\nAutomationItems[automationitem_idx][\"AutomationItem_Playrate\"]- the playrate of the automation item\nAutomationItems[automationitem_idx][\"AutomationItem_Baseline\"]- the baseline of the automation item, between 0 and 1\nAutomationItems[automationitem_idx][\"AutomationItem_Amplitude\"]- the amplitude of the automation item, between -1 and +1\nAutomationItems[automationitem_idx][\"AutomationItem_LoopSource\"]- the loopsource-state of the automation item; 0, unlooped; 1, looped\nAutomationItems[automationitem_idx][\"AutomationItem_UISelect\"]- the selection-state of the automation item; 0, unselected; nonzero, selected\nAutomationItems[automationitem_idx][\"AutomationItem_Pool_QuarteNoteLength\"]- the quarternote-length\nRETURNS:\nnumber_of_automationitems:the number of automation-items found in the current project\nAutomationItems_Table:all found automation-items as a handy table(see description for details)\n",
        "body": "ultraschall.AutomationItems_GetAll()$0"
    },
    "ULTRASCHALL.AUTOMATIONITEM_DELETE lua": {
        "prefix": "ultraschall.AutomationItem_Delete",
        "scope": "lua",
        "description": "Deletes an Automation-Item, optionally preserves the points who are added to the underlying envelope.\nreturns false in case of an error\nPARAMETERS:\nenv:the TrackEnvelope, in which the automation-item to be deleted is located\nautomationitem_idx:the automationitem that shall be deleted; 0, for the first one\npreservepoints:true, keepthe envelopepoints and add them to the underlying envelope; nil or false, just delete the AutomationItem\nRETURNS:\nretval:true, deleting was successful; false, deleting was not successful\n",
        "body": "ultraschall.AutomationItem_Delete(${1:TrackEnvelope env},${2:integer automationitem_idx},${3:optional boolean preservepoints})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSFROMCLIPBOARD lua": {
        "prefix": "ultraschall.GetMediaItemsFromClipboard",
        "scope": "lua",
        "description": "Returns the number of mediaitems and a MediaItemStateChunkArray of the mediaitems, as stored in the clipboard.\nIt does it by pasting the items at the end of the project, getting them and deleting them again.\nUse sparsely and with care, as it uses a lot of resources!\nRETURNS:\ncount:the number of items in the clipboard\n",
        "body": "ultraschall.GetMediaItemsFromClipboard()$0"
    },
    "ULTRASCHALL.GETSTRINGFROMCLIPBOARD_SWS lua": {
        "prefix": "ultraschall.GetStringFromClipboard_SWS",
        "scope": "lua",
        "description": "Returns the content of the clipboard as a string. Uses the SWS-function reaper.CF_GetClipboard, but does everything for you, that is needed for proper use of this function.\nRETURNS:\nclipboard_string:the content of the clipboard as a string\n",
        "body": "ultraschall.GetStringFromClipboard_SWS()$0"
    },
    "ULTRASCHALL.PUTMEDIAITEMSTOCLIPBOARD_MEDIAITEMARRAY lua": {
        "prefix": "ultraschall.PutMediaItemsToClipboard_MediaItemArray",
        "scope": "lua",
        "description": "Puts the items in MediaItemArray into the clipboard.\nReturns false in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, that shall be put into the clipboard\nRETURNS:\nretval:true, if successful; false, if not\n",
        "body": "ultraschall.PutMediaItemsToClipboard_MediaItemArray(${1:MediaItemArray MediaItemArray})$0"
    },
    "ULTRASCHALL.CONVERTCOLOR lua": {
        "prefix": "ultraschall.ConvertColor",
        "scope": "lua",
        "description": "converts r, g, b-values to native-system-color. Works like reaper's ColorToNative, but doesn't need |0x1000000 added.\nreturns color-value 0, and retval=false in case of an error\nPARAMETERS:\nr:the blue colorvalue\ng:the blue colorvalue\nb:the blue colorvalue\nRETURNS:\ncolorvalue:the native-system-color; 0 to 33554431\n",
        "body": "ultraschall.ConvertColor(${1:integer r},${2:integer g},${3:integer b})$0"
    },
    "ULTRASCHALL.CONVERTCOLORREVERSE lua": {
        "prefix": "ultraschall.ConvertColorReverse",
        "scope": "lua",
        "description": "converts a native-system-color to r, g, b-values.\nreturns 0,0,0,false in case of an error\nPARAMETERS:\ncolorvalue:the native-system-color; 0 to 33554431\nRETURNS:\nr:true, color-conversion was successful; false, color-conversion was unsuccessful\ng:the blue colorvalue\nb:true, color-conversion was successful; false, color-conversion was unsuccessful\nretval:true, color-conversion was successful; false, color-conversion was unsuccessful\n",
        "body": "ultraschall.ConvertColorReverse(${1:integer colorvalue})$0"
    },
    "ULTRASCHALL.RGB2GRAYSCALE lua": {
        "prefix": "ultraschall.RGB2Grayscale",
        "scope": "lua",
        "description": "converts rgb to a grayscale value. Works native on Mac as well on Windows, no color conversion needed.\nreturns nil in case of an error\nPARAMETERS:\nred:red-value between 0 and 255.\ngreen:red-value between 0 and 255.\nblue:red-value between 0 and 255.\nRETURNS:\ngraycolor:the gray color-value, generated from red,blue and green.\n",
        "body": "ultraschall.RGB2Grayscale(${1:integer red},${2:integer green},${3:integer blue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORTOGFX lua": {
        "prefix": "ultraschall.ConvertColorToGFX",
        "scope": "lua",
        "description": "converts red,green,blue,alpha-values from 0-255 range to 0-1 range, so these values can be used by Reaper-Lua's gfx.functions().\nsupports negative-values up from -255 to +255, so you can use the function as well for subtraction of colorvalues.\nreturns nil in case of error\nPARAMETERS:\nr:the alpha-color-value between -255 and +255\ng:the alpha-color-value between -255 and +255\nb:the blue-color-value between -255 and +255\na:the alpha-color-value between -255 and +255\nRETURNS:\nr:the converted alpha-value between -1 and +1\ng:the converted green-value between -1 and +1\nb:the converted alpha-value between -1 and +1\na:the converted alpha-value between -1 and +1\n",
        "body": "ultraschall.ConvertColorToGFX(${1:integer r},${2:integer g},${3:integer b},${4:integer a})$0"
    },
    "ULTRASCHALL.CONVERTGFXTOCOLOR lua": {
        "prefix": "ultraschall.ConvertGFXToColor",
        "scope": "lua",
        "description": "converts red,green,blue,alpha-values from 0-1 range to 0-255 range, so these values can be used by Reaper's normal color-value-functions.\nsupports negative-values up from -1 to +1, so you can use the function as well for subtraction of colorvalues.\nreturns nil in case of error\nPARAMETERS:\nr:the converted alpha-value between -1 and +1\ng:the converted green-value between -1 and +1\nb:the converted alpha-value between -1 and +1\na:the converted alpha-value between -1 and +1\nRETURNS:\nr:the alpha-color-value between -255 and +255\ng:the alpha-color-value between -255 and +255\nb:the blue-color-value between -255 and +255\na:the alpha-color-value between -255 and +255\n",
        "body": "ultraschall.ConvertGFXToColor(${1:number r},${2:number g},${3:number b},${4:number a})$0"
    },
    "ULTRASCHALL.CREATECOLORTABLE lua": {
        "prefix": "ultraschall.CreateColorTable",
        "scope": "lua",
        "description": "Returns a colortable to be used by color-graphics-functions.\nThe colorvalue for start and end can be 0 to 255 or the other way round 255 to 0\nCan be used by ApplyColorTableToTrackColors\nreturns nil in case of an error\nPARAMETERS:\nstartr:start redvalue, between 0 and 255\nstartg:start greenvalue, between 0 and 255 \nstartb:start bluevalue, between 0 and 255\nendr:end redvalue, between 0 and 255\nendg:end greenvalue, between 0 and 255\nendb:end bluevalue, between 0 and 255\nnumber_of_steps:the number of steps from the lowest to the highest r,g,b-color start/end-values\nRETURNS:\nColorTable:a colortable for the colors with the number of steps of your choice; \n",
        "body": "ultraschall.CreateColorTable(${1:integer startr},${2:integer startg},${3:integer startb},${4:integer endr},${5:integer endg},${6:integer endb},${7:integer number_of_steps})$0"
    },
    "ULTRASCHALL.CREATESONICRAINBOOMCOLORTABLE lua": {
        "prefix": "ultraschall.CreateSonicRainboomColorTable",
        "scope": "lua",
        "description": "Returns a colortable in Ultraschall's standard-trackcolor-setting \"Sonic Rainboom\"-style.\nCan be used by ApplyColorTableToTrackColors\nRETURNS:\nColorTable:a colortable with all values for Ultraschall's track-color \"Sonic Rainboom\"\n",
        "body": "ultraschall.CreateSonicRainboomColorTable()$0"
    },
    "ULTRASCHALL.ISVALIDCOLORTABLE lua": {
        "prefix": "ultraschall.IsValidColorTable",
        "scope": "lua",
        "description": "Checks for valid color-tables.\nreturns false in case of an error\nPARAMETERS:\nColorTable:a table to check for being a valid ColorTable\nRETURNS:\nretval:true, if it's a valid ColorTable; false, if it's not a valid ColorTable\n",
        "body": "ultraschall.IsValidColorTable(${1:array ColorTable})$0"
    },
    "ULTRASCHALL.APPLYCOLORTABLETOTRACKCOLORS lua": {
        "prefix": "ultraschall.ApplyColorTableToTrackColors",
        "scope": "lua",
        "description": "Apply a ColorTable to Tracks, to colorize MediaTracks\nColorTables can be created by CreateColorTable\nreturns false in case of an error\nPARAMETERS:\nColorTable:the ColorTable to apply to the MediaTrackColors\nSpread:0, apply ColorTable once; will return false, if fewer colors are in ColorTable available than tracks in the project\nStartTrack:the first track to colorize; nil, to use the first track in project\nEndTrack:the last track to colorize; nil, to use the last track in project\nRETURNS:\nretval:true, adjusting track-colors was successful; false, adjusting track-colors was unsuccessful\n",
        "body": "ultraschall.ApplyColorTableToTrackColors(${1:array ColorTable},${2:integer Spread},${3:integer StartTrack},${4:integer EndTrack})$0"
    },
    "ULTRASCHALL.APPLYCOLORTABLETOITEMCOLORS lua": {
        "prefix": "ultraschall.ApplyColorTableToItemColors",
        "scope": "lua",
        "description": "Apply a ColorTable to MediaItems in a MediaItemArray, to colorize MediaItems\nColorTables can be created by CreateColorTable\nreturns false in case of an error\nPARAMETERS:\nColorTable:the ColorTable to apply to the MediaItemColors\nSpread:0, apply ColorTable once; will return false, if fewer colors are in ColorTable available than items in the MediaItemArray\nMediaItemArray:an array with all the MediaItems to colorize\nRETURNS:\nretval:true, adjusting item-colors was successful; false, adjusting item-colors was unsuccessful\n",
        "body": "ultraschall.ApplyColorTableToItemColors(${1:array ColorTable},${2:integer Spread},${3:MediaItemArray MediaItemArray})$0"
    },
    "ULTRASCHALL.CHANGECOLORBRIGHTNESS lua": {
        "prefix": "ultraschall.ChangeColorBrightness",
        "scope": "lua",
        "description": "Changes brightness of a colorvalue. If you only set bright_r without setting bright_g and bright_b, then the value for bright_r will affect g and b as well.\nIf a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.\nreturns color-value 0,0,0 and retval=false in case of an error\nPARAMETERS:\nr:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\ng:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nb:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nbright_r:the change in brightness for the red-color; positive, brighter; negative, darker\nbright_g:the change in brightness for the green-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nbright_b:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nRETURNS:\nred:the new red-value\ngreen:the new green-value\nblue:the new blue-value\nretval:true, color-calculation was successful; false, color-calculation was unsuccessful\n",
        "body": "ultraschall.ChangeColorBrightness(${1:integer r},${2:integer g},${3:integer b},${4:integer bright_r},${5:optional integer bright_g},${6:optional integer bright_b})$0"
    },
    "ULTRASCHALL.CHANGECOLORCONTRAST lua": {
        "prefix": "ultraschall.ChangeColorContrast",
        "scope": "lua",
        "description": "Changes contrast of a colorvalue.\nMinimum will set the new minimal, Maximum will set the new maximum-brightness-level.\nIf you set Minimum to 0 and Maximum to 255, contrast will not change.\nThe lower you set Minimum/Maximum, the darker it becomes; the higher, the brighter it becomes.\nThe farther away Minimum is from Maximum, the stronger the contrast becomes; the closer Minimum is to Maximum, the weaker the contrast becomes.\nIf you only set Minimum\\_r and Maximum\\_r, then these values will be applied to g and b too.\nIf you omit/set to nil a Maximum-value; it's default value will be 255.\nIf a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.\nreturns color-value 0,0,0 and retval=false in case of an error\nPARAMETERS:\nr:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\ng:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\nb:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\nMinimum_r:the new minimum brightness of the contrast-range of the red-color\nMaximum_r:the new maximum brightness of the contrast-range of the red-color; if nil, it will be seen as 255\nMinimum_g:the new minimum brightness of the contrast-range of the green-color; if nil, it will use the value of Minimum_r\nMaximum_g:the new maximum brightness of the contrast-range of the green-color; if nil, it will be seen as 255\nMinimum_b:the new minimum brightness of the contrast-range of the blue-color; if nil, it will use the value of Minimum_r\nMaximum_b:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\nRETURNS:\nred:the new red-value\ngreen:the new green-value\nblue:the new blue-value\nretval:true, color-calculation was successful; false, color-calculation was unsuccessful\n",
        "body": "ultraschall.ChangeColorContrast(${1:integer r},${2:integer g},${3:integer b},${4:integer Minimum_r},${5:optional integer Maximum_r},${6:optional integer Minimum_g},${7:optional integer Maximum_g},${8:optional integer Minimum_b},${9:optional integer Maximum_b})$0"
    },
    "ULTRASCHALL.CHANGECOLORSATURATION lua": {
        "prefix": "ultraschall.ChangeColorSaturation",
        "scope": "lua",
        "description": "Changes saturation of a colorvalue by delta.\nIf a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.\nreturns color-value 0,0,0 and retval=false in case of an error\nPARAMETERS:\nr:the saturation/desaturation-value; negative, desaturates color; positive, saturates color\ng:the saturation/desaturation-value; negative, desaturates color; positive, saturates color\nb:the blue-value to be changed\ndelta:the saturation/desaturation-value; negative, desaturates color; positive, saturates color\nRETURNS:\nred:the new red-value\ngreen:the new green-value\nblue:the new blue-value\nmedian:the median-value, calculated from the the old red, green and blue, values (red+green+blue)/3, which is the basis for the brightness of the unsaturated value\nretval:true, color-calculation was successful; false, color-calculation was unsuccessful\n",
        "body": "ultraschall.ChangeColorSaturation(${1:integer r},${2:integer g},${3:integer b},${4:integer delta})$0"
    },
    "ULTRASCHALL.CONVERTCOLORTOMAC lua": {
        "prefix": "ultraschall.ConvertColorToMac",
        "scope": "lua",
        "description": "Converts a colorvalue to the correct-native-colorvalue for Mac, no matter if you're using Mac, Windows or Linux.\nreturns 0, false in case of an error\nPARAMETERS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nRETURNS:\nmac_colorvalue:the Mac-native-colorvalue\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "ultraschall.ConvertColorToMac(${1:integer red},${2:integer green},${3:integer blue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORTOWIN lua": {
        "prefix": "ultraschall.ConvertColorToWin",
        "scope": "lua",
        "description": "Converts a colorvalue to the correct-native-colorvalue for Windows/Linux, no matter if you're using Mac, Windows or Linux.\nreturns 0, false in case of an error\nPARAMETERS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nRETURNS:\nwin_linux_colorvalue:the Windows/Linux-native-colorvalue\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "ultraschall.ConvertColorToWin(${1:integer red},${2:integer green},${3:integer blue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORFROMMAC lua": {
        "prefix": "ultraschall.ConvertColorFromMac",
        "scope": "lua",
        "description": "Converts a native-colorvalue to the correct rgb-color-values for Mac, no matter if you're using Mac, Windows or Linux.\nreturns 0, 0, 0, false in case of an error\nPARAMETERS:\nmac_colorvalue:the Mac-native-colorvalue\nRETURNS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "ultraschall.ConvertColorFromMac(${1:integer mac_colorvalue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORFROMWIN lua": {
        "prefix": "ultraschall.ConvertColorFromWin",
        "scope": "lua",
        "description": "Converts a native-colorvalue to the correct rgb-color-values for Windows/Linux, no matter if you're using Mac, Windows or Linux.\nreturns 0, 0, 0, false in case of an error\nPARAMETERS:\nwin_colorvalue:the Windows/Linux-native-colorvalue\nRETURNS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "ultraschall.ConvertColorFromWin(${1:integer win_colorvalue})$0"
    },
    "ULTRASCHALL.SETINIFILEEXTERNALSTATE lua": {
        "prefix": "ultraschall.SetIniFileExternalState",
        "scope": "lua",
        "description": "Sets an external state into ini_filename_with_path. Returns false, if it doesn't work.\nPARAMETERS:\nsection:section of the external state. No = allowed!\nkey:key of the external state. No = allowed!\nvalue:value for the key\nRETURNS:\nretval:true, if setting the state was successful; false, if setting was unsuccessful\n",
        "body": "ultraschall.SetIniFileExternalState(${1:string section},${2:string key},${3:string value},${4:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.GETINIFILEEXTERNALSTATE lua": {
        "prefix": "ultraschall.GetIniFileExternalState",
        "scope": "lua",
        "description": "Gets an external state from ini_filename_with_path. Returns -1, if the file does not exist or parameters are invalid.\nPARAMETERS:\nsection:section of the external state\nkey:key of the external state. No = allowed!\nRETURNS:\nvalue:the value stored in a section->key in a configuration-file\n",
        "body": "ultraschall.GetIniFileExternalState(${1:string section},${2:string key},${3:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTINIFILEEXTERNALSTATE_SEC lua": {
        "prefix": "ultraschall.CountIniFileExternalState_sec",
        "scope": "lua",
        "description": "Count external-state-[sections] from an ini-configurationsfile.\nReturns -1, if the file does not exist.\nPARAMETERS:\nini_filename_with_path:filename of the ini-file\nRETURNS:\nsectioncount:number of sections within an ini-configuration-file\n",
        "body": "ultraschall.CountIniFileExternalState_sec(${1:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTINIFILEEXTERNALSTATE_KEY lua": {
        "prefix": "ultraschall.CountIniFileExternalState_key",
        "scope": "lua",
        "description": "Count external-state-keys within a specific section, in a ini_filename_with_path.\nReturns -1, if file does not exist.\nPARAMETERS:\nsection:the section within the ini-filename\nini_filename_with_path:filename of the ini-file\nRETURNS:\nkeyscount:number of keys with section within an ini-configuration-file\n",
        "body": "ultraschall.CountIniFileExternalState_key(${1:string section},${2:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEINIFILEEXTERNALSTATE_SEC lua": {
        "prefix": "ultraschall.EnumerateIniFileExternalState_sec",
        "scope": "lua",
        "description": "Returns the numberth section in an ini_filename_with_path.\nReturns nil, in case of an error.\nPARAMETERS:\nnumber_of_section:the section within the ini-filename; 1, for the first section\nini_filename_with_path:filename of the ini-file\nRETURNS:\nsectionname:the name of the numberth section in the ini-file\n",
        "body": "ultraschall.EnumerateIniFileExternalState_sec(${1:integer number_of_section},${2:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEINIFILEEXTERNALSTATE_KEY lua": {
        "prefix": "ultraschall.EnumerateIniFileExternalState_key",
        "scope": "lua",
        "description": "Returns the numberth key within a section in an ini_filename_with_path.\nReturns nil, in case of an error.\nPARAMETERS:\nsection:the name of the section\nnumber:the number of the key within a section within the ini-filename, with 1 for the first key in the section\nini_filename_with_path:filename of the ini-file\nRETURNS:\nkeyname:the name of the numberth key within section in the ini-file\n",
        "body": "ultraschall.EnumerateIniFileExternalState_key(${1:string section},${2:integer number},${3:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTSECTIONSBYPATTERN lua": {
        "prefix": "ultraschall.CountSectionsByPattern",
        "scope": "lua",
        "description": "Counts the number of sections within an ini-file, that fit a specific pattern.\nUses \"pattern\"-string to determine, how often a section with a certain pattern exists. Good for sections, that have a number in them, like [section1], [section2], [section3].\nReturns the number of sections, that include that pattern as well as a string, that includes the names of all such sections, separated by a comma.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns -1, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nini_filename_with_path:filename of the ini-file\nRETURNS:\nnumber_of_sections:the number of sections, that fit the pattern\nsectionnames:a string, like: [section1],[section8],[section99]\n",
        "body": "ultraschall.CountSectionsByPattern(${1:string pattern},${2:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKEYSBYPATTERN lua": {
        "prefix": "ultraschall.CountKeysByPattern",
        "scope": "lua",
        "description": "Counts the number of keys within an ini-file, that fit a specific pattern.\nUses \"pattern\"-string to determine, how often a key with a certain pattern exists. Good for keys, that have a number in them, like key1, key2, key3.\nReturns the number of keys, that include the pattern, as well as a string with all [sections] that contain keys= with a pattern, separated by a , i.e. [section1],key1=,key2=,key3=,[section2],key1=,key4=\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns -1, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nini_filename_with_path:filename of the ini-file\nRETURNS:\nnumber_of_keys:the number of keys, that fit the pattern\nsections_and_keys:a string, like: [section1],Key1=,Key2=,Key3=[section2],Key7=\n",
        "body": "ultraschall.CountKeysByPattern(${1:string pattern},${2:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTVALUESBYPATTERN lua": {
        "prefix": "ultraschall.CountValuesByPattern",
        "scope": "lua",
        "description": "Counts the number of values within an ini-file, that fit a specific pattern.\nUses \"pattern\"-string to determine, how often a value with a certain pattern exists. Good for values, that have a number in them, like value1, value2, value3\nReturns the number of values, that include that pattern as well as a string, that contains the [sections] and the keys= and values , the latter that contain the pattern, separated by a comma\ne.g. [section1], key1=, value, key4=, value, [section4], key2=, value\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns -1, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nini_filename_with_path:filename of the ini-file\nRETURNS:\nnumber_of_values:the number of values, that fit the pattern\n",
        "body": "ultraschall.CountValuesByPattern(${1:string pattern},${2:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATESECTIONSBYPATTERN lua": {
        "prefix": "ultraschall.EnumerateSectionsByPattern",
        "scope": "lua",
        "description": "Returns the numberth section within an ini-file, that fits the pattern, e.g. the third section containing \"hawaii\" in it.\nUses \"pattern\"-string to determine if a section contains a certain pattern. Good for sections, that have a number in them, like section1, section2, section3\nReturns the section that includes that pattern as a string, numbered by id.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns nil, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nid:the number of section, that contains pattern\nini_filename_with_path:filename of the ini-file\nRETURNS:\nsectionname:a string, that contains the sectionname\n",
        "body": "ultraschall.EnumerateSectionsByPattern(${1:string pattern},${2:integer id},${3:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEKEYSBYPATTERN lua": {
        "prefix": "ultraschall.EnumerateKeysByPattern",
        "scope": "lua",
        "description": "Returns the numberth key within a section in an ini-file, that fits the pattern, e.g. the third key containing \"hawaii\" in it.\nUses \"pattern\"-string to determine if a key contains a certain pattern. Good for keys, that have a number in them, like key1=, key2=, key3=\nReturns the key that includes that pattern as a string, numbered by id.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns nil, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nsection:the section, in which to look for the key\nid:the number of key, that contains pattern\nini_filename_with_path:filename of the ini-file\nRETURNS:\nkeyname:a string, that contains the keyname\n",
        "body": "ultraschall.EnumerateKeysByPattern(${1:string pattern},${2:string section},${3:integer id},${4:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEVALUESBYPATTERN lua": {
        "prefix": "ultraschall.EnumerateValuesByPattern",
        "scope": "lua",
        "description": "Returns the numberth value(and it's accompanying key) within a section in an ini-file, that fits the pattern, e.g. the third value containing \"hawaii\" in it.\nUses \"pattern\"-string to determine if a value contains a certain pattern. Good for values, that have a number in them, like value1, value2, value3\nReturns the value that includes that pattern as a string, numbered by id, as well as it's accompanying key.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns nil, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nsection:the section, in which to look for the key\nid:the number of key, that contains pattern\nini_filename_with_path:filename of the ini-file\nRETURNS:\nvalue:the value that contains the pattern\nkeyname:a string, that contains the keyname\n",
        "body": "ultraschall.EnumerateValuesByPattern(${1:string pattern},${2:string section},${3:string id},${4:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKBINIACTIONS lua": {
        "prefix": "ultraschall.CountKBIniActions",
        "scope": "lua",
        "description": "Count the number of \"ACT\"-Actions of the Reaper-kb.ini-file.\nReturns -1, if no such file exists.\nRETURNS:\nactions:number of actions in the reaper-kb.ini\n",
        "body": "ultraschall.CountKBIniActions(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKBINISCRIPTS lua": {
        "prefix": "ultraschall.CountKBIniScripts",
        "scope": "lua",
        "description": "Count the number of \"SCR\"-Scripts of the Reaper-kb.ini-file.\nReturns -1, if no such file exists.\nRETURNS:\nscripts:number of scripts in the reaper-kb.ini\n",
        "body": "ultraschall.CountKBIniScripts(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKBINIKEYS lua": {
        "prefix": "ultraschall.CountKBIniKeys",
        "scope": "lua",
        "description": "Count the number of \"KEY\"-Keybindings of the Reaper-kb.ini-file.\nReturns -1, if no such file exists.\nRETURNS:\nkeys:number of keys in the reaper-kb.ini\n",
        "body": "ultraschall.CountKBIniKeys(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.GETKBINIACTIONS lua": {
        "prefix": "ultraschall.GetKBIniActions",
        "scope": "lua",
        "description": "Get the states of \"ACT\"-Action number idx. Returns consolidate, section, ActionCommandID, description, ActionsToBeExecuted.\nReturns -1, if no such entry or file exists.\nPARAMETERS:\nfilename_with_path:path and filename of the reaper-kb.ini\nidx:the number of the action to get, beginning with 1 for the first one\nRETURNS:\nconsolidate:consolidate-state\nsection:the section, in which this action is executed\nActionCommandID:the ActionCommandID given to this Action\ndescription:the description of this action\nActionsToBeExecuted:the actions that are run, the ActionCommandIDs beginning with _, multiple ActionCommandIDs are separated by whitespaces\n",
        "body": "ultraschall.GetKBIniActions(${1:string filename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.GETKBINISCRIPTS lua": {
        "prefix": "ultraschall.GetKBIniScripts",
        "scope": "lua",
        "description": "Get the states of \"SCR\"-Scripts number idx. Returns terminateinstance, section, ActionCommandID, description, scriptfile.\nReturns -1, if no such entry or file exists.\nPARAMETERS:\nfilename_with_path:path and filename of the reaper-kb.ini\nidx:the number of the action to get, beginning with 1 for the first one\nRETURNS:\nterminateinstance:the state of terminating instances\nsection:the section, in which this action is executed\nActionCommandID:the ActionCommandID given to this Action\ndescription:the description of this action\nscriptfile:the filename of the script that shall be run\n",
        "body": "ultraschall.GetKBIniScripts(${1:string filename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.GETKBINIKEYS lua": {
        "prefix": "ultraschall.GetKBIniKeys",
        "scope": "lua",
        "description": "Get the states of \"KEY\"-Keybinding-number idx, for MIDI/Key-bindings. Returns keytype_modifier_midichan, key_midinote, ActionCommandID, section.\nFor a detailed description in how KEY-entries work, refer to Reaper-Filetype-Descriptions.html#Reaper-kb.ini.\nReturns -1, if no such entry or file exists.\nDoes not return OSC-keybindings, as they are stored in OSC/reaper-osc-actions.ini !\nreturns -1 in case of an error\nPARAMETERS:\nfilename_with_path:path and filename of the reaper-kb.ini\nidx:the number of the action to get, beginning with 1 for the first one\nRETURNS:\nkeytype_modifier_midichan:Type of Keytype, modifier or midichannel\nkey_midinote:the key(like ASCII-Codes) or midinote. \nActionCommandID:the ActionCommandID associated with this shortcut.\nsection:the section, in which this shortcut is used\n",
        "body": "ultraschall.GetKBIniKeys(${1:string filename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.GETKBINIACTIONSID_BYACTIONCOMMANDID lua": {
        "prefix": "ultraschall.GetKBIniActionsID_ByActionCommandID",
        "scope": "lua",
        "description": "Returns the indexnumber(s) of actions by ActionCommandIDs within a reaper-kb.ini.\nReturns -1, if no such entry or file exists.\nPARAMETERS:\n:the ActionCommandID\n:the ActionCommandID\nRETURNS:\nretval:the ids of actions with ActionCommandID, separated by a ,\n",
        "body": "ultraschall.GetKBIniActionsID_ByActionCommandID(${1:filename_with_path},${2:ActionCommandID})$0"
    },
    "ULTRASCHALL.GETKBINISCRIPTS_BYACTIONCOMMANDID lua": {
        "prefix": "ultraschall.GetKBIniScripts_ByActionCommandID",
        "scope": "lua",
        "description": "Returns the indexnumber(s) of scripts by ActionCommandIDs within a reaper-kb.ini.\nReturns nil, if no such entry or file exists.\nPARAMETERS:\n:the ActionCommandID\n:the ActionCommandID\nRETURNS:\nretval:the ids of scripts with ActionCommandID, separated by a ,\n",
        "body": "ultraschall.GetKBIniScripts_ByActionCommandID(${1:filename_with_path},${2:ActionCommandID})$0"
    },
    "ULTRASCHALL.GETKBINIKEYS_BYACTIONCOMMANDID lua": {
        "prefix": "ultraschall.GetKBIniKeys_ByActionCommandID",
        "scope": "lua",
        "description": "Returns the indexnumber(s) of keys by ActionCommandIDs within a reaper-kb.ini.\nReturns nil, if no such entry or file exists.\nPARAMETERS:\n:the ActionCommandID\n:the ActionCommandID\nRETURNS:\nretval:the ids of keys with ActionCommandID, separated by a ,\n",
        "body": "ultraschall.GetKBIniKeys_ByActionCommandID(${1:filename_with_path},${2:ActionCommandID})$0"
    },
    "ULTRASCHALL.SETKBINIACTIONS lua": {
        "prefix": "ultraschall.SetKBIniActions",
        "scope": "lua",
        "description": "Adds or sets(if it already exists) an \"ACT\"-action of a reaper-kb.ini.\nReturns true/false when adding or setting worked/didn't work, as well as the action-number within the reaper-kb.ini\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nconsolidate:consolidation state of this action\nsection:section, in which this action is started\nActionCommandID:the ActionCommandIDs for the actions, that are triggered by this action; unlike CommandID-numbers, every ActionCommandID must begin with _ ; will not be checked vor valid ones!\nDescription:a description for this action\nActionCommandIDs:the ActionCommandIDs for the actions, that are triggered by this action; unlike CommandID-numbers, every ActionCommandID must begin with _ ; will not be checked vor valid ones!\nreplace:true if an already existing entry shall be replaced, false if not\nRETURNS:\nretval:true, if adding/setting worked, false if it didn't\nactionnumber:the entrynumber within the reaper-kb.ini of this action\n",
        "body": "ultraschall.SetKBIniActions(${1:string filename_with_path},${2:integer consolidate},${3:integer section},${4:string ActionCommandID},${5:string Description},${6:string ActionCommandIDs},${7:boolean replace})$0"
    },
    "ULTRASCHALL.SETKBINISCRIPTS lua": {
        "prefix": "ultraschall.SetKBIniScripts",
        "scope": "lua",
        "description": "Adds or sets(if it already exists) an \"SCR\"-script of a reaper-kb.ini.\nReturns true/false when adding or setting worked/didn't work, as well as the script-number within the reaper-kb.ini\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nterminate:state of handling mulitple running scripts\nsection:section, in which this script is started\nActionCommandID:the ActionCommandID of this action\nDescription:a description for this script\nScriptname:the name of the ReaScript, like .lua or .eel or .py\nreplace:true if an already existing entry shall be replaced, false if not\nRETURNS:\nretval:true, if adding/setting worked, false if it didn't\nscriptnumber:the entrynumber within the reaper-kb.ini of this script\n",
        "body": "ultraschall.SetKBIniScripts(${1:string filename_with_path},${2:integer terminate},${3:integer section},${4:string ActionCommandID},${5:string Description},${6:string Scriptname},${7:boolean replace})$0"
    },
    "ULTRASCHALL.SETKBINIKEYS lua": {
        "prefix": "ultraschall.SetKBIniKeys",
        "scope": "lua",
        "description": "Adds or sets(if it already exists) a \"KEY\"-key of a reaper-kb.ini.\nReturns true/false when adding or setting worked/didn't work, as well as the keybinding-number within the reaper-kb.ini.\nAdditional keybindings cannot share the same keytype_modifier_midichan, key_midinote and section at the same time, as every such keybind must be unique.\nFor a detailed description in how KEY-entries work, refer to Reaper-Filetype-Descriptions.html#Reaper-kb.ini.\nDoes not support OSC-keybindings, as they are stored in OSC/reaper-osc-actions.ini !\nNeeds a restart of Reaper for this change to take effect!\nreturns false in case of an error\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nkeytype_modifier_midichan:Type of Keytype, modifier or midichannel\nkey_midinote:the key(like ASCII-Codes) or midinote. \nActionCommandID:the ActionCommandID associated with this shortcut.\nsection:the section, in which this shortcut is used\nreplace:true if an already existing entry shall be replaced, false if not\nRETURNS:\nretval:true, if adding/setting worked, false if it didn't\n",
        "body": "ultraschall.SetKBIniKeys(${1:string filename_with_path},${2:integer keytype_modifier_midichan},${3:integer key_midinote},${4:string ActionCommandID},${5:integer section},${6:boolean replace})$0"
    },
    "ULTRASCHALL.DELETEKBINIACTIONS lua": {
        "prefix": "ultraschall.DeleteKBIniActions",
        "scope": "lua",
        "description": "Deletes an \"ACT\"-action of a reaper-kb.ini.\nReturns true/false when deleting worked/didn't work.\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nidx:indexnumber of the action within the reaper-kb.ini\nRETURNS:\nretval:true, if deleting worked, false if it didn't\n",
        "body": "ultraschall.DeleteKBIniActions(${1:string filename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.DELETEKBINISCRIPTS lua": {
        "prefix": "ultraschall.DeleteKBIniScripts",
        "scope": "lua",
        "description": "Deletes an \"SCR\"-script of a reaper-kb.ini.\nReturns true/false when deleting worked/didn't work.\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nidx:indexnumber of the script within the reaper-kb.ini\nRETURNS:\nretval:true, if deleting worked, false if it didn't\n",
        "body": "ultraschall.DeleteKBIniScripts(${1:string filename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.DELETEKBINIKEYS lua": {
        "prefix": "ultraschall.DeleteKBIniKeys",
        "scope": "lua",
        "description": "Deletes a \"KEY\"-keybinding of a reaper-kb.ini.\nReturns true/false when deleting worked/didn't work.\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nidx:indexnumber of the keybinding within the reaper-kb.ini\nRETURNS:\nretval:true, if deleting worked, false if it didn't\n",
        "body": "ultraschall.DeleteKBIniKeys(${1:string filename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.SETINIFILEVALUE lua": {
        "prefix": "ultraschall.SetIniFileValue",
        "scope": "lua",
        "description": "Sets a value of a key in an ini-file\nreturns -1 in case of an error\nPARAMETERS:\nsection:the section, in which the key-value-pair is located\nkey:the key whose value you want to change\nvalue:the new value for this key-value-pair\ninifile:the ini-file, in which you want to set the key-value-store\nRETURNS:\nretval:-1, in case of an error; 1, in case of success\n",
        "body": "ultraschall.SetIniFileValue(${1:string section},${2:string key},${3:string value},${4:string inifile})$0"
    },
    "ULTRASCHALL.QUERYKEYBOARDSHORTCUTBYKEYID lua": {
        "prefix": "ultraschall.QueryKeyboardShortcutByKeyID",
        "scope": "lua",
        "description": "Returns the name of the shortcut of the modifier-key-values, as stored in the KEY-entries within the reaper-kb.ini\nThat way, you can take a KEY-entry from the reaper-kb.ini, like\nKEY 1 65 _Ultraschall_Play_From_Editcursor_Position 0\nExtract the modifier and key-values(1 and 65 in the example) and pass them to this function.\nYou will get returned \"A\" as 1 and 65 is the keyboard-shortcut-code for the A-key.\nOnly necessary for those, who try to read keyboard-shortcuts directly from the reaper-kb.ini to display them in some way.\nreturns nil in case of an error\nPARAMETERS:\nmodifier:the modifier value, which is the first one after KEY in a KEY-entry in the reaper-kb.ini-file\nkey:the key value, which is the second one after KEY in a KEY-entry in the reaper-kb.ini-file\nRETURNS:\nShortcutname:the actual name of the shortcut, like \"A\" or \"F1\" or \"Ctrl+Alt+Shift+Win+PgUp\".\n",
        "body": "ultraschall.QueryKeyboardShortcutByKeyID(${1:integer modifier},${2:integer key})$0"
    },
    "ULTRASCHALL.GETSETCONFIGACIDIMPORT lua": {
        "prefix": "ultraschall.GetSetConfigAcidImport",
        "scope": "lua",
        "description": "Gets/Sets the value of \"When importing media\"-dropdownlist, as set in the Media with embedded tempo information-section in Preferences -> Video/REX/Misc\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"acidimport\", as well as the reaper.ini-entry \"REAPER -> acidimport\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAcidImport(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGACTIONMENU lua": {
        "prefix": "ultraschall.GetSetConfigActionMenu",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Show recent actions\"-entry, as set in the Actions-menu.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"actionmenu\", as well as the reaper.ini-entry \"REAPER -> actionmenu\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigActionMenu(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGADJRECLAT lua": {
        "prefix": "ultraschall.GetSetConfigAdjRecLat",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Use audio driver reported latency\"-checkbox, as set in Preferences -> Recording\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"adjreclat\", as well as the reaper.ini-entry \"REAPER -> adjreclat\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAdjRecLat(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGADJRECMANLAT lua": {
        "prefix": "ultraschall.GetSetConfigAdjRecManLat",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Output manual offset-samples\"-inputbox, as set in Preferences -> Recording\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"adjrecmanlat\", as well as the reaper.ini-entry \"REAPER -> adjrecmanlat\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value; 0 to 2147483647; in samples\nsetting:the current/new setting-value; 0 to 2147483647; in samples\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value; 0 to 2147483647; in samples\n",
        "body": "ultraschall.GetSetConfigAdjRecManLat(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAFXCFG lua": {
        "prefix": "ultraschall.GetSetConfigAfxCfg",
        "scope": "lua",
        "description": "Gets/Sets the value of the audioformat for \"Apply FX, Glue, Freeze, etc\", as set in the Project Settings->Media-dialog\nOnly sets the format, not the individual format-settings(like bitrate, etc)!\nTo keep the setting for new projects as standard-setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"afxcfg\", as well as the reaper.ini-entry \"REAPER -> afxcfg\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the new set audioformat\nsetting:the new set audioformat\npersist:true, this setting will be standard-setting for new projects after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/newly set audioformat \n",
        "body": "ultraschall.GetSetConfigAfxCfg(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGALLSTEREOPAIRS lua": {
        "prefix": "ultraschall.GetSetConfigAllStereoPairs",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Show non-standard stereo channel pairs(i.e Input2/Input3 etc)\"-checkbox in the Channel naming/mapping-section, as set in Preferences -> Audio\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"allstereopairs\", as well as the reaper.ini-entry \"REAPER -> allstereopairs\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAllStereoPairs(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGALWAYSALLOWKB lua": {
        "prefix": "ultraschall.GetSetConfigAlwaysAllowKB",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Allow keyboard commands even when mouse-editing\"-checkbox, as set in Preferences -> General ->Advanced UI/system tweaks\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"alwaysallowkb\", as well as the reaper.ini-entry \"REAPER -> alwaysallowkb\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value; 0 to 1\nsetting:the current/new setting-value; 0 to 1\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value; 0(don't allow) to 1(allow)\n",
        "body": "ultraschall.GetSetConfigAlwaysAllowKB(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAPPLYFXTAIL lua": {
        "prefix": "ultraschall.GetSetConfigApplyFXTail",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Tail length when using Apply FX to items\"-inputbox in milliseconds, as set in Preferences -> Media\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"applyfxtail\", as well as the reaper.ini-entry \"REAPER -> applyfxtail\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value; 0 to 2147483647\nsetting:the current/new setting-value; 0 to 2147483647\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value; 0 to 2147483647\n",
        "body": "ultraschall.GetSetConfigApplyFXTail(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGADJRECMANLATIN lua": {
        "prefix": "ultraschall.GetSetConfigAdjRecManLatIn",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Input manual offset-samples\"-inputbox, as set in Preferences -> Recording\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"adjrecmanlatin\", as well as the reaper.ini-entry \"REAPER -> adjrecmanlatin\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAdjRecManLatIn(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOPRSHIFT lua": {
        "prefix": "ultraschall.GetSetConfigAudioPrShift",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Preserve pitch in audio items when changing master playrate\", as set in the contextmenu of the master-playrate in the transport-area as well as toggled by action 40671(all sections)\nThis is a project-setting. That means, setting persist to true will have an effect on new projects create, but only after you restarted Reaper!\nThis alters the configuration-variable \"audioprshift\", as well as the reaper.ini-entry \"REAPER -> audioprshift\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept for new projects, but only after restart of Reaper; false, old standard-project-setting will be kept\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAudioPrShift(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOCLOSESTOP lua": {
        "prefix": "ultraschall.GetSetConfigAudioCloseStop",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Close audio device when stopped and active(less responsive)\"-checkbox, as set in Preferences -> Audio\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"audioclosestop\", as well as the reaper.ini-entry \"REAPER -> audioclosestop\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAudioCloseStop(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOTHREADPR lua": {
        "prefix": "ultraschall.GetSetConfigAudioThreadPr",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Audio thread priority\"-dropdownlist, as set in Preferences -> Device\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"audiothreadpr\", as well as the reaper.ini-entry \"REAPER -> audiothreadpr\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAudioThreadPr(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOCLOSETRACKWNDS lua": {
        "prefix": "ultraschall.GetSetConfigAudioCloseTrackWnds",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Allow snap grid/track envelope/routing windows to stay open\"-checkbox in Preferences -> General -> Advanced UI/system tweaks.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"autoclosetrackwnds\", as well as the reaper.ini-entry \"REAPER -> autoclosetrackwnds\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAudioCloseTrackWnds(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOMUTE lua": {
        "prefix": "ultraschall.GetSetConfigAutoMute",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Automute-dropdownlist in the section Mute\"-settings, as set in Preferences -> Mute/Solo\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"automute\", as well as the reaper.ini-entry \"REAPER -> automute\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAutoMute(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOMUTEFLAGS lua": {
        "prefix": "ultraschall.GetSetConfigAutoMuteFlags",
        "scope": "lua",
        "description": "Sets the \"Reset on playback start\"-checkbox in section Mute-settings, as set in Preferences -> Mute/Solo\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"automuteflags\", as well as the reaper.ini-entry \"REAPER -> automuteflags\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAutoMuteFlags(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOSAVEINT lua": {
        "prefix": "ultraschall.GetSetConfigAutoSaveInt",
        "scope": "lua",
        "description": "Sets the \"Every x minutes\"-inputbox from the Project saving-section, as set in Preferences -> Project.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"autosaveint\", as well as the reaper.ini-entry \"REAPER -> autosaveint\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAutoSaveInt(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOSAVEMODE lua": {
        "prefix": "ultraschall.GetSetConfigAutoSaveMode",
        "scope": "lua",
        "description": "Sets the \"Every x minutes\"-dropdownlist from the Project saving-section, as set in Preferences -> Project.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"autosavemode\", as well as the reaper.ini-entry \"REAPER -> autosavemode\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "ultraschall.GetSetConfigAutoSaveMode(${1:boolean set},${2:integer setting},${3:boolean persist})$0"
    },
    "ULTRASCHALL.SETRENDER_OFFLINEONLINEMODE lua": {
        "prefix": "ultraschall.SetRender_OfflineOnlineMode",
        "scope": "lua",
        "description": "sets the current mode of the offline/online-render-dropdownlist from the Render to File-dialog\nReturns false in case of an error\nPARAMETERS:\nmode:the mode, that you want to set\nRETURNS:\nretval:true, setting it was successful; false, setting it was unsuccessful\n",
        "body": "ultraschall.SetRender_OfflineOnlineMode(${1:integer mode})$0"
    },
    "ULTRASCHALL.GETRENDER_OFFLINEONLINEMODE lua": {
        "prefix": "ultraschall.GetRender_OfflineOnlineMode",
        "scope": "lua",
        "description": "gets the current mode of the offline/online-render-dropdownlist from the Render to File-dialog\nRETURNS:\nmode:the mode, that is set\n",
        "body": "ultraschall.GetRender_OfflineOnlineMode()$0"
    },
    "ULTRASCHALL.GETRENDER_RESAMPLEMODE lua": {
        "prefix": "ultraschall.GetRender_ResampleMode",
        "scope": "lua",
        "description": "gets the current mode of the \"Resample mode (if needed)\"-dropdownlist from the Render to File-dialog\nRETURNS:\nmode:the mode, that is set\n",
        "body": "ultraschall.GetRender_ResampleMode()$0"
    },
    "ULTRASCHALL.SETRENDER_RESAMPLEMODE lua": {
        "prefix": "ultraschall.SetRender_ResampleMode",
        "scope": "lua",
        "description": "sets the current mode of the \"Resample mode (if needed)\"-dropdownlist from the Render to File-dialog\nReturns false in case of an error\nPARAMETERS:\nmode:the mode, that is set\nRETURNS:\nretval:true, setting it was successful; false, setting it was unsuccessful\n",
        "body": "ultraschall.SetRender_ResampleMode(${1:integer mode})$0"
    },
    "ULTRASCHALL.GETSTARTNEWFILERECSIZESTATE lua": {
        "prefix": "ultraschall.GetStartNewFileRecSizeState",
        "scope": "lua",
        "description": "Returns, if Reaper shall start a file after a specified amount of MegaBytes as well, if the fileswitches shall be offset when multitrack-recording and the maximum filesize before starting a new file.\nsee SetStartNewFileRecSizeState for setting the current settings.\nRETURNS:\nstart_new_files:true, Reaper starts a new file, when a recorded file reaches max_rec_size; false, files are as long until recording stops\noffset_file_switches:true, When recording multiple tracks, offset file switches for better performance; false, don't offset file-switches\nmax_rec_size:the maximum length of a recorded file in MegaBytes, before Reaper shall start a new file; only applied when When recording multiple tracks, offset file switches for better performance=true\n",
        "body": "ultraschall.GetStartNewFileRecSizeState()$0"
    },
    "ULTRASCHALL.SETSTARTNEWFILERECSIZESTATE lua": {
        "prefix": "ultraschall.SetStartNewFileRecSizeState",
        "scope": "lua",
        "description": "Sets, if Reaper shall start a file after a specified amount of MegaBytes as well, if the fileswitches shall be offset when multitrack-recording and the maximum filesize before starting a new file.\nsee GetStartNewFileRecSizeState for getting the current settings.\nReturns false in case of an error\nPARAMETERS:\nstart_new_files:true, Reaper starts a new file, when a recorded file reaches max_rec_size; false, files are as long until recording stops\noffset_file_switches:true, When recording multiple tracks, offset file switches for better performance; false, don't offset file-switches\npersist:true, set the setting to reaper.ini so it persists after restarting Reaper; false, set it only for the time, until Reaper is restarted\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "ultraschall.SetStartNewFileRecSizeState(${1:boolean start_new_files},${2:boolean offset_file_switches},${3:integer maxrecsize},${4:boolean persist})$0"
    },
    "ULTRASCHALL.GETDEFERRUNSTATE lua": {
        "prefix": "ultraschall.GetDeferRunState",
        "scope": "lua",
        "description": "returns the run-state of a Ultraschall-defer-loop in a specific scriptinstance\nYou can either request the runstate of a Defer.\nreturns nil in case of an error.\nPARAMETERS:\ndeferinstance:0, to use the parameter identifier\nRETURNS:\nretval:true, defer-instance is running; false, defer-instance isn't running\n",
        "body": "ultraschall.GetDeferRunState(${1:integer deferinstance},${2:optional string scriptidentifier})$0"
    },
    "ULTRASCHALL.STOPDEFERCYCLE lua": {
        "prefix": "ultraschall.StopDeferCycle",
        "scope": "lua",
        "description": "Stops a running ultraschall.Defer-instance of a script-instance.\nreturns false in case of an error\nPARAMETERS:\ndefer_identifier:the identifier of the defer-cycle of a script-instance\nRETURNS:\nretval:true, stopping this defer-cycle was successful; false, it wasn't successful\n",
        "body": "ultraschall.StopDeferCycle(${1:string defer_identifier})$0"
    },
    "ULTRASCHALL.DEFER lua": {
        "prefix": "ultraschall.Defer",
        "scope": "lua",
        "description": "runs a custom-defer-cycle, which can be individualized.\nYou can set, how often this defer-cycle shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\\_identifier you have given.\nTo stop such a defer-cycle, use StopDeferCycle, as long as parameter protected is not set to true!\n**Important:** make the deferidentifier as unique as possible(using guids or similar stuff) to avoid naming conflicts with other defer-cycles using the same identifier.\nOtherwise, you risk stopping multiple such defer-loops, when using StopDeferCycle!\nFor the old Defer1 to Defer20-behavior, try ultraschall.ScriptIdentifier..\".defer_scriptXX\" as defer-identifier, where XX is a number.\nreturns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)\nPARAMETERS:\nfunc:the function, you would love to defer to\ndeferidentifier:an identifier, under which you can access this defer-cycle; make it unique using guids in the name, to avoid name-conflicts!\nmode:0 or nil, just run as regular defer-cycle\ntimer_counter:the timer for the defer-cycle\nprotected:true, this defer-cycle is protected from being stopped by StopDeferCycle(); false or nil, you can stop this defer-cycle using StopDeferCycle()\nRETURNS:\nretval:true, running this defer-cycle was successful; false, it wasn't successful\ndefer_identifier:if running this defer-cycle was successful, this holds the defer-identifier you've chosen\n",
        "body": "ultraschall.Defer(${1:function func},${2:string deferidentifier},${3:optional integer mode},${4:optional number timer_counter},${5:optional boolean protected})$0"
    },
    "ULTRASCHALL.SETDEFERCYCLESETTINGS lua": {
        "prefix": "ultraschall.SetDeferCycleSettings",
        "scope": "lua",
        "description": "Sets the mode and timing settings of a running ultraschall.Defer-instance. You can set its mode and the timer/counter-values, even from a script, which does not run the defer-instance!\nReturns false in case of failure.\nPARAMETERS:\ndeferidentifier:an identifier, under which you can access this defer-cycle; make it unique using guids in the name, to avoid name-conflicts! \nmode:the timing mode, in which the defer-cycle runs\ntimer_counter:the timer for the defer-cycle\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "ultraschall.SetDeferCycleSettings(${1:string deferidentifier},${2:optional integer mode},${3:optional number timer_counter})$0"
    },
    "ULTRASCHALL.GETDEFERCYCLESETTINGS lua": {
        "prefix": "ultraschall.GetDeferCycleSettings",
        "scope": "lua",
        "description": "Gets a the mode and timing-settings of a currently running ultraschall.Defer()-cycle\nReturns nil in case of failure.\nPARAMETERS:\ndeferidentifier:an identifier, under which you can access this defer-cycle; make it unique using guids in the name, to avoid name-conflicts! \nRETURNS:\nmode:the timing mode, in which the defer-cycle runs\ntimer_counter:the timer for the defer-cycle\n",
        "body": "ultraschall.GetDeferCycleSettings(${1:string deferidentifier})$0"
    },
    "ULTRASCHALL.ISVALIDENVSTATECHUNK lua": {
        "prefix": "ultraschall.IsValidEnvStateChunk",
        "scope": "lua",
        "description": "returns, if a EnvelopeStateChunk is a valid statechunk\nreturns false, in case of an error\nPARAMETERS:\nEnvelopeStateChunk:a string to check, if it's a valid EnvelopeStateChunk\nRETURNS:\nvalid:true, if the string is a valid statechunk; false, if not a valid statechunk\n",
        "body": "ultraschall.IsValidEnvStateChunk(${1:string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.MOVETRACKENVELOPEPOINTSBY lua": {
        "prefix": "ultraschall.MoveTrackEnvelopePointsBy",
        "scope": "lua",
        "description": "Moves the envelopepoints between startposition and endposition by moveby in MediaTrack.\nIt moves all trackenvelope-points for all track-envelopes available.\nDoes NOT move item-envelopepoints!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\nMediaTrack:the MediaTrack object of the track, where the EnvelopsPoints shall be moved\ncut_at_border:true, cut envelope-points, that would move outside section between startposition and endposition\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "ultraschall.MoveTrackEnvelopePointsBy(${1:number startposition},${2:number endposition},${3:number moveby},${4:MediaTrack MediaTrack},${5:boolean cut_at_border})$0"
    },
    "ULTRASCHALL.GETENVELOPEPOINT lua": {
        "prefix": "ultraschall.GetEnvelopePoint",
        "scope": "lua",
        "description": "Returns the values for the idxth envelope point in Tracknumber->EnvelopeName.\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track, beginning with 1. Use 0 for Master Track.\nEnvelopeName:the name of the envelope-lane\nidx:the number of the envelope-point, beginning with 0\nRETURNS:\ntime:the time of the envelope point\nvalue:the raw-value of the envelope point\nshape:the shape of this envelope\ntension:the intensity of the tension of the shape\nselected:true, if this point is selected; false if not\ndBVal:the envelopevalue converted to dB\nEnvelopePointObject:an array with all elements of an envelopepoint\n",
        "body": "ultraschall.GetEnvelopePoint(${1:integer Tracknumber},${2:string EnvelopeName},${3:integer idx})$0"
    },
    "ULTRASCHALL.GETCLOSESTENVELOPEPOINTIDX_BYTIME lua": {
        "prefix": "ultraschall.GetClosestEnvelopePointIDX_ByTime",
        "scope": "lua",
        "description": "Returns the idxs and EnvelopePointObject of the envelope-points closest to timeposition CheckTime\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track, beginning with 1. Use 0 for Master Track.\nEnvelopeName:the name of the envelope-lane\nCheckTime:the time in seconds to check for the closest envelope-points\nRETURNS:\nidxpre:the idx of the closest envelopepoint at or before CheckTime\nEnvelopePointObjectPre:an EnvelopePointObject of idxpre\nidxpost:the idx of the closest envelopepoint after CheckTime\nEnvelopePointObjectPost:an EnvelopePointObject of idxpost\n",
        "body": "ultraschall.GetClosestEnvelopePointIDX_ByTime(${1:integer Tracknumber},${2:string EnvelopeName},${3:number CheckTime})$0"
    },
    "ULTRASCHALL.GETENVELOPEPOINTIDX_BETWEEN lua": {
        "prefix": "ultraschall.GetEnvelopePointIDX_Between",
        "scope": "lua",
        "description": "Returns a string and an EnvelopePointArray with all idx/EnvelopePointObjects of all envelopepoints between startposition and endposition in the EnvelopeName-lane.\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track. 1 for track 1, 2 for track 2, etc. 0 for Master-track.\nEnvelopeName:the name of the envelope-lane, where you want to have the envelope-points of.\nstartposition:the startposition of the selection in seconds. Must be bigger than or equal 0.\nendposition:the endposition of the selection in seconds. Must be bigger than startposition.\nRETURNS:\nEnvelopeString:a string with all envelope-point-idx in the selection, separated by commas.\nEnvelopePointArray:an array with all EnvelopePointObjects of all envelope-points in selection.\n",
        "body": "ultraschall.GetEnvelopePointIDX_Between(${1:integer Tracknumber},${2:string EnvelopeName},${3:number startposition},${4:number endposition})$0"
    },
    "ULTRASCHALL.CHECKENVELOPEPOINTOBJECT lua": {
        "prefix": "ultraschall.CheckEnvelopePointObject",
        "scope": "lua",
        "description": "Checks, if EnvelopePointObject is valid or not.\nreturns false in case of an error\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.CheckEnvelopePointObject(${1:array EnvelopePointObject})$0"
    },
    "ULTRASCHALL.ISVALIDENVELOPEPOINTOBJECT lua": {
        "prefix": "ultraschall.IsValidEnvelopePointObject",
        "scope": "lua",
        "description": "Checks, if EnvelopePointObject is valid or not.\nreturns false in case of an error\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.IsValidEnvelopePointObject(${1:array EnvelopePointObject})$0"
    },
    "ULTRASCHALL.SETENVELOPEPOINTS_ENVELOPEPOINTOBJECT lua": {
        "prefix": "ultraschall.SetEnvelopePoints_EnvelopePointObject",
        "scope": "lua",
        "description": "Sets an envelope-point, as defined in EnvelopePointObject.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.SetEnvelopePoints_EnvelopePointObject(${1:array EnvelopePointObject},${2:boolean sort_in})$0"
    },
    "ULTRASCHALL.SETENVELOPEPOINTS_ENVELOPEPOINTARRAY lua": {
        "prefix": "ultraschall.SetEnvelopePoints_EnvelopePointArray",
        "scope": "lua",
        "description": "Sets envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointArray:an array with all EnvelopePointObjects you want to insert\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.SetEnvelopePoints_EnvelopePointArray(${1:array EnvelopePointArray},${2:boolean sort_in})$0"
    },
    "ULTRASCHALL.DELETEENVELOPEPOINTS_ENVELOPEPOINTOBJECT lua": {
        "prefix": "ultraschall.DeleteEnvelopePoints_EnvelopePointObject",
        "scope": "lua",
        "description": "Deletes an envelope-point, as defined in EnvelopePointObject.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.DeleteEnvelopePoints_EnvelopePointObject(${1:array EnvelopePointObject})$0"
    },
    "ULTRASCHALL.DELETEENVELOPEPOINTS_ENVELOPEPOINTARRAY lua": {
        "prefix": "ultraschall.DeleteEnvelopePoints_EnvelopePointArray",
        "scope": "lua",
        "description": "Deletes the envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointArray:an array with all EnvelopePointObjects you want to insert\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.DeleteEnvelopePoints_EnvelopePointArray(${1:array EnvelopePointArray})$0"
    },
    "ULTRASCHALL.ADDENVELOPEPOINTS_ENVELOPEPOINTOBJECT lua": {
        "prefix": "ultraschall.AddEnvelopePoints_EnvelopePointObject",
        "scope": "lua",
        "description": "Adds an envelope-point, as defined in EnvelopePointObject.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.AddEnvelopePoints_EnvelopePointObject(${1:array EnvelopePointObject},${2:boolean sort_in})$0"
    },
    "ULTRASCHALL.ADDENVELOPEPOINTS_ENVELOPEPOINTARRAY lua": {
        "prefix": "ultraschall.AddEnvelopePoints_EnvelopePointArray",
        "scope": "lua",
        "description": "Adds the envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointArray:an array with all EnvelopePointObjects you want to insert\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "ultraschall.AddEnvelopePoints_EnvelopePointArray(${1:array EnvelopePointArray},${2:boolean sort_in})$0"
    },
    "ULTRASCHALL.CREATEENVELOPEPOINTOBJECT lua": {
        "prefix": "ultraschall.CreateEnvelopePointObject",
        "scope": "lua",
        "description": "Creates a new EnvelopePointObject, that can be used by other ultraschall-api-envelope-functions\nreturns false in case of error\nPARAMETERS:\nTrackEnvelope:the track-envelope, in which this EnvelopePointObject shall be\nidx:the number of the envelope-point, beginning with 0\ntime:the time of the envelope point in seconds\nvalue:the raw-value of the envelope point\nshape:the shape of this envelope\ntension:the intensity of the tension of the shape\nselected:true, if this point is selected; false if not\nRETURNS:\nretval:false in case of error, true in case of success.\nEnvelopePointObject:an array with all elements of the envelopepoint\n",
        "body": "ultraschall.CreateEnvelopePointObject(${1:TrackEnvelope TrackEnvelope},${2:integer idx},${3:number time},${4:number value},${5:integer shape},${6:number tension},${7:boolean selected})$0"
    },
    "ULTRASCHALL.COUNTENVELOPEPOINTS lua": {
        "prefix": "ultraschall.CountEnvelopePoints",
        "scope": "lua",
        "description": "Counts and returns the number of envelope-points in track Tracknumber, envelopelane EnvelopeName.\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track, beginning with 1. Use 0 for Master Track.\nEnvelopeName:the name of the envelope-lane\nRETURNS:\nenvpoint_count:the number of envelope-points in requested track+envelope-lane\n",
        "body": "ultraschall.CountEnvelopePoints(${1:integer Tracknumber},${2:string EnvelopeName})$0"
    },
    "ULTRASCHALL.SETENVELOPEHEIGHT lua": {
        "prefix": "ultraschall.SetEnvelopeHeight",
        "scope": "lua",
        "description": "Changes the Envelope-lane-height and compactible state of TrackEnvelope or TrackEnvelopeStateChunk.\nreturns false in case of an error\nPARAMETERS:\nHeight:the height of the envelopelane in pixels when not compacted. Reaper accepts 24-443 currently. Nil keeps old value.\nCompacted:shall the envelopelane be compacted(true) or not(false). Nil keeps old value.\nTrackEnvelope:the TrackEnvelopeStateChunk you want to alter. Will be used only, if TrackEnvelope is set to nil\nTrackEnvelopeStateChunk:the TrackEnvelopeStateChunk you want to alter. Will be used only, if TrackEnvelope is set to nil\nRETURNS:\nretval:true in case of success; false in case of error\nTrackEnvelopeStateChunk:the altered TrackEnvelopeStateChunk\n",
        "body": "ultraschall.SetEnvelopeHeight(${1:integer Height},${2:boolean Compacted},${3:TrackEnvelope TrackEnvelope},${4:string TrackEnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETALLTRACKENVELOPES lua": {
        "prefix": "ultraschall.GetAllTrackEnvelopes",
        "scope": "lua",
        "description": "Returns all TrackEnvelopes of all tracks from the current project as a handy table\nThe format of the table is as follows:\nTrackEnvelopes[trackenvelope_idx][\"Track\"] - the idx of the track; 0, for mastertrack, 1, for first track, etc\nTrackEnvelopes[trackenvelope_idx][\"EnvelopeObject\"] - the TrackEnvelope-object\nTrackEnvelopes[trackenvelope_idx][\"EnvelopeName\"] - the name of of TrackEnvelopeObject\nRETURNS:\nnumber_of_trackenvelopes:the number of TrackEnvelopes found in the current project\nTrackEnvelopes_Table:all found TrackEnvelopes as a handy table(see description for details)\n",
        "body": "ultraschall.GetAllTrackEnvelopes()$0"
    },
    "ULTRASCHALL.ISVALIDENVELOPEPOINTARRAY lua": {
        "prefix": "ultraschall.IsValidEnvelopePointArray",
        "scope": "lua",
        "description": "Checks, if an EnvelopePointArray is a valid one.\nReturns false in case of an error\nPARAMETERS:\nEnvelopePointArray:the EnvelopePointArray to check for it's validity\nRETURNS:\nretval:true, EnvelopePointArray is a valid one; false, EnvelopePointArray isn't valid\n",
        "body": "ultraschall.IsValidEnvelopePointArray(${1:EnvelopePointArray EnvelopePointArray})$0"
    },
    "ULTRASCHALL.GETLASTENVELOPEPOINT_TRACKENVELOPE lua": {
        "prefix": "ultraschall.GetLastEnvelopePoint_TrackEnvelope",
        "scope": "lua",
        "description": "Gets the values of the last envelope-point in TrackEnvelope/MediaItemEnvelope.\nNote: there's a \"hidden\" last envelopepoint in every Envelope, which will be ignored by this function. It will return the last visible envelope-point instead!\nReturns false in case of an error\nPARAMETERS:\nEnvelope:the Trackenvelope/MediaItemenvelope, whose last point you want\nRETURNS:\nretval:true, getting the envelopepoint was successful; false, in case of an error\nenvpointidx:the idx of the found envelope-point; with 0 for the first one on the Envelope\ntime:the time of the envelope-point in seconds\nvalue:the value of the envelope-point\nshape:the shape of the envelope-point\ntension:the intensity of the tension of the shape\noptional boolean selected:true, envelope-point is selected; false, it is not selected\n",
        "body": "ultraschall.GetLastEnvelopePoint_TrackEnvelope(${1:TrackEnvelope Envelope})$0"
    },
    "ULTRASCHALL.GETARMSTATE_ENVELOPE lua": {
        "prefix": "ultraschall.GetArmState_Envelope",
        "scope": "lua",
        "description": "Returns the current armed-state of a TrackEnvelope-object.\nIt is the entry ARM\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose armed-state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nretval:0, unarmed; 1, armed\n",
        "body": "ultraschall.GetArmState_Envelope(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.SETARMSTATE_ENVELOPE lua": {
        "prefix": "ultraschall.SetArmState_Envelope",
        "scope": "lua",
        "description": "Sets the new armed-state of a TrackEnvelope-object.\nreturns false in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose armed-state you want to change\nstate:0, unarmed; 1, armed\nEnvelopeStateChunk:if parameter TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameters and change its arm-state\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\nEnvelopeStateChunk:the altered EnvelopeStateChunk, when parameter TrackEnvelope is set to nil\n",
        "body": "ultraschall.SetArmState_Envelope(${1:TrackEnvelope TrackEnvelope},${2:integer state},${3:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKENVELOPE_CLICKSTATE lua": {
        "prefix": "ultraschall.GetTrackEnvelope_ClickState",
        "scope": "lua",
        "description": "Returns the currently clicked Envelopepoint and TrackEnvelope, as well as the current timeposition.\nWorks only, if the mouse is above the EnvelopePoint while having it clicked!\nReturns false, if no envelope is clicked at\nRETURNS:\nclickstate:true, an envelopepoint has been clicked; false, no envelopepoint has been clicked\nposition:the position, at which the mouse has clicked\ntrack:the track, from which the envelope and it's corresponding point is taken from\nenvelope:the TrackEnvelope, in which the clicked envelope-point lies\nEnvelopePointIDX:the id of the clicked EnvelopePoint\n",
        "body": "ultraschall.GetTrackEnvelope_ClickState()$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_NUMBERSONLY lua": {
        "prefix": "ultraschall.GetEnvelopeState_NumbersOnly",
        "scope": "lua",
        "description": "returns a state from an EnvelopeStateChunk.\nIt only supports single-entry-states with numbers/integers, separated by spaces!\nAll other values will be set to nil and strings with spaces will produce weird results!\nreturns nil in case of an error\nPARAMETERS:\nstate:the state, whose attributes you want to retrieve\nfunctionname:if this function is used within specific gettrackstate-functions, pass here the \"host\"-functionname, so error-messages will reflect that\nnumbertoggle:true or nil; converts all values to numbers; false, keep them as string versions\nRETURNS:\nvalues:all values found as numerical indexed array\n",
        "body": "ultraschall.GetEnvelopeState_NumbersOnly(${1:string state},${2:optional string EnvelopeStateChunk},${3:optional string functionname},${4:optional boolean numbertoggle})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_ACT lua": {
        "prefix": "ultraschall.GetEnvelopeState_Act",
        "scope": "lua",
        "description": "Returns the current act-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry ACT\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nact:0, bypass on\nautomation_settings:automation item-options for this envelope\n",
        "body": "ultraschall.GetEnvelopeState_Act(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_VIS lua": {
        "prefix": "ultraschall.GetEnvelopeState_Vis",
        "scope": "lua",
        "description": "Returns the current visibility-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry VIS\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nvisible:1, envelope is visible\nlane:1, envelope is in it's own lane \nunknown:unknown; default=1\n",
        "body": "ultraschall.GetEnvelopeState_Vis(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_LANEHEIGHT lua": {
        "prefix": "ultraschall.GetEnvelopeState_LaneHeight",
        "scope": "lua",
        "description": "Returns the current laneheight-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry LANEHEIGHT\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nheight:the height of this envelope in pixels; 24 - 263 pixels\ncompacted:1, envelope-lane is compacted(\"normal\" height is not shown but still stored in height); \n",
        "body": "ultraschall.GetEnvelopeState_LaneHeight(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_DEFSHAPE lua": {
        "prefix": "ultraschall.GetEnvelopeState_DefShape",
        "scope": "lua",
        "description": "Returns the current default-shape-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry DEFSHAPE\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nshape:0, linear\nb:unknown; default value is -1; probably pitch/snap\nc:unknown; default value is -1; probably pitch/snap\n",
        "body": "ultraschall.GetEnvelopeState_DefShape(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_VOLTYPE lua": {
        "prefix": "ultraschall.GetEnvelopeState_Voltype",
        "scope": "lua",
        "description": "Returns the current voltype-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry VOLTYPE\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nvoltype:1, default volume-type is fader-scaling; if VOLTYPE-entry is not existing, default volume-type is amplitude-scaling\n",
        "body": "ultraschall.GetEnvelopeState_Voltype(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_POOLEDENVINSTANCE lua": {
        "prefix": "ultraschall.GetEnvelopeState_PooledEnvInstance",
        "scope": "lua",
        "description": "Returns the current state of a certain automation-item within a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry POOLEDENVINST\nreturns nil in case of error\nPARAMETERS:\nindex:the index-number of the automation-item, whose states you want to have\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nid:counts the automation-item-instances in this project, including deleted ones; 1-based\nposition:position in seconds\nlength:length in seconds\nstart_offset:offset in seconds\nplayrate:playrate; minimum value is 0.001; default is 1.000\nselected:1, automation item is selected; 0, automation item isn't selected\nbaseline:0(-100) to 1(+100); default 0.5(0)\nloopsource:Loop Source; 0 and 1 are allowed settings; 1 is default\ni:1, mute automation-item; 0, unmute automation-item\nj:unknown; 0 is default\npool_id:counts the automation-item-instances in this project, including deleted ones; 1-based\nmute:1, mute automation-item; 0, unmute automation-item\n",
        "body": "ultraschall.GetEnvelopeState_PooledEnvInstance(${1:integer index},${2:TrackEnvelope TrackEnvelope},${3:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_PT lua": {
        "prefix": "ultraschall.GetEnvelopeState_PT",
        "scope": "lua",
        "description": "Returns the current state of a certain envelope-point within a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry PT\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nposition:position of the point in seconds\nvolume:volume as fader-value\nselected:1, selected; disappearing, unselected\nbezier_tens2:disappears, if no bezier is set; -1 to 1 \n",
        "body": "ultraschall.GetEnvelopeState_PT(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_ENVNAME lua": {
        "prefix": "ultraschall.GetEnvelopeState_EnvName",
        "scope": "lua",
        "description": "Returns the current envelope-name-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the opening <-tag of the EnvelopeStateChunk\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nenvelopename:the name of the envelope, usually:\nfx_env_id:fx_env is the id of the envelope, as provided by this fx; beginning with 1 for the first\nwet_byp:wet_byp is either \"\" if not existing, wet or bypass\nminimum_range:the minimum value, accepted by this envelope; 6 digits-precision\nmaximum_range:the maximum-value, accepted by this envelope; 6 digits-precision\nunknown:unknown\n",
        "body": "ultraschall.GetEnvelopeState_EnvName(${1:TrackEnvelope TrackEnvelope},${2:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETALLTAKEENVELOPES lua": {
        "prefix": "ultraschall.GetAllTakeEnvelopes",
        "scope": "lua",
        "description": "Returns all TakeEnvelopes of all MediaItems from the current project as a handy table\nThe format of the table is as follows:\nTakeEnvelopes[takeenvelope_idx][\"MediaItem\"] - the idx of the MediaItem\nTakeEnvelopes[takeenvelope_idx][\"MediaItem_Take\"] - the idx of the trake of the MediaItem\nTakeEnvelopes[takeenvelope_idx][\"MediaItem_Take_Name\"] - the name of the MediaItek_Take\nTakeEnvelopes[takeenvelope_idx][\"EnvelopeObject\"] - the TakeEnvelopeObject in question\nTakeEnvelopes[takeenvelope_idx][\"EnvelopeName\"] - the name of of TakeEnvelopeObject\nRETURNS:\nnumber_of_takeenvelopes:the number of TakeEnvelopes found in the current project\nTakeEnvelopes_Table:all found TakeEnvelopes as a handy table(see description for details)\n",
        "body": "ultraschall.GetAllTakeEnvelopes()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATESTARTUPEVENTS lua": {
        "prefix": "ultraschall.EventManager_EnumerateStartupEvents",
        "scope": "lua",
        "description": "Enumerates already existing startupevents, that shall be automatically run at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be started automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nindex:the index of the StartUp-event, whose attributes you want to get; 1 for the first, etc\nRETURNS:\nEventIdentifier:the EventIdentifier of the startup-event\nCallerScriptIdentifier:the ScriptIdentifier of the script, which added this event to the StartUpEvents\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nPaused:true, the event shall be started as paused; false, the event shall be run immediately\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "ultraschall.EventManager_EnumerateStartupEvents(${1:integer index})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATESTARTUPEVENTS2 lua": {
        "prefix": "ultraschall.EventManager_EnumerateStartupEvents2",
        "scope": "lua",
        "description": "Enumerates already existing startupevents by an EventIdentifier.\nStartupEvents are events, that shall be automatically run at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be started automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the identifier of the StartupEvent, that you want to enumerate\nRETURNS:\nindex:the index of the StartupEvent within all StartUpEvents\nEventIdentifier:the EventIdentifier of the startup-event\nCallerScriptIdentifier:the ScriptIdentifier of the script, which added this event to the StartUpEvents\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nPaused:true, the event shall be started as paused; false, the event shall be run immediately\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "ultraschall.EventManager_EnumerateStartupEvents2(${1:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ADDEVENT lua": {
        "prefix": "ultraschall.EventManager_AddEvent",
        "scope": "lua",
        "description": "Adds a new event to the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nPARAMETERS:\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet\nCheckFunction:the function, which shall check if the event occurred\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred\nRETURNS:\nevent_identifier:the unique identifier for this registered event, which can be used later for setting, deleting, etc\n",
        "body": "ultraschall.EventManager_AddEvent(${1:string EventName},${2:integer CheckAllXSeconds},${3:integer CheckForXSeconds},${4:boolean StartActionsOnceDuringTrue},${5:boolean EventPaused},${6:function CheckFunction},${7:table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ISVALIDEVENTIDENTIFIER lua": {
        "prefix": "ultraschall.EventManager_IsValidEventIdentifier",
        "scope": "lua",
        "description": "Checks, if a string is a valid EventIdentifier (valid) and currently registered with an event(valid_inuse) in the Ultraschall-EventManager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, that you want to check\nRETURNS:\nvalid:true, valid EventIdentifier, which is currently registered and in use by the EventManager; false, no currently registered EventIdentifier\nvalid_inuse:true, valid EventIdentifier, which is currently registered and in use by the EventManager; false, no currently registered EventIdentifier\n",
        "body": "ultraschall.EventManager_IsValidEventIdentifier(${1:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVEEVENT lua": {
        "prefix": "ultraschall.EventManager_RemoveEvent",
        "scope": "lua",
        "description": "Removes a new event to the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, which you want to remove from the EventManager\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "ultraschall.EventManager_RemoveEvent(${1:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVEALLEVENTS_SCRIPT lua": {
        "prefix": "ultraschall.EventManager_RemoveAllEvents_Script",
        "scope": "lua",
        "description": "Removes all registered events from a script with a certain ScriptIdentifier in the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nScriptIdentifier:the unique identifier of the registered event, which you want to remove from the EventManager\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "ultraschall.EventManager_RemoveAllEvents_Script(${1:string ScriptIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_SETEVENT lua": {
        "prefix": "ultraschall.EventManager_SetEvent",
        "scope": "lua",
        "description": "Sets the attributes of an already added event in the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the registered event, which you want to set\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed; nil, keep the old name\nCheckAllXSeconds:only check all x seconds; 0, for constant checking; nil, keep the old value\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed; nil, keep the old value\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet; nil, keep the old value\nCheckFunction:the function, which shall check if the event occurred; nil, keep the old function\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred; nil, keep the old actionlist\nRETURNS:\nretval:true, setting was successful; false, setting wasn't successful\n",
        "body": "ultraschall.EventManager_SetEvent(${1:string EventIdentifier},${2:optional string EventName},${3:optional integer CheckAllXSeconds},${4:optional integer CheckForXSeconds},${5:optional boolean StartActionsOnceDuringTrue},${6:optional boolean EventPaused},${7:optional function CheckFunction},${8:optional table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATEEVENTS lua": {
        "prefix": "ultraschall.EventManager_EnumerateEvents",
        "scope": "lua",
        "description": "Gets the attributes of an already added event in the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nPARAMETERS:\nid:the id of the currently registered event, of which you want to have the attributes; starting with 1 for the first\nRETURNS:\nEventIdentifier:the EventIdentifier of the registered event\nEventName:the name of the event\nCallerScriptIdentifier:the ScriptIdentifier of the script, who registered the event\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:true, eventcheck is currently paused; false, eventcheck is currently running\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "ultraschall.EventManager_EnumerateEvents(${1:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATEEVENTS2 lua": {
        "prefix": "ultraschall.EventManager_EnumerateEvents2",
        "scope": "lua",
        "description": "Gets the attributes of an already added event in the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nRETURNS:\nEventIdentifier:the EventIdentifier of the registered event\nEventName:the name of the event\nCallerScriptIdentifier:the ScriptIdentifier of the script, who registered the event\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:true, eventcheck is currently paused; false, eventcheck is currently running\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "ultraschall.EventManager_EnumerateEvents2(${1:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_COUNTREGISTEREDEVENTS lua": {
        "prefix": "ultraschall.EventManager_CountRegisteredEvents",
        "scope": "lua",
        "description": "Returns the number of currently registered events in the EventManager-checking-queue\nRETURNS:\ncount_of_registered_events:the number of currently registered events\n",
        "body": "ultraschall.EventManager_CountRegisteredEvents()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETLASTUPDATETIME lua": {
        "prefix": "ultraschall.EventManager_GetLastUpdateTime",
        "scope": "lua",
        "description": "Returns the last time, the eventlist in the EventManager had been updated in any way.\nRETURNS:\ndatetime:the date and time of the last update, as returned by os.date()\nprecise_time:the last update time as number, as returned by reaper.time_precise()\n",
        "body": "ultraschall.EventManager_GetLastUpdateTime()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_PAUSEEVENT lua": {
        "prefix": "ultraschall.EventManager_PauseEvent",
        "scope": "lua",
        "description": "Pauses a registered event in the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, which you want to pause in the EventManager\nRETURNS:\nretval:true, pausing was successful; false, pausing was unsuccessful\n",
        "body": "ultraschall.EventManager_PauseEvent(${1:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_RESUMEEVENT lua": {
        "prefix": "ultraschall.EventManager_ResumeEvent",
        "scope": "lua",
        "description": "Resumes a registered and paused event in the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, which you want to resume in the EventManager\nRETURNS:\nretval:true, resuming was successful; false, resuming was unsuccessful\n",
        "body": "ultraschall.EventManager_ResumeEvent(${1:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_START lua": {
        "prefix": "ultraschall.EventManager_Start",
        "scope": "lua",
        "description": "Starts the Ultraschall-EventManager, if it has not been started yet.\nRETURNS:\nretval:true, EventManager has been started successfully; false, EventManager couldn't be started\n",
        "body": "ultraschall.EventManager_Start()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_STOP lua": {
        "prefix": "ultraschall.EventManager_Stop",
        "scope": "lua",
        "description": "Unregisters the current script; will stop the EventManager if no scripts are registered anymore to the EventManager.\nYou can use the parameter force to force stopping of the EventManager immediately.\nPARAMETERS:\nforce:true, stops the EventManager, even if other scripts have registered events to it; false or nil, don't force stop\nScriptIdentifier:if you want to unregister events from a different script, pass here the ScriptIdentifier of this script; nil, use the ScriptIdentifier of the current script\n",
        "body": "ultraschall.EventManager_Stop(${1:optional boolean force},${2:optional string ScriptIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ADDSTARTUPEVENT lua": {
        "prefix": "ultraschall.EventManager_AddStartupEvent",
        "scope": "lua",
        "description": "Adds a new event, that shall be automatically registered at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be added automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet\nCheckFunction:the function, which shall check if the event occurred\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred\nRETURNS:\nevent_identifier:the unique identifier for this registered event, which can be used later for setting, deleting, etc\n",
        "body": "ultraschall.EventManager_AddStartupEvent(${1:string EventName},${2:integer CheckAllXSeconds},${3:integer CheckForXSeconds},${4:boolean StartActionsOnceDuringTrue},${5:boolean EventPaused},${6:function CheckFunction},${7:table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVESTARTUPEVENT2 lua": {
        "prefix": "ultraschall.EventManager_RemoveStartupEvent2",
        "scope": "lua",
        "description": "Removes a startup-event from the config-file of the Ultraschall Event Manager.\nreturns false in case of an error\nPARAMETERS:\nid:the unique identifier of the startup event, which you want to remove from the EventManager-startup-procedure\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "ultraschall.EventManager_RemoveStartupEvent2(${1:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVESTARTUPEVENT lua": {
        "prefix": "ultraschall.EventManager_RemoveStartupEvent",
        "scope": "lua",
        "description": "Removes a startup-event from the config-file of the Ultraschall Event Manager.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the startup event, which you want to remove from the EventManager-startup-procedure\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "ultraschall.EventManager_RemoveStartupEvent(${1:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_COUNTSTARTUPEVENTS lua": {
        "prefix": "ultraschall.EventManager_CountStartupEvents",
        "scope": "lua",
        "description": "Counts the currently available startup-events\nRETURNS:\ncount_startup_events:the number of currently available start-up-events for the EventManager\n",
        "body": "ultraschall.EventManager_CountStartupEvents()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_SETSTARTUPEVENT lua": {
        "prefix": "ultraschall.EventManager_SetStartupEvent",
        "scope": "lua",
        "description": "Sets an already existing startupevent, that shall be automatically run at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be started automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the startup-event, which you want to set\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed; nil, to keep current name\nCheckAllXSeconds:only check all x seconds; 0, for constant checking; nil, to keep current value\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed; nil, to keep current value\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet; nil, to keep current value\nCheckFunction:the function, which shall check if the event occurred; nil, to keep current function\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred; nil, to keep current actionlist\nRETURNS:\nevent_identifier:the unique identifier for this registered event, which can be used later for setting, deleting, etc\n",
        "body": "ultraschall.EventManager_SetStartupEvent(${1:string EventIdentifier},${2:optional string EventName},${3:optional integer CheckAllXSeconds},${4:optional integer CheckForXSeconds},${5:optional boolean StartActionsOnceDuringTrue},${6:optional boolean EventPaused},${7:optional function CheckFunction},${8:optional table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETPAUSEDSTATE2 lua": {
        "prefix": "ultraschall.EventManager_GetPausedState2",
        "scope": "lua",
        "description": "returns, if a certain event, currently registered in the EventManager, is paused(true) or not(false).\nState is requested by EventIdentifier.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the identifier of the registered event, whose pause state you want to retrieve\n",
        "body": "ultraschall.EventManager_GetPausedState2(${1:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETPAUSEDSTATE lua": {
        "prefix": "ultraschall.EventManager_GetPausedState",
        "scope": "lua",
        "description": "returns, if a certain event, currently registered in the EventManager, is paused(true) or not(false)\nState is requested by number-id, with 1 for the first event, 2 for the second, etc.\nreturns nil in case of an error\nPARAMETERS:\nid:the id of the event, whose paused-state you want to retrieve; 1, the first event; 2, the second event, etc\n",
        "body": "ultraschall.EventManager_GetPausedState(${1:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETEVENTIDENTIFIER lua": {
        "prefix": "ultraschall.EventManager_GetEventIdentifier",
        "scope": "lua",
        "description": "returns the EventIdentifier of a registered event, by id\nevent is requested by number-id, with 1 for the first event, 2 for the second, etc.\nreturns nil in case of an error\nPARAMETERS:\nid:the id of the event, whose EventIdenrifier you want to retrieve; 1, the first event; 2, the second event, etc\n",
        "body": "ultraschall.EventManager_GetEventIdentifier(${1:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETLASTCHECKFUNCTIONSTATE lua": {
        "prefix": "ultraschall.EventManager_GetLastCheckfunctionState",
        "scope": "lua",
        "description": "returns the last state the eventcheck-function returned the last time it was called; of a certain registered event in the EventManager.\nState is requested by number-id, with 1 for the first event, 2 for the second, etc.\nreturns nil in case of an error; nil and time, if the EventCheck-function didn't return a boolean\nPARAMETERS:\nid:the id of the event, whose eventcheckfunction-retval you want to retrieve; 1, the first event; 2, the second event, etc\n",
        "body": "ultraschall.EventManager_GetLastCheckfunctionState(${1:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETREGISTEREDEVENTID lua": {
        "prefix": "ultraschall.EventManager_GetRegisteredEventID",
        "scope": "lua",
        "description": "returns the id of a registered event, meaning 1, if it's the first event, 2 if it's the second, etc\nIt is the position within all events currently registered within the EventManager.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the event, whose id you want to retrieve\n",
        "body": "ultraschall.EventManager_GetRegisteredEventID(${1:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETLASTCHECKFUNCTIONSTATE2 lua": {
        "prefix": "ultraschall.EventManager_GetLastCheckfunctionState2",
        "scope": "lua",
        "description": "returns the last state the eventcheck-function returned the last time it was called; of a certain registered event in the EventManager.\nState is requested by EventIdentifier\nreturns nil in case of an error; nil and time, if the EventCheck-function didn't return a boolean\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the event, whose last checkfunction-state you want to retrieve\n",
        "body": "ultraschall.EventManager_GetLastCheckfunctionState2(${1:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_DEBUGMODE lua": {
        "prefix": "ultraschall.EventManager_DebugMode",
        "scope": "lua",
        "description": "Starts Debugmode of the EventManager, which returns additional internal states.\nAllows you to get the contents of the UserSpace of a certain checkfunction of a registered event, see EventManager_DebugMode_UserSpace.\nNote: Debugmode is not for productive usecases, as it costs resources. Please turn it off again, after you've finished debugging.\nPARAMETERS:\ntoggle:true, turn debugmode on; false, turn debugmode off\n",
        "body": "ultraschall.EventManager_DebugMode(${1:boolean toggle})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_DEBUGMODE_USERSPACE lua": {
        "prefix": "ultraschall.EventManager_DebugMode_UserSpace",
        "scope": "lua",
        "description": "Returns the current contents of the UserSpace, as stored by the checkfunction of a registered event in the EventManager.\nThe table is of the format:\nuserspace[index][\"index\"]    - the name of the index\nuserspace[index][\"datatype\"] - the datatype of the value in this userspace-index\nuserspace[index][\"value\"]    - the value in this userspace-index\nNote: Debugmode is not for productive usecases, as it costs resources. Please turn it off again, after you've finished debugging.\nSee EventManager\\_DebugMode for more details on stopping DebugMode.\nreturns nil in case of an error\nPARAMETERS:\nindex:the index of the event, whose UserSpace you want to retrieve\nRETURNS:\nuserspace_count:the number of values within the userspace\nuserspace:the contents of the userspace as a handy table\n",
        "body": "ultraschall.EventManager_DebugMode_UserSpace(${1:integer index})$0"
    },
    "ULTRASCHALL.READFULLFILE lua": {
        "prefix": "ultraschall.ReadFullFile",
        "scope": "lua",
        "description": "Return contents of filename_with_path.\nReturns nil in case of an error.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nbinary:true if the file shall be read as a binary file; false if read as ASCII. Default is ASCII.\nRETURNS:\ncontents:the contents of the whole file.\nlength_of_file:the number of bytes of the file\nnumber_of_lines:number of lines in file (-1 if parameter binary is set to true)\n",
        "body": "ultraschall.ReadFullFile(${1:string filename_with_path},${2:boolean binary})$0"
    },
    "ULTRASCHALL.READVALUEFROMFILE lua": {
        "prefix": "ultraschall.ReadValueFromFile",
        "scope": "lua",
        "description": "Return contents of filename_with_path.\nIf \"value\" is given, it will return all lines, containing the value in the file \"filename_with_path\".\nThe second line-numbers return-value is very valuable when giving a \"value\". \"Value\" is not case-sensitive.\nThe value can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nvalue:the value to look in the file for. Not case-sensitive.\nRETURNS:\ncontents:the contents of the file, or the lines that contain parameter value in it, separated by a newline\nlinenumbers:a string, that contains the linenumbers returned as a , separated csv-string\nnumberoflines:the total number of lines in the file\nnumber_of_foundlines:the number of found lines\n",
        "body": "ultraschall.ReadValueFromFile(${1:string filename_with_path},${2:string value})$0"
    },
    "ULTRASCHALL.READLINERANGEFROMFILE lua": {
        "prefix": "ultraschall.ReadLinerangeFromFile",
        "scope": "lua",
        "description": "Return contents of filename_with_path, from firstlinenumber to lastlinenumber. Counting of linenumbers starts with 1 for the first line.\nThe returned string contains all requested lines, separated by a newline.\nReturns nil, if the linenumbers are invalid.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nfirstlinenumber:the first linenumber to be returned. First line in the file begins with 1!\nlastlinenumber:the last linenumber to be returned; -1, for the whole file\nRETURNS:\ncontents:the contents the lines of the file, that you requested\ncorrectnumberoflines:true, if the number of lines are returned, as requested; false if fewer lines are returned\nnumber_of_lines:the number of read lines\n",
        "body": "ultraschall.ReadLinerangeFromFile(${1:string filename_with_path},${2:integer firstlinenumber},${3:integer lastlinenumber})$0"
    },
    "ULTRASCHALL.MAKECOPYOFFILE lua": {
        "prefix": "ultraschall.MakeCopyOfFile",
        "scope": "lua",
        "description": "Copies input_filename_with_path to output_filename_with_path.\nOnly textfiles! For binary-files use MakeCopyOfFile_Binary() instead!\nReturns true, if it worked, false if it didn't.\nPARAMETERS:\ninput_filename_with_path:filename of the file to copy\noutput_filename_with_path:filename of the copied file to be created.\nRETURNS:\nretval:true, if copy worked, false if it didn't.\n",
        "body": "ultraschall.MakeCopyOfFile(${1:string input_filename_with_path},${2:string output_filename_with_path})$0"
    },
    "ULTRASCHALL.MAKECOPYOFFILE_BINARY lua": {
        "prefix": "ultraschall.MakeCopyOfFile_Binary",
        "scope": "lua",
        "description": "Copies input_filename_with_path to output_filename_with_path as binary-file.\nreturns false in case of an error\nPARAMETERS:\ninput_filename_with_path:filename of the file to copy\noutput_filename_with_path:filename of the copied file, that shall be created\nRETURNS:\nretval:returns true, if copy worked; false if it didn't\n",
        "body": "ultraschall.MakeCopyOfFile_Binary(${1:string input_filename_with_path},${2:string output_filename_with_path})$0"
    },
    "ULTRASCHALL.READBINARYFILEUNTILPATTERN lua": {
        "prefix": "ultraschall.ReadBinaryFileUntilPattern",
        "scope": "lua",
        "description": "Returns a binary file, up until a pattern. The pattern is not case-sensitive.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nreturns false in case of an error\nPARAMETERS:\npattern:a pattern to search for. Case-sensitive.\nRETURNS:\nlength:the length of the returned data\ncontent:the content of the file, that has been read until pattern\n",
        "body": "ultraschall.ReadBinaryFileUntilPattern(${1:string input_filename_with_path},${2:string pattern})$0"
    },
    "ULTRASCHALL.READBINARYFILEFROMPATTERN lua": {
        "prefix": "ultraschall.ReadBinaryFileFromPattern",
        "scope": "lua",
        "description": "Returns a binary file, from pattern onwards. The pattern is not case-sensitive.\nThe pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nreturns false in case of an error\nPARAMETERS:\npattern:a pattern to search for. Case-sensitive.\nRETURNS:\nlength:the length of the returned data\ncontent:the content of the file, that has been read from pattern to the end\n",
        "body": "ultraschall.ReadBinaryFileFromPattern(${1:string input_filename_with_path},${2:string pattern})$0"
    },
    "ULTRASCHALL.COUNTLINESINFILE lua": {
        "prefix": "ultraschall.CountLinesInFile",
        "scope": "lua",
        "description": "Counts lines in a textfile. In binary files, the number of lines may be weird and unexpected!\nReturns -1, if no such file exists.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nRETURNS:\nlinesinfile:number of lines in a textfile; -1 in case of error\n",
        "body": "ultraschall.CountLinesInFile(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.READFILEASLINES_ARRAY lua": {
        "prefix": "ultraschall.ReadFileAsLines_Array",
        "scope": "lua",
        "description": "Return contents of filename_with_path, from firstlinenumber to lastlinenumber as an array. Counting of linenumbers starts with 1 for the first line.\nThe returned array contains all requested lines, which each entry holding one returned line.\nReturns nil, if the linenumbers are invalid.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nfirstlinenumber:the first linenumber to be returned. First line in the file begins with 1!\nlastlinenumber:the last linenumber to be returned; -1, read all lines in the file\nRETURNS:\ncontents:the contents the lines of the file, that you requested as an array, in which each entry hold one line of the file\ncorrectnumberoflines:true, if the number of lines are returned, as you requested; false if fewer lines are returned\nnumber_of_lines:the number of lines returned\n",
        "body": "ultraschall.ReadFileAsLines_Array(${1:string filename_with_path},${2:integer firstlinenumber},${3:integer lastlinenumber})$0"
    },
    "ULTRASCHALL.READBINARYFILE_OFFSET lua": {
        "prefix": "ultraschall.ReadBinaryFile_Offset",
        "scope": "lua",
        "description": "Returns the contents of a binary file from startoffset until startoffset+numberofbytes.\nWhen setting startoffset to a negative value, it will read from the end of the file, means:\n-100 will start -100 characters before the end of the file and numberofbytes will read from that point on\nReturns false, if file can not be opened.\nPARAMETERS:\ninput_filename_with_path:filename of the file to be read\nstartoffset:the offset, at where to begin the fileread. 0 for the beginning of the file; negative values set offset from the end of the file\nnumberofbytes:the number of bytes to read. -1 for until the end of the file. If there are fewer bytes than requested, the returned string will be shorter.\nRETURNS:\nlength:the length of the returned part of the file, might be shorter than requested, if file ends before\ncontent:the content of the file, that has been read\n",
        "body": "ultraschall.ReadBinaryFile_Offset(${1:string input_filename_with_path},${2:integer startoffset},${3:integer numberofbytes})$0"
    },
    "ULTRASCHALL.GETLENGTHOFFILE lua": {
        "prefix": "ultraschall.GetLengthOfFile",
        "scope": "lua",
        "description": "Returns the length of the file filename_with_path in bytes.\nWill return -1, if no such file exists.\nPARAMETERS:\nfilename_with_path:filename to write the value to\nRETURNS:\nlengthoffile:the length of the file in bytes. -1 in case of error\n",
        "body": "ultraschall.GetLengthOfFile(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTDIRECTORIESANDFILESINPATH lua": {
        "prefix": "ultraschall.CountDirectoriesAndFilesInPath",
        "scope": "lua",
        "description": "returns the number of files and directories in path\nreturns -1, in case of error\nPARAMETERS:\npath:the path to count the files and directories from\nRETURNS:\nfilecount:the number of files found in path\ndircount:the number of directories found in path\n",
        "body": "ultraschall.CountDirectoriesAndFilesInPath(${1:string path})$0"
    },
    "ULTRASCHALL.GETALLFILENAMESINPATH lua": {
        "prefix": "ultraschall.GetAllFilenamesInPath",
        "scope": "lua",
        "description": "returns the number of files and the filenames in path\nreturns -1, in case of error\nPARAMETERS:\npath:the path to get the filenames from\nRETURNS:\nfilecount:the number of files found in path\nfiles:the filenames found in path\n",
        "body": "ultraschall.GetAllFilenamesInPath(${1:string path})$0"
    },
    "ULTRASCHALL.GETALLDIRECTORIESINPATH lua": {
        "prefix": "ultraschall.GetAllDirectoriesInPath",
        "scope": "lua",
        "description": "returns the number of directories and the directorynames in path\nreturns -1, in case of error\nPARAMETERS:\npath:the path to get the directories from\nRETURNS:\nfilecount:the number of directories found in path\n",
        "body": "ultraschall.GetAllDirectoriesInPath(${1:string path})$0"
    },
    "ULTRASCHALL.CHECKFORVALIDFILEFORMATS lua": {
        "prefix": "ultraschall.CheckForValidFileFormats",
        "scope": "lua",
        "description": "Returns the fileformat of a Reaper-supported-file, images, audios(opus and m4a missing, though!), and video(mp4-video missing, though!).\nNote: Checks the file itself and does not check for correct file-extension. Reaper needs the correct file-extension or it can't read an otherwise valid imagefile.\nFor example: if you want to import a GIF, renamed to filename.JPG, Reaper will not be able to read it. Only when the extension is the same as the file itself(filename.GIF).\nReturns nil in case of an error\nPARAMETERS:\nfilename_with_path:the file to check for it's image-fileformat\nRETURNS:\nfileformat:the format of the file; JPG, PNG, GIF, LCF, ICO, WAV, AIFF, ASF/WMA/WMV, MP3, MP3 -ID3TAG, FLAC, MKV/MKA/MKS/MK3D/WEBM, AVI, RPP_PROJECT, unknown\nsupported_by_reaper:true, if importing of the fileformat is supported by Reaper; false, if not\nmediatype:the type of the media; Image, Audio, Audio/Video, Video, Reaper\n",
        "body": "ultraschall.CheckForValidFileFormats(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.DIRECTORYEXISTS lua": {
        "prefix": "ultraschall.DirectoryExists",
        "scope": "lua",
        "description": "Checks, if a directory exists in path.\nOn Linux: path and directory are case-sensitive!\nReturns false in case of error.\nPARAMETERS:\npath:the path, in which to look for the existence of parameter directory\ndirectory:the name of the directory to check for in path\nRETURNS:\nretval:true, directory exists; false, directory does not exist\n",
        "body": "ultraschall.DirectoryExists(${1:string path},${2:string directory})$0"
    },
    "ULTRASCHALL.ONLYFILESOFCERTAINTYPE lua": {
        "prefix": "ultraschall.OnlyFilesOfCertainType",
        "scope": "lua",
        "description": "Returns the filenames_with_path from a filearray, that are of a certain filetype\nreturns -1 in case of an error\nPARAMETERS:\nfilearray:an array with files to check for; index is 1-based\nRETURNS:\nfoundfilecount:the number of files that contain the right filetype\nfoundfilearray:an array with all the files that contain the right filetype\n",
        "body": "ultraschall.OnlyFilesOfCertainType(${1:array filearray},${2:string filetype})$0"
    },
    "ULTRASCHALL.GETREAPERWORKDIR lua": {
        "prefix": "ultraschall.GetReaperWorkDir",
        "scope": "lua",
        "description": "returns the current workdir, which is the directory. If you create a file without giving a path, this file will be created in this work-dir.\nRETURNS:\ncurrent_workdir:the current workdir of Reaper\n",
        "body": "ultraschall.GetReaperWorkDir()$0"
    },
    "ULTRASCHALL.DIRECTORYEXISTS2 lua": {
        "prefix": "ultraschall.DirectoryExists2",
        "scope": "lua",
        "description": "returns, if Path is an existing path.\nreturns false in case of an error\nPARAMETERS:\nPath:the path to check for\nRETURNS:\nretval:true, if path exists; false, if not\n",
        "body": "ultraschall.DirectoryExists2(${1:string Path})$0"
    },
    "ULTRASCHALL.SETREAPERWORKDIR lua": {
        "prefix": "ultraschall.SetReaperWorkDir",
        "scope": "lua",
        "description": "sets a new current working directory for Reaper. This requires a restart of Reaper to take effect, due API-limitations!\nreturns false in case of an error\nPARAMETERS:\nPath:the path to set as new current working directory\nRETURNS:\nretval:true, if path could be set; false, if not\n",
        "body": "ultraschall.SetReaperWorkDir(${1:string Path})$0"
    },
    "ULTRASCHALL.CREATEVALIDTEMPFILE lua": {
        "prefix": "ultraschall.CreateValidTempFile",
        "scope": "lua",
        "description": "Tries to determine a valid temporary filename. Will check filename_with_path with an included number between 0 and 16384 to create such a filename.\nYou can also add your own suffix to the filename.\nThe pattern is: filename_with_path$Suffix~$number.ext (when retainextension is set to true!)\nIf you wish, you can also create this temporary-file as an empty file.\nThe path of the tempfile is always the same as the original file.\nReturns nil in case of failure.\nPARAMETERS:\nfilename_with_path:the original filename\ncreate:true, if you want to create that temporary file as an empty file; false, just return the filename\nsuffix:if you want to alter the temporary filename with an additional suffix, use this parameter\nretainextension:true, keep the extension(if existing) at the end of the tempfile; false, just add the suffix~number at the end.\nRETURNS:\ntempfilename:the valid temporary filename found\n",
        "body": "ultraschall.CreateValidTempFile(${1:string filename_with_path},${2:boolean create},${3:string suffix},${4:boolean retainextension})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_INSERT lua": {
        "prefix": "ultraschall.WriteValueToFile_Insert",
        "scope": "lua",
        "description": "Inserts value into a file at linenumber. All lines, up to linenumber-1 come before value, all lines at linenumber to the end of the file will come after value.\nWill return -1, if no such line exists.\nNote: non-binary-files only!\nPARAMETERS:\nfilename_with_path:filename to write the value to\nlinenumber:the linenumber, at where to insert the value into the file\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "ultraschall.WriteValueToFile_Insert(${1:string filename_with_path},${2:integer linenumber},${3:string value})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_REPLACE lua": {
        "prefix": "ultraschall.WriteValueToFile_Replace",
        "scope": "lua",
        "description": "Replaces the linenumbers startlinenumber to endlinenumber in a file with value. All lines, up to startlinenumber-1 come before value, all lines at endlinenumber+1 to the end of the file will come after value.\nWill return -1, if no such lines exists.\nNote: non-binary-files only!\nPARAMETERS:\nfilename_with_path:filename to write the value to\nstartlinenumber:the first linenumber, to be replaced with value in the file\nendlinenumber:the last linenumber, to be replaced with value in the file\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "ultraschall.WriteValueToFile_Replace(${1:string filename_with_path},${2:integer startlinenumber},${3:integer endlinenumber},${4:string value})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_INSERTBINARY lua": {
        "prefix": "ultraschall.WriteValueToFile_InsertBinary",
        "scope": "lua",
        "description": "Inserts value into a file at byteposition. All bytes, up to byteposition-1 come before value, all bytes at byteposition to the end of the file will come after value.\nWill return -1, if no such line exists.\nNote: good for binary files\nPARAMETERS:\nfilename_with_path:filename to write the value to\nbyteposition:the byteposition, at where to insert the value into the file\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "ultraschall.WriteValueToFile_InsertBinary(${1:string filename_with_path},${2:integer byteposition},${3:string value})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_REPLACEBINARY lua": {
        "prefix": "ultraschall.WriteValueToFile_ReplaceBinary",
        "scope": "lua",
        "description": "Replaces content in the file from startbyteposition to endbyteposition-1 with value. All bytes, up to startbyteposition-1 come before value, all bytes from (and including)endbyteposition to the end of the file will come after value.\nWill return -1, if no such line exists.\nNote: good for binary files\nPARAMETERS:\nfilename_with_path:filename to write the value to\nstartbyteposition:the first byte in the file to be replaced, starting with 1, if you want to replace at the beginning of the file. Everything before startposition will be kept.\nendbyteposition:the first byte after the replacement. Everything from endbyteposition to the end of the file will be kept.\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "ultraschall.WriteValueToFile_ReplaceBinary(${1:string filename_with_path},${2:integer startbyteposition},${3:integer endbyteposition},${4:string value})$0"
    },
    "ULTRASCHALL.GETALLRECURSIVEFILESANDSUBDIRECTORIES lua": {
        "prefix": "ultraschall.GetAllRecursiveFilesAndSubdirectories",
        "scope": "lua",
        "description": "Returns all subdirectories and files within a given path.\nMight take some time with many folders/files.\nReturns -1 in case of an error.\nPARAMETERS:\npath:the path from where to retrieve the files and subdirectories\nRETURNS:\nfound_dirs:the number of directories found; -1, in case of an error\ndirs_array:the full path to the found directories as an array\nfound_files:the number of files found\nfiles_array:the full path to the found files as an array\n",
        "body": "ultraschall.GetAllRecursiveFilesAndSubdirectories(${1:string path})$0"
    },
    "ULTRASCHALL.SAVESUBTITLES_SRT lua": {
        "prefix": "ultraschall.SaveSubtitles_SRT",
        "scope": "lua",
        "description": "saves the subtitles from the subtitle-table.\nThe subtitles-table is expected to be of the following format:\nsubtitle_table[subtitle_index][\"start\"]   = starttime in seconds\nsubtitle_table[subtitle_index][\"end\"]     = endtime in seconds\nsubtitle_table[subtitle_index][\"caption\"] = the caption, which shall be shown from start to end-time\nreturns -1 in case of an error\nPARAMETERS:\nsubtitle_filename_with_path:the filename of the subtitle-file, into which you want to store the subtitles\n",
        "body": "ultraschall.SaveSubtitles_SRT(${1:string subtitle_filename_with_path},${2:table subtitle_table})$0"
    },
    "ULTRASCHALL.READSUBTITLES_SRT lua": {
        "prefix": "ultraschall.ReadSubtitles_SRT",
        "scope": "lua",
        "description": "parses an srt-subtitle-file and returns its contents as table\nreturns nil in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the subrip srt-file\nRETURNS:\nCaptions_Counter:the number of captions in the file\nCaptions:the Captions as a table of the format:\n",
        "body": "ultraschall.ReadSubtitles_SRT(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.MOVEFILEORFOLDER lua": {
        "prefix": "ultraschall.MoveFileOrFolder",
        "scope": "lua",
        "description": "Moves a file or folder from oldpath to newpath.\nreturns false in case of an error\nPARAMETERS:\nfile_foldername:the folder- or filename, which you want to move\noldpath:the old path, in which the file or folder is located\nnewpath:the new path, into which the file or folder shall be moved\nRETURNS:\nretval:true, moving was successful; false, moving was unsuccessful\n",
        "body": "ultraschall.MoveFileOrFolder(${1:string file_foldername},${2:string oldpath},${3:string newpath})$0"
    },
    "ULTRASCHALL.ISVALIDFXSTATECHUNK lua": {
        "prefix": "ultraschall.IsValidFXStateChunk",
        "scope": "lua",
        "description": "Returns, if a StateChunk is a valid FXStateChunk.\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nReturns false in case of an error\nPARAMETERS:\nStateChunk:the StateChunk, which you want to check, whether it's a valid FXStateChunk\nRETURNS:\nretval:true, it is a valid FXStateChunk; false, it is not\n",
        "body": "ultraschall.IsValidFXStateChunk(${1:string StateChunk})$0"
    },
    "ULTRASCHALL.GETFXFROMFXSTATECHUNK lua": {
        "prefix": "ultraschall.GetFXFromFXStateChunk",
        "scope": "lua",
        "description": "Returns all lines of a specific TrackFX/ItemFX from a StateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the FX-entries\nid:the id of the FX-entries you want to have, starting with 1 for the first\nRETURNS:\nfx:all lines of an fx from a statechunk\n",
        "body": "ultraschall.GetFXFromFXStateChunk(${1:string FXStateChunk},${2:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.GetParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-learn-setting from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is the PARMLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmLearn-settings\nfxid:the fx, of which you want to get the parameter-learn-settings\nid:the id of the ParmLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn\n",
        "body": "ultraschall.GetParmLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLEARN_MEDIAITEM lua": {
        "prefix": "ultraschall.GetParmLearn_MediaItem",
        "scope": "lua",
        "description": "Returns a parameter-learn-setting from a MediaItem\nIt is the PARMLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose ParmLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-learn-settings\nid:the id of the ParmLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn\n",
        "body": "ultraschall.GetParmLearn_MediaItem(${1:MediaItem MediaItem},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLEARN_MEDIATRACK lua": {
        "prefix": "ultraschall.GetParmLearn_MediaTrack",
        "scope": "lua",
        "description": "Returns a parameter-learn-setting from a MediaTrack\nIt is the PARMLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaTrack:the MediaTrack, whose ParmLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-learn-settings\nid:the id of the ParmLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-messages\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn\n",
        "body": "ultraschall.GetParmLearn_MediaTrack(${1:MediaTrack MediaTrack},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMALIAS_FXSTATECHUNK lua": {
        "prefix": "ultraschall.GetParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-alias-setting from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nParameter-aliases are only stored for MediaTracks.\nIt is the PARMALIAS-entry\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmAlias-settings\nfxid:the fx, of which you want to get the parameter-alias-settings\nid:the id of the ParmAlias-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparm_aliasname:the alias-name of the parameter\n",
        "body": "ultraschall.GetParmAlias_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMALIAS_MEDIATRACK lua": {
        "prefix": "ultraschall.GetParmAlias_MediaTrack",
        "scope": "lua",
        "description": "Returns a parameter-aliasname-setting from a MediaTrack\nIt is the PARMALIAS-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaTrack:the MediaTrack, whose ParmAlias-setting you want to get\nfxid:the fx, of which you want to get the parameter-alias-settings\nid:the id of the ParmAlias-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparm_aliasname:the alias-name of the parameter\n",
        "body": "ultraschall.GetParmAlias_MediaTrack(${1:MediaTrack MediaTrack},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMMODULATIONCHUNK_FXSTATECHUNK lua": {
        "prefix": "ultraschall.GetParmModulationChunk_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-modulation-chunk from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt's the\nstring parm_modulation_chunk - a chunk of the parameter-modulation settings\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the Parameter-modulation-settings\ninteger fxid - the fx, of which you want to get the parameter-modulation-chunk-settings\ninteger id - the id of the Parameter-modulation you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, modulation, fxstatechunk\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the Parameter-modulation-settings\nfxid:the fx, of which you want to get the parameter-modulation-chunk-settings\nid:the id of the Parameter-modulation you want to have, starting with 1 for the first\nRETURNS:\nparm_modulation_chunk:a chunk of the parameter-modulation settings\n",
        "body": "ultraschall.GetParmModulationChunk_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFOLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.GetParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-lfo-learn-setting from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is the LFOLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmLFOLearn-settings\nfxid:the fx, of which you want to get the parameter-lfo-learn-settings\nid:the id of the ParmLFOLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn\n",
        "body": "ultraschall.GetParmLFOLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFOLEARN_MEDIAITEM lua": {
        "prefix": "ultraschall.GetParmLFOLearn_MediaItem",
        "scope": "lua",
        "description": "Returns a parameter-lfo-learn-setting from a MediaItem\nIt is the LFOLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose ParmLFOLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-lfo-learn-settings\nid:the id of the ParmLFOLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn\n",
        "body": "ultraschall.GetParmLFOLearn_MediaItem(${1:MediaItem MediaItem},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFOLEARN_MEDIATRACK lua": {
        "prefix": "ultraschall.GetParmLFOLearn_MediaTrack",
        "scope": "lua",
        "description": "Returns a parameter-lfo-learn-setting from a MediaTrack\nIt is the LFOLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaTrack:the MediaTrack, whose ParmLFOLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-lfo-learn-settings\nid:the id of the ParmLFOLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-messages\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn\n",
        "body": "ultraschall.GetParmLFOLearn_MediaTrack(${1:MediaTrack MediaTrack},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMAUDIOCONTROL_FXSTATECHUNK lua": {
        "prefix": "ultraschall.GetParmAudioControl_FXStateChunk",
        "scope": "lua",
        "description": "Returns the parameter-modulation-settings of the Audio control signal-settings from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is entries from the\ninteger parmidx - the id of the parameter, that shall be modulated; order like in the dropdownlist\nstring parmname - the name of the parameter, usually bypass or wet\ninteger parameter_modulation - the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nnumber parmbase - parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\ninteger audioctrl - \"Audio control signal (sidechain)\"-checkbox - 0, disabled; 1, enabled\nnumber audioctrlstrength - the strength-slider for AudioControlSignal; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\ninteger audioctrl_direction - the direction-radiobuttons for AudioControlSignal; -1, Negative; 0, Centered; 1, Positive\ninteger channels - the Track audio channel-dropdownlist; linked to entry parameter stereo as well\n- -1, no channel selected(yet) (default)\n- 0 and higher, track 1 and higher is selected\ninteger stereo - linked to channels as well\n- 0, mono(use only the channel set in CHAN); 1, stereo(use the channel set in CHAN and CHAN+1)\ninteger rms_attack - rms attack in milliseconds; 0 to 1000; default is 300\ninteger rms_release - rms release in milliseconds; 0 to 1000; default is 300\nnumber db_lo - db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\n- Min volume-slider in dB; maximum valuerange possible is -60dB to 11.9dB\nnumber db_hi - db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\n- Max volume-slider in dB; maximum valuerange possible is -59.9dB to 12dB\nnumber audioctrlshaping_x - the x-position of the shaping-dragging-point; between 0.000000 and 1.000000\nnumber audioctrlshaping_y - the y-position of the shaping-dragging-point; between 0.000000 and 1.000000\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the ParmModulation-settings\ninteger fxid - the fx, of which you want to get the parameter-modulation-settings\ninteger id - the id of the ParmModulation-settings you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, modulation, fxstatechunk, audio control signal\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmModulation-settings\nfxid:the fx, of which you want to get the parameter-modulation-settings\nid:the id of the ParmModulation-settings you want to have, starting with 1 for the first\nRETURNS:\nparmidx:the id of the parameter, that shall be modulated; order like in the dropdownlist\nparmname:the name of the parameter, usually bypass or wet\nparameter_modulation:the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nparmbase:parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\naudioctrl:the y-position of the shaping-dragging-point; between 0.000000 and 1.000000\naudioctrlstrength:the strength-slider for AudioControlSignal; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\naudioctrl_direction:the direction-radiobuttons for AudioControlSignal; -1, Negative; 0, Centered; 1, Positive\nchannels:the Track audio channel-dropdownlist; linked to entry parameter stereo as well\nstereo:linked to channels as well\nrms_attack:rms attack in milliseconds; 0 to 1000; default is 300\nrms_release:rms release in milliseconds; 0 to 1000; default is 300\ndb_lo:db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\ndb_hi:db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\naudioctrlshaping_x:the x-position of the shaping-dragging-point; between 0.000000 and 1.000000\naudioctrlshaping_y:the y-position of the shaping-dragging-point; between 0.000000 and 1.000000\n",
        "body": "ultraschall.GetParmAudioControl_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFO_FXSTATECHUNK lua": {
        "prefix": "ultraschall.GetParmLFO_FXStateChunk",
        "scope": "lua",
        "description": "Returns the parameter-modulation-settings of the LFO-settings from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is entries from the\ninteger parmidx - the id of the parameter, that shall be modulated; order like in the dropdownlist\nstring parmname - the name of the parameter, usually bypass or wet\ninteger parameter_modulation - the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nnumber parmbase - parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\ninteger lfo - LFO checkbox; 0, disabled; 1, enabled\nnumber lfo_strength - Strength-slider in the LFO parameter-modulation; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\ninteger lfo_direction - Direction-radiobuttons in the LFO parameter modulation; -1, Negative; 0, Centered; 1, Positive\ninteger lfo_shape - the shape of the LFO\n- 0, sine\n- 1, square\n- 2, saw L\n- 3, saw R\n- 4, triangle\n- 5, random\ninteger temposync - the Tempo sync-checkbox in the LFO parameter-modulation; 0, disabled; 1, enabled\ninteger unknown - unknown\ninteger phase_reset - phase-reset-dropdownlist\n- 0, On seek/loop (deterministic output)\n- 1, Free-running (non-deterministic output)\nnumber lfo_speed - Speed-slider in the LFO parameter-modulation; either Hz(temposync=0) or QN(temposync=1)\n- Hz: 0(0.0039Hz) to 1(8.0000Hz); higher values are possible, lower values go into negative; default is 0.124573(1.0000Hz)\n- QN: 0(8.0000QN) to 1(0.2500QN); lower values are possible; higher values go into negative; default is 0.9(1.0000QN)\nnumber lfo_speedphase - Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the ParmModulation-settings\ninteger fxid - the fx, of which you want to get the parameter-modulation-settings\ninteger id - the id of the ParmModulation-settings you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, modulation, fxstatechunk, lfo\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmModulation-settings\nfxid:the fx, of which you want to get the parameter-modulation-settings\nid:the id of the ParmModulation-settings you want to have, starting with 1 for the first\nRETURNS:\nparmidx:the id of the parameter, that shall be modulated; order like in the dropdownlist\nparmname:the name of the parameter, usually bypass or wet\nparameter_modulation:the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nparmbase:parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\nlfo:Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\nlfo_strength:Strength-slider in the LFO parameter-modulation; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\nlfo_direction:Direction-radiobuttons in the LFO parameter modulation; -1, Negative; 0, Centered; 1, Positive\nlfo_shape:the shape of the LFO\ntemposync:the Tempo sync-checkbox in the LFO parameter-modulation; 0, disabled; 1, enabled\nunknown:unknown\nphase_reset:phase-reset-dropdownlist\nlfo_speed:Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\nlfo_speedphase:Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\n",
        "body": "ultraschall.GetParmLFO_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.GETPARMMIDIPLINK_FXSTATECHUNK lua": {
        "prefix": "ultraschall.GetParmMIDIPLink_FXStateChunk",
        "scope": "lua",
        "description": "Returns the parameter-modulation-settings of the Parameter-Link-Modulation-settings from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is entries from the\ninteger parmidx - the id of the parameter, that shall be modulated; order like in the dropdownlist\nstring parmname - the name of the parameter, usually bypass or wet\ninteger parameter_modulation - the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nnumber parmbase - parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\nboolean plink_enabled - true, parameter-linking is enabled; false, parameter linking is disabled\nnumber scale - the scale-slider; -1.00(-100%) to 1.00(100%); default is 0(0%)\ninteger midi_fx_idx - the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area\n-  -1, nothing selected\n-  -100, MIDI-parameter-settings\n-  0 - the first fx\n-  1 - the second fx\n-  2 - the third fx, etc\ninteger midi_fx_idx2 - the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area; Reaper stores the idx for idx using two values, where this is the second one\n- it is unknown why, so I include it in here anyway\n-  -1, nothing selected\n-  -100, MIDI-parameter-settings\n-  0 - the first fx\n-  1 - the second fx\n-  2 - the third fx, etc\ninteger linked_parmidx - the parameter idx, that you want to link;\n- When MIDI:\n-     16\n- When FX-parameter:\n-     0 to n; 0 for the first; 1, for the second, etc\nnumber offset - Offset-slider; -1.00(-100%) to 1.00(100%); default is 0(0%)\noptional integer bus - the MIDI-bus; 0 to 15 for bus 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\noptional integer channel - the MIDI-channel; 0, omni; 1 to 16 for channel 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\noptional integer category - the MIDI-category, which affects the meaning of parameter midi_note; only available, when midi_fx_idx=-100, otherwise nil\n- 144, MIDI note\n- 160, Aftertouch\n- 176, CC 14Bit and CC\n- 192, Program Change\n- 208, Channel Pressure\n- 224, Pitch\noptional integer midi_note - the midi_note/command, whose meaning depends on parameter category; only available, when midi_fx_idx=-100, otherwise nil\n-   When MIDI note:\n-        0(C-2) to 127(G8)\n-   When Aftertouch:\n-        0(C-2) to 127(G8)\n-   When CC14 Bit:\n-        128 to 159; see dropdownlist for the commands(the order of the list is the same as this numbering)\n-   When CC:\n-        0 to 119; see dropdownlist for the commands(the order of the list is the same as this numbering)\n-   When Program Change:\n-        0\n-   When Channel Pressure:\n-        0\n-   When Pitch:\n-        0\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the ParmLinkModulation-settings\ninteger fxid - the fx, of which you want to get the parameter-linking-modulation-settings\ninteger id - the id of the ParmLinkModulation-settings you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, linking, linked, midi, fx, modulation, fxstatechunk, lfo\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmLinkModulation-settings\nfxid:the fx, of which you want to get the parameter-linking-modulation-settings\nid:the id of the ParmLinkModulation-settings you want to have, starting with 1 for the first\nRETURNS:\nparmidx:the parameter idx, that you want to link; \nparmname:the name of the parameter, usually bypass or wet\nparameter_modulation:the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nparmbase:parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\nplink_enabled:true, parameter-linking is enabled; false, parameter linking is disabled\nscale:the scale-slider; -1.00(-100%) to 1.00(100%); default is 0(0%)\nmidi_fx_idx:the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area; Reaper stores the idx for idx using two values, where this is the second one\nmidi_fx_idx2:the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area; Reaper stores the idx for idx using two values, where this is the second one\nlinked_parmidx:the parameter idx, that you want to link; \noffset:Offset-slider; -1.00(-100%) to 1.00(100%); default is 0(0%) \nbus:the MIDI-bus; 0 to 15 for bus 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\nchannel:the MIDI-channel; 0, omni; 1 to 16 for channel 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\ncategory:the MIDI-category, which affects the meaning of parameter midi_note; only available, when midi_fx_idx=-100, otherwise nil\nmidi_note:the midi_note/command, whose meaning depends on parameter category; only available, when midi_fx_idx=-100, otherwise nil\n",
        "body": "ultraschall.GetParmMIDIPLink_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.SCANDXPLUGINS lua": {
        "prefix": "ultraschall.ScanDXPlugins",
        "scope": "lua",
        "description": "(Re-)scans all DX-Plugins.\n",
        "body": "ultraschall.ScanDXPlugins(${1:optional boolean re_scan})$0"
    },
    "ULTRASCHALL.DELETEPARMLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.DeleteParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Deletes a ParmLearn-entry from an FXStateChunk.\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, which you want to delete a ParmLearn from\nfxid:the id of the fx, which holds the to-delete-ParmLearn-entry; beginning with 1\nid:the id of the ParmLearn-entry to delete; beginning with 1\nRETURNS:\nretval:true, if deletion was successful; false, if the function couldn't delete anything\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.DeleteParmLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.DELETEPARMALIAS_FXSTATECHUNK lua": {
        "prefix": "ultraschall.DeleteParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Deletes a ParmAlias-entry from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, which you want to delete a ParmAlias from\nfxid:the id of the fx, which holds the to-delete-ParmAlias-entry; beginning with 1\nid:the id of the ParmAlias-entry to delete; beginning with 1\nRETURNS:\nretval:true, if deletion was successful; false, if the function couldn't delete anything\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.DeleteParmAlias_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.DELETEPARMLFOLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.DeleteParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Deletes a ParmLFO-Learn-entry from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, which you want to delete a ParmLFO-Learn-entry from\nfxid:the id of the fx, which holds the to-delete-ParmLFO-Learn-entry; beginning with 1\nid:the id of the ParmLFO-Learn-entry to delete; beginning with 1\nRETURNS:\nretval:true, if deletion was successful; false, if the function couldn't delete anything\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.DeleteParmLFOLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id})$0"
    },
    "ULTRASCHALL.SETPARMLFOLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.SetParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Sets an already existing ParmLFO-Learn-entry of an FX-plugin from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a ParmLFO-Learn-entry\nfxid:the id of the fx, which holds the to-set-ParmLFO-Learn-entry; beginning with 1\nid:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLFO)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.SetParmLFOLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message})$0"
    },
    "ULTRASCHALL.SETPARMLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.SetParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Sets an already existing Parm-Learn-entry of an FX-plugin from an FXStateChunk.\nIt's the PARMLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nid:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.SetParmLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message})$0"
    },
    "ULTRASCHALL.SETPARMALIAS_FXSTATECHUNK lua": {
        "prefix": "ultraschall.SetParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Sets an already existing Parm-Learn-entry of an FX-plugin from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nid:the id of the Parm-Learn-entry to set; beginning with 1\nparmalias:the new aliasname of the parameter\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.SetParmAlias_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer id},${4:string parmalias})$0"
    },
    "ULTRASCHALL.SETFXSTATECHUNK lua": {
        "prefix": "ultraschall.SetFXStateChunk",
        "scope": "lua",
        "description": "Adds/replaces FXStateChunk to/in a TrackStateChunk or a MediaItemStateChunk.\nreturns false in case of an error\nPARAMETERS:\nStateChunk:the FXStateChunk, which you want to set into the TrackStateChunk\nFXStateChunk:the FXStateChunk, which you want to set into the TrackStateChunk\nTakeFXChain_id:when using MediaItemStateChunks, this allows you to choose the take of which you want the FXChain; default is 1\nRETURNS:\nretval:true, if setting fxstatechunk was successful; false, if setting was unsuccessful\nalteredStateChunk:the altered StateChunk\n",
        "body": "ultraschall.SetFXStateChunk(${1:string StateChunk},${2:string FXStateChunk},${3:optional integer TakeFXChain_id})$0"
    },
    "ULTRASCHALL.GETFXSTATECHUNK lua": {
        "prefix": "ultraschall.GetFXStateChunk",
        "scope": "lua",
        "description": "Returns an FXStateChunk from a TrackStateChunk or a MediaItemStateChunk.\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nReturns nil in case of an error or if no FXStateChunk has been found.\nPARAMETERS:\nStateChunk:the StateChunk, from which you want to retrieve the FXStateChunk\nTakeFXChain_id:when using MediaItemStateChunks, this allows you to choose the take of which you want the FXChain; default is 1\nRETURNS:\nFXStateChunk:the FXStateChunk, stored in the StateChunk\n",
        "body": "ultraschall.GetFXStateChunk(${1:string StateChunk},${2:optional integer TakeFXChain_id})$0"
    },
    "ULTRASCHALL.ADDPARMLFOLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.AddParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Adds a new Parm-LFOLearn-entry to an FX-plugin from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nparmidx:the parameter, whose alias you want to add\nparmname:the name of the parameter, usually \\\"\\\" or \\\"byp\\\" for bypass or \\\"wet\\\" for wet; when using wet or bypass, these are essential to give!\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.AddParmLFOLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer parmidx},${4:string parmname},${5:integer midi_note},${6:integer checkboxflags},${7:optional string osc_message})$0"
    },
    "ULTRASCHALL.ADDPARMLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.AddParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Adds a new Parm-Learn-entry to an FX-plugin from an FXStateChunk.\nIt's the PARMLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nparmidx:the parameter, whose alias you want to add\nparmname:the name of the parameter, usually \\\"\\\" or \\\"byp\\\" for bypass or \\\"wet\\\" for wet; when using wet or bypass, these are essential to give!\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.AddParmLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:integer parmidx},${4:string parmname},${5:integer midi_note},${6:integer checkboxflags},${7:optional string osc_message})$0"
    },
    "ULTRASCHALL.ADDPARMALIAS_FXSTATECHUNK lua": {
        "prefix": "ultraschall.AddParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Adds a new Parm-Alias-entry to an FX-plugin from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nparmalias:the new aliasname of the parameter\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "ultraschall.AddParmAlias_FXStateChunk(${1:string FXStateChunk},${2:integer fxid},${3:string parmalias})$0"
    },
    "ULTRASCHALL.COUNTPARMALIAS_FXSTATECHUNK lua": {
        "prefix": "ultraschall.CountParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Counts already existing Parm-Alias-entries of an FX-plugin from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns -1 in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to count a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-count-Parm-Learn-entry; beginning with 1\nRETURNS:\ncount:the number of ParmAliases found\n",
        "body": "ultraschall.CountParmAlias_FXStateChunk(${1:string FXStateChunk},${2:integer fxid})$0"
    },
    "ULTRASCHALL.COUNTPARMLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.CountParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Counts already existing Parm-Learn-entries of an FX-plugin from an FXStateChunk.\nIt's the PARMLEARN-entry\nreturns -1 in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to count a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-count-Parm-Learn-entry; beginning with 1\nRETURNS:\ncount:the number of ParmLearn-entried found\n",
        "body": "ultraschall.CountParmLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid})$0"
    },
    "ULTRASCHALL.COUNTPARMLFOLEARN_FXSTATECHUNK lua": {
        "prefix": "ultraschall.CountParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Counts already existing Parm-LFOLearn-entries of an FX-plugin from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns -1 in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to count a Parm-LFOLearn-entry\nfxid:the id of the fx, which holds the to-count-Parm-LFOLearn-entry; beginning with 1\nRETURNS:\ncount:the number of LFOLearn-entried found\n",
        "body": "ultraschall.CountParmLFOLearn_FXStateChunk(${1:string FXStateChunk},${2:integer fxid})$0"
    },
    "ULTRASCHALL.SCANVSTPLUGINS lua": {
        "prefix": "ultraschall.ScanVSTPlugins",
        "scope": "lua",
        "description": "Re-scans all VST-Plugins.\nPARAMETERS:\nclear_cache:true, clear cache before re-scanning; false or nil, just scan vts-plugins\n",
        "body": "ultraschall.ScanVSTPlugins(${1:optional boolean clear_cache})$0"
    },
    "ULTRASCHALL.AUTODETECTVSTPLUGINSFOLDER lua": {
        "prefix": "ultraschall.AutoDetectVSTPluginsFolder",
        "scope": "lua",
        "description": "Auto-detects the vst-plugins-folder.\n",
        "body": "ultraschall.AutoDetectVSTPluginsFolder()$0"
    },
    "ULTRASCHALL.COUNTFXSTATECHUNKSINSTATECHUNK lua": {
        "prefix": "ultraschall.CountFXStateChunksInStateChunk",
        "scope": "lua",
        "description": "Counts all FXStateChunks within a StateChunk.\nYou can pass ItemStateChunks, TrackStateChunks and ProjectStateChunks.\nreturns -1 in case of an error.\nPARAMETERS:\nStateChunk:the StateChunk, whose count of FXStateChunks you want to retrieve\nRETURNS:\ncount_of_takefx_statechunks:the number of take-fx-StateChunks within the StateChunk. When passing Track/ProjectStateChunks, it returns number of all FXStateChunks from all Takes within the StateChunk\ncount_of_trackfx_statechunks:the number of TrackFX-StateChunks; each track alawys has a single one, so it should match the number of tracks within the StateChunk; 0, if you pass a ItemStateChunk\n",
        "body": "ultraschall.CountFXStateChunksInStateChunk(${1:string StateChunk})$0"
    },
    "ULTRASCHALL.REMOVEFXSTATECHUNKFROMTRACKSTATECHUNK lua": {
        "prefix": "ultraschall.RemoveFXStateChunkFromTrackStateChunk",
        "scope": "lua",
        "description": "Clears the FXChain from a TrackStateChunk\nreturns nil in case of an error.\nPARAMETERS:\nTrackStateChunk:the TrackStateChunk, whose FXStateChunk you want to remove\nRETURNS:\naltered_TrackStateChunk:the TrackStateChunk, cleared of the Track-FXStateChunk\n",
        "body": "ultraschall.RemoveFXStateChunkFromTrackStateChunk(${1:string TrackStateChunk})$0"
    },
    "ULTRASCHALL.REMOVEFXSTATECHUNKFROMITEMSTATECHUNK lua": {
        "prefix": "ultraschall.RemoveFXStateChunkFromItemStateChunk",
        "scope": "lua",
        "description": "Removes a certain Take-FXStateChunk from an ItemStateChunk.\nReturns nil in case of failure.\nPARAMETERS:\nItemStateChunk:the ItemStateChunk, from which you want to remove an FXStateChunk\ntake_id:the take, whose FXStateChunk you want to remove\nRETURNS:\nalteredItemStateChunk:the StateChunk, from which the FXStateChunk was removed\n",
        "body": "ultraschall.RemoveFXStateChunkFromItemStateChunk(${1:string ItemStateChunk},${2:integer take_id})$0"
    },
    "ULTRASCHALL.LOADFXSTATECHUNKFROMRFXCHAINFILE lua": {
        "prefix": "ultraschall.LoadFXStateChunkFromRFXChainFile",
        "scope": "lua",
        "description": "Loads an FXStateChunk from an RFXChain-file.\nIf you don't give a path, it will try to load the file from the folder ResourcePath()/FXChains.\nreturns nil in case of an error\nPARAMETERS:\nfilename:the filename of the RFXChain-file(must include \".RfxChain\"); omit the path to load it from the folder ResourcePath()/FXChains\ntrackfx_or_takefx:0, return the FXStateChunk as Track-FXStateChunk; 1, return the FXStateChunk as Take-FXStateChunk\nRETURNS:\nFXStateChunk:the loaded FXStateChunk; nil, in case of an error\n",
        "body": "ultraschall.LoadFXStateChunkFromRFXChainFile(${1:string filename},${2:integer trackfx_or_takefx})$0"
    },
    "ULTRASCHALL.SAVEFXSTATECHUNKASRFXCHAINFILE lua": {
        "prefix": "ultraschall.SaveFXStateChunkAsRFXChainfile",
        "scope": "lua",
        "description": "Loads an FXStateChunk from an RFXChain-file.\nIf you don't give a path, it will try to load the file from the folder ResourcePath/FXChains.\nreturns -1 in case of an error\nPARAMETERS:\nfilename:the filename of the output-RFXChain-file(must include \".RfxChain\"); omit the path to save it into the folder ResourcePath/FXChains\nFXStateChunk:the FXStateChunk, which you want to set into the TrackStateChunk\nRETURNS:\nretval:-1 in case of failure, 1 in case of success\n",
        "body": "ultraschall.SaveFXStateChunkAsRFXChainfile(${1:string filename},${2:string FXStateChunk})$0"
    },
    "ULTRASCHALL.GETALLRFXCHAINFILENAMES lua": {
        "prefix": "ultraschall.GetAllRFXChainfilenames",
        "scope": "lua",
        "description": "Returns all available RFXChainfiles in the folder ResourcePath/FXChains\nRETURNS:\ncount_of_RFXChainfiles:the number of available RFXChainFiles\nRFXChainfiles:the filenames of the RFXChainfiles\n",
        "body": "ultraschall.GetAllRFXChainfilenames()$0"
    },
    "ULTRASCHALL.GETRECENTFX lua": {
        "prefix": "ultraschall.GetRecentFX",
        "scope": "lua",
        "description": "Returns the recent fx-list\nRETURNS:\ncount_of_RecentFX:the number of available recent fx\nRecentFX:the names of the recent fx\n",
        "body": "ultraschall.GetRecentFX()$0"
    },
    "ULTRASCHALL.SPLITSTRINGATLINEFEEDTOARRAY lua": {
        "prefix": "ultraschall.SplitStringAtLineFeedToArray",
        "scope": "lua",
        "description": "Splits the string unsplitstring at linefeed/tabs/control characters and puts each of these splitpieces into an array, each splitpiece one array-entry.\nThe linefeeds will not(!) be returned in the array's entries.\nReturns the number of entries in the array, as well as the array itself\nIf there are no control characters or linefeeds in the string, the array will have only one entry with unsplitstring in it.\nreturns -1 in case of failure\nPARAMETERS:\nunsplitstring:the string, that shall be split at LineFeed/Tabs/Control Characters. Nil is not allowed.\nRETURNS:\ncount:number of entries in the split_string-array\nsplit_string:an array with all the individual \"postsplit\"-pieces of the string\n",
        "body": "ultraschall.SplitStringAtLineFeedToArray(${1:string unsplitstring})$0"
    },
    "ULTRASCHALL.COUNTCHARACTERINSTRING lua": {
        "prefix": "ultraschall.CountCharacterInString",
        "scope": "lua",
        "description": "Counts, how often character appears in checkstring and returns the count, as well as a array an with the position-numbers.\nreturns -1 in case of error\nPARAMETERS:\ncheckstring:the string to check search through\ncharacter:the character to search for. Only single characters are allowed. Controlcodes like \\n \\t count as single character. Case sensitive.\nRETURNS:\ncount:the number of occurences of character in checkstring\npositions:the positionnumbers of the character in checkstring\n",
        "body": "ultraschall.CountCharacterInString(${1:string checkstring},${2:string character})$0"
    },
    "ULTRASCHALL.ISVALIDMATCHINGPATTERN lua": {
        "prefix": "ultraschall.IsValidMatchingPattern",
        "scope": "lua",
        "description": "Returns, if patstring is a valid pattern-matching-string\nPARAMETERS:\npatstring:the string to check for, if it's a valid pattern-matching-string\nRETURNS:\nretval:true, patstring is a valid pattern-matching-string; false, patstring isn't a valid pattern-matching-string\n",
        "body": "ultraschall.IsValidMatchingPattern(${1:string patstring})$0"
    },
    "ULTRASCHALL.CSV2INDIVIDUALLINESASARRAY lua": {
        "prefix": "ultraschall.CSV2IndividualLinesAsArray",
        "scope": "lua",
        "description": "convert a csv-string to an array of the individual values. If separator cannot be found, it'll return the original string\nreturns nil in case or error\nPARAMETERS:\ncsv_line:a string as a csv, with all values included and separated by parameter separator\nseparator:the separator, that separates the individual entries; use nil for commas; separators will be removed from the final strings!\nRETURNS:\ncount:the number of entries\nindividual_values:all values, each in an individual array-position\n",
        "body": "ultraschall.CSV2IndividualLinesAsArray(${1:string csv_line},${2:optional string separator})$0"
    },
    "ULTRASCHALL.ROUNDNUMBER lua": {
        "prefix": "ultraschall.RoundNumber",
        "scope": "lua",
        "description": "returns a rounded value of the parameter number. %.5 and higher rounds up, lower than %.5 round down.\nreturns nil in case of an error\nPARAMETERS:\nnum:the floatingpoint number, you'd like to have rounded.\nRETURNS:\nretval:the rounded number\n",
        "body": "ultraschall.RoundNumber(${1:number num})$0"
    },
    "ULTRASCHALL.GETPARTIALSTRING lua": {
        "prefix": "ultraschall.GetPartialString",
        "scope": "lua",
        "description": "returns the part of a filename-string between sep1 and sep2\nreturns nil if it doesn't work, no sep1 or sep2 exist\nPARAMETERS:\nstr:separator on the \"right\" side of the partial string\nsep1:separator on the \"left\" side of the partial string\nsep2:separator on the \"right\" side of the partial string\nRETURNS:\npartial_string:the partial string between sep1 and sep2\n",
        "body": "ultraschall.GetPartialString(${1:string str},${2:string sep1},${3:string sep2})$0"
    },
    "ULTRASCHALL.NOTES2CSV lua": {
        "prefix": "ultraschall.Notes2CSV",
        "scope": "lua",
        "description": "Gets the project's notes and returns it as a CSV.\nRETURNS:\ncsv_retval:the project notes, returned as a csv-string; entries separated by a comma\n",
        "body": "ultraschall.Notes2CSV()$0"
    },
    "ULTRASCHALL.CSV2LINE lua": {
        "prefix": "ultraschall.CSV2Line",
        "scope": "lua",
        "description": "converts a string of csv-values into a string with all values and without the ,-separators\nreturns nil in case of error\nRETURNS:\nvalues:all values in one string\n",
        "body": "ultraschall.CSV2Line(${1:string csv_line})$0"
    },
    "ULTRASCHALL.ISITEMINTRACK lua": {
        "prefix": "ultraschall.IsItemInTrack",
        "scope": "lua",
        "description": "checks, whether a given item is part of the track tracknumber\nreturns true, if the itemIDX is part of track tracknumber, false if not, nil if no such itemIDX or Tracknumber available\nPARAMETERS:\ntracknumber:the number of the track to check in, with 1 for track 1, 2 for track 2, etc.\nitemIDX:the number of the item to check of\nRETURNS:\nretval:true, if item is in track, false if item isn't in track\n",
        "body": "ultraschall.IsItemInTrack(${1:integer tracknumber},${2:integer itemIDX})$0"
    },
    "ULTRASCHALL.CHECKACTIONCOMMANDIDFORMAT2 lua": {
        "prefix": "ultraschall.CheckActionCommandIDFormat2",
        "scope": "lua",
        "description": "Checks, whether an action command id is a valid commandid(which is a number) or a valid _action_command_id (which is a string with an _underscore in the beginning).\nUnlike CheckActionCommandIDFormat, this checks whether an action-command-id-string is an actual registered one(case sensitive!).\nreturns false in case of an error\nPARAMETERS:\n:the ActionCommandID you want to check; either a number or an action_command_id with an underscore at the beginning\nRETURNS:\nretval:true, valid action_command_id; false, not a valid action_command_id\n",
        "body": "ultraschall.CheckActionCommandIDFormat2(${1:action_command_id})$0"
    },
    "ULTRASCHALL.TOGGLESTATEACTION lua": {
        "prefix": "ultraschall.ToggleStateAction",
        "scope": "lua",
        "description": "Toggles state of an action using the actioncommand_id(instead of the CommandID-number)\nreturns current state of the action after toggling or -1 in case of error.\nPARAMETERS:\nsection:the section of the action(see ShowActionlist-dialog)\nactioncommand_id:the ActionCommandID of the action to toggle\nstate:1 or 0\nRETURNS:\nretval:state if the action, after it has been toggled\n",
        "body": "ultraschall.ToggleStateAction(${1:integer section},${2:string actioncommand_id},${3:integer state})$0"
    },
    "ULTRASCHALL.REFRESHTOOLBAR_ACTION lua": {
        "prefix": "ultraschall.RefreshToolbar_Action",
        "scope": "lua",
        "description": "Refreshes a toolbarbutton with an ActionCommandID(instead of the CommandID-number)\nreturns -1 in case of error\nPARAMETERS:\nsection:section\nactioncommand_id:ActionCommandID of the action, associated with the toolbarbutton \n",
        "body": "ultraschall.RefreshToolbar_Action(${1:integer section},${2:string actioncommand_id})$0"
    },
    "ULTRASCHALL.TOGGLESTATEBUTTON lua": {
        "prefix": "ultraschall.ToggleStateButton",
        "scope": "lua",
        "description": "Toggles state and refreshes the button of an actioncommand_id\nreturns false in case of error\nPARAMETERS:\nsection:the section of the action(see ShowActionlist-dialog)\nactioncommand_id:the ActionCommandID of the action to toggle\nstate:1 or 0\nRETURNS:\nretval:true, toggling worked; false, toggling didn't work\n",
        "body": "ultraschall.ToggleStateButton(${1:integer section},${2:string actioncommand_id},${3:integer state})$0"
    },
    "ULTRASCHALL.SECONDSTOTIME lua": {
        "prefix": "ultraschall.SecondsToTime",
        "scope": "lua",
        "description": "converts timeposition in seconds(pos) to a timestring (h)hh:mm:ss.mss\nreturns nil in case of error\nPARAMETERS:\npos:timeposition in seconds\nRETURNS:\ntime_string:timestring in (h)hh:mm:ss.mss\n",
        "body": "ultraschall.SecondsToTime(${1:number pos})$0"
    },
    "ULTRASCHALL.TIMETOSECONDS lua": {
        "prefix": "ultraschall.TimeToSeconds",
        "scope": "lua",
        "description": "converts a timestring days:hours:minutes:seconds.milliseconds to timeposition in seconds\nit is ok, to have only some of the last ones given, so i.e. excluding days and hours is ok. Though excluding values inbetween does not work!\nA single integer in timestring will be seen as seconds.\nTo only specifiy milliseconds in particular, start the number with a .\nall other values are separated by :\nreturns -1 in case of error, timestring is a nil or if you try to add an additional value, added before days\ndoes not check for valid timeranges, so 61 minutes is possible to give, even if hours are present in the string\nPARAMETERS:\ntimestring:a string like: days:hours:minutes:seconds.milliseconds , i.e. 1:16:27:50.098\nRETURNS:\nposition:the converted position\n",
        "body": "ultraschall.TimeToSeconds(${1:string timestring})$0"
    },
    "ULTRASCHALL.SECONDSTOTIMESTRING_HH_MM_SS_MSS lua": {
        "prefix": "ultraschall.SecondsToTimeString_hh_mm_ss_mss",
        "scope": "lua",
        "description": "Converts the parameter time into a timestring of the format hh:mm:ss.mss\nValid timeranges are from 0 to 359999.99 seconds(about 99 hours).\nreturns -1 in case of error\nPARAMETERS:\ntime:the time in seconds to be converted into the timestring\nRETURNS:\ntimestring:the converted timestring. It will always follow the format hh:mm:ss.mss and fill up digits with zeros, if necessary.\n",
        "body": "ultraschall.SecondsToTimeString_hh_mm_ss_mss(${1:number time})$0"
    },
    "ULTRASCHALL.TIMESTRINGTOSECONDS_HH_MM_SS_MSS lua": {
        "prefix": "ultraschall.TimeStringToSeconds_hh_mm_ss_mss",
        "scope": "lua",
        "description": "Converts the parameter timestring of the format hh:mm:ss.mss into seconds\nThe timestring must follow strictly this format, or the function returns -1 as result.\nreturns -1 in case of error\nPARAMETERS:\ntimestring:the converted timestring. It must always follow the format hh:mm:ss.mss. Fill up digits with zeros, if necessary.\nRETURNS:\ntime:the time in seconds to be converted into the timestring, -1 in case of an error\n",
        "body": "ultraschall.TimeStringToSeconds_hh_mm_ss_mss(${1:string timestring})$0"
    },
    "ULTRASCHALL.COUNTPATTERNINSTRING lua": {
        "prefix": "ultraschall.CountPatternInString",
        "scope": "lua",
        "description": "returns the count and an array with all positions of searchstring in sourcestring.\nPARAMETERS:\nsourcestring:the string, you want to search through\nsearchstring:the string, you want to search for in sourcestring\nnon_case_sensitive:true, the search does not care about case-sensitivity; false, case of searchstring will be kept\nRETURNS:\ncount:the number of appearances of searchstring in sourcestring\npositions:an array with count-entries, where every entry contains the position of searchstring in sourcestring\n",
        "body": "ultraschall.CountPatternInString(${1:string sourcestring},${2:string searchstring},${3:boolean non_case_sensitive})$0"
    },
    "ULTRASCHALL.OPENURL lua": {
        "prefix": "ultraschall.OpenURL",
        "scope": "lua",
        "description": "Opens the URI with the standard-browser installed in your system.\nreturns -1 in case of an error\nPARAMETERS:\nurl:the url to be opened in the browser; will check for :// in it for validity!\n",
        "body": "ultraschall.OpenURL(${1:string url})$0"
    },
    "ULTRASCHALL.COMPAREARRAYS lua": {
        "prefix": "ultraschall.CompareArrays",
        "scope": "lua",
        "description": "Compares Array using parameter CompareArray2 and returns an array with all entries in CompareArray2, that are not in Array.\nThe comparable arrays must be indexed by integer-numbers.\nReturns nil in case of an error\nPARAMETERS:\nArray:the array you want to check against Array; all entries in CompareArray2 that are not in Array will be returned\nCompareArray2:the array you want to check against Array; all entries in CompareArray2 that are not in Array will be returned\nRETURNS:\ndiff_array:an array with all entries from CompareArray2, that are not in Array\n",
        "body": "ultraschall.CompareArrays(${1:table Array},${2:table CompareArray2})$0"
    },
    "ULTRASCHALL.GETOS lua": {
        "prefix": "ultraschall.GetOS",
        "scope": "lua",
        "description": "Returns operating system and if it's a 64bit/32bit-operating system.\nRETURNS:\noperating_system:the operating system used; usually \"Win\", \"Mac\" or \"Other\"(e.g. when Linux is used)\nbits:the number of bits of the operating-system. Either 32 or 64 bit.\n",
        "body": "ultraschall.GetOS()$0"
    },
    "ULTRASCHALL.ISOS_WINDOWS lua": {
        "prefix": "ultraschall.IsOS_Windows",
        "scope": "lua",
        "description": "returns, if the current operating system is windows\nRETURNS:\nis_windows:true, if the operating-system is windows; false if not\n",
        "body": "ultraschall.IsOS_Windows()$0"
    },
    "ULTRASCHALL.ISOS_MAC lua": {
        "prefix": "ultraschall.IsOS_Mac",
        "scope": "lua",
        "description": "returns, if the current operating system is mac-osx\nRETURNS:\nis_mac:true, if the operating-system is mac-osx; false if not\n",
        "body": "ultraschall.IsOS_Mac()$0"
    },
    "ULTRASCHALL.ISOS_OTHER lua": {
        "prefix": "ultraschall.IsOS_Other",
        "scope": "lua",
        "description": "returns, if the current operating system is neither mac or win\nRETURNS:\nis_other:true, if the operating-system is neither mac or win; false if not\n",
        "body": "ultraschall.IsOS_Other()$0"
    },
    "ULTRASCHALL.GETREAPERAPPVERSION lua": {
        "prefix": "ultraschall.GetReaperAppVersion",
        "scope": "lua",
        "description": "Returns operating system and if it's a 64bit/32bit-operating system.\nRETURNS:\nmajorversion:the majorversion of Reaper. Can be used for comparisions like \"if version<5 then ... end\".\nsubversion:the subversion of Reaper. Can be used for comparisions like \"if subversion<96 then ... end\".\nbits:the number of bits of the reaper-app\noperating_system:the operating system, either \"Win\", \"OSX\" or \"Other\"\nportable:true, if it's a portable installation; false, if it isn't a portable installation\nbetaversion:if you use a pre-release of Reaper, this contains the beta-version, like \"rc9\" or \"+dev0423\" or \"pre6\"\n",
        "body": "ultraschall.GetReaperAppVersion()$0"
    },
    "ULTRASCHALL.LIMITFRACTIONOFFLOAT lua": {
        "prefix": "ultraschall.LimitFractionOfFloat",
        "scope": "lua",
        "description": "limits the fraction of a float-number to a specific length of fraction(digits). You can also choose to round the value or not.\nreturns nil in case of error\nPARAMETERS:\nnumber:the number, whose fraction shall be limited\nlength_of_fraction:the number of digits in the fraction\nroundit:false, no rounding; true, rounds the fraction. Rounding-precision is only length_of_fraction+1, all the other digits will be ignored. If length_of_fraction+1>=5, it will be rounded up, otherwise down.\nRETURNS:\naltered_number:the altered number with the new fraction-length. Will be equal to parameter number, if number was integer or fraction less digits than length_of_fraction\n",
        "body": "ultraschall.LimitFractionOfFloat(${1:number number},${2:integer length_of_fraction},${3:boolean roundit})$0"
    },
    "ULTRASCHALL.GETALLENTRIESFROMTABLE lua": {
        "prefix": "ultraschall.GetAllEntriesFromTable",
        "scope": "lua",
        "description": "Gets an iterable version of table. Good for analysing unknown tables.\nReturns the number of entries, a table(array) with the datatypes of each entry and the table with all it's entries in the same order as in the foundtypes-table.\nThis doesn't treat table recursivley, means: each \"Subtable\" within the table is treated as one entry of the type \"table\". That means, that these tables must be analysed themselves in an extra step!\nA[1]=1\nA[2][1]=2\nA[2][2]=3.4\nwill return two(!) entries, the first being of type \"integer\", the second being of type \"table\". Next step would be to run use this function to analyse A[2] as well, which would result in two entries: the first being of type \"integer\" and the second of type \"float\", etc.\nreturns -1 in case of error\nPARAMETERS:\ntable:the table to get the individual entries from\nRETURNS:\ncount:the number of table-entries found\nfoundtypes:a table, with count-entries, each entry having the type of each entry in the returned_table as string.\nreturned_table:an iterable version of table. The type of each entry can be found in the accompanying entry of foundtypes\n",
        "body": "ultraschall.GetAllEntriesFromTable(${1:table table})$0"
    },
    "ULTRASCHALL.APIEXISTS lua": {
        "prefix": "ultraschall.APIExists",
        "scope": "lua",
        "description": "returns true, if a certain function/variable exists in ultraschall.\nreturns false if nothing has been found\nPARAMETERS:\nfunctionname:the name of the function to check for; only the functionname without ultraschall. !\nRETURNS:\nretval:true, if element exists; false if it doesn't exist\n",
        "body": "ultraschall.APIExists(${1:string functionname})$0"
    },
    "ULTRASCHALL.ISVALIDGUID lua": {
        "prefix": "ultraschall.IsValidGuid",
        "scope": "lua",
        "description": "Checks, if guid is a valid guid. Can also be used for strings, that contain a guid somewhere in them(strict=false)\nA valid guid is a string that follows the following pattern:\n{........-....-....-....-............}\nwhere . is a hexadecimal value(0-F)\nReturns false in case of error\nPARAMETERS:\nguid:the guid to check for validity\nstrict:true, guid must only be the valid guid; false, guid must contain a valid guid somewhere in it(means, can contain trailing or preceding characters)\nRETURNS:\nretval:true, guid is/contains a valid guid; false, guid isn't/does not contain a valid guid\n",
        "body": "ultraschall.IsValidGuid(${1:string guid},${2:boolean strict})$0"
    },
    "ULTRASCHALL.SETGUIDEXTSTATE lua": {
        "prefix": "ultraschall.SetGuidExtState",
        "scope": "lua",
        "description": "Sets an extension-state using a given guid. Good for storing additional metadata of objects like MediaTracks, MediaItems, MediaItem_Takes, etc(everything, that has a guid).\nThe state can be saved as either global extension state or \"local\" extension-project-state(in the currently opened project)\nThe guid can have additional text, but must contain a valid guid somewhere in it!\nA valid guid is a string that follows the following pattern:\n{........-....-....-....-............}\nwhere . is a hexadecimal value(0-F)\nReturns -1 in case of error\nPARAMETERS:\nguid:the guid of the object, for whom you want to store a key/value-pair; can have additional characters before and after the guid, but must contain a valid guid!\nkey:the key for this guid\nvalue:the value to store into the key/value-store\nsavelocation:0, store as project extension state(into the currently opened project); 1, store as global extension state(when persist=true, into reaper-extstate.ini in the resourcesfolder)\noverwrite:true, overwrite a previous given value; false, don't overwrite, if a value exists already\npersists:true, make extension state persistent(available after Reaper-restart); false, don't make it persistent; Only with global extension states\nRETURNS:\nretval:the idx of the extstate(if a project extension state); 1, successful(with extension states), -1, unsuccessful\n",
        "body": "ultraschall.SetGuidExtState(${1:string guid},${2:string key},${3:string value},${4:integer savelocation},${5:boolean overwrite},${6:boolean persists})$0"
    },
    "ULTRASCHALL.SETBITFIELD lua": {
        "prefix": "ultraschall.SetBitfield",
        "scope": "lua",
        "description": "Alters an integer-bitfield.\nReturns nil in case of error, like invalid bit-values\nPARAMETERS:\ninteger_bitfield:the old integer-bitfield that you want to alter\nset_to:true, set the bits to 1; false, set the bits to 0; nil, toggle the bits\nRETURNS:\nnew_integer_bitfield:the newly altered bitfield\n",
        "body": "ultraschall.SetBitfield(${1:integer integer_bitfield},${2:boolean set_to},${3:integer bit_1},${4:integer bit_2},${5:... integer bit_n})$0"
    },
    "ULTRASCHALL.PREVENTCREATINGUNDOPOINT lua": {
        "prefix": "ultraschall.PreventCreatingUndoPoint",
        "scope": "lua",
        "description": "Prevents creation of an Undo-point. Only useful in non-defer-scripts.\n",
        "body": "ultraschall.PreventCreatingUndoPoint()$0"
    },
    "ULTRASCHALL.SETINTCONFIGVAR_BITFIELD lua": {
        "prefix": "ultraschall.SetIntConfigVar_Bitfield",
        "scope": "lua",
        "description": "Alters an integer-bitfield stored by a ConfigVariable.\nReturns false in case of error, like invalid bit-values, etc\nPARAMETERS:\nconfigvar:the config-variable, that is stored as an integer-bitfield, that you want to alter.\nset_to:true, set the bits to 1; false, set the bits to 0; nil, toggle the bits\nRETURNS:\nretval:true, if altering was successful; false, if not successful\nnew_integer_bitfield:the newly altered bitfield\n",
        "body": "ultraschall.SetIntConfigVar_Bitfield(${1:string configvar},${2:boolean set_to},${3:integer bit_1},${4:integer bit_2},${5:... integer bit_n})$0"
    },
    "ULTRASCHALL.CONVERTSTRINGTOASCII_ARRAY lua": {
        "prefix": "ultraschall.ConvertStringToAscii_Array",
        "scope": "lua",
        "description": "Converts a string into it's individual characters and numerical-representation as a table and after that returns its number of table-entries and the table.\nReturns -1 if string isn't a valid string\nPARAMETERS:\nstring:the string to be converted\nRETURNS:\nlength:the number of characters in the string/entries in the returned table byte_array\nbyte_array:the ByteArray as a table, with the format\n",
        "body": "ultraschall.ConvertStringToAscii_Array(${1:string string})$0"
    },
    "ULTRASCHALL.COMPARESTRINGWITHASCIIVALUES lua": {
        "prefix": "ultraschall.CompareStringWithAsciiValues",
        "scope": "lua",
        "description": "Compares a string with a number of byte-values(like ASCII-values).\nBytevalues can be either decimal and hexadecimal.\n-1, if you want to skip checking of a specific position in string.\nReturns false in case of error\nPARAMETERS:\nstring:the string to check against the bytevalues\nbytevalue_1:one or more parameters, that include the bytevalues to check against the accompanying byte in string; -1, if you want to skip check for that position\nRETURNS:\nretval:true, if check was successful; false, if not successful\nerrorposition:if retval is false, this will contain the position in string, where the checking failed; nil, if retval is true\n",
        "body": "ultraschall.CompareStringWithAsciiValues(${1:string string},${2:integer bytevalue_1},${3:integer bytevalue_2},${4:... integer bytevalue_n})$0"
    },
    "ULTRASCHALL.RETURNSMINUSONEINCASEOFERROR_ARZALA lua": {
        "prefix": "ultraschall.ReturnsMinusOneInCaseOfError_Arzala",
        "scope": "lua",
        "description": "Returns -1 in case of an error\nRETURNS:\nretval:returns -1 in case of error\n",
        "body": "ultraschall.ReturnsMinusOneInCaseOfError_Arzala()$0"
    },
    "ULTRASCHALL.COUNTLINESINSTRING lua": {
        "prefix": "ultraschall.CountLinesInString",
        "scope": "lua",
        "description": "Counts the lines in a string. It counts them by counting \\n-newlines(not carriage returns!)\nReturns -1 in case of an error\nPARAMETERS:\nString:the string to count the lines of\nRETURNS:\nnumber_of_lines:number of lines of the string\n",
        "body": "ultraschall.CountLinesInString(${1:string String})$0"
    },
    "ULTRASCHALL.RETURNTYPEOFREAPEROBJECT lua": {
        "prefix": "ultraschall.ReturnTypeOfReaperObject",
        "scope": "lua",
        "description": "returns the type of a Reaper-object.\nPARAMETERS:\nobject:a Reaper-object of the following types:\nRETURNS:\nobjecttype:the type of the parameter of object\n",
        "body": "ultraschall.ReturnTypeOfReaperObject(${1:Reaperobject object})$0"
    },
    "ULTRASCHALL.ISOBJECTVALIDREAPEROBJECT lua": {
        "prefix": "ultraschall.IsObjectValidReaperObject",
        "scope": "lua",
        "description": "checks, if object is a valid Reaper-object. It also returns the type of that Reaper-object.\nPARAMETERS:\nobject:a Reaper-object of the following types:\nRETURNS:\nretval:true, if it's a valid Reaper-object; false, if not\nobjecttype:the type of the parameter of object\n",
        "body": "ultraschall.IsObjectValidReaperObject(${1:Reaperobject object})$0"
    },
    "ULTRASCHALL.REMOVETABLEENTRIESOFTYPE lua": {
        "prefix": "ultraschall.RemoveTableEntriesOfType",
        "scope": "lua",
        "description": "Removes all entries from worktable, that are of the datatype as given by removetype.\nreturns nil in case of error\nPARAMETERS:\nworktable:the unaltered source-table for processing\nremovetype:the type that shall be removed from table\nRETURNS:\nalteredtable:the table, that contains only the entries that are nt of the type as given by parameter removetype\n",
        "body": "ultraschall.RemoveTableEntriesOfType(${1:table worktable},${2:string removetype})$0"
    },
    "ULTRASCHALL.ISITEMINTRACK3 lua": {
        "prefix": "ultraschall.IsItemInTrack3",
        "scope": "lua",
        "description": "Checks, whether a MediaItem is in any of the tracks, given by trackstring.\nsee IsItemInTrack to use itemidx instead of the MediaItem-object.\nsee IsItemInTrack2 to check against only one track.\nreturns nil in case of error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to know the track is is placed in\ntrackstring:a string with all tracknumbers, separated by commas; 1 for track 1, 2 for track 2, etc\nRETURNS:\nretval:true, if item is in track; false, if not\n",
        "body": "ultraschall.IsItemInTrack3(${1:MediaItem MediaItem},${2:string trackstring})$0"
    },
    "ULTRASCHALL.ADDINTTOCHAR lua": {
        "prefix": "ultraschall.AddIntToChar",
        "scope": "lua",
        "description": "Adds/subtracts int to/from the numeric representation of character. It will return the new character.\nIt will not(!) include \"overflows\" into the adding/subtraction. That said, if you want to add a value resulting in a character above ASCII-code 255, it will fail!\nReturns nil in case of an error\nPARAMETERS:\ncharacter:the character, onto which you want to add/subtract parameter int; only single character allowed\nint:the value, that you want to add to the numerical representation of parameter character\nRETURNS:\nnew_character:the new character, after parameter int has been added/subtracted from/to character\n",
        "body": "ultraschall.AddIntToChar(${1:string character},${2:integer int})$0"
    },
    "ULTRASCHALL.MAKEFUNCTIONUNDOABLE lua": {
        "prefix": "ultraschall.MakeFunctionUndoable",
        "scope": "lua",
        "description": "Run the function Func and create an undopoint for this function. You can also give an UndoMessage and a flag for Reaper to use.\nAll parameters needed by Func follow after parameter Flag, as if it would be the normal parameters.\nThis should make creating undo-points much much easier...\nNote: Reaper will use the undo-point only for functions, who do \"undo\"-able things. If you don't have something of that kind(no creating a track or something), Reaper will not create an undo-point.\nReturns false in case of an error\nPARAMETERS:\nFunc:the parameters, as needed by the function Func; will be given to Func as provided by you\nUndoMessage:the undo-message to be displayed by Reaper in the Undo-history\nFlag:you can set a flag, if you want, for this undo-point\n:the parameters, as needed by the function Func; will be given to Func as provided by you\nFunc_parameters_n:the parameters, as needed by the function Func; will be given to Func as provided by you\nRETURNS:\nretval:the returnvalues, as returned by function Func\ncurrent_UndoMessage:the current UndoMessage for the last action done by Reaper. Use this so see, if getting an undo-point was successful\nretvals_1:the returnvalues, as returned by function Func\n...:the returnvalues, as returned by function Func\nretvals_2:the returnvalues, as returned by function Func\n",
        "body": "ultraschall.MakeFunctionUndoable(${1:function Func},${2:string UndoMessage},${3:integer Flag},${4:Func_parameters_1},${5: ... Func_parameters_n})$0"
    },
    "ULTRASCHALL.RETURNTABLEASINDIVIDUALVALUES lua": {
        "prefix": "ultraschall.ReturnTableAsIndividualValues",
        "scope": "lua",
        "description": "Returns the first 64 entries of an numerical-indexed table as returnvalues\nPARAMETERS:\nTable:the table, whose values you want to return. It will only return values with index 1...64!\nRETURNS:\nretval1:the values from Table returned\nretval2:the values from Table returned\nretval3:the values from Table returned\n...:the values from Table returned\nretval64:the values from Table returned\n",
        "body": "ultraschall.ReturnTableAsIndividualValues(${1:table Table})$0"
    },
    "ULTRASCHALL.TYPE lua": {
        "prefix": "ultraschall.type",
        "scope": "lua",
        "description": "Returns the type of the object.\nSupported types are Lua's own datatypes as well as Reaper's own datatypes.\nDue API-limitations, SWS-specific datatypes are not supported in this function!\nPARAMETERS:\nobject:the object, whose type you want to know\nRETURNS:\ntype_of_object:the type of the object; the following are valid:\nisnumber:true, if object is a number(either integer or number)\n",
        "body": "ultraschall.type(${1:identifier object})$0"
    },
    "ULTRASCHALL.CONCATINTEGERINDEXEDTABLES lua": {
        "prefix": "ultraschall.ConcatIntegerIndexedTables",
        "scope": "lua",
        "description": "Concatenates the entries of two tables into one table. The entries of each table must be indexed by integers\nThe new table still has the same references as the old table, means: if you remove the old tables/entries in the old tables, the concatenated table/accompanying entries will loose elements.\nTo get a \"true\"-concatenated copy, you should first create new copies of the tables, using MakeCopyOfTable.\nPARAMETERS:\ntable1:the first table to be concatenated; the entries must be indexed by integer-numbers!\ntable2:the second table to be concatenated; the entries must be indexed by integer-numbers!\nRETURNS:\nnumentries:the number of entries in the new table\nconcatenated_table:the new concatenated table\n",
        "body": "ultraschall.ConcatIntegerIndexedTables(${1:array table1},${2:array table2})$0"
    },
    "ULTRASCHALL.REVERSETABLE lua": {
        "prefix": "ultraschall.ReverseTable",
        "scope": "lua",
        "description": "reversed the order of the entries of a table, means, the last entry will become the first, the first become the last, etc.\nThe table must be indexed by integers.\nReturns nil if table isn't a valid table\nRETURNS:\nreversed_table:the resulting table with the reversed order of all entries\nentry_count:the number of entries in the reversed_table\n",
        "body": "ultraschall.ReverseTable(${1:table the_table})$0"
    },
    "ULTRASCHALL.GETDUPLICATESFROMARRAYS lua": {
        "prefix": "ultraschall.GetDuplicatesFromArrays",
        "scope": "lua",
        "description": "Returns the duplicates and the originals(entries only in one of the arrays) of two arrays. It will also return the number of entries.\nThis works only on arrays with integer-indexed entries; index must start with index 1!\nreturns -1 in case of an error\nPARAMETERS:\narray1:the first array to check for duplicates and \"original\"-entries\narray2:the second array to check for duplicates and \"original\"-entries\nRETURNS:\nduplicate_count:the number of entries in both arrays\nduplicate_array:the entries in both arrays\noriginalscount_array1:the number of entries only in array1\noriginals_array1:the entries that are only existing in array1\noriginalscount_array2:the number of entries only in array2\narray originals_array2:the entries that are only existing in array2\n",
        "body": "ultraschall.GetDuplicatesFromArrays(${1:array array1},${2:array array2})$0"
    },
    "ULTRASCHALL.GETSCRIPTFILENAMEFROMACTIONCOMMANDID lua": {
        "prefix": "ultraschall.GetScriptFilenameFromActionCommandID",
        "scope": "lua",
        "description": "returns the filename with path of a script, associated to a ReaScript.\nCommand-ID-numbers do not work!\nreturns false in case of an error\nRETURNS:\nscriptfilename_with_path:the scriptfilename with path associated with this ActionCommandID\n",
        "body": "ultraschall.GetScriptFilenameFromActionCommandID(${1:string action_command_id})$0"
    },
    "ULTRASCHALL.COMBINEBYTESTOINTEGER lua": {
        "prefix": "ultraschall.CombineBytesToInteger",
        "scope": "lua",
        "description": "Combines the Byte-values Byte_1 to Byte_n into one integer.\nThat means, if you give 4 values, it will return a 32bit-integer(4*8Bits).\nNegative values will use the maximum possible value of that byte minus the bits.\nIn Byte_1, -2 will be 255-1=254, in Byte 2, -2 will be 65280-256=65024.\nUse bitoffset to define, from which bit on you want to combine the values.\nReturns -1 in case of an error\nPARAMETERS:\nbitoffset:if you want to start combining the values from a certain bitoffset-onwards, set the offset here; use 0 to start with the first bit.\nByte_1:a bytevalue that you want to combine into one\nByte_2:a bytevalue that you want to combine into one\n:a bytevalue that you want to combine into one\nByte_n:a bytevalue that you want to combine into one\nRETURNS:\nretval:the combined integer\n",
        "body": "ultraschall.CombineBytesToInteger(${1:integer bitoffset},${2:integer Byte_1},${3:optional Byte_2},${4:...},${5:optional Byte_n})$0"
    },
    "ULTRASCHALL.SPLITINTEGERINTOBYTES lua": {
        "prefix": "ultraschall.SplitIntegerIntoBytes",
        "scope": "lua",
        "description": "Splits a 32-bit-integer-value into four bytes.\nReturns -1 in case of an error\nRETURNS:\nByte1:the first eight bits of the integer-value as a Byte\nByte2:the second eight bits of the integer-value as a Byte\nByte3:the third eight bits of the integer-value as a Byte\nByte4:the fourth eight bits of the integer-value as a Byte\n",
        "body": "ultraschall.SplitIntegerIntoBytes(${1:integer integervalue})$0"
    },
    "ULTRASCHALL.GETREAPERSCRIPTPATH lua": {
        "prefix": "ultraschall.GetReaperScriptPath",
        "scope": "lua",
        "description": "Returns path to Reaper's script-folder\nRETURNS:\nreaper_script_path:the path of the scripts-folder of Reaper\n",
        "body": "ultraschall.GetReaperScriptPath()$0"
    },
    "ULTRASCHALL.GETREAPERCOLORTHEMESPATH lua": {
        "prefix": "ultraschall.GetReaperColorThemesPath",
        "scope": "lua",
        "description": "Returns path to Reaper's color-theme-folder\nRETURNS:\nreaper_colorthemes_path:the path of the color-theme-folder of Reaper\n",
        "body": "ultraschall.GetReaperColorThemesPath()$0"
    },
    "ULTRASCHALL.GETREAPERJSFXPATH lua": {
        "prefix": "ultraschall.GetReaperJSFXPath",
        "scope": "lua",
        "description": "Returns path to Reaper's JSFX-plugin-folder\nRETURNS:\nreaper_jsfx_path:the path of the JSFX-plugin-folder of Reaper\n",
        "body": "ultraschall.GetReaperJSFXPath()$0"
    },
    "ULTRASCHALL.GETREAPERWEBRCPATH lua": {
        "prefix": "ultraschall.GetReaperWebRCPath",
        "scope": "lua",
        "description": "Returns path to the Web-RC-folder for Reaper as well as for the user-webrc-pages.\n",
        "body": "ultraschall.GetReaperWebRCPath()$0"
    },
    "ULTRASCHALL.CYCLETABLE lua": {
        "prefix": "ultraschall.CycleTable",
        "scope": "lua",
        "description": "Cycles the entries by offset. Offset can be positive(cycle forward) or negative(cycle negative). The number also tells the function, by how many entries the table shall be cycled, with 1 for one entry, 2 for 2 entries, etc.\nEntries \"falling out\" of one side(top or bottom) of the table will be readded on the other side.\nreturns nil in case of error\nPARAMETERS:\nthe_table:the table to cycle through\noffset:the offset, by which to cycle the entries through; positive, cycle entries forward; negative, cycle entries backward\nRETURNS:\nnew_table:the altered table\n",
        "body": "ultraschall.CycleTable(${1:table the_table},${2:integer offset})$0"
    },
    "ULTRASCHALL.SPLITSTRINGATNULLBYTES lua": {
        "prefix": "ultraschall.SplitStringAtNULLBytes",
        "scope": "lua",
        "description": "Splits splitstring into individual string at NULL-Bytes.\nreturns -1 in case of an error\nPARAMETERS:\nsplitstring:the string with NULL-Bytes(\\0) into it, that you want to split\nRETURNS:\ncount:the number of found strings\nsplit_strings:the found strings put into an array\n",
        "body": "ultraschall.SplitStringAtNULLBytes(${1:string splitstring})$0"
    },
    "ULTRASCHALL.RUNBACKGROUNDHELPERFEATURES lua": {
        "prefix": "ultraschall.RunBackgroundHelperFeatures",
        "scope": "lua",
        "description": "Starts background-scripts supplied with the Ultraschall-API, like:\n- a script for getting the last edit-cursor-position before the current one -> GetLastCursorPosition()\n- a script for getting the last playstate before the current one -> GetLastPlayState()\n- a script for getting the last loopstate before the current one -> GetLastLoopState()\nPARAMETERS:\nswitch_on:true, start the background-scripts/start unstarted background-helper-scripts; false, stop all background-helper-scripts\n",
        "body": "ultraschall.RunBackgroundHelperFeatures(${1:boolean switch_on})$0"
    },
    "ULTRASCHALL.MAIN_ONCOMMANDBYFILENAME lua": {
        "prefix": "ultraschall.Main_OnCommandByFilename",
        "scope": "lua",
        "description": "Runs a command by a filename. It internally registers the file temporarily as command, runs it and unregisters it again.\nThis is especially helpful, when you want to run a command for sure without possible command-id-number-problems.\nIt returns a unique script-identifier for this script, which can be used to communicate with this script-instance.\nThe started script gets its script-identifier using GetScriptIdentifier.\nYou can use this script-identifier e.g. as extstate.\nReturns false in case of an error\nPARAMETERS:\nfilename:the name and path of the scriptfile to run\n...:parameters that shall be passed over to the script\nRETURNS:\nretval:true, if running it was successful; false, if not\nscript_identifier:a unique script-identifier, which can be used as extstate to communicate with the started scriptinstance\n",
        "body": "ultraschall.Main_OnCommandByFilename(${1:string filename},${2:string ...})$0"
    },
    "ULTRASCHALL.MIDI_ONCOMMANDBYFILENAME lua": {
        "prefix": "ultraschall.MIDI_OnCommandByFilename",
        "scope": "lua",
        "description": "Runs a command by a filename in the MIDI-editor-context. It internally registers the file temporarily as command, runs it and unregisters it again.\nThis is especially helpful, when you want to run a command for sure without possible command-id-number-problems.\nIt returns a unique script-identifier for this script, which can be used to communicate with this script-instance.\nThe started script gets its script-identifier using GetScriptIdentifier.\nYou can use this script-identifier e.g. as extstate.\nReturns false in case of an error\nPARAMETERS:\nfilename:the name plus path of the scriptfile to run\nMidi_EditorHWND:the window-handler of the MIDI-editor, in which to run the script; nil, for the last active MIDI-editor\n...:parameters, that shall be passed over to the script\nRETURNS:\nretval:true, if running it was successful; false, if not\nscript_identifier:a unique script-identifier, which can be used as extstate to communicate with the started scriptinstance\n",
        "body": "ultraschall.MIDI_OnCommandByFilename(${1:string filename},${2:optional HWND Midi_EditorHWND},${3:string ...})$0"
    },
    "ULTRASCHALL.GETSCRIPTPARAMETERS lua": {
        "prefix": "ultraschall.GetScriptParameters",
        "scope": "lua",
        "description": "Gets the parameters stored for a specific script_identifier.\nreturns -1 in case of an error\nPARAMETERS:\nscript_identifier:the script-identifier, whose parameters you want to retrieve; \nremove:true or nil, remove the stored parameter-extstates; false, keep them for later retrieval\nRETURNS:\nnum_params:the number of parameters available\nparams:the values of the parameters as an array\ncaller_script_identifier:the scriptidentifier of the script, that set the parameters\n",
        "body": "ultraschall.GetScriptParameters(${1:optional string script_identifier},${2:optional boolean remove})$0"
    },
    "ULTRASCHALL.SETSCRIPTPARAMETERS lua": {
        "prefix": "ultraschall.SetScriptParameters",
        "scope": "lua",
        "description": "Sets the parameters stored for a specific script_identifier.\nPARAMETERS:\nscript_identifier:the script-identifier, whose parameters you want to retrieve; \n...:the parameters you want to set; there can be more than one, but they must be strings\nRETURNS:\nretval:true, storing was successful\nscript_identifier:the script_identifier, whose parameters have been set\n",
        "body": "ultraschall.SetScriptParameters(${1:string script_identifier},${2:string ...})$0"
    },
    "ULTRASCHALL.GETSCRIPTRETURNVALUES lua": {
        "prefix": "ultraschall.GetScriptReturnvalues",
        "scope": "lua",
        "description": "Gets the return-values which a specific sender\\_script\\_identifier sent to the current script.\nIf you have started numerous child-scripts and want to know, which child-script sent you return-values, see GetScriptReturnvalues_Sender\nreturns -1 in case of an error\nPARAMETERS:\nsender_script_identifier:the script-identifier, that sent the return-values to your script\nremove:true or nil, remove the stored retval-extstates; false, keep them for later retrieval\nRETURNS:\nretvals:the number of return-values available\n",
        "body": "ultraschall.GetScriptReturnvalues(${1:string sender_script_identifier},${2:optional boolean remove})$0"
    },
    "ULTRASCHALL.SETSCRIPTRETURNVALUES lua": {
        "prefix": "ultraschall.SetScriptReturnvalues",
        "scope": "lua",
        "description": "Send return-values back to the script, that has a specific script_identifier.\nreturns false in case of an error\nPARAMETERS:\nscript_identifier:the script-identifier of the script-instance, to where you want to send the returnvalues \n...:the returnvalues you want to set; there can be more than one, but they must be strings\nRETURNS:\nretval:true, storing was successful; false, there was an error\n",
        "body": "ultraschall.SetScriptReturnvalues(${1:string script_identifier},${2:string ...})$0"
    },
    "ULTRASCHALL.GETSCRIPTRETURNVALUES_SENDER lua": {
        "prefix": "ultraschall.GetScriptReturnvalues_Sender",
        "scope": "lua",
        "description": "Retrieves, which scripts sent returnvalues to the current script.\nRETURNS:\ncount:the number of scripts, who have left returnvalues for the current script\nretval_sender:the ScriptIdentifier of the scripts, who returned values\n",
        "body": "ultraschall.GetScriptReturnvalues_Sender()$0"
    },
    "ULTRASCHALL.BASE64_ENCODER lua": {
        "prefix": "ultraschall.Base64_Encoder",
        "scope": "lua",
        "description": "Converts a string into a Base64-Encoded string.\nCurrently, only standard Base64-encoding is supported.\nReturns nil in case of an error\nPARAMETERS:\nsource_string:the string that you want to convert into Base64\nbase64_type:the Base64-decoding-style\nremove_newlines:1, removes \\n-newlines(including \\r-carriage return) from the string\nremove_tabs:1, removes \\t-tabs from the string\nRETURNS:\nencoded_string:the encoded string\n",
        "body": "ultraschall.Base64_Encoder(${1:string source_string},${2:optional integer base64_type},${3:optional integer remove_newlines},${4:optional integer remove_tabs})$0"
    },
    "ULTRASCHALL.BASE64_DECODER lua": {
        "prefix": "ultraschall.Base64_Decoder",
        "scope": "lua",
        "description": "Converts a Base64-encoded string into a normal string.\nCurrently, only standard Base64-encoding is supported.\nReturns nil in case of an error\nPARAMETERS:\nsource_string:the Base64-encoded string\nbase64_type:the Base64-decoding-style\nRETURNS:\ndecoded_string:the decoded string\n",
        "body": "ultraschall.Base64_Decoder(${1:string source_string},${2:optional integer base64_type})$0"
    },
    "ULTRASCHALL.STATECHUNKLAYOUTER lua": {
        "prefix": "ultraschall.StateChunkLayouter",
        "scope": "lua",
        "description": "Layouts StateChunks as returned by GetTrackStateChunk or GetItemStateChunk into a format that resembles the formatting-rules of an rpp-file.\nThis is very helpful, when parsing such a statechunk, as you can now use the number of spaces used for intendation as help parsing.\nUsually, every new element, that starts with < will be followed by none or more lines, that have two spaces added in the beginning.\nExample of a MediaItemStateChunk(I use . to display the needed spaces in the beginning of each line):\n<ITEM\n..POSITION 6.96537864205337\n..SNAPOFFS 0\n..LENGTH 1745.2745\n..LOOP 0\n..ALLTAKES 0\n..FADEIN 1 0.01 0 1 0 0\n..FADEOUT 1 0.01 0 1 0 0\n..MUTE 0\n..SEL 1\n..IGUID {020E6372-97E6-4066-9010-B044F67F2772}\n..IID 1\n..NAME myaudio.flac\n..VOLPAN 1 0 1 -1\n..SOFFS 0\n..PLAYRATE 1 1 0 -1 0 0.0025\n..CHANMODE 0\n..GUID {79F087CE-49E8-4212-91F5-8487FBCF10B1}\n..<SOURCE FLAC\n....FILE \"C:\\Users\\meo\\Desktop\\X_Karo_Lynn-Interview.flac\"\n..>\n>\nThis function will not check, if you've passed a valid statechunk!\nreturns nil in case of an error\nPARAMETERS:\nstatechunk:a statechunk, that you want to layout properly\nRETURNS:\nlayouted_statechunk:the statechunk, that is now layouted to the rules of rpp-projectfiles\n",
        "body": "ultraschall.StateChunkLayouter(${1:string statechunk})$0"
    },
    "ULTRASCHALL.REVERSEENDIANESS_BYTE lua": {
        "prefix": "ultraschall.ReverseEndianess_Byte",
        "scope": "lua",
        "description": "reverses the endianess of a byte and returns this as value.\nThe parameter byte must be between 0 and 255!\nreturns nil in case of an error\nPARAMETERS:\nbyte:the integer whose endianess you want to reverse\nRETURNS:\nnewbyte:the endianess-reversed byte\n",
        "body": "ultraschall.ReverseEndianess_Byte(${1:integer byte})$0"
    },
    "ULTRASCHALL.CONVERTINTEGERTOBITS lua": {
        "prefix": "ultraschall.ConvertIntegerToBits",
        "scope": "lua",
        "description": "converts an integer-value(up to 64 bits) into it's individual bits and returns it as comma-separated csv-string as well as a table with 64 entries.\nreturns nil in case of an error\nPARAMETERS:\ninteger:the integer-number to separated into it's individual bits\nRETURNS:\nbitvals_csv:a comma-separated csv-string of all bitvalues, with bit 1 coming first and bit 32 coming last\nbitvalues:a 64-entry table, where each entry contains the bit-value of integer; first entry for bit 1, 64th entry for bit 64\n",
        "body": "ultraschall.ConvertIntegerToBits(${1:integer integer})$0"
    },
    "ULTRASCHALL.CONVERTBITSTOINTEGER lua": {
        "prefix": "ultraschall.ConvertBitsToInteger",
        "scope": "lua",
        "description": "converts a table with all bitvalues into it's integer-representation.\neach table-entry holds either a 1 or a 0;\nwith index 1 being the first (for 1),\nindex 2 for the second (for 2),\nindex 3 for the third (for 4),\nindex 4 for the fourth(for 8), etc\nreturns nil in case of an error\nPARAMETERS:\nbitvalues:a table, where each entry contains the bit-value of integer; first entry for bit 1, 64th entry for bit 64, etc\n",
        "body": "ultraschall.ConvertBitsToInteger(${1:table bitvalues})$0"
    },
    "ULTRASCHALL.GETSETINTCONFIGVAR lua": {
        "prefix": "ultraschall.GetSetIntConfigVar",
        "scope": "lua",
        "description": "Gets/Sets an integer-bitfield of an integer-configvariable.\nPass to it a varname, if it shall be set or gotten from and up to 32 parameters who specify, if that bit shall be set(true) or not(false) or the currently set value shall be used(nil)\nSee Reaper_Config_Variables.html for more details on config-variables in Reaper.\nreturns false in case of an error\nPARAMETERS:\nvarname:the name of the config-variable\nset:true, set this config-var; false, don't set it\nbit1:true, set this bit; false, don't set this bit; nil, use the currently set value\n:true, set this bit; false, don't set this bit; nil, use the currently set value\nbit32:true, set this bit; false, don't set this bit; nil, use the currently set value\nRETURNS:\nretval:true, getting/setting the config-var was successful; false, it wasn't successful\nconfig_var_value:the new/current value of the configuration-variable\n",
        "body": "ultraschall.GetSetIntConfigVar(${1:string varname},${2:boolean set},${3:optional boolean bit1},${4:...},${5:optional boolean bit32})$0"
    },
    "ULTRASCHALL.GETSCRIPTIDENTIFIER lua": {
        "prefix": "ultraschall.GetScriptIdentifier",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nThe identifier is of the format \"ScriptIdentifier:scriptfilename-{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}.ext\", where the {}-part is a guid and ext either .lua .py or .eel\nDefer1](#Defer1) to [Defer20 make use of this to stop a running defer-loop from the outside of a deferred-script.\nRETURNS:\nscript_identifier:a unique script-identifier for this script-instance, of the format:\n",
        "body": "ultraschall.GetScriptIdentifier()$0"
    },
    "ULTRASCHALL.REPLACEPARTOFSTRING lua": {
        "prefix": "ultraschall.ReplacePartOfString",
        "scope": "lua",
        "description": "replaces a part of a string with a second string\nReturns nil in case of an error\nPARAMETERS:\noriginalstring:the originalstring, in which you want to insert the string\ninsertstring:the string that shall be inserted\noffset:the position, at which to insert the string; it is the position BEFORE the position at which to insert, so if you want to replace the 25th character, offset is 24!\nlength:the length of the part of the originalstring that shall be replaced, counted from offset. 0 or nil for simple insertion.\nRETURNS:\nreplaced_string:the altered string\n",
        "body": "ultraschall.ReplacePartOfString(${1:string originalstring},${2:string insertstring},${3:integer offset},${4:optional integer length})$0"
    },
    "ULTRASCHALL.SEARCHSTRINGINSTRING lua": {
        "prefix": "ultraschall.SearchStringInString",
        "scope": "lua",
        "description": "Searches for the string searchstring in fullstring.\nKeep in mind: Umlauts may produce multibyte-values. Therefore, the returned offsets might be confusing.\nreturns -1 in case of error, 0 if string wasn't found\nPARAMETERS:\nfullstring:the string to be searched through\nsearchstring:the string to search for within fullstring\nRETURNS:\ncount:the number of found occurences of searchstring in fullstring\nposarray:an array that contains the positions, where searchstring was found within fullstring\n",
        "body": "ultraschall.SearchStringInString(${1:string fullstring},${2:string searchstring})$0"
    },
    "ULTRASCHALL.MKVOL2DB lua": {
        "prefix": "ultraschall.MKVOL2DB",
        "scope": "lua",
        "description": "Converts an MKVOL-value into a dB-value.\nMKVOL-values are used by the routing-functions for HWOut/AUXSendReceive, specifically for their volume-value as these can't be converted using Reaper's own DB2SLIDER or SLIDER2DB, so this function should help you.\nThis function is an adapted one from the function provided in Plugins/reaper\\_www\\_root/main.js\nSee DB2MKVOL to convert a dB-value into it's MKVOL-representation\nreturns nil in case of an error\nPARAMETERS:\nmkvol_value:the mkvol_value, that you want to convert into dB\nRETURNS:\ndb_value:the dB-value, converted from the MKVOL-value; minimum -144dB\n",
        "body": "ultraschall.MKVOL2DB(${1:number mkvol_value})$0"
    },
    "ULTRASCHALL.DB2MKVOL lua": {
        "prefix": "ultraschall.DB2MKVOL",
        "scope": "lua",
        "description": "Converts an dB-value into a MKVOL-value.\nMKVOL-values are used by the routing-functions for HWOut/AUXSendReceive, specifically for their volume-value as these can't be converted using Reaper's own DB2SLIDER or SLIDER2DB, so this function should help you.\nSee MKVOL2DB to convert a MKVOL-value into it's dB-representation\nreturns nil in case of an error\nPARAMETERS:\ndb_value:the dB-value, that you want to convert into the MKVOL-value; minimum is -144dB\nRETURNS:\nmkvol_value:the mkvol-value, converted from the dB-value\n",
        "body": "ultraschall.DB2MKVOL(${1:number db_value})$0"
    },
    "ULTRASCHALL.CONVERTINTEGERINTOSTRING2 lua": {
        "prefix": "ultraschall.ConvertIntegerIntoString2",
        "scope": "lua",
        "description": "Splits numerous integers into its individual bytes and converts them into a string-representation.\nMaximum 32bit-integers are supported.\nReturns nil in case of an error.\nPARAMETERS:\nSize:the maximum size of the integer to convert, 1(8 bit) to 4(32 bit)\nintegervalue_1:the first integer value to convert from\n:the last integer value to convert from\nintegervalue_n:the last integer value to convert from\nRETURNS:\nconverted_value:the string-representation of the integer\n",
        "body": "ultraschall.ConvertIntegerIntoString2(${1:integer Size},${2:integer integervalue_1},${3:...},${4:integer integervalue_n})$0"
    },
    "ULTRASCHALL.CONVERTSTRINGTOINTEGERS lua": {
        "prefix": "ultraschall.ConvertStringToIntegers",
        "scope": "lua",
        "description": "Converts a string into its integer-representation. Allows you to set the size of the integers between 1 Byte and 8 Bytes(64 bits).\nReturns -1 in case of an error.\nPARAMETERS:\nString:the string to convert into its integer representation\nSize:the size of the integers. 1 for 8 bits, 2 for 16 bits, ..., 8 for 64 bits\nRETURNS:\nnum_integers:the number of integers converted from this string\nindividual_integers:the individual integers, as converted from the original string\n",
        "body": "ultraschall.ConvertStringToIntegers(${1:string String},${2:integer Size})$0"
    },
    "ULTRASCHALL.SETSCRIPTIDENTIFIER_DESCRIPTION lua": {
        "prefix": "ultraschall.SetScriptIdentifier_Description",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can set its description, that is less cryptic than the ScriptIdentifier itself.\nYou can get it using GetScriptIdentifier_Description.\nreturns -1 in case of an error\nPARAMETERS:\ndescription:the new description of your script\nRETURNS:\nretval:-1 in case of an error\n",
        "body": "ultraschall.SetScriptIdentifier_Description(${1:string description})$0"
    },
    "ULTRASCHALL.GETSCRIPTIDENTIFIER_DESCRIPTION lua": {
        "prefix": "ultraschall.GetScriptIdentifier_Description",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can get its description, that is less cryptic than the ScriptIdentifier itself.\nYou can set it using SetScriptIdentifier_Description.\nRETURNS:\nscript_identifier_description:the description of your script\n",
        "body": "ultraschall.GetScriptIdentifier_Description()$0"
    },
    "ULTRASCHALL.SETSCRIPTIDENTIFIER_TITLE lua": {
        "prefix": "ultraschall.SetScriptIdentifier_Title",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can set its title, that is less cryptic than the ScriptIdentifier itself.\nNo \\n-newlines, \\r-carriag returns or \\0-nullbytes are allowed and will be removed\nYou can get it using GetScriptIdentifier_Title.\nreturns -1 in case of an error\nPARAMETERS:\ntitle:the new title of your script\nRETURNS:\nretval:-1 in case of an error\n",
        "body": "ultraschall.SetScriptIdentifier_Title(${1:string title})$0"
    },
    "ULTRASCHALL.GETSCRIPTIDENTIFIER_TITLE lua": {
        "prefix": "ultraschall.GetScriptIdentifier_Title",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can get its description, that is less cryptic than the ScriptIdentifier itself.\nDefault is the script's filename.\nYou can set it using SetScriptIdentifier_Title.\nRETURNS:\nscript_identifier_title:the title of your script; default is the filename of the script\n",
        "body": "ultraschall.GetScriptIdentifier_Title()$0"
    },
    "ULTRASCHALL.RESETPROGRESSBAR lua": {
        "prefix": "ultraschall.ResetProgressBar",
        "scope": "lua",
        "description": "Resets the initial-values of the progressbar. Should be called, if you want to start a new progressbar after you filled up the former one, or you may have update-issues.\n",
        "body": "ultraschall.ResetProgressBar()$0"
    },
    "ULTRASCHALL.PRINTPROGRESSBAR lua": {
        "prefix": "ultraschall.PrintProgressBar",
        "scope": "lua",
        "description": "Calculate a simple progressbar, which can be optionally displayed in the ReaScript console; Will clear the console before displaying the next updated progressbar.\nWill update it only, if the current-value of last time this function got called is different from the current one or toptext or bottomtext changed.\nYou can also use the returnvalues to draw your own progressbar, e.g. in a gfx.init-window\nIf you need to calculate a new progressbar, after the former got to 100%, it is wise to call ResetProgressBar, or it might not update the first time you call this function.\nReturns false in case of an error\nPARAMETERS:\nshow:true, show progressbar in the ReaScript-console; false, don't show it there\nlength:the length of the progressbar in characters. Minimum is 10.\nmaximumvalue:the maximum integer-value, to which to count; minimum 1\ncurrentvalue:the current integer-value, at which we are with counting, minimum 0\npercentage:true, show percentage in progressbar; false, show only progressbar\noffset:an offset to be added before the progressbar, so you can indent it\ntoptext:an optional string, that shall be displayed above the progressbar\nbottomtext:an optional string, that shall be displayed below the progressbar\nRETURNS:\nretval:true, displaying was successful; false, displaying wasn't successful\nProgressString:the progressbar including its full statuses and layout\npercentage:the progression of the progressbar in percent\nprogress_position:the current progress-position, relative to length and maximumvalue\n",
        "body": "ultraschall.PrintProgressBar(${1:boolean show},${2:integer length},${3:integer maximumvalue},${4:integer currentvalue},${5:boolean percentage},${6:integer offset},${7:optional string toptext},${8:optional string bottomtext})$0"
    },
    "ULTRASCHALL.STOREFUNCTIONINEXTSTATE lua": {
        "prefix": "ultraschall.StoreFunctionInExtState",
        "scope": "lua",
        "description": "Stores a function into an extstate. You can store it's debug-information as well.\nTo load the function again, use LoadFunctionFromExtState\nReturns false in case of an error\nPARAMETERS:\nsection:the sectionname of the extstate\nkey:the keyname of the extstate\nfunc:the function, that you want to store\ndebug:true, store debug-values as well; false, don't store the debug-values as well\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.StoreFunctionInExtState(${1:string section},${2:string key},${3:function func},${4:boolean debug})$0"
    },
    "ULTRASCHALL.LOADFUNCTIONFROMEXTSTATE lua": {
        "prefix": "ultraschall.LoadFunctionFromExtState",
        "scope": "lua",
        "description": "Loads a function from an extstate, if it has been stored in there before.\nThe extstate must contain a valid function. If something else is stored, the loaded \"function\" might crash Lua!\nTo store the function, use StoreFunctionInExtState\nReturns false in case of an error\nPARAMETERS:\nsection:the sectionname of the extstate\nkey:the keyname of the extstate\nRETURNS:\nfunction:the stored function, that you want to (re-)load\n",
        "body": "ultraschall.LoadFunctionFromExtState(${1:string section},${2:string key})$0"
    },
    "ULTRASCHALL.CONVERTHEX2ASCII lua": {
        "prefix": "ultraschall.ConvertHex2Ascii",
        "scope": "lua",
        "description": "converts a hexstring into an ascii-string.\nWill combine two hexvalues into one byte, until the whole string is converted.\nSee ConvertAscii2Hex to convert a string into its HEX-representation.\nReturns nil in case of an error\nPARAMETERS:\nhexstring:the original string with only hexadecimal numbers \nRETURNS:\nascii_string:the converted string\n",
        "body": "ultraschall.ConvertHex2Ascii(${1:string hexstring})$0"
    },
    "ULTRASCHALL.CONVERTASCII2HEX lua": {
        "prefix": "ultraschall.ConvertAscii2Hex",
        "scope": "lua",
        "description": "converts an ascii-string into a hexstring.\nSee ConvertHex2Ascii to convert a HEX-string into its normal string-representation.\nReturns nil in case of an error\nPARAMETERS:\nascii_string:the converted string\nRETURNS:\nhexstring:the original string with only hexadecimal numbers \n",
        "body": "ultraschall.ConvertAscii2Hex(${1:string ascii_string})$0"
    },
    "ULTRASCHALL.GETALLACTIONS lua": {
        "prefix": "ultraschall.GetAllActions",
        "scope": "lua",
        "description": "Returns all actions and accompanying attributes from a specific section as a handy table\nThe table is of the following format:\nactiontable[index][\"commandid\"]       - the command-id-number of the action\nactiontable[index][\"actioncommandid\"] - the action-command-id-string of the action, if it's a named command(usually scripts or extensions), otherwise empty string\nactiontable[index][\"name\"]            - the name of command\nactiontable[index][\"scriptfilename\"]  - the filename+path of a command, that is a ReaScript, otherwise empty string\nactiontable[index][\"termination\"]     - the termination-state of the action\n-1  - not available\n4   - Dialogwindow appears(Terminate, New Instance, Abort), if another instance of a given script is started, that's already running\n260 - always Terminate All(!) Instances, if you try to run another instance of a script, that's already running. When no instance is running, it simply starts the script.\n516 - always start a New Instance of the script, that's already running\nactiontable[index][\"consolidate\"]     - the consolidate-state of custom actions; 1 consolidate undo points, 2 show in Actions-Menu, 3 consolidate undo points AND show in Actions Menu; -1, if not available\nactiontable[index][\"actiontype\"]      - the type of the action; \"native action\", \"extension action\", \"custom action\", \"script\"\nreturns -1 in case of an error.\nPARAMETERS:\nsection:the section, whose actions you want to retrieve\nRETURNS:\nnumber_of_actions:the number of actions found; -1 in case of an error\nactiontable:a table, which holds all attributes of an action(see description for more details)\n",
        "body": "ultraschall.GetAllActions(${1:integer section})$0"
    },
    "ULTRASCHALL.ISWITHINTIMERANGE lua": {
        "prefix": "ultraschall.IsWithinTimeRange",
        "scope": "lua",
        "description": "returns if time is between(including) start and stop.\nreturns false in case of an error\nPARAMETERS:\ntime:the time in seconds, to check for\nstart:the starttime in seconds, within to check for\nstop:the endtime in seconds, within to check for\nRETURNS:\nretval:true, time is between start and stop; false, it isn't\n",
        "body": "ultraschall.IsWithinTimeRange(${1:number time},${2:number start},${3:number stop})$0"
    },
    "ULTRASCHALL.MEDIAEXPLORER_ONCOMMAND lua": {
        "prefix": "ultraschall.MediaExplorer_OnCommand",
        "scope": "lua",
        "description": "runs a Media Explorer-associated action.\nNote: Can only run Reaper's native actions currently(all actions having a number as actioncommandid), not scripts!\nreturns false if Media Explorer is closed\nRETURNS:\nretval:true, could update run the action in the Media Explorer; false, couldn't run it\n",
        "body": "ultraschall.MediaExplorer_OnCommand(${1:integer actioncommandid})$0"
    },
    "ULTRASCHALL.UPDATEMEDIAEXPLORER lua": {
        "prefix": "ultraschall.UpdateMediaExplorer",
        "scope": "lua",
        "description": "updates the listview of the Media Explorer.\nreturns false if Media Explorer is closed\nRETURNS:\nretval:true, could update the listview of the Media Explorer; false, couldn't update the listview\n",
        "body": "ultraschall.UpdateMediaExplorer()$0"
    },
    "ULTRASCHALL.FINDPATTERNSINSTRING lua": {
        "prefix": "ultraschall.FindPatternsInString",
        "scope": "lua",
        "description": "Finds all occurrences of matching-patterns in a string. You can sort them optionally.\nreturns -1 in case of an error\nPARAMETERS:\nSourceString:the source-string to search for all occurences\npattern:the matching-pattern, with which to search for in the string\nsort_after_finding:true, sorts the entries; false, doesn't sort the entries\nRETURNS:\ncount_found_items:the number of found items in the string; -1, in case of an error\nfound_items:all occurrences found in the string as an array\n",
        "body": "ultraschall.FindPatternsInString(${1:string SourceString},${2:string pattern},${3:boolean sort_after_finding})$0"
    },
    "ULTRASCHALL.RUNLUASOURCECODE lua": {
        "prefix": "ultraschall.RunLuaSourceCode",
        "scope": "lua",
        "description": "runs the Lua-code stored in the parameter code\nDoes not check for validity and syntaxerrors in the code!\nYou can also add new callable functions that way. Just put function-declarations in the parameter code.\nFor instance from the following code:\ncode=function main()\nreaper.MB(\"I'm only run, when my parent function main is called\", \"\", 0)\nend\nreaper.MB(\"I'm run immediately\", \"\", 0)\"\nwhen called by\nultraschall.RunLuaSourceCode(code)\nonly the line reaper.MB(\"I'm run immediately\", \"\", 0) will be run immediately.\nIf you want to run the function main as well, you need to explicitly call it with main()\nreturns false in case of an error; nil, in case of an syntax/lua-error in the code itself\nPARAMETERS:\ncode:the code, that you want to execute; you can also add new functions that way\nRETURNS:\nretval:true, code was run successfully; false, code wasn't successfully; nil, code had an error in it, probably syntax error\n",
        "body": "ultraschall.RunLuaSourceCode(${1:string code})$0"
    },
    "ULTRASCHALL.MAIN_ONCOMMAND_LUACODE lua": {
        "prefix": "ultraschall.Main_OnCommand_LuaCode",
        "scope": "lua",
        "description": "Runs LuaCode as new temporary script-instance. It internally registers the code as a file temporarily as command, runs it and unregisters it again.\nThis is especially helpful, when you want to run a command for sure without possible command-id-number-problems.\nIt returns a unique script-identifier for this script, which can be used to communicate with this script-instance.\nThe started script gets its script-identifier using GetScriptIdentifier.\nYou can use this script-identifier e.g. as extstate.\nReturns false in case of an error\nPARAMETERS:\nCode:the Lua-code, which shall be run; will not be checked vor validity!\n...:parameters that shall be passed over to the script\nRETURNS:\nretval:true, if running it was successful; false, if not\nscript_identifier:a unique script-identifier, which can be used as extstate to communicate with the started code\n",
        "body": "ultraschall.Main_OnCommand_LuaCode(${1:string Code},${2:string ...})$0"
    },
    "ULTRASCHALL.REPLACEPATTERNINSTRING lua": {
        "prefix": "ultraschall.ReplacePatternInString",
        "scope": "lua",
        "description": "Replaces the index'th occurrence of pattern in OriginalString with replacepattern.\nUnlike string.gsub, this replaces only the selected pattern!\nreturns nil, false in case of an error\nPARAMETERS:\nOriginalString:the string, from which you want to replace a specific occurence of a matching pattern\npattern:the pattern to look for\nreplacestring:the string, which shall replace the found pattern\nindex:the number of found occurence of the pattern in the string, which shall be replaced\nRETURNS:\naltered_string:the altered string, where the n'th occurence of the pattern has been replaced\nreplaced:true, there has been a replacement; false, no replacement has happened\n",
        "body": "ultraschall.ReplacePatternInString(${1:string OriginalString},${2:string pattern},${3:string replacestring},${4:integer index})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_TOBASE64STRING lua": {
        "prefix": "ultraschall.ConvertFunction_ToBase64String",
        "scope": "lua",
        "description": "Converts a function into a BASE64-string.\nTo load a function from a BASE64-string, use ConvertFunction_FromBase64String\nReturns nil in case of an error\nPARAMETERS:\nto_convert_function:the function, that you want to convert\ndebug:true, store debug-information as well; false, only store function\nRETURNS:\nBASE64_functionstring:the function, stored as BASE64-string\n",
        "body": "ultraschall.ConvertFunction_ToBase64String(${1:function to_convert_function},${2:boolean debug})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_FROMBASE64STRING lua": {
        "prefix": "ultraschall.ConvertFunction_FromBase64String",
        "scope": "lua",
        "description": "Loads a function from a BASE64-string.\nTo convert a function into a BASE64-string, use ConvertFunction_ToBase64String\nReturns nil in case of an error\nPARAMETERS:\nBASE64_functionstring:the function, stored as BASE64-string\nRETURNS:\nfunction:the loaded function\n",
        "body": "ultraschall.ConvertFunction_FromBase64String(${1:string BASE64_functionstring})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_TOHEXSTRING lua": {
        "prefix": "ultraschall.ConvertFunction_ToHexString",
        "scope": "lua",
        "description": "Converts a function into a HEX-string.\nTo load a function from a HEX-string, use ConvertFunction_FromHexString\nReturns nil in case of an error\nPARAMETERS:\nto_convert_function:the function, that you want to convert\ndebug:true, store debug-information as well; false, only store function\nRETURNS:\nHEX_functionstring:the function, stored as HEX-string\n",
        "body": "ultraschall.ConvertFunction_ToHexString(${1:function to_convert_function},${2:boolean debug})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_FROMHEXSTRING lua": {
        "prefix": "ultraschall.ConvertFunction_FromHexString",
        "scope": "lua",
        "description": "Loads a function from a HEX-string.\nTo convert a function into a HEX-string, use ConvertFunction_ToHexString\nReturns nil in case of an error\nPARAMETERS:\nHEX_functionstring:the function, stored as HEX-string\nRETURNS:\nfunction:the loaded function\n",
        "body": "ultraschall.ConvertFunction_FromHexString(${1:string HEX_functionstring})$0"
    },
    "ULTRASCHALL.BENCHMARK_GETSTARTTIME lua": {
        "prefix": "ultraschall.Benchmark_GetStartTime",
        "scope": "lua",
        "description": "This function is for benchmarking parts of your code.\nIt returns the starttime of the last benchmark-start.\nreturns nil, if no benchmark has been made yet.\nUse Benchmark_MeasureTime to start/reset a new benchmark-measureing.\nRETURNS:\nstarttime:the starttime of the currently running benchmark\n",
        "body": "ultraschall.Benchmark_GetStartTime()$0"
    },
    "ULTRASCHALL.BENCHMARK_MEASURETIME lua": {
        "prefix": "ultraschall.Benchmark_MeasureTime",
        "scope": "lua",
        "description": "This function is for benchmarking parts of your code.\nIt returns the passed time, since last time calling this function.\nUse Benchmark_GetStartTime to start the benchmark.\nPARAMETERS:\ntime_mode:the formatting of elapsed_time_string\nreset:true, resets the starttime(for new measuring); false, keeps current measure-starttime(for continuing measuring)\nRETURNS:\nelapsed_time:the elapsed time, formatted by parameter time_mode\nelapsed_time_string:the elapsed time, formatted by parameter time_mode\nmeasure_evaluation:an evaluation of time, mostly starting with < or > an a number of +\n",
        "body": "ultraschall.Benchmark_MeasureTime(${1:optional integer time_mode},${2:optional boolean reset})$0"
    },
    "ULTRASCHALL.RESIZEPNG lua": {
        "prefix": "ultraschall.ResizePNG",
        "scope": "lua",
        "description": "resizes a png-file. It will stretch/shrink the picture by that. That means you can't crop or enhance pngs with this function.\nIf you set aspectratio=true, then the image will be resized with correct aspect-ratio. However, it will use the value from parameter width as maximum size for each side of the picture.\nSo if the height of the png is bigger than the width, the height will get the size and width will be shrinked accordingly.\nWhen making pngs bigger, pixelation will occur. No pixel-filtering within this function!\nreturns false in case of an error\nPARAMETERS:\nfilename_with_path:the output-file, where to store the resized png\noutputfilename_with_path:the output-file, where to store the resized png\naspectratio:true, keep aspect-ratio(use size of param width as base); false, don't keep aspect-ratio\nwidth:the width of the newly created png in pixels\nheight:the height of the newly created png in pixels\n",
        "body": "ultraschall.ResizePNG(${1:string filename_with_path},${2:string outputfilename_with_path},${3:boolean aspectratio},${4:integer width},${5:integer height})$0"
    },
    "ULTRASCHALL.CAPTURESCREENAREAASPNG lua": {
        "prefix": "ultraschall.CaptureScreenAreaAsPNG",
        "scope": "lua",
        "description": "captures an area of the screen and writes it as png-file.\nNote for Mac-users: it doesn't seem to work under certain circumstances, which are still under investigation.\nreturns false in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the png-file to write\nx:the x-position of the area to capture\ny:the y-position of the area to capture\nw:the width of the area to capture\nh:the height of the area to capture\nRETURNS:\nretval:true, capturing was successful; false, capturing was unsuccessful\n",
        "body": "ultraschall.CaptureScreenAreaAsPNG(${1:string filename_with_path},${2:integer x},${3:integer y},${4:integer w},${5:integer h})$0"
    },
    "ULTRASCHALL.CAPTUREWINDOWASPNG lua": {
        "prefix": "ultraschall.CaptureWindowAsPNG",
        "scope": "lua",
        "description": "captures a window and stores it as png-file.\nNote for Windows-users with no Windows 10:\nKeep in mind, that even if you choose a dedicated window, if it's located behind other windows, these might be captured as well.\nNote for Mac-users: it doesn't seem to work under certain circumstances, which are still under investigation.\nreturns false in case of an error\nPARAMETERS:\nwindow_or_windowtitle:either a hwnd or the exact windowtitle of the window, which you want to capture\nfilename_with_path:the filename with path of the output-file\nx:the x-position within the window to capture; nil, to use the left side of the window\ny:the y-position within the window to capture; nil, to use the top side of the window\nw:true, use the workaround for invisible window-borders on windows 10; false, just capture the window\nh:the height of the capture-area; nil, to use the height of the window\nwin10:true, use the workaround for invisible window-borders on windows 10; false, just capture the window\nRETURNS:\nretval:true, capturing was successful; false, capturing was unsuccessful\n",
        "body": "ultraschall.CaptureWindowAsPNG(${1:identifier window_or_windowtitle},${2:string filename_with_path},${3:integer x},${4:integer y},${5:integer w},${6:integer h},${7:boolean win10})$0"
    },
    "ULTRASCHALL.LOCALIZE lua": {
        "prefix": "ultraschall.Localize",
        "scope": "lua",
        "description": "Translates the string original_string into its translated version, as stored in a translation-file.\nTo set a translationfile, see Localize_UseFile.\nIf the string contains %s, the optional parameters \"...\" will replace them. The order of the parameters is the order of the replacement of the %s in the string.\nIf no translation is available, it returns the original string. In that case, %s in the string could be replaced by optional parameters ...\nThis function can be used with or without ultraschall. at the beginning, for your convenience.\nsee [specs for more information](../misc/ultraschall_translation_file_format.USLangPack).\nreturns nil in case of an error\nPARAMETERS:\noriginal_string:the original string, that you want to translate\n:optional parameters, who will be used to substitute %s in the returned string; order of the optional parameters reflects order of %s in the string\nRETURNS:\ntranslated_string:the translated string; will be the original_string(with optional substitution), if translation is not possible\nretval:true, translation-was successful; false, translation wasn't successful\n",
        "body": "ultraschall.Localize(${1:string original_string},${2:...})$0"
    },
    "ULTRASCHALL.LOCALIZE_REFRESHFILE lua": {
        "prefix": "ultraschall.Localize_RefreshFile",
        "scope": "lua",
        "description": "Reloads the translation-file, that has been set using Localize_UseFile.\nsee [specs for more information](../misc/ultraschall_translation_file_format.USLangPack).\nRETURNS:\nretval:true, translation-file has been found and set successfully; false, translation-file hasn't been found\n",
        "body": "ultraschall.Localize_RefreshFile()$0"
    },
    "ULTRASCHALL.ADDNORMALMARKER lua": {
        "prefix": "ultraschall.AddNormalMarker",
        "scope": "lua",
        "description": "Adds a normal marker. Returns the index of the marker as marker_number.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nposition:position in seconds.\nshown_number:the number, that will be shown within Reaper. Can be multiple times. Use -1 to let Reaper decide the number.\nmarkertitle:the title of the marker.\nRETURNS:\nmarker_number:the overall-marker-index, can be used for reaper's own marker-management functions\nguid:the guid, associated with this marker\n",
        "body": "ultraschall.AddNormalMarker(${1:number position},${2:integer shown_number},${3:string markertitle})$0"
    },
    "ULTRASCHALL.ADDPODRANGEREGION lua": {
        "prefix": "ultraschall.AddPodRangeRegion",
        "scope": "lua",
        "description": "Adds a region, which shows the time-range from the beginning to the end of the podcast.\nreturns -1 in case of an error\nPARAMETERS:\nstartposition:begin of the podcast in seconds\nendposition:end of the podcast in seconds\nRETURNS:\nmarker_number:the overall-marker-index, can be used for reaper's own marker-management functions\nguid:the guid of the PodRangeRegion\n",
        "body": "ultraschall.AddPodRangeRegion(${1:number startposition},${2:number endposition})$0"
    },
    "ULTRASCHALL.GETMARKERBYNAME lua": {
        "prefix": "ultraschall.GetMarkerByName",
        "scope": "lua",
        "description": "Get all markers/regions that have a certain name. This function is not case-sensitive.\nreturns -1 in case of an error\nPARAMETERS:\nsearchname:the name to look for; must be exact; not case-sensitive\nsearchisrgn:true, search only within regions; false, search only within markers\nRETURNS:\ncount_markers:the number of found markers/regions\nfoundmarkers:an array with all marker/region-numbers of the found markers; counts only regions or markers(depending on parameter searchisrgn); markernumbers are 0-based\nfound_guids:the guids of all markers/regions found\n",
        "body": "ultraschall.GetMarkerByName(${1:string searchname},${2:boolean searchisrgn})$0"
    },
    "ULTRASCHALL.GETMARKERBYNAME_PATTERN lua": {
        "prefix": "ultraschall.GetMarkerByName_Pattern",
        "scope": "lua",
        "description": "Get all markers/regions that have a certain character-sequence in their name. This function is not case-sensitive.\nreturns -1 in case of an error\nPARAMETERS:\nsearchname:the name to look for; a character-sequence that shall be part of the name; not case-sensitive\nsearchisrgn:true, search only within regions; false, search only within markers\nRETURNS:\ncount_markers:the number of found markers/regions\nfoundmarkers:an array with all marker/region-numbers of the found markers; counts only regions or markers(depending on parameter searchisrgn)\nfoundguids:the guids of all found markers/regions\n",
        "body": "ultraschall.GetMarkerByName_Pattern(${1:string searchname},${2:boolean searchisrgn})$0"
    },
    "ULTRASCHALL.GETMARKERANDREGIONSBYINDEX lua": {
        "prefix": "ultraschall.GetMarkerAndRegionsByIndex",
        "scope": "lua",
        "description": "Returns the values of a certain marker/region. The numbering of idx is either only for the markers or for regions, depending on what you set with parameter searchisrgn.\nreturns nil in case of an error\nPARAMETERS:\nidx:the number of the requested marker/region; counts only within either markers or regions, depending on what you've set searchisrgn to; 1-based!\nsearchisrgn:true, search only within regions; false, search only within markers\nRETURNS:\nname:the name of the marker/region\ncolor:the color-value of the marker/region\npos:the position of the marker/region\nrgnend:the end of the region\nguid:the guid of the marker/region; if it's a marker, the retval rgnend will be nil!\n",
        "body": "ultraschall.GetMarkerAndRegionsByIndex(${1:integer idx},${2:boolean searchisrgn})$0"
    },
    "ULTRASCHALL.SETMARKERBYINDEX lua": {
        "prefix": "ultraschall.SetMarkerByIndex",
        "scope": "lua",
        "description": "Sets the values of a certain marker/region. The numbering of idx is either only for the markers or for regions, depending on what you set with parameter searchisrgn.\nreturns false in case of an error\nPARAMETERS:\nidx:the number of the requested marker/region; counts only within either markers or regions, depending on what you've set searchisrgn to\nsearchisrgn:true, search only within regions; false, search only within markers\nshown_number:the shown-number of the region/marker; no duplicate numbers for regions allowed; nil to keep previous shown_number\nposition:the end of the region in seconds; nil to keep previous region-end\nrgnend:the end of the region in seconds; nil to keep previous region-end\nname:the name of the marker/region; nil to keep the previous name\ncolor:color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000; nil to keep the previous color\nflags:flags&1 to clear name; 0, keep it; nil to use the previous setting\nRETURNS:\nretval:true, setting the marker/region was successful; false, setting of the marker/region was unsuccessful.\n",
        "body": "ultraschall.SetMarkerByIndex(${1:integer idx},${2:boolean searchisrgn},${3:integer shown_number},${4:number position},${5:position rgnend},${6:string name},${7:integer color},${8:integer flags})$0"
    },
    "ULTRASCHALL.ADDEDITMARKER lua": {
        "prefix": "ultraschall.AddEditMarker",
        "scope": "lua",
        "description": "Adds an Edit marker. Returns the index of the marker as marker_number.\nreturns -1 in case of an error\nPARAMETERS:\nposition:position in seconds.\nshown_number:the number, that will be shown within Reaper. Can be multiple times. Use -1 to let Reaper decide the number.\nedittitle:the title of the edit-marker; will be shown as _Edit:edittitle\nRETURNS:\nmarker_number:the overall-marker-index, can be used for reaper's own marker-management functions\nguid:the guid, associated with this marker\n",
        "body": "ultraschall.AddEditMarker(${1:number position},${2:integer shown_number},${3:string edittitle})$0"
    },
    "ULTRASCHALL.COUNTNORMALMARKERS lua": {
        "prefix": "ultraschall.CountNormalMarkers",
        "scope": "lua",
        "description": "Counts all normal markers.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nRETURNS:\nnumber_of_markers:number of normal markers\n",
        "body": "ultraschall.CountNormalMarkers()$0"
    },
    "ULTRASCHALL.COUNTEDITMARKERS lua": {
        "prefix": "ultraschall.CountEditMarkers",
        "scope": "lua",
        "description": "Counts all edit-markers.\nRETURNS:\nnumber_of_edit_markers:number of edit markers\n",
        "body": "ultraschall.CountEditMarkers()$0"
    },
    "ULTRASCHALL.GETPODRANGEREGION lua": {
        "prefix": "ultraschall.GetPodRangeRegion",
        "scope": "lua",
        "description": "Gets the start_position and the end_position of the PodRangeRegion.\nreturns -1 if no PodRangeRegion exists\nRETURNS:\nstart_position:beginning of the podrangeregion, that marks the beginning of the podcast\nend_position:end of the podrangeregion, that marks the end of the podcast\nguid:the guid associated with this marker\n",
        "body": "ultraschall.GetPodRangeRegion()$0"
    },
    "ULTRASCHALL.ENUMERATENORMALMARKERS lua": {
        "prefix": "ultraschall.EnumerateNormalMarkers",
        "scope": "lua",
        "description": "Get the data of a normal marker.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nReturns -1 in case of error\nPARAMETERS:\nnumber:number of the marker(normal markers only). Refer ultraschall.CountNormalMarkers for getting the number of normal markers.\nRETURNS:\nretnumber:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nretidxnum:indexnumber of the marker\nposition:the position of the marker\nmarkertitle:the name of the marker\nguid:the guid of the enumerated marker\n",
        "body": "ultraschall.EnumerateNormalMarkers(${1:integer number})$0"
    },
    "ULTRASCHALL.ENUMERATEEDITMARKERS lua": {
        "prefix": "ultraschall.EnumerateEditMarkers",
        "scope": "lua",
        "description": "Gets the data of an edit marker.\nreturns -1 in case of an error\nPARAMETERS:\nedit_index:number of the edit-marker. Refer ultraschall.CountEditMarkers for getting the number of edit-markers.\nRETURNS:\nretnumber:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nshown_number:indexnumber of the marker\nposition:the position of the marker\nedittitle:the name of the marker\nguid:the guid of the editmarker\n",
        "body": "ultraschall.EnumerateEditMarkers(${1:integer edit_index})$0"
    },
    "ULTRASCHALL.GETALLEDITMARKERS lua": {
        "prefix": "ultraschall.GetAllEditMarkers",
        "scope": "lua",
        "description": "returns the number of editmarkers and an array with each editmarker in the format:\neditmarkersarray[index][0] - position\neditmarkersarray[index][1] - name\neditmarkersarray[index][2] - idx\neditmarkersarray[index][3] - guid\nRETURNS:\nnumber_of_editmarkers:the number of editmarkers returned\neditmarkersarray:an array with all the edit-markers of the project\n",
        "body": "ultraschall.GetAllEditMarkers()$0"
    },
    "ULTRASCHALL.GETALLNORMALMARKERS lua": {
        "prefix": "ultraschall.GetAllNormalMarkers",
        "scope": "lua",
        "description": "returns the number of normalmarkers and an array with each normalmarker in the format:\nnormalmarkersarray[index][0] - position\nnormalmarkersarray[index][1] - name\nnormalmarkersarray[index][2] - idx of the marker within all markers in project\nnormalmarkersarray[index][3] - the shown index number of the marker\nnormalmarkersarray[index][4] - the guid of the marker\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nRETURNS:\nnumber_of_normalmarkers:the number of normalmarkers returned\nnormalmarkersarray:an array, that holds all normal markers of the project\n",
        "body": "ultraschall.GetAllNormalMarkers()$0"
    },
    "ULTRASCHALL.GETALLMARKERS lua": {
        "prefix": "ultraschall.GetAllMarkers",
        "scope": "lua",
        "description": "To get all Markers in the project(normal, edit, chapter), regardless of their category.\nDoesn't return regions!\nreturns the number of markers and an array with each marker in the format:\nmarkersarray[index][0] - position\nmarkersarray[index][1] - name\nmarkersarray[index][2] - indexnumber of the marker within all markers in the project\nmarkersarray[index][3] - the shown index-number\nmarkersarray[index][4] - the color of the marker\nmarkersarray[index][5] - the guid of the marker\nRETURNS:\nallmarkersarray:an array, that holds all markers(not regions!) of the project\n",
        "body": "ultraschall.GetAllMarkers()$0"
    },
    "ULTRASCHALL.SETNORMALMARKER lua": {
        "prefix": "ultraschall.SetNormalMarker",
        "scope": "lua",
        "description": "Sets values of a normal Marker(no _Chapter:, _Shownote:, etc). Returns true if successful and false if not(i.e. marker doesn't exist)\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns false in case of an error\nPARAMETERS:\nnumber:the number of the marker\nposition:position of the marker in seconds\nshown_number:the number of the marker\nmarkertitle:title of the marker\nRETURNS:\nretval:true if successful and false if not(i.e. marker doesn't exist)\n",
        "body": "ultraschall.SetNormalMarker(${1:integer number},${2:number position},${3:integer shown_number},${4:string markertitle})$0"
    },
    "ULTRASCHALL.SETEDITMARKER lua": {
        "prefix": "ultraschall.SetEditMarker",
        "scope": "lua",
        "description": "Sets values of an Edit Marker. Returns true if successful and false if not(i.e. marker doesn't exist)\nreturns false in case of an error\nPARAMETERS:\nedit_index:the number of the edit marker\nposition:position of the marker in seconds\nshown_number:the number of the marker\nRETURNS:\nretval:true if successful and false if not(i.e. marker doesn't exist)\n",
        "body": "ultraschall.SetEditMarker(${1:integer edit_index},${2:number position},${3:integer shown_number},${4:string edittitle})$0"
    },
    "ULTRASCHALL.DELETEPODRANGEREGION lua": {
        "prefix": "ultraschall.DeletePodRangeRegion",
        "scope": "lua",
        "description": "deletes the PodRange-Region.\nReturns false if unsuccessful\nRETURNS:\nretval:true, if deleting was successful; false, if not\n",
        "body": "ultraschall.DeletePodRangeRegion()$0"
    },
    "ULTRASCHALL.DELETENORMALMARKER lua": {
        "prefix": "ultraschall.DeleteNormalMarker",
        "scope": "lua",
        "description": "Deletes a Normal-Marker. Returns true if successful and false if not(i.e. marker doesn't exist) Use ultraschall.EnumerateNormalMarkers to get the correct number.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nnumber:number of a normal marker\nRETURNS:\nretval:true, if successful, false if not\n",
        "body": "ultraschall.DeleteNormalMarker(${1:integer number})$0"
    },
    "ULTRASCHALL.DELETEEDITMARKER lua": {
        "prefix": "ultraschall.DeleteEditMarker",
        "scope": "lua",
        "description": "Deletes an _Edit:-Marker. Returns true if successful and false if not(i.e. marker doesn't exist) Use ultraschall.EnumerateEditMarkers to get the correct number.\nPARAMETERS:\nedit_index:number of an edit marker\nRETURNS:\nretval:true, if successful, false if not\n",
        "body": "ultraschall.DeleteEditMarker(${1:integer edit_index})$0"
    },
    "ULTRASCHALL.EXPORTEDITMARKERSTOFILE lua": {
        "prefix": "ultraschall.ExportEditMarkersToFile",
        "scope": "lua",
        "description": "Export Edit-Markers (not regions!) to filename_with_path.\nEach line in the exportfile contains an entry for such an edit-marker in the format:\nhh:mm:ss.mss Title\nReturns -1 in case of error.\nPARAMETERS:\nfilename_with_path:the name of the export-file\nPodRangeStart:beginning of the podcast in seconds\nPodRangeEnd:end of the podcast in seconds\nRETURNS:\nretval:1 in case of success, -1 if it failed\n",
        "body": "ultraschall.ExportEditMarkersToFile(${1:string filename_with_path},${2:number PodRangeStart},${3:number PodRangeEnd})$0"
    },
    "ULTRASCHALL.EXPORTNORMALMARKERSTOFILE lua": {
        "prefix": "ultraschall.ExportNormalMarkersToFile",
        "scope": "lua",
        "description": "Export Normal-Markers to filename_with_path. Returns -1 in case of error.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nfilename_with_path:the name of the export-file\nPodRangeStart:beginning of the podcast in seconds\nPodRangeEnd:end of the podcast in seconds\nRETURNS:\nretval:1 in case of success, -1 if it failed\n",
        "body": "ultraschall.ExportNormalMarkersToFile(${1:string filename_with_path},${2:number PodRangeStart},${3:number PodRangeEnd})$0"
    },
    "ULTRASCHALL.IMPORTEDITFROMFILE lua": {
        "prefix": "ultraschall.ImportEditFromFile",
        "scope": "lua",
        "description": "Imports editentries from a file and returns an array of the imported values.\nreturns -1 in case of error\nPARAMETERS:\nfilename_with_path:markerfile to be imported\n:podcast-start-offset\n",
        "body": "ultraschall.ImportEditFromFile(${1:string filename_with_path},${2:PodRangestart})$0"
    },
    "ULTRASCHALL.IMPORTMARKERSFROMFILE lua": {
        "prefix": "ultraschall.ImportMarkersFromFile",
        "scope": "lua",
        "description": "Imports markerentries from a file and returns an array of the imported values.\nreturns -1 in case of error\nPARAMETERS:\nfilename_with_path:markerfile to be imported\n:podcast-start-offset\n",
        "body": "ultraschall.ImportMarkersFromFile(${1:string filename_with_path},${2:PodrangeStart})$0"
    },
    "ULTRASCHALL.MARKERTOEDITMARKER lua": {
        "prefix": "ultraschall.MarkerToEditMarker",
        "scope": "lua",
        "description": "Converts a normal-marker to an edit-marker.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nmarkerindex:number of the normal-marker. Refer ultraschall.CountNormalMarkers for getting the number of normal-markers.\nRETURNS:\nidx:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nshown_number:the shown number of the marker\nposition:the position of the marker in seconds\nmarkertitle:the markertitle\n",
        "body": "ultraschall.MarkerToEditMarker(${1:integer markerindex})$0"
    },
    "ULTRASCHALL.EDITTOMARKER lua": {
        "prefix": "ultraschall.EditToMarker",
        "scope": "lua",
        "description": "Converts an edit-marker to a normal marker.\nreturns -1 in case of an error\nPARAMETERS:\nedit_index:number of the edit-marker. Refer ultraschall.CountEditMarkers for getting the number of edit-markers.\nRETURNS:\nidx:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nshown_number:the shown number of the marker\nposition:the position of the marker in seconds\nmarkertitle:the markertitle\n",
        "body": "ultraschall.EditToMarker(${1:integer edit_index})$0"
    },
    "ULTRASCHALL.GETMARKERBYSCREENCOORDINATES lua": {
        "prefix": "ultraschall.GetMarkerByScreenCoordinates",
        "scope": "lua",
        "description": "returns the markers at a given absolute-x-pixel-position. It sees markers according their graphical representation in the arrange-view, not just their position! Returned string will be \"Markeridx\\npos\\nName\\nMarkeridx2\\npos2\\nName2\\n...\".\nWill return \"\", if no marker has been found.\nReturns only markers, no time markers or regions!\nreturns nil in case of an error\nPARAMETERS:\nxmouseposition:the absolute x-screen-position, like current mouse-position\nRETURNS:\nmarker:a string with all markernumbers, markerpositions and markertitles, separated by a newline. \n",
        "body": "ultraschall.GetMarkerByScreenCoordinates(${1:integer xmouseposition})$0"
    },
    "ULTRASCHALL.GETMARKERBYTIME lua": {
        "prefix": "ultraschall.GetMarkerByTime",
        "scope": "lua",
        "description": "returns the markers at a given project-position in seconds.\nIt sees markers according their actual graphical representation in the arrange-view, not just their position.\nIf, for example, you pass to it the current playposition, the function will return the marker as long as the playcursor is behind the marker-graphics.\nReturned string will be \"Markeridx\\npos\\nName\\nMarkeridx2\\npos2\\nName2\\n...\".\nWill return \"\", if no marker has been found.\nReturns only markers, no time markers or regions!\nreturns nil in case of an error\nPARAMETERS:\nposition:the time-position in seconds\n",
        "body": "ultraschall.GetMarkerByTime(${1:number position})$0"
    },
    "ULTRASCHALL.GETREGIONBYSCREENCOORDINATES lua": {
        "prefix": "ultraschall.GetRegionByScreenCoordinates",
        "scope": "lua",
        "description": "returns the regions at a given absolute-x-pixel-position. It sees regions according their graphical representation in the arrange-view, not just their position! Returned string will be \"Regionidx\\npos\\nName\\nRegionidx2\\npos2\\nName2\\n...\".\nReturns only regions, no time markers or other markers!\nWill return \"\", if no region has been found.\nreturns nil in case of an error\nPARAMETERS:\nxmouseposition:the absolute x-screen-position, like current mouse-position\n",
        "body": "ultraschall.GetRegionByScreenCoordinates(${1:integer xmouseposition})$0"
    },
    "ULTRASCHALL.GETREGIONBYTIME lua": {
        "prefix": "ultraschall.GetRegionByTime",
        "scope": "lua",
        "description": "returns the regions at a given absolute-x-pixel-position. It sees regions according their graphical representation in the arrange-view, not just their position! Returned string will be \"Regionidx\\npos\\nName\\nRegionidx2\\npos2\\nName2\\n...\".\nReturns only regions, no timesignature-markers or other markers!\nWill return \"\", if no region has been found.\nreturns nil in case of an error\nPARAMETERS:\nposition:position in seconds\n",
        "body": "ultraschall.GetRegionByTime(${1:number position})$0"
    },
    "ULTRASCHALL.GETTIMESIGNATURESBYSCREENCOORDINATES lua": {
        "prefix": "ultraschall.GetTimeSignaturesByScreenCoordinates",
        "scope": "lua",
        "description": "returns the time-signature/tempo-marker at a given absolute-x-pixel-position. It sees time-signature/tempo-markers according their graphical representation in the arrange-view, not just their position! Returned string will be \"tempomarkeridx\\npos\\ntempomarkeridx2\\npos2\\n...\".\nReturns only time-signature-markers, no regions or other markers!\nWill return \"\", if no timesig-marker has been found.\nreturns nil in case of an error\nPARAMETERS:\nxmouseposition:the absolute x-screen-position, like current mouse-position\n",
        "body": "ultraschall.GetTimeSignaturesByScreenCoordinates(${1:integer xmouseposition})$0"
    },
    "ULTRASCHALL.GETTIMESIGNATURESBYTIME lua": {
        "prefix": "ultraschall.GetTimeSignaturesByTime",
        "scope": "lua",
        "description": "returns the time-signature/tempo-marker at a given absolute-x-pixel-position. It sees time-signature/tempo-markers according their graphical representation in the arrange-view, not just their position! Returned string will be \"tempomarkeridx\\npos\\ntempomarkeridx2\\npos2\\n...\".\nReturns only time-signature-markers, no other markers or regions!\nWill return \"\", if no timesig-marker has been found.\nreturns nil in case of an error\nPARAMETERS:\nposition:position in seconds\n",
        "body": "ultraschall.GetTimeSignaturesByTime(${1:number position})$0"
    },
    "ULTRASCHALL.ISMARKEREDIT lua": {
        "prefix": "ultraschall.IsMarkerEdit",
        "scope": "lua",
        "description": "returns true, if the marker is an edit-marker, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's an edit-marker, false if not\n",
        "body": "ultraschall.IsMarkerEdit(${1:integer markerid})$0"
    },
    "ULTRASCHALL.ISMARKERNORMAL lua": {
        "prefix": "ultraschall.IsMarkerNormal",
        "scope": "lua",
        "description": "returns true, if the marker is a normal-marker, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's an normal-marker, false if not\n",
        "body": "ultraschall.IsMarkerNormal(${1:integer markerid})$0"
    },
    "ULTRASCHALL.ISREGIONPODRANGE lua": {
        "prefix": "ultraschall.IsRegionPodrange",
        "scope": "lua",
        "description": "returns true, if the marker is a Podrange-region, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's a PodRange-Region, false if not\n",
        "body": "ultraschall.IsRegionPodrange(${1:integer markerid})$0"
    },
    "ULTRASCHALL.ISREGIONEDITREGION lua": {
        "prefix": "ultraschall.IsRegionEditRegion",
        "scope": "lua",
        "description": "returns true, if the marker is an Edit-region, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's an Edit-Region, false if not\n",
        "body": "ultraschall.IsRegionEditRegion(${1:integer markerid})$0"
    },
    "ULTRASCHALL.ADDEDITREGION lua": {
        "prefix": "ultraschall.AddEditRegion",
        "scope": "lua",
        "description": "Adds a new edit-region and returns index of the newly created edit-marker-region.\nreturns -1 in case of an error\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntext:the title of the marker\nRETURNS:\nmarkernr:the number of the newly created region\nguid:the guid, associated with this edit-region\n",
        "body": "ultraschall.AddEditRegion(${1:number startposition},${2:number endposition},${3:string text})$0"
    },
    "ULTRASCHALL.SETEDITREGION lua": {
        "prefix": "ultraschall.SetEditRegion",
        "scope": "lua",
        "description": "Sets the values of an already existing edit-region. To retain an already set position, endposition and/or edittitle, use nil.\nReturns true in case of success, false if not.\nNote: if you set the new beginning of the region before another region, the indexnumber of the edit-region changes. So if you want to set an edit-region repeatedly, you should get the indexnumber using ultraschall.EnumerateEditRegion, or you might accidently change another region!\nreturns -1 in case of an error\nPARAMETERS:\nnumber:endposition in seconds, nil to retain the old value\nposition:endposition in seconds, nil to retain the old value\nendposition:endposition in seconds, nil to retain the old value\nRETURNS:\nretval:true, in case of success, false if not\n",
        "body": "ultraschall.SetEditRegion(${1:integer number},${2:number position},${3:number endposition},${4:string edittitle})$0"
    },
    "ULTRASCHALL.DELETEEDITREGION lua": {
        "prefix": "ultraschall.DeleteEditRegion",
        "scope": "lua",
        "description": "Deletes an already existing edit-region.\nReturns true in case of success, false if not.\nPARAMETERS:\nnumber:the number of the edit-region, beginning with 1 for the first edit-region\nRETURNS:\nretval:true, in case of success, false if not\n",
        "body": "ultraschall.DeleteEditRegion(${1:integer number})$0"
    },
    "ULTRASCHALL.ENUMERATEEDITREGION lua": {
        "prefix": "ultraschall.EnumerateEditRegion",
        "scope": "lua",
        "description": "Returns the values of an edit-region.\nreturns -1 in case of an error\nPARAMETERS:\nnumber:the number of the edit-region, beginning with 1 for the first edit-region\nRETURNS:\nretval:the overall marker-index-number of all markers in the project, -1 in case of error\nposition:endposition in seconds\nendposition:endposition in seconds\ntitle:the title of the region\nrgnindexnumber:the overall region index number, as used by other of Reaper's own marker-functions\nguid:the guid of the edit-region\n",
        "body": "ultraschall.EnumerateEditRegion(${1:integer number})$0"
    },
    "ULTRASCHALL.COUNTEDITREGIONS lua": {
        "prefix": "ultraschall.CountEditRegions",
        "scope": "lua",
        "description": "returns the number of edit-regions in the project.\nRETURNS:\nretval:the number of edit-regions in the project\n",
        "body": "ultraschall.CountEditRegions()$0"
    },
    "ULTRASCHALL.GETALLMARKERSBETWEEN lua": {
        "prefix": "ultraschall.GetAllMarkersBetween",
        "scope": "lua",
        "description": "To get all Markers in the project(normal, edit, chapter), regardless of their category, between startposition and endposition.\nDoesn't return regions!\nreturns the number of markers and an array with each marker in the format:\nmarkersarray[index][0] - position\nmarkersarray[index][1] - name\nmarkersarray[index][2] - indexnumber of the marker within all markers in the project\nmarkersarray[index][3] - the shown index-number\nmarkersarray[index][4] - the color of the marker\nmarkersarray[index][5] - the guid of the marker\nreturns -1 in case of error\nPARAMETERS:\nstartposition:the earliest position a returned marker may have\nendposition:the latest position a returned marker may have\nRETURNS:\nallmarkersarray:an array, that holds all markers(not regions!) of the project\n",
        "body": "ultraschall.GetAllMarkersBetween(${1:number startposition},${2:number endposition})$0"
    },
    "ULTRASCHALL.GETALLREGIONS lua": {
        "prefix": "ultraschall.GetAllRegions",
        "scope": "lua",
        "description": "To get all Regions in the project(normal, edit, chapter), regardless of their category.\nDoesn't return markers!\nreturns the number of markers and an array with each marker in the format:\nregionarray[index][0] - position\nregionarray[index][1] - endposition\nregionarray[index][2] - name\nregionarray[index][3] - indexnumber of the region within all markers in the project. This is 1-based, unlike in Reaper's own API!\nregionarray[index][4] - the shown index-number\nregionarray[index][5] - the color of the region\nregionarray[index][6] - the guid of the region\nreturns -1 in case of error\n",
        "body": "ultraschall.GetAllRegions()$0"
    },
    "ULTRASCHALL.GETALLREGIONSBETWEEN lua": {
        "prefix": "ultraschall.GetAllRegionsBetween",
        "scope": "lua",
        "description": "To get all Regions in the project(normal, edit, chapter), regardless of their category between start- and endposition.\nSet partial to true, if you want to get regions as well, that are only partially between start- and endposition\nDoesn't return markers!\nreturns the number of markers and an array with each marker in the format:\nregionarray[index][0] - position\nregionarray[index][1] - endposition\nregionarray[index][2] - name\nregionarray[index][3] - indexnumber of the region within all markers in the project\nregionarray[index][4] - the shown index-number\nregionarray[index][5] - the color of the region\nregionarray[index][6] - the guid of the region\nreturns -1 in case of error\nPARAMETERS:\nstartposition:the earliest position a returned region may have\nendposition:the latest position a returned region may have\n",
        "body": "ultraschall.GetAllRegionsBetween(${1:number startposition},${2:number endposition},${3:boolean partial})$0"
    },
    "ULTRASCHALL.PARSEMARKERSTRING lua": {
        "prefix": "ultraschall.ParseMarkerString",
        "scope": "lua",
        "description": "Parses the entries in markerstring for timestrings and markertitles.\nIt returns the number of entries as well as a table with all marker-information.\nThe table works as such:\nmarkertable[1][markernumber] - the timestring of the marker, -1 if no time is available\nmarkertable[2][markernumber] - the time, converted into position in seconds, -1 if no time is available\nmarkertable[3][markernumber] - the name of the marker\nreturns -1 in case of an error\nPARAMETERS:\nmarkerstring:a string with all markers. An entry is \"timestring markertitle\\n\". Each marker-entry must be separated by a newline from each other.\nstrict:interpret the time in timestring more strict or more loosely?\nRETURNS:\nnumber_of_entries:the number of markers in markerstring\nmarkerarray:a table with all the information of a marker\n",
        "body": "ultraschall.ParseMarkerString(${1:string markerstring},${2:boolean strict})$0"
    },
    "ULTRASCHALL.RENUMERATEMARKERS lua": {
        "prefix": "ultraschall.RenumerateMarkers",
        "scope": "lua",
        "description": "Renumbers the shown numbers of markers(not regions!) in the current project, that have the color colorvalue.\nThe numbering starts with the number startingnumber.\nThe markers will be renumbered from the earliest marker in the project to the latest one.\nreturns -1 in case of an error\nPARAMETERS:\ncolorvalue:the (systemdependent)colorvalue a marker must have. -1 if you want all markers to be numbered.\nstartingnumber:the first number that shall be given.\nRETURNS:\nretval:-1 in case of error, nil in case of success\n",
        "body": "ultraschall.RenumerateMarkers(${1:integer colorvalue},${2:integer startingnumber})$0"
    },
    "ULTRASCHALL.ISMARKERATPOSITION lua": {
        "prefix": "ultraschall.IsMarkerAtPosition",
        "scope": "lua",
        "description": "returns, if markers are at position and returns the marker-numbers.\nThe marker-numbers are numerated by order, not the shown marker-numbers!\nreturns false in case of error\nPARAMETERS:\nposition:the position to check for markers in seconds; only positive numbers\nRETURNS:\nretval:true, if the function found marker(s); false, if no markers are available at position\ncount:the count of markers at position\nmarkersstring:a string with all the markernumbers, separated by a ,\nmarkersarray:an array with each entry consisting a markernumber\n",
        "body": "ultraschall.IsMarkerAtPosition(${1:number position})$0"
    },
    "ULTRASCHALL.ISREGIONATPOSITION lua": {
        "prefix": "ultraschall.IsRegionAtPosition",
        "scope": "lua",
        "description": "returns, if regions are at position and returns the region-numbers.\nThe region-numbers are numerated by order, not the shown region-numbers!\nreturns false in case of error\nPARAMETERS:\nposition:the position to check for regions in seconds; only positive numbers\nRETURNS:\nretval:true, if the function found region(s); false, if no regions are available at position\ncount:the count of regions at position\nregionsstring:a string with all the regionnumbers, separated by a ,\nregionsarray:an array with each entry consisting a regionnumber\n",
        "body": "ultraschall.IsRegionAtPosition(${1:number position})$0"
    },
    "ULTRASCHALL.COUNTMARKERSANDREGIONS lua": {
        "prefix": "ultraschall.CountMarkersAndRegions",
        "scope": "lua",
        "description": "Returns the position of the last projectmarker in the project(no regions or time-sig-markers!).\nUse GetMarkerAndRegionsByIndex to enumerate markers or regions in particular.\nReturns -1 in case of no markers available\nRETURNS:\ncount_markers:the number of markers available in the project\ncount_regions:the number of regions available in the project\n",
        "body": "ultraschall.CountMarkersAndRegions()$0"
    },
    "ULTRASCHALL.GETLASTMARKERPOSITION lua": {
        "prefix": "ultraschall.GetLastMarkerPosition",
        "scope": "lua",
        "description": "Returns the position of the last projectmarker in the project(no regions or time-sig-markers!).\nReturns -1 in case of no markers available\nRETURNS:\nposition:the position of the last marker in the project\nmarker_idx:the idx of the last marker in the project. Not the shown number!\n",
        "body": "ultraschall.GetLastMarkerPosition()$0"
    },
    "ULTRASCHALL.GETLASTREGION lua": {
        "prefix": "ultraschall.GetLastRegion",
        "scope": "lua",
        "description": "Returns the position of the last region in the project(no markers or time-sig-markers!).\nNote: Last region means the last ending region in the project, even if it's the first starting.\nReturns -1 in case of no regions available\nRETURNS:\nposition:the endposition of the last region in the project\nendposition:the endposition of the last region in the project\nregion_idx:the idx of the last region in the project. Not the shown number!\n",
        "body": "ultraschall.GetLastRegion()$0"
    },
    "ULTRASCHALL.GETLASTTIMESIGMARKERPOSITION lua": {
        "prefix": "ultraschall.GetLastTimeSigMarkerPosition",
        "scope": "lua",
        "description": "Returns the position of the last time-signature-marker in the project(no markers or regions!).\nReturns -1 in case of no time-signature-markers available\nRETURNS:\nposition:the beatposition of the last timesig-marker in the project\nmeasureposition:the measureposition of the last timesig-marker in the project\nbeatposition:the beatposition of the last timesig-marker in the project\ntimesig_idx:the idx of the last timesig-marker in the project.\n",
        "body": "ultraschall.GetLastTimeSigMarkerPosition()$0"
    },
    "ULTRASCHALL.GETMARKERUPDATECOUNTER lua": {
        "prefix": "ultraschall.GetMarkerUpdateCounter",
        "scope": "lua",
        "description": "returns the number of times, a marker in any project has been updated since Reaper started.\nCounts up, if a marker is added, set, moved, deleted from any project opened in Reaper.\nThis counter includes already closed projects as well\nRETURNS:\nmarker_update_counter:the number of times a marker in any project in Reaper has been updated\n",
        "body": "ultraschall.GetMarkerUpdateCounter()$0"
    },
    "ULTRASCHALL.MOVETIMESIGMARKERSBY lua": {
        "prefix": "ultraschall.MoveTimeSigMarkersBy",
        "scope": "lua",
        "description": "Moves time-signature-markers between startposition and endposition by moveby.\nDoes NOT move normal projectmarkers or regions!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\ncut_at_borders:shortens or cuts markers, that leave the section between startposition and endposition\nupdate_timeline:true, updates the timeline after moving time-signature markers; false, don't update timeline(must be done manually then)\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "ultraschall.MoveTimeSigMarkersBy(${1:number startposition},${2:number endposition},${3:number moveby},${4:boolean cut_at_borders},${5:boolean update_timeline})$0"
    },
    "ULTRASCHALL.GETALLTIMESIGMARKERS lua": {
        "prefix": "ultraschall.GetAllTimeSigMarkers",
        "scope": "lua",
        "description": "Returns the number of Tempo/Time-Signature-Markers in the project, as well as an array with all attributes of all these markers.\nThe array is of the format: TimeSigArray[markernumber(1-based)][attribute-idx]\nwhere attribute-idx is\n1, number timepos\n2, number measurepos\n3, number beatpos\n4, number bpm\n5, number timesig_num\n6, number timesig_denom\n7, boolean lineartempo\nreturns -1 in case of error\nRETURNS:\nnum_timesig_markers:the number of time-signature-markers in the project\nTimeSigArray:an array with all time-signature-markers and all their attributes; see Description for more details\n",
        "body": "ultraschall.GetAllTimeSigMarkers()$0"
    },
    "ULTRASCHALL.MOVEMARKERSBY lua": {
        "prefix": "ultraschall.MoveMarkersBy",
        "scope": "lua",
        "description": "Moves the markers between startposition and endposition by moveby.\nDoes NOT move regions and time-signature-markers!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\ncut_at_borders:shortens or cuts markers, that leave the section between startposition and endposition when applying moveby\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "ultraschall.MoveMarkersBy(${1:number startposition},${2:number endposition},${3:number moveby},${4:boolean cut_at_borders})$0"
    },
    "ULTRASCHALL.MOVEREGIONSBY lua": {
        "prefix": "ultraschall.MoveRegionsBy",
        "scope": "lua",
        "description": "Moves the regions between startposition and endposition by moveby.\nWill affect only regions, who start within start and endposition. It will not affect those, who end within start and endposition but start before startposition.\nDoes NOT move markers and time-signature-markers!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\ncut_at_borders:shortens or cuts markers, that leave the section between startposition and endposition\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "ultraschall.MoveRegionsBy(${1:number startposition},${2:number endposition},${3:number moveby},${4:boolean cut_at_borders})$0"
    },
    "ULTRASCHALL.RIPPLECUT_REGIONS lua": {
        "prefix": "ultraschall.RippleCut_Regions",
        "scope": "lua",
        "description": "Ripplecuts regions, where applicable.\nIt cuts all (parts of) regions between startposition and endposition and moves remaining parts plus all regions after endposition by endposition-startposition toward projectstart.\nReturns false in case of an error.\nPARAMETERS:\nstartposition:the startposition from where regions shall be cut from\nendposition:the endposition to which regions shall be cut from; all regions/parts of regions after that will be moved toward projectstart\nRETURNS:\nwere_regions_altered:true, if regions were cut/altered; false, if not\nnumber_of_altered_regions:the number of regions that were altered/cut/moved\narray altered_regions:  altered_regions_array[index_of_region][8] - the new endposition\n",
        "body": "ultraschall.RippleCut_Regions(${1:number startposition},${2:number endposition})$0"
    },
    "ULTRASCHALL.GETALLCUSTOMMARKERS lua": {
        "prefix": "ultraschall.GetAllCustomMarkers",
        "scope": "lua",
        "description": "Will return all custom-markers with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not check custom-regions, use GetAllCustomRegions instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nRETURNS:\ncount:the number of found markers; -1, in case of an error\nmarker_array:an array with all found custom-markers. It follows the scheme:\n",
        "body": "ultraschall.GetAllCustomMarkers(${1:string custom_marker_name})$0"
    },
    "ULTRASCHALL.GETALLCUSTOMREGIONS lua": {
        "prefix": "ultraschall.GetAllCustomRegions",
        "scope": "lua",
        "description": "Will return all custom-regions with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not check custom-markers, use GetAllCustomMarkers instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_region_name:the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called \"__CustomRegion::\"\nRETURNS:\ncount:the number of found regions; -1, in case of an error\n",
        "body": "ultraschall.GetAllCustomRegions(${1:string custom_region_name})$0"
    },
    "ULTRASCHALL.COUNTALLCUSTOMMARKERS lua": {
        "prefix": "ultraschall.CountAllCustomMarkers",
        "scope": "lua",
        "description": "Will count all custom-markers with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not count custom-regions, use CountAllCustomRegions instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nRETURNS:\ncount:the number of found markers; -1, in case of an error\n",
        "body": "ultraschall.CountAllCustomMarkers(${1:string custom_marker_name})$0"
    },
    "ULTRASCHALL.COUNTALLCUSTOMREGIONS lua": {
        "prefix": "ultraschall.CountAllCustomRegions",
        "scope": "lua",
        "description": "Will count all custom-regions with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not count custom-markers, use CountAllCustomMarkers instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_region_name:the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called \"__CustomRegion::\"\nRETURNS:\ncount:the number of found regions; -1, in case of an error\n",
        "body": "ultraschall.CountAllCustomRegions(${1:string custom_region_name})$0"
    },
    "ULTRASCHALL.ENUMERATECUSTOMMARKERS lua": {
        "prefix": "ultraschall.EnumerateCustomMarkers",
        "scope": "lua",
        "description": "Will return a specific custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not enumerate custom-regions, use EnumerateCustomRegions instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nidx:the index of the marker within all same-named custom-markers; 0, for the first custom-marker\nRETURNS:\nretval:true, if the custom-marker exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\n",
        "body": "ultraschall.EnumerateCustomMarkers(${1:string custom_marker_name},${2:integer idx})$0"
    },
    "ULTRASCHALL.ENUMERATECUSTOMREGIONS lua": {
        "prefix": "ultraschall.EnumerateCustomRegions",
        "scope": "lua",
        "description": "Will return a specific custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not enumerate custom-markers, use EnumerateCustomMarkers instead.\nreturns false in case of an error\nPARAMETERS:\nidx:the index of the region within all same-named custom-regions; 0, for the first custom-region\nRETURNS:\nretval:true, if the custom-region exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the region\nguid:the guid of the custom-region\n",
        "body": "ultraschall.EnumerateCustomRegions(${1:string custom_marker_name},${2:integer idx})$0"
    },
    "ULTRASCHALL.DELETECUSTOMMARKERS lua": {
        "prefix": "ultraschall.DeleteCustomMarkers",
        "scope": "lua",
        "description": "Will delete a specific custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not delete custom-regions, use DeleteCustomRegions instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nidx:the index of the marker within all same-named custom-markers; 0, for the first custom-marker\nRETURNS:\nretval:true, if the custom-marker exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\n",
        "body": "ultraschall.DeleteCustomMarkers(${1:string custom_marker_name},${2:integer idx})$0"
    },
    "ULTRASCHALL.DELETECUSTOMREGIONS lua": {
        "prefix": "ultraschall.DeleteCustomRegions",
        "scope": "lua",
        "description": "Deletes a specific custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not delete custom-markers, use DeleteCustomMarkers instead.\nreturns false in case of an error\nPARAMETERS:\nidx:the index of the region within all same-named custom-regions; 0, for the first custom-region\nRETURNS:\nretval:true, if the custom-region exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the region\n",
        "body": "ultraschall.DeleteCustomRegions(${1:string custom_marker_name},${2:integer idx})$0"
    },
    "ULTRASCHALL.ADDCUSTOMMARKER lua": {
        "prefix": "ultraschall.AddCustomMarker",
        "scope": "lua",
        "description": "Will add new custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not add custom-regions, use AddCustomRegion instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"; nil, adds a normal marker\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if adding the custom-marker was successful; false, if not or an error occurred\nmarkernumber:the indexnumber of the newly added custommarker\nguid:the guid of the custommarker\n",
        "body": "ultraschall.AddCustomMarker(${1:string custom_marker_name},${2:number pos},${3:string name},${4:integer shown_number},${5:integer color})$0"
    },
    "ULTRASCHALL.ADDCUSTOMREGION lua": {
        "prefix": "ultraschall.AddCustomRegion",
        "scope": "lua",
        "description": "Will add new custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not add custom-markers, use AddCustomMarker instead.\nreturns false in case of an error\nPARAMETERS:\npos:the position of the region in seconds\nregionend:the endposition of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if adding the custom-region was successful; false, if not or an error occurred\nshown_number:if the desired shown_number is already used by another region, this will hold the alternative number for the new custom-region\nguid:the guid of the customregion\n",
        "body": "ultraschall.AddCustomRegion(${1:string custom_region_name},${2:number pos},${3:number regionend},${4:string name},${5:integer shown_number},${6:integer color})$0"
    },
    "ULTRASCHALL.SETCUSTOMMARKER lua": {
        "prefix": "ultraschall.SetCustomMarker",
        "scope": "lua",
        "description": "Will set attributes of an already existing custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not set custom-regions, use SetCustomRegion instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"; nil, make it a normal marker\nidx:the index-number of the custom-marker within all custom-markers\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if setting the new attributes of the custom-marker was successful; false, if not or an error occurred\n",
        "body": "ultraschall.SetCustomMarker(${1:string custom_marker_name},${2:integer idx},${3:number pos},${4:string name},${5:integer shown_number},${6:integer color})$0"
    },
    "ULTRASCHALL.SETCUSTOMREGION lua": {
        "prefix": "ultraschall.SetCustomRegion",
        "scope": "lua",
        "description": "Will set an already existing custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not add custom-markers, use AddCustomMarker instead.\nreturns false in case of an error, like the desired shown_number is already taken by another region\nPARAMETERS:\nidx:the index of the custom region to change\npos:the position of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if adding the region was successful; false, if not or an error occurred\nshown_number:if the desired shown_number is already used by another region, this will hold the alternative number for the new custom-region\n",
        "body": "ultraschall.SetCustomRegion(${1:string custom_region_name},${2:integer idx},${3:number pos},${4:number regionend},${5:string name},${6:integer shown_number},${7:integer color})$0"
    },
    "ULTRASCHALL.GETNEXTFREEREGIONINDEX lua": {
        "prefix": "ultraschall.GetNextFreeRegionIndex",
        "scope": "lua",
        "description": "returns the next unused region-index-number, beginning with 0.\nRETURNS:\nfree_shown_number:the next free/unused region-index-number\n",
        "body": "ultraschall.GetNextFreeRegionIndex()$0"
    },
    "ULTRASCHALL.ISMARKERVALIDCUSTOMMARKER lua": {
        "prefix": "ultraschall.IsMarkerValidCustomMarker",
        "scope": "lua",
        "description": "returns true, if the marker with id markeridx is a valid custom-marker of the type custom_marker_name\nmarkeridx is the index of all markers and regions!\nreturns false in case of an error\n",
        "body": "ultraschall.IsMarkerValidCustomMarker(${1:string custom_marker_name},${2:integer markeridx})$0"
    },
    "ULTRASCHALL.ISREGIONVALIDCUSTOMREGION lua": {
        "prefix": "ultraschall.IsRegionValidCustomRegion",
        "scope": "lua",
        "description": "returns true, if the marker with id markeridx is a valid custom-region of the type custom_region_name\nmarkeridx is the index of all markers and regions!\nreturns false in case of an error\n",
        "body": "ultraschall.IsRegionValidCustomRegion(${1:string custom_region_name},${2:integer markeridx})$0"
    },
    "ULTRASCHALL.GETMARKERIDFROMGUID lua": {
        "prefix": "ultraschall.GetMarkerIDFromGuid",
        "scope": "lua",
        "description": "Gets the corresponding indexnumber of a marker-guid\nThe index is for all markers and regions, inclusive and 1-based\nreturns -1 in case of an error\nPARAMETERS:\nguid:the guid of the marker/region, whose index-number you want to retrieve\nRETURNS:\nindex:the index of the marker/region, whose guid you have passed to this function\n",
        "body": "ultraschall.GetMarkerIDFromGuid(${1:string guid})$0"
    },
    "ULTRASCHALL.GETGUIDFROMMARKERID lua": {
        "prefix": "ultraschall.GetGuidFromMarkerID",
        "scope": "lua",
        "description": "Gets the corresponding marker-guid of a marker with a specific index\nThe index is for all markers and regions, inclusive and 1-based\nreturns -1 in case of an error\nPARAMETERS:\nindex:the index of the marker/region, whose guid you want to retrieve\nRETURNS:\nguid:the guid of the marker/region of the marker with a specific index\n",
        "body": "ultraschall.GetGuidFromMarkerID(${1:integer index})$0"
    },
    "ULTRASCHALL.ISTIMESIGMARKERATPOSITION lua": {
        "prefix": "ultraschall.IsTimeSigmarkerAtPosition",
        "scope": "lua",
        "description": "returns, if at position is a time-signature marker\nreturns false in case of an error\nPARAMETERS:\nposition:nil or 0, use position in seconds; 1, use position in measures\nposition_mode:nil or 0, use position in seconds; 1, use position in measures\nRETURNS:\nretval:true, marker found; false, marker not found\n",
        "body": "ultraschall.IsTimeSigmarkerAtPosition(${1:number position},${2:optional integer position_mode})$0"
    },
    "ULTRASCHALL.GETITEMPOSITION lua": {
        "prefix": "ultraschall.GetItemPosition",
        "scope": "lua",
        "description": "Returns position-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nposition:the position in seconds, as set in the statechunk\n",
        "body": "ultraschall.GetItemPosition(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMLENGTH lua": {
        "prefix": "ultraschall.GetItemLength",
        "scope": "lua",
        "description": "Returns length-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nlength:the length in seconds, as set in the statechunk\n",
        "body": "ultraschall.GetItemLength(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSNAPOFFSET lua": {
        "prefix": "ultraschall.GetItemSnapOffset",
        "scope": "lua",
        "description": "Returns snapoffs-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nsnapoffset:the snapoffset in seconds, as set in the statechunk\n",
        "body": "ultraschall.GetItemSnapOffset(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMLOOP lua": {
        "prefix": "ultraschall.GetItemLoop",
        "scope": "lua",
        "description": "Returns loopstate-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nloopstate:the loopstate, as set in the statechunk; 1, loop source; 0, don't loop source\n",
        "body": "ultraschall.GetItemLoop(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMALLTAKES lua": {
        "prefix": "ultraschall.GetItemAllTakes",
        "scope": "lua",
        "description": "Returns alltakes-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nalltakes:Play all takes(1) or don't play all takes(0)\n",
        "body": "ultraschall.GetItemAllTakes(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMFADEIN lua": {
        "prefix": "ultraschall.GetItemFadeIn",
        "scope": "lua",
        "description": "Returns fadein-entries of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nfadestate3:fadeinstate entry as set in the rppxml-mediaitem-statechunk\nfadestate5:fadeinstate entry as set in the rppxml-mediaitem-statechunk\n",
        "body": "ultraschall.GetItemFadeIn(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMFADEOUT lua": {
        "prefix": "ultraschall.GetItemFadeOut",
        "scope": "lua",
        "description": "Returns fadeout-entries of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\ncurvetype1:the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype2\nfadeout_length:the fadeout-length in seconds; overrides fadeout_length and will be moved to fadeout_length when fadeout-length changes(e.g. mouse-drag); might be autocrossfade-length\nfadeout_length2:the fadeout-length in seconds; overrides fadeout_length and will be moved to fadeout_length when fadeout-length changes(e.g. mouse-drag); might be autocrossfade-length\ncurvetype2:the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype1\nfadestate5:unknown\ncurve:curvation of the fadeout, -1 to 1\n",
        "body": "ultraschall.GetItemFadeOut(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMFADEFLAG lua": {
        "prefix": "ultraschall.GetItemFadeFlag",
        "scope": "lua",
        "description": "Returns autofade-entry of a MediaItem or MediaItemStateChunk.\nIt's the FADEFLAG-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nautofade_state:the autofade-state; 1, autofade is off; nil, autofade is on\n",
        "body": "ultraschall.GetItemFadeFlag(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMIGUID lua": {
        "prefix": "ultraschall.GetItemIGUID",
        "scope": "lua",
        "description": "Returns the IGUID-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nIGUID:the IGUID of the item\n",
        "body": "ultraschall.GetItemIGUID(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMIID lua": {
        "prefix": "ultraschall.GetItemIID",
        "scope": "lua",
        "description": "Returns the IID-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nIID:the IID of the item; the item-id, which is basically a counter of all items created within this project. May change, so use it only as a counter. If you want to identify a specific item, use GUID and IGUID instead.\n",
        "body": "ultraschall.GetItemIID(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMNAME lua": {
        "prefix": "ultraschall.GetItemName",
        "scope": "lua",
        "description": "Returns the name-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nname:the name of the item\n",
        "body": "ultraschall.GetItemName(${1:MediaItem MediaItem},${2:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMVOLPAN lua": {
        "prefix": "ultraschall.GetItemVolPan",
        "scope": "lua",
        "description": "Returns the vol/pan-entries of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nvolpan1:unknown\npan:unknown\nvolume:from 0(-inf) to 3.981072(+12db), 1 is 0db; higher numbers are allowed; negative means phase inverted\nvolpan4:unknown\n",
        "body": "ultraschall.GetItemVolPan(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSAMPLEOFFSET lua": {
        "prefix": "ultraschall.GetItemSampleOffset",
        "scope": "lua",
        "description": "Returns the sampleoffset-entry of a MediaItem or MediaItemStateChunk.\nIt's the SOFFS-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nsampleoffset:sampleoffset in seconds\n",
        "body": "ultraschall.GetItemSampleOffset(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMPLAYRATE lua": {
        "prefix": "ultraschall.GetItemPlayRate",
        "scope": "lua",
        "description": "Returns the playback-rate-entries of a MediaItem or MediaItemStateChunk.\nIt's the PLAYRATE-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nplaybackrate:1 is 1x, 2 is 2x, 1.8 is 1.8x,etc\npreserve_pitch:preserve pitch, 1 - preserve, 0 - don't preserve\npitch_adjust:pitch_adjust(semitones); negative values allowed; 1.1=1.1 semitones higher, -0.3=0.3 semitones lower,etc\ntakepitch_timestretch_mode:- the item's pitchmode - 65536 for project-default\noptimize_tonal_content:2, checkbox for optimize-tonal-content is set on; 0, checkbox for optimize-tonal-content is set off\nstretch_marker_fadesize:in milliseconds; negative values are allowed\n",
        "body": "ultraschall.GetItemPlayRate(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMCHANMODE lua": {
        "prefix": "ultraschall.GetItemChanMode",
        "scope": "lua",
        "description": "Returns the channelmode-entry of a MediaItem or MediaItemStateChunk.\nIt's the CHANMODE-entry\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nchannelmode:channelmode of the MediaItem\n",
        "body": "ultraschall.GetItemChanMode(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMGUID lua": {
        "prefix": "ultraschall.GetItemGUID",
        "scope": "lua",
        "description": "Returns the GUID-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nGUID:the GUID of the item\n",
        "body": "ultraschall.GetItemGUID(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMRECPASS lua": {
        "prefix": "ultraschall.GetItemRecPass",
        "scope": "lua",
        "description": "Returns the recpass-entry of a MediaItem or MediaItemStateChunk.\nIt's the counter of the recorded item-takes within a project, ordered by the order of recording. Only displayed with recorded item-takes, not imported ones.\nIt's the RECPASS-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nrecpass_state:the number of recorded mediaitem; every recorded item gets it's counting-number.\n",
        "body": "ultraschall.GetItemRecPass(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMBEAT lua": {
        "prefix": "ultraschall.GetItemBeat",
        "scope": "lua",
        "description": "Returns the beatstate/timebase-entry of a MediaItem or MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nbeatstate:the item-timebase state\n",
        "body": "ultraschall.GetItemBeat(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMMIXFLAG lua": {
        "prefix": "ultraschall.GetItemMixFlag",
        "scope": "lua",
        "description": "Returns the item-mix-behavior-entry of a MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nitemmix_state:the item-mix-behavior\n",
        "body": "ultraschall.GetItemMixFlag(${1:MediaItem MediaItem},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMUSTRACKNUMBER_STATECHUNK lua": {
        "prefix": "ultraschall.GetItemUSTrackNumber_StateChunk",
        "scope": "lua",
        "description": "Returns the tracknumber as well as the mediatrack-object from where the mediaitem was from, as given by a MediaItemStateChunk.\nThis works only, if the StateChunk contains the entry \"ULTRASCHALL_TRACKNUMBER\", which holds the original tracknumber of the MediaItem.\nThis entry will only be added by functions from the Ultraschall-API, like GetAllMediaItemsBetween\nReturns -1 in case of error.\nPARAMETERS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\ntracknumber:the tracknumber, where this item came from; starts with 1 for the first track!\ntrack:the accompanying track as MediaTrack-object\n",
        "body": "ultraschall.GetItemUSTrackNumber_StateChunk(${1:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMUSTRACKNUMBER_STATECHUNK lua": {
        "prefix": "ultraschall.SetItemUSTrackNumber_StateChunk",
        "scope": "lua",
        "description": "Adds/Replaces the entry \"ULTRASCHALL_TRACKNUMBER\" in a MediaItemStateChunk, that tells other Ultraschall-Apifunctions, from which track this item originated from.\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\ntracknumber:the tracknumber you want to set, with 1 for track 1, 2 for track 2\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "ultraschall.SetItemUSTrackNumber_StateChunk(${1:string MediaItemStateChunk},${2:integer tracknumber})$0"
    },
    "ULTRASCHALL.SETITEMPOSITION lua": {
        "prefix": "ultraschall.SetItemPosition",
        "scope": "lua",
        "description": "Sets position in a MediaItem or MediaItemStateChunk in seconds.\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nposition:position in seconds\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "ultraschall.SetItemPosition(${1:MediaItem MediaItem},${2:integer position},${3:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMLENGTH lua": {
        "prefix": "ultraschall.SetItemLength",
        "scope": "lua",
        "description": "Sets length in a MediaItem and MediaItemStateChunk in seconds.\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nlength:length in seconds\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "ultraschall.SetItemLength(${1:MediaItem MediaItem},${2:integer length},${3:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSTATECHUNK lua": {
        "prefix": "ultraschall.GetItemStateChunk",
        "scope": "lua",
        "description": "Returns the statechunk of MediaItem. Parameter AddTracknumber allows you to set, whether the tracknumber of the MediaItem shall be inserted to the statechunk as well, by the new entry \"ULTRASCHALL_TRACKNUMBER\".\nreturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose statechunk you want to have\nAddTracknumber:nil or true; add the tracknumber, where the MediaItem lies, as additional entry entry \"ULTRASCHALL_TRACKNUMBER\" to the statechunk; false, just return the original statechunk.\nRETURNS:\nretval:true, if getting the statechunk was successful; false, if not\nMediaItemStateChunk:the statechunk of the MediaItem\n",
        "body": "ultraschall.GetItemStateChunk(${1:MediaItem MediaItem},${2:boolean AddTracknumber})$0"
    },
    "ULTRASCHALL.ISVALIDMEDIAITEMSTATECHUNK lua": {
        "prefix": "ultraschall.IsValidMediaItemStateChunk",
        "scope": "lua",
        "description": "Checks, whether MediaItemStateChunk is a valide MediaItemStateChunk.\nReturns false in case of an error\nPARAMETERS:\nMediaItemStateChunk:the string to check, if it's a valid MediaItemStateChunk\nRETURNS:\nretval:true, MediaItemStateChunk is valid; false, MediaItemStateChunk isn't a valid statechunk\n",
        "body": "ultraschall.IsValidMediaItemStateChunk(${1:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.CHECKMEDIAITEMARRAY lua": {
        "prefix": "ultraschall.CheckMediaItemArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemArray is valid.\nIt throws out all entries, that are not MediaItems and returns the altered array as result.\nreturns false in case of error or if it is not a valid MediaItemArray\nPARAMETERS:\nMediaItemArray:a MediaItemArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemArray is valid, false if not\ncount:the number of entries in the returned retMediaItemArray\nretMediaItemArray:the, possibly, altered MediaItemArray\n",
        "body": "ultraschall.CheckMediaItemArray(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.ISVALIDMEDIAITEMARRAY lua": {
        "prefix": "ultraschall.IsValidMediaItemArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemArray is valid.\nIt throws out all entries, that are not MediaItems and returns the altered array as result.\nreturns false in case of an error or if it is not a valid MediaItemArray\nPARAMETERS:\nMediaItemArray:a MediaItemArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemArray is valid, false if not\ncount:the number of entries in the returned retMediaItemArray\nretMediaItemArray:the, possibly, altered MediaItemArray\n",
        "body": "ultraschall.IsValidMediaItemArray(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.CHECKMEDIAITEMSTATECHUNKARRAY lua": {
        "prefix": "ultraschall.CheckMediaItemStateChunkArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemStateChunkArray is valid.\nIt throws out all entries, that are not MediaItemStateChunks and returns the altered array as result.\nreturns false in case of an error or if it is not a valid MediaItemStateChunkArray\nPARAMETERS:\nMediaItemStateChunkArray:a MediaItemStateChunkArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemStateChunkArray is valid, false if not\ncount:the number of entries in the returned retMediaItemStateChunkArray\nretMediaItemStateChunkArray:the, possibly, altered MediaItemStateChunkArray\n",
        "body": "ultraschall.CheckMediaItemStateChunkArray(${1:array MediaItemStateChunkArray})$0"
    },
    "ULTRASCHALL.ISVALIDMEDIAITEMSTATECHUNKARRAY lua": {
        "prefix": "ultraschall.IsValidMediaItemStateChunkArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemStateChunkArray is valid.\nIt throws out all entries, that are not MediaItemStateChunks and returns the altered array as result.\nreturns false in case of an error or if it is not a valid MediaItemStateChunkArray\nPARAMETERS:\nMediaItemStateChunkArray:a MediaItemStateChunkArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemStateChunkArray is valid, false if not\ncount:the number of entries in the returned retMediaItemStateChunkArray\nretMediaItemStateChunkArray:the, possibly, altered MediaItemStateChunkArray\n",
        "body": "ultraschall.IsValidMediaItemStateChunkArray(${1:array MediaItemStateChunkArray})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSATPOSITION lua": {
        "prefix": "ultraschall.GetMediaItemsAtPosition",
        "scope": "lua",
        "description": "Gets all Mediaitems at position, from the tracks given by trackstring.\nReturns a MediaItemArray with the found MediaItems\nreturns -1 in case of error\nPARAMETERS:\nposition:position in seconds\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nnumber_of_items:the number of items at position\nMediaItemArray:an array, that contains all MediaItems at position from the tracks given by trackstring.\nMediaItemStateChunkArray:an array, that contains all Mediaitem's MediaItemStatechunks at position from the tracks given by trackstring.\n",
        "body": "ultraschall.GetMediaItemsAtPosition(${1:number position},${2:string trackstring})$0"
    },
    "ULTRASCHALL.ONLYMEDIAITEMSOFTRACKSINTRACKSTRING lua": {
        "prefix": "ultraschall.OnlyMediaItemsOfTracksInTrackstring",
        "scope": "lua",
        "description": "Throws all MediaItems out of the MediaItemArray, that are not within the tracks, as given with trackstring.\nReturns the \"cleared\" MediaItemArray\nreturns -1 in case of error\nPARAMETERS:\nMediaItemArray:an array with MediaItems; no nil-entries allowed, will be seen as the end of the array\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nMediaItemArray:the \"cleared\" array, that contains only Items in tracks, as given by trackstring, -1 in case of error\n",
        "body": "ultraschall.OnlyMediaItemsOfTracksInTrackstring(${1:array MediaItemArray},${2:string trackstring})$0"
    },
    "ULTRASCHALL.SPLITMEDIAITEMS_POSITION lua": {
        "prefix": "ultraschall.SplitMediaItems_Position",
        "scope": "lua",
        "description": "Splits items at position, in the tracks given by trackstring.\nIf auto-crossfade is set in the Reaper-preferences, crossfade turns it on(true) or off(false).\nReturns false, in case of error.\nPARAMETERS:\nposition:the position in seconds\ntrackstring:the numbers for the tracks, where split shall be applied to; numbers separated by a comma\ncrossfade:true or nil, automatic crossfade(if enabled) will be applied; false, automatic crossfade is off\nRETURNS:\nretval:true - success, false - error\nMediaItemArray:an array with the items on the right side of the split\n",
        "body": "ultraschall.SplitMediaItems_Position(${1:number position},${2:string trackstring},${3:boolean crossfade})$0"
    },
    "ULTRASCHALL.SPLITITEMSATPOSITIONFROMARRAY lua": {
        "prefix": "ultraschall.SplitItemsAtPositionFromArray",
        "scope": "lua",
        "description": "Splits items in MediaItemArray at position, in the tracks given by trackstring.\nIf auto-crossfade is set in the Reaper-preferences, crossfade turns it on(true) or off(false).\nReturns false, in case of error.\nPARAMETERS:\nposition:the position in seconds\nMediaItemArray:an array with the items, where split shall be applied to. No nil-entries allowed!\ncrossfade:true - automatic crossfade(if enabled) will be applied; false - automatic crossfade is off\nRETURNS:\nretval:true - success, false - error\nMediaItemArray:an array with the items on the right side of the split\n",
        "body": "ultraschall.SplitItemsAtPositionFromArray(${1:number position},${2:array MediaItemArray},${3:boolean crossfade})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEM lua": {
        "prefix": "ultraschall.DeleteMediaItem",
        "scope": "lua",
        "description": "deletes a MediaItem. Returns true, in case of success, false in case of error.\nreturns the MediaItemStateChunk of the deleted MediaItem as well, so you can do additional processing with a deleted item.\nreturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem to be deleted\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\nMediaItemStateChunk:the StateChunk of the deleted MediaItem\n",
        "body": "ultraschall.DeleteMediaItem(${1:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEMSFROMARRAY lua": {
        "prefix": "ultraschall.DeleteMediaItemsFromArray",
        "scope": "lua",
        "description": "deletes the MediaItems from MediaItemArray. Returns true, in case of success, false in case of error.\nIn addition, it returns a MediaItemStateChunkArray, that contains the statechunks of all deleted MediaItems\nreturns false in case of an error\nPARAMETERS:\nMediaItemArray:a array with MediaItem-objects to delete; no nil entries allowed\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\n",
        "body": "ultraschall.DeleteMediaItemsFromArray(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEMS_POSITION lua": {
        "prefix": "ultraschall.DeleteMediaItems_Position",
        "scope": "lua",
        "description": "Delete the MediaItems at given position, from the tracks as given by trackstring.\nreturns, if deleting was successful and an array with all statechunks of all deleted MediaItems\nreturns false in case of an error\nPARAMETERS:\nposition:the position in seconds\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\nMediaItemStateChunkArray:and array with all statechunks of all deleted MediaItems; \n",
        "body": "ultraschall.DeleteMediaItems_Position(${1:number position},${2:string trackstring})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSBETWEEN lua": {
        "prefix": "ultraschall.GetAllMediaItemsBetween",
        "scope": "lua",
        "description": "Gets all MediaItems between startposition and endposition from the tracks as given by trackstring.\nSet inside to true to get only items, that are fully within the start and endposition, set it to false, if you also want items, that are just partially inside(end or just the beginning of the item).\nReturns the number of items, an array with all the MediaItems and an array with all the MediaItemStateChunks of the items, as used by functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nThe statechunks include a new element \"ULTRASCHALL_TRACKNUMBER\", which contains the tracknumber of where the item originally was in; important, if you delete the items as you'll otherwise loose this information!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntrackstring:the tracknumbers, separated by a comma\ninside:true, only items that are completely within selection; false, include items that are partially within selection\nRETURNS:\ncount:the number of found items\nMediaItemArray:an array with all the found MediaItems\nMediaItemStateChunkArray:an array with the MediaItemStateChunks, that can be used to create new items with InsertMediaItem_MediaItemStateChunk\n",
        "body": "ultraschall.GetAllMediaItemsBetween(${1:number startposition},${2:number endposition},${3:string trackstring},${4:boolean inside})$0"
    },
    "ULTRASCHALL.MOVEMEDIAITEMSAFTER_BY lua": {
        "prefix": "ultraschall.MoveMediaItemsAfter_By",
        "scope": "lua",
        "description": "Moves all items after old_position by change_position_by-seconds. Affects only items, that begin after oldposition, so items that start before and end after old_position do not move.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nchange_position_by:the change of the position in seconds; positive - toward the end of the project, negative - toward the beginning.\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "ultraschall.MoveMediaItemsAfter_By(${1:number old_position},${2:number change_position_by},${3:string trackstring})$0"
    },
    "ULTRASCHALL.MOVEMEDIAITEMSBEFORE_BY lua": {
        "prefix": "ultraschall.MoveMediaItemsBefore_By",
        "scope": "lua",
        "description": "Moves all items before old_position by change_position_by-seconds. Affects only items, that end before oldposition, so items that start before and end after old_position do not move.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nchange_position_by:the change of the position in seconds; positive - toward the end of the project, negative - toward the beginning.\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "ultraschall.MoveMediaItemsBefore_By(${1:number old_position},${2:number change_position_by},${3:string trackstring})$0"
    },
    "ULTRASCHALL.MOVEMEDIAITEMSBETWEEN_TO lua": {
        "prefix": "ultraschall.MoveMediaItemsBetween_To",
        "scope": "lua",
        "description": "Moves the items between sectionstart and sectionend to newposition, within the tracks given by trackstring.\nIf inside is set to true, only items completely within the section are moved; if set to false, also items are affected, that are just partially within the section.\nItems, that start after sectionstart, and therefore have an offset, will be moved to newposition+their offset. Keep that in mind.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nstartposition:begin of the item-selection in seconds\nendposition:end of the item-selection in seconds\nnewposition:new position in seconds\ntrackstring:the tracknumbers, separated by a ,\ninside:true, only items completely within the section; false, also items partially within the section\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "ultraschall.MoveMediaItemsBetween_To(${1:number startposition},${2:number endposition},${3:number newposition},${4:string trackstring},${5:boolean inside})$0"
    },
    "ULTRASCHALL.CHANGELENGTHOFMEDIAITEMS_FROMARRAY lua": {
        "prefix": "ultraschall.ChangeLengthOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the length of the MediaItems in MediaItemArray to newlength.\nThey will all be set to the new length, regardless of their old length. If you want to change the length of the items not >to< newlength, but >by< newlength, use ChangeDeltaLengthOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\nnewlength:the new length of the items in seconds\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "ultraschall.ChangeLengthOfMediaItems_FromArray(${1:array MediaItemArray},${2:number newlength})$0"
    },
    "ULTRASCHALL.CHANGEDELTALENGTHOFMEDIAITEMS_FROMARRAY lua": {
        "prefix": "ultraschall.ChangeDeltaLengthOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the length of the MediaItems in MediaItemArray by deltalength.\nIf you want to change the length of the items not >by< deltalength, but >to< deltalength, use ChangeLengthOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\ndeltalength:the change of the length of the items in seconds, positive value - longer, negative value - shorter\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "ultraschall.ChangeDeltaLengthOfMediaItems_FromArray(${1:array MediaItemArray},${2:number deltalength})$0"
    },
    "ULTRASCHALL.CHANGEOFFSETOFMEDIAITEMS_FROMARRAY lua": {
        "prefix": "ultraschall.ChangeOffsetOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the audio-offset of the MediaItems in MediaItemArray to newoffset.\nIt affects all(!) takes that the MediaItems has.\nIf you want to change the offset of the items not >to< newoffset, but >by< newoffset, use ChangeDeltaOffsetOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\nnewoffset:the new offset of the items in seconds\nRETURNS:\nretval:true, in case of success; false, in case of failure\n",
        "body": "ultraschall.ChangeOffsetOfMediaItems_FromArray(${1:array MediaItemArray},${2:number newoffset})$0"
    },
    "ULTRASCHALL.CHANGEDELTAOFFSETOFMEDIAITEMS_FROMARRAY lua": {
        "prefix": "ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the audio-offset of the MediaItems in MediaItemArray by deltaoffset.\nIt affects all(!) takes of the MediaItems have.\nIf you want to change the offset of the items not >by< deltaoffset, but >to< deltaoffset, use ChangeOffsetOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray(${1:array MediaItemArray},${2:number deltaoffset})$0"
    },
    "ULTRASCHALL.SECTIONCUT lua": {
        "prefix": "ultraschall.SectionCut",
        "scope": "lua",
        "description": "Cuts out all items between startposition and endposition in the tracks given by trackstring.\nReturns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition of the section in seconds\nendposition:the endposition of the section in seconds\ntrackstring:the tracknumbers, separated by ,\nadd_to_clipboard:true, puts the cut items into the clipboard; false, don't put into the clipboard\nRETURNS:\nnumber_items:the number of cut items\nMediaItemArray_StateChunk:an array with the mediaitem-states of the cut items.\n",
        "body": "ultraschall.SectionCut(${1:number startposition},${2:number endposition},${3:string trackstring},${4:boolean add_to_clipboard})$0"
    },
    "ULTRASCHALL.SECTIONCUT_INVERSE lua": {
        "prefix": "ultraschall.SectionCut_Inverse",
        "scope": "lua",
        "description": "Cuts out all items before(!) startposition and after(!) endposition in the tracks given by trackstring; it keeps all items inbetween startposition and endposition.\nReturns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition of the section in seconds\nendposition:the endposition of the section in seconds\ntrackstring:the tracknumbers, separated by ,\nadd_to_clipboard:true, puts the cut items into the clipboard; false, don't put into the clipboard\nRETURNS:\nnumber_items_beforestart:the number of cut items before startposition\nMediaItemArray_StateChunk_beforestart:an array with the mediaitem-states of the cut items before startposition\nnumber_items_afterend:the number of cut items after endposition\nMediaItemArray_StateChunk_afterend:an array with the mediaitem-states of the cut items after endposition\n",
        "body": "ultraschall.SectionCut_Inverse(${1:number startposition},${2:number endposition},${3:string trackstring},${4:boolean add_to_clipboard})$0"
    },
    "ULTRASCHALL.RIPPLECUT lua": {
        "prefix": "ultraschall.RippleCut",
        "scope": "lua",
        "description": "Cuts out all items between startposition and endposition in the tracks given by trackstring. After cut, it moves the remaining items after(!) endposition toward projectstart, by the difference between start and endposition.\nReturns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition of the section in seconds\nendposition:the endposition of the section in seconds\ntrackstring:the tracknumbers, separated by ,\nmoveenvelopepoints:moves envelopepoints, if existing, as well\nadd_to_clipboard:true, puts the cut items into the clipboard; false, don't put into the clipboard\nRETURNS:\nnumber_items:the number of cut items\nMediaItemArray_StateChunk:an array with the mediaitem-states of the cut items\n",
        "body": "ultraschall.RippleCut(${1:number startposition},${2:number endposition},${3:string trackstring},${4:boolean moveenvelopepoints},${5:boolean add_to_clipboard})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEM_MEDIAITEM lua": {
        "prefix": "ultraschall.InsertMediaItem_MediaItem",
        "scope": "lua",
        "description": "Inserts MediaItem in MediaTrack at position. Returns the newly created(or better: inserted) MediaItem as well as startposition, endposition and length of the inserted item.\nReturns -1 in case of failure.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItem:the MediaItem that shall be inserted into a track\nMediaTrack:the track, where the item shall be inserted to\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nMediaItem:the newly created MediaItem\nstartposition:the startposition of the inserted MediaItem in seconds\nendposition:the endposition of the inserted MediaItem in seconds\nlength:the length of the inserted MediaItem in seconds\n",
        "body": "ultraschall.InsertMediaItem_MediaItem(${1:number position},${2:MediaItem MediaItem},${3:MediaTrack MediaTrack})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEM_MEDIAITEMSTATECHUNK lua": {
        "prefix": "ultraschall.InsertMediaItem_MediaItemStateChunk",
        "scope": "lua",
        "description": "Inserts a new MediaItem in MediaTrack at position. Uses a mediaitem-state-chunk as created by functions like GetAllMediaItemsBetween, reaper.GetItemStateChunk and reaper.SetItemStateChunk.. Returns the newly created MediaItem.\nReturns -1 in case of failure.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaTrack:the track, where the item shall be inserted to; nil, use the statechunk-entry ULTRASCHALL_TRACKNUMBER for the track instead.\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nMediaItem:the newly created MediaItem\nstartposition:the startposition of the inserted MediaItem in seconds\nendposition:the endposition of the inserted MediaItem in seconds\nlength:the length of the inserted MediaItem in seconds\n",
        "body": "ultraschall.InsertMediaItem_MediaItemStateChunk(${1:number position},${2:string MediaItemStateChunk},${3:MediaTrack MediaTrack})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEMARRAY lua": {
        "prefix": "ultraschall.InsertMediaItemArray",
        "scope": "lua",
        "description": "Inserts the MediaItems from MediaItemArray at position into the tracks, as given by trackstring.\nReturns the number of newly created items, as well as an array with the newly create MediaItems.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemArray:an array with the MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nRETURNS:\nnumber_of_items:the number of MediaItems created\nMediaItemArray:an array with the newly created MediaItems\n",
        "body": "ultraschall.InsertMediaItemArray(${1:number position},${2:array MediaItemArray},${3:string trackstring})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSTATECHUNKSFROMITEMS lua": {
        "prefix": "ultraschall.GetMediaItemStateChunksFromItems",
        "scope": "lua",
        "description": "Returns the MediaItem-StateChunks for all MediaItems in MediaItemArray. It returns the number of items as well as an array, with each entry one MediaItemStateChunk.\nStateChunks are used by the reaper-functions reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nMediaItemArray:an array with the MediaItems you want the statechunks of\nRETURNS:\nnumber_of_items:the number of trackstatechunks, usually the same as MediaItems in MediaItemArray\nMediaItemArray_StateChunks:an array with the StateChunks of the MediaItems in MediaItemArray\n",
        "body": "ultraschall.GetMediaItemStateChunksFromItems(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.RIPPLEINSERT lua": {
        "prefix": "ultraschall.RippleInsert",
        "scope": "lua",
        "description": "It inserts the MediaItems from MediaItemArray at position into the tracks, as given by trackstring. It moves the items, that were there before, accordingly toward the end of the project.\nReturns the number of newly created items, as well as an array with the newly created MediaItems and the endposition of the last(projectposition) inserted item into the project.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemArray:an array with the MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nmoveenvelopepoints:true, move the envelopepoints as well; false, keep the envelopepoints where they are\nmovemarkers:true, move markers as well; false, keep markers where they are\nRETURNS:\nnumber_of_items:the number of newly created items\nMediaItemArray:an array with the newly created MediaItems\nendpos_inserted_items:the endposition of the last newly inserted MediaItem\n",
        "body": "ultraschall.RippleInsert(${1:number position},${2:array MediaItemArray},${3:string trackstring},${4:boolean moveenvelopepoints},${5:boolean movemarkers})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEMSTATECHUNKARRAY lua": {
        "prefix": "ultraschall.InsertMediaItemStateChunkArray",
        "scope": "lua",
        "description": "Inserts the MediaItems from MediaItemStateChunkArray at position into the tracks, as given by trackstring.\nNote:Needs ULTRASCHALL_TRACKNUMBER within the statechunks, which includes the tracknumber for each mediaitem to be included. Else it will return -1. That entry will be included automatically into the MediaItemStateChunkArray as provided by GetAllMediaItemsBetween. If you need to manually insert that entry into a statechunk, use SetItemUSTRackNumber_StateChunk.\nReturns the number of newly created items, as well as an array with the newly create MediaItems.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from(or the tracks set with the entry ULTRASCHALL_TRACKNUMBER). Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemStateChunkArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemStateChunkArray:an array with the statechunks of the MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nRETURNS:\nnumber_of_items:the number of MediaItems created\nMediaItemArray:an array with the newly created MediaItems\n",
        "body": "ultraschall.InsertMediaItemStateChunkArray(${1:number position},${2:array MediaItemStateChunkArray},${3:string trackstring})$0"
    },
    "ULTRASCHALL.RIPPLEINSERT_MEDIAITEMSTATECHUNKS lua": {
        "prefix": "ultraschall.RippleInsert_MediaItemStateChunks",
        "scope": "lua",
        "description": "It inserts the MediaItems from MediaItemStateChunkArray at position into the tracks, as given by trackstring. It moves the items, that were there before, accordingly toward the end of the project.\nReturns the number of newly created items, as well as an array with the newly created MediaItems as statechunks and the endposition of the last(projectposition) inserted item into the project.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemStateChunkArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemStateChunkArray:an array with the statechunks of MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nmoveenvelopepoints:true, move the envelopepoints as well; false, keep the envelopepoints where they are\nmovemarkers:true, move markers as well; false, keep markers where they are\nRETURNS:\nnumber_of_items:the number of newly created items\nMediaItemStateChunkArray:an array with the newly created MediaItems as StateChunkArray\nendpos_inserted_items:the endposition of the last newly inserted MediaItem\n",
        "body": "ultraschall.RippleInsert_MediaItemStateChunks(${1:number position},${2:array MediaItemStateChunkArray},${3:string trackstring},${4:boolean moveenvelopepoints},${5:boolean movemarkers})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSFROMTRACK lua": {
        "prefix": "ultraschall.GetAllMediaItemsFromTrack",
        "scope": "lua",
        "description": "returns the number of items of tracknumber, as well as an array with all MediaItems and an array with all MediaItemStateChunks\nreturns -1 in case of error\nPARAMETERS:\ntracknumber:the tracknumber, from where you want to get the item\nRETURNS:\nitemcount:the number of items in that track\nMediaItemArray:an array with all MediaItems from this track\nMediaItemStateChunkArray:an array with all MediaItemStateCunks from this track\n",
        "body": "ultraschall.GetAllMediaItemsFromTrack(${1:integer tracknumber})$0"
    },
    "ULTRASCHALL.SETITEMSLOCKSTATE lua": {
        "prefix": "ultraschall.SetItemsLockState",
        "scope": "lua",
        "description": "Sets the lockstate of the items in MediaItemArray. Set lockstate=true to set the items locked; false to set them unlocked.\nreturns true in case of success, false in case of error\nPARAMETERS:\nMediaItemArray:an array with the MediaItems to be processed\nlockstate:true, to set the MediaItems to locked, false to set them to unlocked\nRETURNS:\nretval:true in case of success, false in case of error\n",
        "body": "ultraschall.SetItemsLockState(${1:array MediaItemArray},${2:boolean lockstate})$0"
    },
    "ULTRASCHALL.ADDLOCKSTATETOMEDIAITEMSTATECHUNK lua": {
        "prefix": "ultraschall.AddLockStateToMediaItemStateChunk",
        "scope": "lua",
        "description": "Sets the lockstate in a MediaItemStateChunk. Set lockstate=true to set the chunk locked; false to set it unlocked.\nDoes not apply the changes to the MediaItem itself. To do that, use reaper.GetItemStateChunk or ApplyStateChunkToItems!\nreturns the changed MediaItemStateChunk\nreturns -1 in case of failure\nPARAMETERS:\nMediaItemStateChunk:the statechunk of the item to be processed, as returned by functions like reaper.GetItemStateChunk\nlockstate:true, to set the MediaItemStateChunk to locked, false to set it to unlocked\nRETURNS:\nchangedMediaItemStateChunk:the lockstate-modified MediaItemStateChunk\n",
        "body": "ultraschall.AddLockStateToMediaItemStateChunk(${1:string MediaItemStateChunk},${2:boolean lockstate})$0"
    },
    "ULTRASCHALL.ADDLOCKSTATETO_MEDIAITEMSTATECHUNKARRAY lua": {
        "prefix": "ultraschall.AddLockStateTo_MediaItemStateChunkArray",
        "scope": "lua",
        "description": "Sets the lockstates in a MediaItemStateChunkArray. Set lockstate=true to set the chunks locked; false to set them unlocked.\nDoes not apply the changes to the MediaItem itself. To do that, use reaper.GetItemStateChunk or ApplyStateChunkToItems!\nreturns the number of entries and the altered MediaItemStateChunkArray; -1 in case of failure\nPARAMETERS:\nMediaItemStateChunkArray:the statechunkarray of the items to be processed, as returned by functions like reaper.GetItemStateChunk\nlockstate:true, to set the MediaItemStateChunk to locked, false to set it to unlocked\nRETURNS:\ncount:the number of entries in the changed MediaItemStateChunkArray\nchangedMediaItemStateChunkArray:the lockstate-modified MediaItemStateChunkArray\n",
        "body": "ultraschall.AddLockStateTo_MediaItemStateChunkArray(${1:array MediaItemStateChunkArray},${2:boolean lockstate})$0"
    },
    "ULTRASCHALL.APPLYSTATECHUNKTOITEMS lua": {
        "prefix": "ultraschall.ApplyStateChunkToItems",
        "scope": "lua",
        "description": "Applies changed StateChunks to the respective items. Skips deleted items, as they can't be set.\nIt will look into the IGUID-entry of the statechunks, to find the right corresponding MediaItem to apply the statechunk to.\nreturns the number of entries and the altered MediaItemStateChunkArray; -1 in case of failure\nPARAMETERS:\nMediaItemStateChunkArray:the statechunkarray of the items to be applied, as returned by functions like reaper.GetItemStateChunk\nundostate:true, sets the changed undo-possible, false undo-impossible\nRETURNS:\nretval:true it worked, false it didn't\nskippeditemscount:the number of entries that couldn't be applied\nskipped_MediaItemStateChunkArray:the StateChunks, that couldn't be aplied\n",
        "body": "ultraschall.ApplyStateChunkToItems(${1:array MediaItemStateChunkArray},${2:boolean undostate})$0"
    },
    "ULTRASCHALL.GETALLLOCKEDITEMSFROMMEDIAITEMARRAY lua": {
        "prefix": "ultraschall.GetAllLockedItemsFromMediaItemArray",
        "scope": "lua",
        "description": "Returns the number and the items that are locked, as well as the number and the items that are NOT locked.\nThe items are returned as MediaItemArrays\nreturns -1 in case of failure\nPARAMETERS:\nMediaItemArray:the statechunkarray of the items to be checked.\nRETURNS:\ncountlock:the number of locked items. -1 in case of failure\nlocked_MediaItemArray:the un(!)locked items in a mediaitemarray\ncountunlock:the number of un(!)locked items\nunlocked_MediaItemArray:the un(!)locked items in a mediaitemarray\n",
        "body": "ultraschall.GetAllLockedItemsFromMediaItemArray(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSTATECHUNKSFROMMEDIAITEMARRAY lua": {
        "prefix": "ultraschall.GetMediaItemStateChunksFromMediaItemArray",
        "scope": "lua",
        "description": "Returns the number of items and statechunks of the Items in MediaItemArray. It skips items in MediaItemArray, that are deleted.\nreturns -1 in case of failure\nPARAMETERS:\nMediaItemArray:the statechunkarray of the items to be checked.\nRETURNS:\ncount:the number of statechunks returned. -1 in case of failure\nMediaItemStateChunkArray:the statechunks of the items in mediaitemarray\n",
        "body": "ultraschall.GetMediaItemStateChunksFromMediaItemArray(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETSELECTEDMEDIAITEMSATPOSITION lua": {
        "prefix": "ultraschall.GetSelectedMediaItemsAtPosition",
        "scope": "lua",
        "description": "Returns all selected items at position in the tracks as given by trackstring, as MediaItemArray. Empty MediaItemAray if none is found.\nreturns -1 in case of error\nPARAMETERS:\nposition:position in seconds\ntrackstring:the tracknumbers, separated by commas\nRETURNS:\ncount:the number of entries in the returned MediaItemArray\nMediaItemArray:the found MediaItems returned as an array\n",
        "body": "ultraschall.GetSelectedMediaItemsAtPosition(${1:number position},${2:string trackstring})$0"
    },
    "ULTRASCHALL.GETSELECTEDMEDIAITEMSBETWEEN lua": {
        "prefix": "ultraschall.GetSelectedMediaItemsBetween",
        "scope": "lua",
        "description": "Returns all selected items between startposition and endposition in the tracks as given by trackstring, as MediaItemArray. Empty MediaItemAray if none is found.\nreturns -1 in case of error\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntrackstring:the tracknumbers, separated by commas\ninside:true, only items completely within start/endposition; false, also items, that are partially within start/endposition\nRETURNS:\ncount:the number of entries in the returned MediaItemArray\nMediaItemArray:the found MediaItems returned as an array\n",
        "body": "ultraschall.GetSelectedMediaItemsBetween(${1:number startposition},${2:number endposition},${3:string trackstring},${4:boolean inside})$0"
    },
    "ULTRASCHALL.DESELECTMEDIAITEMS_MEDIAITEMARRAY lua": {
        "prefix": "ultraschall.DeselectMediaItems_MediaItemArray",
        "scope": "lua",
        "description": "Deselects all MediaItems, that are in MediaItemArray.\nreturns -1 in case of error\nPARAMETERS:\nMediaItemArray:an array with all the MediaItemObjects, that shall be deselected\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.DeselectMediaItems_MediaItemArray(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.SELECTMEDIAITEMS_MEDIAITEMARRAY lua": {
        "prefix": "ultraschall.SelectMediaItems_MediaItemArray",
        "scope": "lua",
        "description": "Selects all MediaItems, that are in MediaItemArray.\nreturns -1 in case of error\nPARAMETERS:\nMediaItemArray:an array with all the MediaItemObjects, that shall be selected\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SelectMediaItems_MediaItemArray(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.ENUMERATEMEDIAITEMSINTRACK lua": {
        "prefix": "ultraschall.EnumerateMediaItemsInTrack",
        "scope": "lua",
        "description": "returns the itemnumberth MediaItemobject in track, the number of items in tracknumber and an array with all MediaItems from this track.\nreturns -1 in case of error\nPARAMETERS:\ntracknumber:the tracknumber, from where you want to get the item\nitemnumber:the itemnumber within that track. 1 for the first, 2 for the second, etc\nRETURNS:\nitem:the number of items in that track\nitemcount:the number of items in that track\nMediaItemArray:an array with all MediaItems from this track\n",
        "body": "ultraschall.EnumerateMediaItemsInTrack(${1:integer tracknumber},${2:integer itemnumber})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMARRAYLENGTH lua": {
        "prefix": "ultraschall.GetMediaItemArrayLength",
        "scope": "lua",
        "description": "Returns the beginning of the first item, the end of the last item as well as the length between start and end of all items within the MediaItemArray.\nWill return -1, in case of error\nPARAMETERS:\nMediaItemArray:an array with MediaItems, as returned by functions like GetAllMediaItemsBetween or GetMediaItemsAtPosition or similar.\nRETURNS:\nstart:the beginning of the earliest item in the MediaItemArray in seconds\nend:the end of the latest item in the MediaItemArray, timewise, in seconds\nlength:the length of the MediaItemArray in seconds\n",
        "body": "ultraschall.GetMediaItemArrayLength(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSTATECHUNKARRAYLENGTH lua": {
        "prefix": "ultraschall.GetMediaItemStateChunkArrayLength",
        "scope": "lua",
        "description": "Returns the beginning of the first item, the end of the last item as well as the length between start and end of all items within the MediaItemStateChunkArray.\nWill return -1, in case of error\nPARAMETERS:\nMediaItemStateChunkArray:an array with MediaItemStateChunks, as returned by functions like GetAllMediaItemsBetween or GetMediaItemsAtPosition or similar.\nRETURNS:\nstart:the beginning of the earliest item in the MediaItemArray in seconds\nend:the end of the latest item in the MediaItemArray, timewise, in seconds\nlength:the length of the MediaItemArray in seconds\n",
        "body": "ultraschall.GetMediaItemStateChunkArrayLength(${1:array MediaItemStateChunkArray})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMGUIDS lua": {
        "prefix": "ultraschall.GetAllMediaItemGUIDs",
        "scope": "lua",
        "description": "Returns an array with all MediaItem-GUIDs in order of the MediaItems-count(1 for first MediaItem, etc).\nReturns nil in case of an error\n",
        "body": "ultraschall.GetAllMediaItemGUIDs()$0"
    },
    "ULTRASCHALL.GETITEMSPECTRALCONFIG lua": {
        "prefix": "ultraschall.GetItemSpectralConfig",
        "scope": "lua",
        "description": "returns the item-spectral-config, which is the fft-size of the spectral view for this item.\nset itemidx to -1 to use the optional parameter MediaItemStateChunk to alter a MediaItemStateChunk instead of an item directly.\nreturns -1 in case of error or nil if no spectral-config exists(e.g. when no spectral-edit is applied to this item)\nPARAMETERS:\nitemidx:the number of the item, with 1 for the first item, 2 for the second, etc.; -1, to use the parameter MediaItemStateChunk\nMediaItemStateChunk:you can give a MediaItemStateChunk to process, if itemidx is set to -1\nRETURNS:\nitem_spectral_config:the fft-size in points for the spectral-view; 16, 32, 64, 128, 256, 512, 1024(default), 2048, 4096, 8192; -1, if not existing\n",
        "body": "ultraschall.GetItemSpectralConfig(${1:integer itemidx},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMSPECTRALCONFIG lua": {
        "prefix": "ultraschall.SetItemSpectralConfig",
        "scope": "lua",
        "description": "sets the item-spectral-config, which is the fft-size of the spectral view for this item.\nreturns false in case of error or if no spectral-config exists(e.g. when no spectral-edit is applied to this item)\nPARAMETERS:\nitemidx:the number of the item, with 1 for the first item, 2 for the second, etc.; -1, if you want to use the optional parameter MediaItemStateChunk\nitem_spectral_config:the fft-size in points for the spectral-view; 16, 32, 64, 128, 256, 512, 1024(default), 2048, 4096, 8192; nil, to remove it\nMediaItemStateChunk:a MediaItemStateChunk you want to have altered; works only, if itemdidx is set to -1, otherwise it will be ignored\nRETURNS:\nretval:true, if setting spectral-config worked; false, if not\nMediaItemStateChunk:the altered MediaItemStateChunk\n",
        "body": "ultraschall.SetItemSpectralConfig(${1:integer itemidx},${2:integer item_spectral_config},${3:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.COUNTITEMSPECTRALEDITS lua": {
        "prefix": "ultraschall.CountItemSpectralEdits",
        "scope": "lua",
        "description": "counts the number of SPECTRAL_EDITs in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns -1 in case of error\nPARAMETERS:\nitemidx:the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\ncount:the number of spectral-edits available in a given MediaItem/MediaItemStateChunk\n",
        "body": "ultraschall.CountItemSpectralEdits(${1:integer itemidx},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSPECTRALEDIT lua": {
        "prefix": "ultraschall.GetItemSpectralEdit",
        "scope": "lua",
        "description": "returns the settings of a specific SPECTRAL_EDIT in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns -1 in case of error\nPARAMETERS:\nitemidx:the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead\nspectralidx:the number of the spectral-edit to return; 1 for the first, 2 for the second, etc\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\nstart_pos:the startposition of the spectral-edit-region in seconds\nlength:the length of the spectral-edit-region in seconds\ngain:the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB\nfade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_range_bottom:the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nfreq_range_top:the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\nbyp_solo:sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo\ngate_thres:sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)\ngate_floor:sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)\ncomp_thresh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\ncomp_exp_ratio:sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default\nn:negative with low frequency-fade, positive with high-frequency-fade\no:unknown\nfade2:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade2:negative with low frequency-fade, positive with high-frequency-fade\n",
        "body": "ultraschall.GetItemSpectralEdit(${1:integer itemidx},${2:integer spectralidx},${3:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.DELETEITEMSPECTRALEDIT lua": {
        "prefix": "ultraschall.DeleteItemSpectralEdit",
        "scope": "lua",
        "description": "deletes a specific SPECTRAL_EDIT in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns false in case of error\nPARAMETERS:\nitemidx:the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead\nspectralidx:the number of the spectral-edit to delete; 1 for the first, 2 for the second, etc\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\nretval:true, if deleting an spectral-edit-entry was successful; false, if it was unsuccessful\nMediaItemStateChunk:the altered MediaItemStateChunk\n",
        "body": "ultraschall.DeleteItemSpectralEdit(${1:integer itemidx},${2:integer spectralidx},${3:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMSPECTRALVISIBILITYSTATE lua": {
        "prefix": "ultraschall.SetItemSpectralVisibilityState",
        "scope": "lua",
        "description": "Sets SPECTROGRAM-state in a MediaItem or MediaItemStateChunk.\nSetting it shows the spectrogram, in which you can do spectral-editing, as selected in the MediaItem-menu \"Spectral-editing -> Toggle show spectrogram for selected items\"\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nitemidx:the number of the item in the project; use -1 to use MediaItemStateChunk instead\nstate:the state of the SPECTROGRAM; 0, to hide SpectralEdit; 1, to set SpectralEdit visible\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk; only read, when itemidx=-1\nRETURNS:\nMediaItemStateChunk:the altered rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "ultraschall.SetItemSpectralVisibilityState(${1:integer itemidx},${2:integer state},${3:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMSPECTRALEDIT lua": {
        "prefix": "ultraschall.SetItemSpectralEdit",
        "scope": "lua",
        "description": "Sets a spectral-edit-instance in a MediaItem or MediaItemStateChunk.\nAfter committing the changed MediaItemStateChunk to a MediaItem, Reaper may change the order of the spectral-edits! Keep that in mind, when changing numerous Spectral-Edits or use MediaItemStateChunks for the setting before committing them to a MediaItem using Reaper's function reaper.SetItemStateChunk().\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nitemidx:the number of the item in the project; use -1 to use MediaItemStateChunk instead\nspectralidx:the number of the spectral-edit-instance, that you want to set\nstart_pos:the startposition of the spectral-edit-region in seconds\nlength:the length of the spectral-edit-region in seconds\ngain:the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB\nfade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_range_bottom:the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nfreq_range_top:the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nh:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nbyp_solo:sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo\ngate_thres:sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)\ngate_floor:sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)\ncomp_thresh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\ncomp_exp_ratio:sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default\nn:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\no:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nfade2:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade2:negative with low frequency-fade, positive with high-frequency-fade\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "ultraschall.SetItemSpectralEdit(${1:integer itemidx},${2:integer spectralidx},${3:number start_pos},${4:number length},${5:number gain},${6:number fade},${7:number freq_fade},${8:number freq_range_bottom},${9:number freq_range_top},${10:integer h},${11:integer byp_solo},${12:number gate_thres},${13:number gate_floor},${14:number comp_thresh},${15:number comp_exp_ratio},${16:number n},${17:number o},${18:number fade2},${19:number freq_fade2},${20:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSOURCEFILE_TAKE lua": {
        "prefix": "ultraschall.GetItemSourceFile_Take",
        "scope": "lua",
        "description": "returns filename, the PCM_Source-object and the MediaItem_Take-object of a specific take. Use take_nr=0 for active take.\nreturns nil in case of error\nPARAMETERS:\nMediaItem:the MediaItem-object, in which the requested take lies\ntake_nr:the number of the requested take; use 0 for the active take\nRETURNS:\nsource_filename:the filename of the requested take\nsource:the PCM_source-object of the requested take\ntake:the Media-Item_Take-object of the requested take\n",
        "body": "ultraschall.GetItemSourceFile_Take(${1:MediaItem MediaItem},${2:integer take_nr})$0"
    },
    "ULTRASCHALL.ADDITEMSPECTRALEDIT lua": {
        "prefix": "ultraschall.AddItemSpectralEdit",
        "scope": "lua",
        "description": "Adds a new SPECTRAL_EDIT-entry in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns false in case of error\nPARAMETERS:\nitemidx:the MediaItem to add to another spectral-edit-entry; -1, to use the parameter MediaItemStateChunk instead\nstart_pos:the startposition of the spectral-edit-region in seconds\nlength:the length of the spectral-edit-region in seconds\ngain:the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB\nfade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_range_bottom:the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nfreq_range_top:the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nh:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nbyp_solo:sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo\ngate_thres:sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)\ngate_floor:sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)\ncomp_thresh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\ncomp_exp_ratio:sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default\nn:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\no:unknown\nfade2:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade2:negative with low frequency-fade, positive with high-frequency-fade\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\nretval:true, if adding was successful; false, if adding wasn't successful\nstatechunk:the altered MediaItemStateChunk\n",
        "body": "ultraschall.AddItemSpectralEdit(${1:integer itemidx},${2:number start_pos},${3:number length},${4:number gain},${5:number fade},${6:number freq_fade},${7:number freq_range_bottom},${8:number freq_range_top},${9:integer h},${10:integer byp_solo},${11:number gate_thres},${12:number gate_floor},${13:number comp_thresh},${14:number comp_exp_ratio},${15:number n},${16:number o},${17:number fade2},${18:number freq_fade2},${19:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSPECTRALVISIBILITYSTATE lua": {
        "prefix": "ultraschall.GetItemSpectralVisibilityState",
        "scope": "lua",
        "description": "returns, if spectral-editing is shown in the arrange-view of item itemidx\nset itemidx to -1 to use the optional parameter MediaItemStateChunk to alter a MediaItemStateChunk instead of an item directly.\nreturns -1 in case of error\nPARAMETERS:\nitemidx:the number of the item, with 1 for the first item, 2 for the second, etc.; -1, to use the parameter MediaItemStateChunk\nMediaItemStateChunk:you can give a MediaItemStateChunk to process, if itemidx is set to -1\n",
        "body": "ultraschall.GetItemSpectralVisibilityState(${1:integer itemidx},${2:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.INSERTIMAGEFILE lua": {
        "prefix": "ultraschall.InsertImageFile",
        "scope": "lua",
        "description": "Inserts a supported image-file into your project.\nDue API-limitations, it creates two undo-points(one for inserting the MediaItem and one for changing the length).\nReturns false in case of an error\nPARAMETERS:\nfilename_with_path:the file to check for it's image-fileformat\ntrack:the track, in which the image shall be inserted\nposition:the position of the inserted image in seconds\nlength:the length of the image-item in seconds; 1, for the default length of 1 second\nlooped:true, loop the inserted image-file; false, don't loop the inserted image-file\nRETURNS:\nretval:true, if inserting was successful; false, if inserting was unsuccessful\nitem:the MediaItem of the newly inserted image\n",
        "body": "ultraschall.InsertImageFile(${1:string filename_with_path},${2:integer track},${3:number position},${4:number length},${5:boolean looped})$0"
    },
    "ULTRASCHALL.GETALLSELECTEDMEDIAITEMS lua": {
        "prefix": "ultraschall.GetAllSelectedMediaItems",
        "scope": "lua",
        "description": "Returns all selected items in the project as MediaItemArray. Empty MediaItemAray if none is found.\nRETURNS:\ncount:the number of entries in the returned MediaItemArray\nMediaItemArray:all selected MediaItems returned as an array\nMediaItemStateChunkArray:the statechunks of all found MediaItems as an array\n",
        "body": "ultraschall.GetAllSelectedMediaItems()$0"
    },
    "ULTRASCHALL.SETMEDIAITEMSSELECTED_TIMESELECTION lua": {
        "prefix": "ultraschall.SetMediaItemsSelected_TimeSelection",
        "scope": "lua",
        "description": "Sets all MediaItems selected, that are within the time-selection.\n",
        "body": "ultraschall.SetMediaItemsSelected_TimeSelection()$0"
    },
    "ULTRASCHALL.GETPARENTTRACK_MEDIAITEM lua": {
        "prefix": "ultraschall.GetParentTrack_MediaItem",
        "scope": "lua",
        "description": "Returns the tracknumber and the MediaTrack-object of the track in which the MediaItem is placed.\nreturns -1 in case of error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to know the track is is placed in\nRETURNS:\ntracknumber:the tracknumber of the track, in which the MediaItem is placed; 1 for track 1, 2 for track 2, etc\nmediatrack:the MediaTrack-object of the track, in which the MediaItem is placed\n",
        "body": "ultraschall.GetParentTrack_MediaItem(${1:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.ISITEMINTRACK2 lua": {
        "prefix": "ultraschall.IsItemInTrack2",
        "scope": "lua",
        "description": "Checks, whether a MediaItem is in track with tracknumber.\nsee IsItemInTrack to use itemidx instead of the MediaItem-object.\nsee IsItemInTrack3 to check against multiple tracks at once using a trackstring.\nreturns nil in case of error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to know the track is is placed in\ntracknumber:the tracknumber to check the parent track of the MediaItem against, with 1 for track 1, etc\nRETURNS:\nretval:true, if item is in track; false, if not\ntracknumber:the tracknumber of the track, in which the item lies\n",
        "body": "ultraschall.IsItemInTrack2(${1:MediaItem MediaItem},${2:integer tracknumber})$0"
    },
    "ULTRASCHALL.ISITEMINTIMERANGE lua": {
        "prefix": "ultraschall.IsItemInTimerange",
        "scope": "lua",
        "description": "checks, whether a given MediaItem is within startposition and endposition and returns the result.\nreturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem to check for, if it's within the timerange\nendposition:the endtime of the timerange, in which the MediaItem must be, in seconds\ninside:true, MediaItem must be fully within timerange; false, MediaItem can be partially inside timerange\nRETURNS:\nretval:true, item is in timerange; false, item isn't in timerange\n",
        "body": "ultraschall.IsItemInTimerange(${1:MediaItem MediaItem},${2:number startposiiton},${3:number endposition},${4:boolean inside})$0"
    },
    "ULTRASCHALL.ONLYITEMSINTRACKSANDTIMERANGE lua": {
        "prefix": "ultraschall.OnlyItemsInTracksAndTimerange",
        "scope": "lua",
        "description": "Removes all items from MediaItemArray, that aren't in tracks, as given by trackstring and are outside the timerange(starttime to endtime).\nreturns -1 in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, that shall be checked for trackexistence and timerange\ntrackstring:a string with all requested tracknumbers in which the MediaItem must be, separated by commas; 1 for track 1, 2 for track 2, etc\nstarttime:the starttime of the timerange, in which the MediaItem must be, in seconds\nendtime:the endtime of the timerange, in which the MediaItem must be, in seconds\ninside:true, only MediaItems are returned, that are fully within starttime and endtime; false, return also MediaItems partially in timerange\nRETURNS:\ncount:the number of items that fit the requested tracks and timerange\nMediaItemArray:the altered MediaItemArray, that has only the MediaItems from tracks as requested by trackstring and from within timerange\n",
        "body": "ultraschall.OnlyItemsInTracksAndTimerange(${1:MediaItemArray MediaItemArray},${2:string trackstring},${3:number starttime},${4:number endtime},${5:boolean inside})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOMEDIAITEM lua": {
        "prefix": "ultraschall.ApplyActionToMediaItem",
        "scope": "lua",
        "description": "Applies an action to a MediaItem, in either main or MIDI-Editor section-context.\nThe action given must support applying itself to selected items.\nReturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, to whom the action shall be applied to\nactioncommandid:the commandid-number or ActionCommandID, that shall be run.\nrepeat_action:the number of times this action shall be applied to each item; minimum value is 1\nmidi:true, run an action from MIDI-Editor-section-context; false, run an action from the main section\nMIDI_hwnd:the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one\nRETURNS:\nretval:true, if running the action was successful; false, if not or an error occured\n",
        "body": "ultraschall.ApplyActionToMediaItem(${1:MediaItem MediaItem},${2:string actioncommandid},${3:integer repeat_action},${4:boolean midi},${5:optional HWND MIDI_hwnd})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOMEDIAITEMARRAY lua": {
        "prefix": "ultraschall.ApplyActionToMediaItemArray",
        "scope": "lua",
        "description": "Applies an action to the MediaItems in MediaItemArray, in either main or MIDI-Editor section-context\nThe action given must support applying itself to selected items.\nThis function applies the action to each MediaItem individually. To apply the action to all MediaItems in MediaItemArray at once, see ApplyActionToMediaItemArray2.\nReturns false in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, to whom the action shall be applied to\nactioncommandid:the commandid-number or ActionCommandID, that shall be run.\nrepeat_action:the number of times this action shall be applied to each item; minimum value is 1\nmidi:true, run an action from MIDI-Editor-section-context; false, run an action from the main section\nMIDI_hwnd:the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one\nRETURNS:\nretval:true, if running the action was successful; false, if not or an error occured\n",
        "body": "ultraschall.ApplyActionToMediaItemArray(${1:MediaItemArray MediaItemArray},${2:string actioncommandid},${3:integer repeat_action},${4:boolean midi},${5:optional HWND MIDI_hwnd})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSINTIMESELECTION lua": {
        "prefix": "ultraschall.GetAllMediaItemsInTimeSelection",
        "scope": "lua",
        "description": "Gets all MediaItems from within a time-selection\nReturns -1 in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers, separated by a comma; 1 for the first track, 2 for the second\nRETURNS:\ncount:the number of items found in time-selection\nMediaItemArray:an array with all MediaItems found within time-selection\n",
        "body": "ultraschall.GetAllMediaItemsInTimeSelection(${1:string trackstring},${2:boolean inside})$0"
    },
    "ULTRASCHALL.NORMALIZEITEMS lua": {
        "prefix": "ultraschall.NormalizeItems",
        "scope": "lua",
        "description": "Normalizes all items in MediaItemArray.\nReturns -1 in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, that shall be normalized\nRETURNS:\nretval:-1, in case of an error\n",
        "body": "ultraschall.NormalizeItems(${1:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMS lua": {
        "prefix": "ultraschall.GetAllMediaItems",
        "scope": "lua",
        "description": "Returns a MediaItemArray with all MediaItems in the current project\nRETURNS:\nitemcount:the number of items in the MediaItemArray\nMediaItemArray:an array with all MediaItems from the current project\n",
        "body": "ultraschall.GetAllMediaItems()$0"
    },
    "ULTRASCHALL.PREVIEWMEDIAITEM lua": {
        "prefix": "ultraschall.PreviewMediaItem",
        "scope": "lua",
        "description": "Will play a preview a given MediaItem.\nYou can just play one preview at a time, except when previewing additionally through the MediaExplorer.\nReturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to play a preview\nPreviewtype:the type of the preview\nRETURNS:\nretval:false, in case of error; true, in case of success\n",
        "body": "ultraschall.PreviewMediaItem(${1:MediaItem MediaItem},${2:integer Previewtype})$0"
    },
    "ULTRASCHALL.STOPANYPREVIEW lua": {
        "prefix": "ultraschall.StopAnyPreview",
        "scope": "lua",
        "description": "Stops any playing preview of a MediaItem.\n",
        "body": "ultraschall.StopAnyPreview()$0"
    },
    "ULTRASCHALL.PREVIEWMEDIAFILE lua": {
        "prefix": "ultraschall.PreviewMediaFile",
        "scope": "lua",
        "description": "Plays a preview of a media-file. You can only play one file at a time.\nReturns false in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the media-file to play\ngain:the gain of the volume; nil, defaults to 1\nloop:true, loop the previewed file; false or nil, don't loop the file\nRETURNS:\nretval:true, starting preview was successful; false, starting preview wasn't successful\n",
        "body": "ultraschall.PreviewMediaFile(${1:string filename_with_path},${2:optional number gain},${3:optional boolean loop})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMTAKE lua": {
        "prefix": "ultraschall.GetMediaItemTake",
        "scope": "lua",
        "description": "Returns the requested MediaItem-Take of MediaItem. Use TakeNr=0 for the active take(!)\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, of whom you want to request a certain take.\nTakeNr:the take that you want to request; 1 for the first; 2 for the second, etc; 0, for the current active take\nRETURNS:\nTake:the number of takes available within this Mediaitem\nTakeCount:the number of takes available within this Mediaitem\n",
        "body": "ultraschall.GetMediaItemTake(${1:MediaItem MediaItem},${2:integer TakeNr})$0"
    },
    "ULTRASCHALL.APPLYFUNCTIONTOMEDIAITEMARRAY lua": {
        "prefix": "ultraschall.ApplyFunctionToMediaItemArray",
        "scope": "lua",
        "description": "Applies function \"functionname\" on all items in MediaItemArray. Parameter ... is all parameters used for function \"functionname\", where you should use nil in place of the parameter that shall hold a MediaItem.\nReturns a table with a boolean(did the function run without an error) and all returnvalues returned by function \"functionname\".\nReturns nil in case of an error. Will NOT(!) stop execution, if function \"functionname\" produces an error(see table returnvalues for more details)\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, who you want to apply functionname to.\nfunctionname:the name of the function to apply to every MediaItem in MediaItemArray\n:This nil-parameter will be filled with the appropriate MediaItem by ApplyFunctionToMediaItemArray automatically\n:This nil-parameter will be filled with the appropriate MediaItem by ApplyFunctionToMediaItemArray automatically\n:This nil-parameter will be filled with the appropriate MediaItem by ApplyFunctionToMediaItemArray automatically\nRETURNS:\ntable returnvalues:all other tableentries contain the returnvalues, as returned by function \"functionname\"\n",
        "body": "ultraschall.ApplyFunctionToMediaItemArray(${1:MediaItemArray MediaItemArray},${2:function functionname},${3:functionparameters1},${4:...},${5:functionparametersn})$0"
    },
    "ULTRASCHALL.GETGAPSBETWEENITEMS lua": {
        "prefix": "ultraschall.GetGapsBetweenItems",
        "scope": "lua",
        "description": "Returns a table with all gaps between items in MediaTrack.\nReturns -1 in case of an error\nPARAMETERS:\nMediaTrack:the track, of which you want to have the gaps between items\nRETURNS:\nnumber_of_gaps:the number of gaps found between items; -1, in case of error\ngaptable:an array with all gappositions found\n",
        "body": "ultraschall.GetGapsBetweenItems(${1:MediaTrack MediaTrack})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEMS_BETWEEN lua": {
        "prefix": "ultraschall.DeleteMediaItems_Between",
        "scope": "lua",
        "description": "Delete the MediaItems between start- and endposition, from the tracks as given by trackstring.\nReturns also a MediaItemStateChunkArray, that contains the statechunks of all deleted MediaItem\nreturns false in case of an error\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\ntrackstring:the tracknumbers, separated by a comma\ninside:true, delete only MediaItems that are completely within start and endposition; false, also include MediaItems partially within start and endposition\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\nMediaItemStateChunkArray:and array with all statechunks of all deleted MediaItems; \n",
        "body": "ultraschall.DeleteMediaItems_Between(${1:number startposition},${2:number endposition},${3:string trackstring},${4:boolean inside})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOMEDIAITEMARRAY2 lua": {
        "prefix": "ultraschall.ApplyActionToMediaItemArray2",
        "scope": "lua",
        "description": "Applies an action to the MediaItems in MediaItemArray, in either main or MIDI-Editor section-context\nThe action given must support applying itself to selected items.\nThis function applies the action to all MediaItems at once. To apply the action to each MediaItem in MediaItemArray individually, see ApplyActionToMediaItemArray\nReturns false in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, to whom the action shall be applied to\nactioncommandid:the commandid-number or ActionCommandID, that shall be run.\nrepeat_action:the number of times this action shall be applied to each item; minimum value is 1\nmidi:true, run an action from MIDI-Editor-section-context; false, run an action from the main section\nMIDI_hwnd:the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one\nRETURNS:\nretval:true, if running the action was successful; false, if not or an error occured\n",
        "body": "ultraschall.ApplyActionToMediaItemArray2(${1:MediaItemArray MediaItemArray},${2:string actioncommandid},${3:integer repeat_action},${4:boolean midi},${5:optional HWND MIDI_hwnd})$0"
    },
    "ULTRASCHALL.GETMEDIAFILEATTRIBUTES lua": {
        "prefix": "ultraschall.GetMediafileAttributes",
        "scope": "lua",
        "description": "returns the attributes of a mediafile\nif the mediafile is an rpp-project, this function creates a proxy-file called filename.RPP-PROX, which is a wave-file of the length of the project.\nThis file can be deleted safely after that, but would be created again the next time this function is called.\nreturns -1 in case of an error\nPARAMETERS:\nfilename:the file whose attributes you want to have\nRETURNS:\nlength:the length of the mediafile in seconds\nnumchannels:the number of channels of the mediafile\nSamplerate:the samplerate of the mediafile in hertz\nFiletype:the type of the mediafile, like MP3, WAV, MIDI, FLAC, RPP_PROJECT etc\n",
        "body": "ultraschall.GetMediafileAttributes(${1:string filename})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEMFROMFILE lua": {
        "prefix": "ultraschall.InsertMediaItemFromFile",
        "scope": "lua",
        "description": "Inserts the mediafile filename into the project at position in track\nWhen giving an rpp-projectfile, it will be rendered by Reaper and inserted as subproject!\nDue API-limitations, it creates two undo-points: one for inserting the MediaItem and one for changing the length(when endposition isn't -1).\nReturns -1 in case of failure\nPARAMETERS:\nfilename:the path+filename of the mediafile to be inserted into the project\ntrack:the track, in which the file shall be inserted\nposition:the length of the newly created mediaitem; -1, use the length of the sourcefile\nendposition:the length of the newly created mediaitem; -1, use the length of the sourcefile\neditcursorpos:the position of the editcursor after insertion of the mediafile\noffset:an offset, to delay the insertion of the item, to overcome possible \"too late\"-starting of playback of item during recording\nRETURNS:\nretval:0, if insertion worked; -1, if it failed\nitem:the newly created MediaItem\nendposition:the endposition of the newly created MediaItem in seconds\nnumchannels:the number of channels of the mediafile\nSamplerate:the samplerate of the mediafile in hertz\nFiletype:the type of the mediafile, like MP3, WAV, MIDI, FLAC, etc\neditcursorposition:the (new) editcursorposition\ntrack:returns the MediaTrack, in which the item is included\n",
        "body": "ultraschall.InsertMediaItemFromFile(${1:string filename},${2:integer track},${3:number position},${4:number endposition},${5:integer editcursorpos},${6:optional number offset})$0"
    },
    "ULTRASCHALL.COPYMEDIAITEMTODESTINATIONTRACK lua": {
        "prefix": "ultraschall.CopyMediaItemToDestinationTrack",
        "scope": "lua",
        "description": "Copies MediaItem to MediaTrack_destination at position.\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, that you want to create a copy from\nMediaTrack_destination:the track, into which you want to copy the MediaItem\nposition:the position of the copy of the MediaItem; negative, to keep the position of the source-MediaItem\nRETURNS:\nnewMediaItem:the newly created MediaItem; nil, if no item could be created\nstatechunk:the statechunk of the newly created MediaItem\n",
        "body": "ultraschall.CopyMediaItemToDestinationTrack(${1:MediaItem MediaItem},${2:MediaTrack MediaTrack_destination},${3:number position})$0"
    },
    "ULTRASCHALL.ISSPLITATPOSITION lua": {
        "prefix": "ultraschall.IsSplitAtPosition",
        "scope": "lua",
        "description": "returns, if theres at least one split, MediaItemend or MediaItemstart at position within the tracks given in trackstring.\nreturns false in case of an error\nPARAMETERS:\ntrackstring:the tracknumbers, within to search for, as comma separated string. Starting 1 for the first track.\nposition:the position, at which to check for.\nRETURNS:\nretval:true, there's a split/mediaitemend/mediaitemstart at position; false, it isn't\n",
        "body": "ultraschall.IsSplitAtPosition(${1:string trackstring},${2:number position})$0"
    },
    "ULTRASCHALL.GETITEM_NUMBER lua": {
        "prefix": "ultraschall.GetItem_Number",
        "scope": "lua",
        "description": "returns the indexnumber of a MediaItem-object\nCan be helpful with Reaper's own API-functions, like reaper.GetMediaItem(ReaProject proj, integer itemidx)\nreturns -1 in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose itemidx you want to have\nRETURNS:\nitemidx:the indexnumber of the MediaItem, zero based. \n",
        "body": "ultraschall.GetItem_Number(${1:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.GETITEM_HIGHESTRECCOUNTER lua": {
        "prefix": "ultraschall.GetItem_HighestRecCounter",
        "scope": "lua",
        "description": "Takes the RECPASS-counters of all items and takes and returns the highest one, which usually means, the number of items, who have been recorded since the project has been created.\nNote: a RECPASS-entry can also be part of a copy of a recorded item, so multiple items/takes can share the same RECPASS-entries with the same counter.\nMeans: the highest number can be of multiple items\nreturns -1 if no recorded item/take has been found.\nRETURNS:\nhighest_item_reccount:the highest reccount of all MediaItems, which usually means, that so many Items have been recorded in this project\nfound:the number of MediaItems, who have a recpass-entry in their StateChunk, means, who have been recorded.    \n",
        "body": "ultraschall.GetItem_HighestRecCounter()$0"
    },
    "ULTRASCHALL.GETITEM_CLICKSTATE lua": {
        "prefix": "ultraschall.GetItem_ClickState",
        "scope": "lua",
        "description": "Returns the currently clicked item and take, as well as the current timeposition.\nMostly useful in defer-scripts.\nReturns false, if no item is clicked at\nRETURNS:\nclickstate:true, item is clicked on; false, item isn't clicked on\nposition:the position, at which the item is currently clicked at\nitem:the Item, which is currently clicked at\ntake:the take found at clickposition\n",
        "body": "ultraschall.GetItem_ClickState()$0"
    },
    "ULTRASCHALL.GETENDOFITEM lua": {
        "prefix": "ultraschall.GetEndOfItem",
        "scope": "lua",
        "description": "Returns the endposition of MediaItem\nreturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose ending-position you want to know\nRETURNS:\nend_of_item_position:the position of the ending edge of the MediaItem\n",
        "body": "ultraschall.GetEndOfItem(${1:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMATTRIBUTES_TABLE lua": {
        "prefix": "ultraschall.GetAllMediaItemAttributes_Table",
        "scope": "lua",
        "description": "Returns all attributes of MediaItem as a handy table.\nThe returned table is of the following scheme:\nAttributeTable[\"B_MUTE\"] - bool * : muted\nAttributeTable[\"B_LOOPSRC\"] - bool * : loop source\nAttributeTable[\"B_ALLTAKESPLAY\"] - bool * : all takes play\nAttributeTable[\"B_UISEL\"] - bool * : selected in arrange view\nAttributeTable[\"C_BEATATTACHMODE\"] - char * : item timebase, -1=track or project default, 1=beats (position, length, rate), 2=beats (position only). for auto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nAttributeTable[\"C_AUTOSTRETCH:\"] - char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nAttributeTable[\"C_LOCK\"] - char * : locked, &1=locked\nAttributeTable[\"D_VOL\"] - double * : item volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nAttributeTable[\"D_POSITION\"] - double * : item position in seconds\nAttributeTable[\"D_LENGTH\"] - double * : item length in seconds\nAttributeTable[\"D_SNAPOFFSET\"] - double * : item snap offset in seconds\nAttributeTable[\"D_FADEINLEN\"] - double * : item manual fadein length in seconds\nAttributeTable[\"D_FADEOUTLEN\"] - double * : item manual fadeout length in seconds\nAttributeTable[\"D_FADEINDIR\"] - double * : item fadein curvature, -1..1\nAttributeTable[\"D_FADEOUTDIR\"] - double * : item fadeout curvature, -1..1\nAttributeTable[\"D_FADEINLEN_AUTO\"] - double * : item auto-fadein length in seconds, -1=no auto-fadein\nAttributeTable[\"D_FADEOUTLEN_AUTO\"] - double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nAttributeTable[\"C_FADEINSHAPE\"] - int * : fadein shape, 0..6, 0=linear\nAttributeTable[\"C_FADEOUTSHAPE\"] - int * : fadeout shape, 0..6, 0=linear\nAttributeTable[\"I_GROUPID\"] - int * : group ID, 0=no group\nAttributeTable[\"I_LASTY\"] - int * : Y-position of track in pixels (read-only)\nAttributeTable[\"I_LASTH\"] - int * : height in track in pixels (read-only)\nAttributeTable[\"I_CUSTOMCOLOR\"] - int * : custom color, OS dependent color|0x100000 (i.e. ColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will not be used, but will store the color anyway)\nAttributeTable[\"I_CURTAKE\"] - int * : active take number\nAttributeTable[\"IP_ITEMNUMBER\"] - int, item number on this track (read-only, returns the item number directly)\nAttributeTable[\"F_FREEMODE_Y\"] - float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nAttributeTable[\"F_FREEMODE_H\"] - float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nAttributeTable[\"P_TRACK\"] - MediaTrack * (read-only)\nreturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose attributes you want to retrieve\nRETURNS:\nAttributeTable:a table with all attributes of a MediaItem\n",
        "body": "ultraschall.GetAllMediaItemAttributes_Table(${1:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.SETALLMEDIAITEMATTRIBUTES_TABLE lua": {
        "prefix": "ultraschall.SetAllMediaItemAttributes_Table",
        "scope": "lua",
        "description": "Sets all attributes of MediaItem using a AttributeTable, which holds all the new settings for the MediaItem.\nThe expected table is of the following scheme:\nAttributeTable[\"B_MUTE\"] - bool * : muted\nAttributeTable[\"B_LOOPSRC\"] - bool * : loop source\nAttributeTable[\"B_ALLTAKESPLAY\"] - bool * : all takes play\nAttributeTable[\"B_UISEL\"] - bool * : selected in arrange view\nAttributeTable[\"C_BEATATTACHMODE\"] - char * : item timebase, -1=track or project default, 1=beats (position, length, rate), 2=beats (position only). for auto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nAttributeTable[\"C_AUTOSTRETCH:\"] - char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nAttributeTable[\"C_LOCK\"] - char * : locked, &1=locked\nAttributeTable[\"D_VOL\"] - double * : item volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nAttributeTable[\"D_POSITION\"] - double * : item position in seconds\nAttributeTable[\"D_LENGTH\"] - double * : item length in seconds\nAttributeTable[\"D_SNAPOFFSET\"] - double * : item snap offset in seconds\nAttributeTable[\"D_FADEINLEN\"] - double * : item manual fadein length in seconds\nAttributeTable[\"D_FADEOUTLEN\"] - double * : item manual fadeout length in seconds\nAttributeTable[\"D_FADEINDIR\"] - double * : item fadein curvature, -1..1\nAttributeTable[\"D_FADEOUTDIR\"] - double * : item fadeout curvature, -1..1\nAttributeTable[\"D_FADEINLEN_AUTO\"] - double * : item auto-fadein length in seconds, -1=no auto-fadein\nAttributeTable[\"D_FADEOUTLEN_AUTO\"] - double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nAttributeTable[\"C_FADEINSHAPE\"] - int * : fadein shape, 0..6, 0=linear\nAttributeTable[\"C_FADEOUTSHAPE\"] - int * : fadeout shape, 0..6, 0=linear\nAttributeTable[\"I_GROUPID\"] - int * : group ID, 0=no group\nAttributeTable[\"I_LASTY\"] - int * : Y-position of track in pixels (read-only)\nAttributeTable[\"I_LASTH\"] - int * : height in track in pixels (read-only)\nAttributeTable[\"I_CUSTOMCOLOR\"] - int * : custom color, OS dependent color|0x100000 (i.e. ColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will not be used, but will store the color anyway)\nAttributeTable[\"I_CURTAKE\"] - int * : active take number\nAttributeTable[\"IP_ITEMNUMBER\"] - int, item number on this track (read-only, returns the item number directly)\nAttributeTable[\"F_FREEMODE_Y\"] - float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nAttributeTable[\"F_FREEMODE_H\"] - float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nAttributeTable[\"P_TRACK\"] - MediaTrack * (read-only)\nreturns false in case of an error or if some of the attributes could not be set.\nPARAMETERS:\nMediaItem:the MediaItem, whose attributes you want to set\nAttributeTable:a table which holds all settings, that you want to set\nRETURNS:\nretval:true, setting was successful; false, setting attributes failed\n",
        "body": "ultraschall.SetAllMediaItemAttributes_Table(${1:MediaItem MediaItem},${2:table AttributeTable})$0"
    },
    "ULTRASCHALL.GETALLSELECTEDMEDIAITEMSBETWEEN lua": {
        "prefix": "ultraschall.GetAllSelectedMediaItemsBetween",
        "scope": "lua",
        "description": "Gets all selected MediaItems between startposition and endposition from the tracks as given by trackstring.\nSet inside to true to get only items, that are fully within the start and endposition, set it to false, if you also want items, that are just partially inside(end or just the beginning of the item).\nReturns the number of selected items, an array with all the selected MediaItems and an array with all the MediaItemStateChunks of the selected items, as used by functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nThe statechunks include a new element \"ULTRASCHALL_TRACKNUMBER\", which contains the tracknumber of where the item originally was in; important, if you delete the items as you'll otherwise loose this information!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntrackstring:the tracknumbers, separated by a comma\ninside:true, only items that are completely within selection; false, include items that are partially within selection\nRETURNS:\ncount:the number of selected items\nMediaItemArray:an array with all the found and selected MediaItems\nMediaItemStateChunkArray:an array with the MediaItemStateChunks, that can be used to create new items with InsertMediaItem_MediaItemStateChunk\n",
        "body": "ultraschall.GetAllSelectedMediaItemsBetween(${1:number startposition},${2:number endposition},${3:string trackstring},${4:boolean inside})$0"
    },
    "ULTRASCHALL.MEDIAITEMS_OUTTAKES_ADDSELECTEDITEMS lua": {
        "prefix": "ultraschall.MediaItems_Outtakes_AddSelectedItems",
        "scope": "lua",
        "description": "Adds selected MediaItems to the outtakes-vault of a given project.\nreturns -1 in case of an error\nPARAMETERS:\nTargetProject:the project, into whose outtakes-vault the selected items shall be added to; 0 or nil, for the current project\nRETURNS:\nnumber_of_items:the number of items, added to the outtakes-vault\n",
        "body": "ultraschall.MediaItems_Outtakes_AddSelectedItems(${1:ReaProject TargetProject})$0"
    },
    "ULTRASCHALL.MEDIAITEMS_OUTTAKES_GETALLITEMS lua": {
        "prefix": "ultraschall.MediaItems_Outtakes_GetAllItems",
        "scope": "lua",
        "description": "Returns all MediaItems stored in the outtakes-vault of a given project.\nreturns -1 in case of an error\nPARAMETERS:\nTargetProject:the project, into whose outtakes-vault the selected items shall be added to; 0 or nil, for the current project\nEachItemsAfterAnother:position the MediaItems one after the next, so if you import them, they would be stored one after another\nRETURNS:\nnumber_of_items:the number of items, added to the outtakes-vault\nMediaItemStateChunkArray:all the MediaItemStateChunks of the stored MediaItems in the outtakes vault\n",
        "body": "ultraschall.MediaItems_Outtakes_GetAllItems(${1:ReaProject TargetProject},${2:optional boolean EachItemsAfterAnother})$0"
    },
    "ULTRASCHALL.MEDIAITEMS_OUTTAKES_INSERTALLITEMS lua": {
        "prefix": "ultraschall.MediaItems_Outtakes_InsertAllItems",
        "scope": "lua",
        "description": "Inserts all MediaItems from the outtakes-vault into a certain track, with one item after the other, back to back.\nreturns false in case of an error\nPARAMETERS:\nTargetProject:the project, into whose outtakes-vault the selected items shall be added to; 0 or nil, for the current project\ntracknumber:the tracknumber, into which to insert all items from the outtakes-vault\nStartposition:the position, at which to insert the first MediaItem; nil, startposition=0\nRETURNS:\nretval:true, adding was successful; false, adding was unsuccessful\nnumber_of_items:the number of added items\nMediaItemArray:all the inserted MediaItems\n",
        "body": "ultraschall.MediaItems_Outtakes_InsertAllItems(${1:ReaProject TargetProject},${2:integer tracknumber},${3:number Startposition})$0"
    },
    "ULTRASCHALL.DELETEPROJEXTSTATE_SECTION lua": {
        "prefix": "ultraschall.DeleteProjExtState_Section",
        "scope": "lua",
        "description": "Deletes all key/values from a specific section.\nReturns -1 in case of an error.\nPARAMETERS:\nsection:the section/extname, whose key/values shall be deleted\nRETURNS:\nretval:0, in case of success; -1, in case of an error\n",
        "body": "ultraschall.DeleteProjExtState_Section(${1:string section})$0"
    },
    "ULTRASCHALL.DELETEPROJEXTSTATE_KEY lua": {
        "prefix": "ultraschall.DeleteProjExtState_Key",
        "scope": "lua",
        "description": "Deletes the value from a specific section -> key.\nReturns -1 in case of an error.\nPARAMETERS:\nsection:the section/extname, from whom a key/value shall be deleted\nkey:the key, whose value shall be deleted\nRETURNS:\nretval:0, in case of success; -1, in case of an error\n",
        "body": "ultraschall.DeleteProjExtState_Key(${1:string section},${2:section key})$0"
    },
    "ULTRASCHALL.GETPROJEXTSTATE_ALLKEYVALUES lua": {
        "prefix": "ultraschall.GetProjExtState_AllKeyValues",
        "scope": "lua",
        "description": "Returns the count of all key/values in a specific section, as well as an array with all keynames and their accompanying stored values.\nThe array has the format:\nAllValues[idx][1]=Key\nAllValues[idx][2]=Value\nReturns -1 in case of an error or if no key exists in the given section\nPARAMETERS:\nsection:the section/extname, from whom a key/value shall be deleted\nRETURNS:\nretval:0, in case of success; -1, in case of an error\n",
        "body": "ultraschall.GetProjExtState_AllKeyValues(${1:string section})$0"
    },
    "ULTRASCHALL.GETGUIDEXTSTATE lua": {
        "prefix": "ultraschall.GetGuidExtState",
        "scope": "lua",
        "description": "Gets an extension-state using a given guid. Good for storing additional metadata of objects like MediaTracks, MediaItems, MediaItem_Takes, etc(everything, that has a guid).\nThe guid can have additional text, but must contain a valid guid somewhere in it!\nA valid guid is a string that follows the following pattern:\n{........-....-....-....-............}\nwhere . is a hexadecimal value(0-F)\nReturns -1 in case of error\nPARAMETERS:\nguid:the guid of the object, for whom you want to get the key/value-pair; can have additional characters before and after the guid, but must contain a valid guid!\nkey:the key for this guid\nsavelocation:0, get as project extension state(from the currently opened project); 1, get as global extension state(when persist=true, from reaper-extstate.ini in the resourcesfolder)\nRETURNS:\nretval:the idx of the extstate(if a project extension state); 1, successful(with extension states), -1, unsuccessful\nvalue:the returned value from the extstate\n",
        "body": "ultraschall.GetGuidExtState(${1:string guid},${2:string key},${3:integer savelocation})$0"
    },
    "ULTRASCHALL.SETMARKEREXTSTATE lua": {
        "prefix": "ultraschall.SetMarkerExtState",
        "scope": "lua",
        "description": "Stores an Extstate for a specific marker/region.\nThe index is for all markers and regions, inclusive and 1-based\nreturns -1 in case of an error\nPARAMETERS:\nindex:the marker/region-index, for which to store an extstate; starting with 1 for first marker/region, 2 for second marker/region\nkey:the key, into which the marker-extstate shall be stored\nvalue:the value, which you want to store into the marker-extstate\nRETURNS:\nretval:-1, in case of an error; 1, in case of success\n",
        "body": "ultraschall.SetMarkerExtState(${1:integer index},${2:string key},${3:string value})$0"
    },
    "ULTRASCHALL.GETMARKEREXTSTATE lua": {
        "prefix": "ultraschall.GetMarkerExtState",
        "scope": "lua",
        "description": "Retrieves an Extstate for a specific marker/region.\nThe index is for all markers and regions, inclusive and 1-based\nreturns nil in case of an error\nPARAMETERS:\nindex:the marker/region-index, for which an extstate has been stored; starting with 1 for first marker/region, 2 for second marker/region\nkey:the key, in which the marker-extstate is stored\nRETURNS:\nvalue:the value, that has been stored into the marker-extstate; nil, in case of an error\n",
        "body": "ultraschall.GetMarkerExtState(${1:integer index},${2:string key})$0"
    },
    "ULTRASCHALL.PROJEXTSTATE_COUNTALLKEYS lua": {
        "prefix": "ultraschall.ProjExtState_CountAllKeys",
        "scope": "lua",
        "description": "Counts all keys stored within a certain ProjExtState-section.\nBe aware: if you want to enumerate them using reaper.EnumProjExtState, the first key is indexed 0, the second 1, etc!\nreturns -1 in case of an error\nPARAMETERS:\nsection:the section, of which you want to count all keys\n",
        "body": "ultraschall.ProjExtState_CountAllKeys(${1:string section})$0"
    },
    "ULTRASCHALL.ZOOMVERTICAL_MIDIEDITOR lua": {
        "prefix": "ultraschall.ZoomVertical_MidiEditor",
        "scope": "lua",
        "description": "Zooms within the Midi-Editor vertically.\nreturns false in case of an error\nPARAMETERS:\nzoomamt:the zoom-factor; positive values, zoom in; negative values, zoom out\nmidieditor_hwnd:the HWND of the MIDI-Editor, in which you want to zoom; nil, uses active MIDI-Editor\nRETURNS:\nretval:true, if zooming was successful; false, if not\n",
        "body": "ultraschall.ZoomVertical_MidiEditor(${1:integer zoomamt},${2:optional HWND midieditor_hwnd})$0"
    },
    "ULTRASCHALL.ZOOMHORIZONTAL_MIDIEDITOR lua": {
        "prefix": "ultraschall.ZoomHorizontal_MidiEditor",
        "scope": "lua",
        "description": "Zooms within the Midi-Editor horizontally.\nreturns false in case of an error\nPARAMETERS:\nzoomamt:the zoom-factor; positive values, zoom in; negative values, zoom out\nmidieditor_hwnd:the HWND of the MIDI-Editor, in which you want to zoom; nil, uses active MIDI-Editor\nRETURNS:\nretval:true, if zooming was successful; false, if not\n",
        "body": "ultraschall.ZoomHorizontal_MidiEditor(${1:integer zoomamt},${2:optional HWND midieditor_hwnd})$0"
    },
    "ULTRASCHALL.OPENITEMINMIDIEDITOR lua": {
        "prefix": "ultraschall.OpenItemInMidiEditor",
        "scope": "lua",
        "description": "opens a given MediaItem in the MIDI-Editor\nreturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem to be opened in the MIDI-Editor\nRETURNS:\nretval:true, if opening was successful; false, if not\n",
        "body": "ultraschall.OpenItemInMidiEditor(${1:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.MIDI_SENDMIDINOTE lua": {
        "prefix": "ultraschall.MIDI_SendMidiNote",
        "scope": "lua",
        "description": "Sends a MIDI-note to a specific channel with a specific velocity.\nPARAMETERS:\nChannel:the channel, to which the Midi-note shall be sent; 1-16\nNote:the note to be played; 0-127\nVelocity:the velocity of the note; 0-255\nMode:0 for VKB\n",
        "body": "ultraschall.MIDI_SendMidiNote(${1:integer Channel},${2:integer Note},${3:integer Velocity},${4:optional integer Mode})$0"
    },
    "ULTRASCHALL.MIDI_SENDMIDICC lua": {
        "prefix": "ultraschall.MIDI_SendMidiCC",
        "scope": "lua",
        "description": "Sends a MIDI-CC-message to a specific channel with a specific velocity.\nPARAMETERS:\nChannel:the channel, to which the Midi-note shall be sent; 1-16\nNote:the note to be played; 0-127\nVelocity:the velocity of the note; 0-255\nMode:0 for VKB\n",
        "body": "ultraschall.MIDI_SendMidiCC(${1:integer Channel},${2:integer Note},${3:integer Velocity},${4:optional integer Mode})$0"
    },
    "ULTRASCHALL.MIDI_SENDMIDIPC lua": {
        "prefix": "ultraschall.MIDI_SendMidiPC",
        "scope": "lua",
        "description": "Sends a MIDI-PC-message to a specific channel with a specific velocity.\nPARAMETERS:\nChannel:the channel, to which the Midi-note shall be sent; 1-16\nNote:the note to be played; 0-127\nVelocity:the velocity of the note; 0-255\nMode:0 for VKB\n",
        "body": "ultraschall.MIDI_SendMidiPC(${1:integer Channel},${2:integer Note},${3:integer Velocity},${4:optional integer Mode})$0"
    },
    "ULTRASCHALL.MIDI_SENDMIDIPITCH lua": {
        "prefix": "ultraschall.MIDI_SendMidiPitch",
        "scope": "lua",
        "description": "Sends a MIDI-Pitch-message to a specific channel with a specific velocity.\nPARAMETERS:\nChannel:the channel, to which the Midi-pitch shall be sent; 1-16\nPitch:the pitchbend of the note; 0-127\nMode:0 for VKB\n",
        "body": "ultraschall.MIDI_SendMidiPitch(${1:integer Channel},${2:integer Pitch},${3:optional integer Mode})$0"
    },
    "ULTRASCHALL.QUERYMIDIMESSAGENAMEBYID lua": {
        "prefix": "ultraschall.QueryMIDIMessageNameByID",
        "scope": "lua",
        "description": "Returns the name of the MIDI-message, as used by Reaper's function StuffMIDIMessage.\nJust pass over the first and second value. The last one is always velocity, which is ~=0 for it to be accepted.\nHowever, some codes don't have a name associated. In that case, this function returns \"-1\"\nOnly returns the names for mode 1 and english on Windows!\nreturns nil in case of an error\nPARAMETERS:\nmodifier:the modifier value, which is the second parameter of StuffMIDIMessage\nkey:the key value, which is the third parameter of StuffMIDIMessage\nRETURNS:\nmidimessage_name:the actual name of the midi-message, like \"A\" or \"F1\" or \"Ctrl+Alt+Shift+Win+PgUp\".\n",
        "body": "ultraschall.QueryMIDIMessageNameByID(${1:integer modifier},${2:integer key})$0"
    },
    "ULTRASCHALL.TOGGLEMUTE lua": {
        "prefix": "ultraschall.ToggleMute",
        "scope": "lua",
        "description": "Sets mute within the mute-envelope-lane, by inserting the fitting envelope-points. Can be used to program coughbuttons.\nReturns -1, in case of an error\nPARAMETERS:\ntrack:the track-number, for where you want to set the mute-envelope-lane.\nposition:position in seconds\nstate:0, for mute the track on this position; 1, for unmuting the track on this position\nRETURNS:\nretval:toggling was 0, success; -1, fail\n",
        "body": "ultraschall.ToggleMute(${1:integer track},${2:number position},${3:integer state})$0"
    },
    "ULTRASCHALL.TOGGLEMUTE_TRACKOBJECT lua": {
        "prefix": "ultraschall.ToggleMute_TrackObject",
        "scope": "lua",
        "description": "Sets mute within the mute-envelope-lane, by inserting the fitting envelope-points. Can be used to program coughbuttons.\nReturns -1, if it fails.\nWorks like ultraschall.ToggleMute but uses a trackobject instead of the tracknumber as parameter.\nPARAMETERS:\ntrackobject:the track-object for the track, where you want to set the mute-envelope-lane. Refer GetTrack() for more details.\nposition:position in seconds\nstate:0, for mute the track on this position, 1, for unmuting the track on this position\nRETURNS:\nretval:toggling was 0, success; -1, fail\n",
        "body": "ultraschall.ToggleMute_TrackObject(${1:MediaTrack trackobject},${2:number position},${3:integer state})$0"
    },
    "ULTRASCHALL.GETNEXTMUTESTATE lua": {
        "prefix": "ultraschall.GetNextMuteState",
        "scope": "lua",
        "description": "Returns the next mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the track-number, for where you want to set the mute-envelope-lane, beginning with 1.\nposition:position in seconds, from where to look for the next mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "ultraschall.GetNextMuteState(${1:integer track},${2:number position})$0"
    },
    "ULTRASCHALL.GETPREVIOUSMUTESTATE lua": {
        "prefix": "ultraschall.GetPreviousMuteState",
        "scope": "lua",
        "description": "Returns the previous mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the track-number, for where you want to set the mute-envelope-lane, beginning with 1.\nposition:position in seconds, from where to look for the previous mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "ultraschall.GetPreviousMuteState(${1:integer track},${2:number position})$0"
    },
    "ULTRASCHALL.GETNEXTMUTESTATE_TRACKOBJECT lua": {
        "prefix": "ultraschall.GetNextMuteState_TrackObject",
        "scope": "lua",
        "description": "Returns the next mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the MediaTrack-object, for the track, where you want to set the mute-envelope-lane.\nposition:position in seconds, from where to look for the next mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "ultraschall.GetNextMuteState_TrackObject(${1:MediaTrack track},${2:number position})$0"
    },
    "ULTRASCHALL.GETPREVIOUSMUTESTATE_TRACKOBJECT lua": {
        "prefix": "ultraschall.GetPreviousMuteState_TrackObject",
        "scope": "lua",
        "description": "Returns the previous mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the MediaTrack-object, for the track, where you want to set the mute-envelope-lane.\nposition:position in seconds, from where to look for the previous mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "ultraschall.GetPreviousMuteState_TrackObject(${1:MediaTrack track},${2:number position})$0"
    },
    "ULTRASCHALL.COUNTMUTEENVELOPEPOINTS lua": {
        "prefix": "ultraschall.CountMuteEnvelopePoints",
        "scope": "lua",
        "description": "Returns the number of the envelope-points in the Mute-lane of track \"track\".\nReturns -1, if it fails.\nPARAMETERS:\ntrack:the track-number, for which you want to count the mute-envelope-points, beginning with 1.\nRETURNS:\nretval:number of mute-envelope-points\n",
        "body": "ultraschall.CountMuteEnvelopePoints(${1:integer track})$0"
    },
    "ULTRASCHALL.DELETEMUTESTATE lua": {
        "prefix": "ultraschall.DeleteMuteState",
        "scope": "lua",
        "description": "Deletes a mute-point in track tracknumber at position.\nReturns false in case of an error\nPARAMETERS:\ntracknumber:the track in which to delete the mute-point; is 1-based, means 1 for track 1\nposition:the position of the mute-point to delete\nRETURNS:\nretval:true, deleting was successful; false, deleting wasn't successful.\n",
        "body": "ultraschall.DeleteMuteState(${1:integer tracknumber},${2:number position})$0"
    },
    "ULTRASCHALL.DELETEMUTESTATE_TRACKOBJECT lua": {
        "prefix": "ultraschall.DeleteMuteState_TrackObject",
        "scope": "lua",
        "description": "Deletes a mute-point in a MediaTrack-object at position.\nReturns false in case of an error\nPARAMETERS:\nMediaTrack:the track in which to delete the mute-point\nposition:the position of the mute-point to delete\nRETURNS:\nretval:true, deleting was successful; false, deleting wasn't successful.\n",
        "body": "ultraschall.DeleteMuteState_TrackObject(${1:MediaTrack MediaTrack},${2:number position})$0"
    },
    "ULTRASCHALL.ISMUTEATPOSITION lua": {
        "prefix": "ultraschall.IsMuteAtPosition",
        "scope": "lua",
        "description": "Returns true, if a mute-point exists in track tracknumber at position position.\nReturns false in case of an error\nPARAMETERS:\ntracknumber:the track in which to check for a mute-point; is 1-based, means 1 for track 1\nposition:the position to check for a mute-point\nRETURNS:\nretval:true, if there is a mute-point; false, if there isn't one\nenvIDX:if a mute-point is at position, this holds the index of the envelope-point\nenvVal:the current set value of the mute-point\n",
        "body": "ultraschall.IsMuteAtPosition(${1:integer tracknumber},${2:number position})$0"
    },
    "ULTRASCHALL.ISMUTEATPOSITION_TRACKOBJECT lua": {
        "prefix": "ultraschall.IsMuteAtPosition_TrackObject",
        "scope": "lua",
        "description": "Returns true, if a mute-point exists in MediaTrack-object at position position.\nReturns false in case of an error\nPARAMETERS:\nMediaTrack:the track in which to check for a mute-point\nposition:the position to check for a mute-point\nRETURNS:\nretval:true, if there is a mute-point; false, if there isn't one\nenvIDX:if a mute-point is at position, this holds the index of the envelope-point\nenvVal:the current set value of the mute-point\n",
        "body": "ultraschall.IsMuteAtPosition_TrackObject(${1:MediaTrack MediaTrack},${2:number position})$0"
    },
    "ULTRASCHALL.TOGGLESCROLLINGDURINGPLAYBACK lua": {
        "prefix": "ultraschall.ToggleScrollingDuringPlayback",
        "scope": "lua",
        "description": "Toggles scrolling during playback and recording. Let's you choose to put the edit-marker at the playposition, where you toggled scrolling.\nYou can also move the view to the playcursor-position.\nIt changes, if necessary, the state of the actions 41817, 40036 and 40262 to scroll or not to scroll; keep that in mind, if you use these actions otherwise as well!\nreturns -1 in case of error\nPARAMETERS:\nscrolling_switch:1, on; 0, off\nmove_editcursor:when scrolling stops, shall the editcursor be moved to current position of the playcursor(true) or not(false)\ngoto_playcursor:true, move view to playcursor; false, don't move\n",
        "body": "ultraschall.ToggleScrollingDuringPlayback(${1:integer scrolling_switch},${2:boolean move_editcursor},${3:boolean goto_playcursor})$0"
    },
    "ULTRASCHALL.SETPLAYCURSOR_WHENPLAYING lua": {
        "prefix": "ultraschall.SetPlayCursor_WhenPlaying",
        "scope": "lua",
        "description": "Changes position of the play-cursor, when playing. Changes view to new playposition.\nHas no effect during recording, when paused or stop and returns -1 in these cases!\nPARAMETERS:\nposition:in seconds\n",
        "body": "ultraschall.SetPlayCursor_WhenPlaying(${1:number position})$0"
    },
    "ULTRASCHALL.SETPLAYANDEDITCURSOR_WHENPLAYING lua": {
        "prefix": "ultraschall.SetPlayAndEditCursor_WhenPlaying",
        "scope": "lua",
        "description": "Changes position of the play and edit-cursor, when playing. Changes view to new playposition.\nHas no effect during recording, when paused or stop and returns -1 in these cases!\nPARAMETERS:\nposition:in seconds\n",
        "body": "ultraschall.SetPlayAndEditCursor_WhenPlaying(${1:number position})$0"
    },
    "ULTRASCHALL.JUMPFORWARDBY lua": {
        "prefix": "ultraschall.JumpForwardBy",
        "scope": "lua",
        "description": "Jumps editcursor forward by seconds seconds.\nReturns -1 if parameter is negative. During Recording: only the playcursor will be moved, the current recording-position is still at it's \"old\" position! If you want to move the current recording position as well, use ultraschall.JumpForwardBy_Recording instead.\nPARAMETERS:\nseconds:jump forward by seconds\nseekplay:true, move playcursor as well; false, don't move playcursor\n",
        "body": "ultraschall.JumpForwardBy(${1:number seconds},${2:boolean seekplay})$0"
    },
    "ULTRASCHALL.JUMPBACKWARDBY lua": {
        "prefix": "ultraschall.JumpBackwardBy",
        "scope": "lua",
        "description": "Jumps editcursor backward by seconds seconds.\nReturns -1 if parameter is negative. During Recording: only the playcursor will be moved, the current recording-position is still at it's \"old\" position! If you want to move the current recording position as well, use ultraschall.JumpBackwardBy_Recording instead.\nPARAMETERS:\nseconds:jump backwards by seconds\nseekplay:true, move playcursor as well; false, leave playcursor at it's old position\n",
        "body": "ultraschall.JumpBackwardBy(${1:number seconds},${2:boolean seekplay})$0"
    },
    "ULTRASCHALL.JUMPFORWARDBY_RECORDING lua": {
        "prefix": "ultraschall.JumpForwardBy_Recording",
        "scope": "lua",
        "description": "Stops recording, jumps forward by seconds seconds and restarts recording. Will keep paused-recording, if recording was paused. Has no effect during play,play/pause and stop.\nreturns -1 in case of an error\nPARAMETERS:\nseconds:restart recording forwards by seconds\n",
        "body": "ultraschall.JumpForwardBy_Recording(${1:number seconds})$0"
    },
    "ULTRASCHALL.JUMPBACKWARDBY_RECORDING lua": {
        "prefix": "ultraschall.JumpBackwardBy_Recording",
        "scope": "lua",
        "description": "Stops recording, jumps backward by seconds seconds and restarts recording. Will keep paused-recording, if recording was paused. Has no effect during play,play/pause and stop.\nreturns -1 in case of an error\nPARAMETERS:\nseconds:restart recording backwards by seconds\n",
        "body": "ultraschall.JumpBackwardBy_Recording(${1:number seconds})$0"
    },
    "ULTRASCHALL.GETNEXTCLOSESTITEMEDGE lua": {
        "prefix": "ultraschall.GetNextClosestItemEdge",
        "scope": "lua",
        "description": "returns the position of the next closest item in seconds. It will return the position of the beginning or the end of that item, depending on what is closer.\nreturns -1 in case of an error\nPARAMETERS:\ntrackstring:a string with the numbers of tracks to check for closest items, separated by a comma (e.g. \"0,1,6\")\ncursor_type:next closest item related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the next closest item. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nposition:the position of the next closest item-edge in tracks in trackstring\nitem_number:the itemnumber in the project\nedgetype:\"beg\" for beginning of the item, \"end\" for the end of the item\nMediaItem found_item:the next closest found MediaItem \n",
        "body": "ultraschall.GetNextClosestItemEdge(${1:string trackstring},${2:integer cursor_type},${3:optional number time_position})$0"
    },
    "ULTRASCHALL.GETPREVIOUSCLOSESTITEMEDGE lua": {
        "prefix": "ultraschall.GetPreviousClosestItemEdge",
        "scope": "lua",
        "description": "returns the position of the previous closest item-edge in seconds. It will return the position of the beginning or the end of that item, depending on what is closer.\nreturns -1 in case of an error\nPARAMETERS:\ntracks:a string with the numbers of tracks to check for closest items, separated by a comma (e.g. \"0,1,6\")\ncursor_type:previous closest item related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the previous closest item. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nposition:the position of the previous closest item edge in tracks in trackstring\nposition:the position of the previous closest item edge in tracks in trackstring\nitem_number:the itemnumber in the project\nedgetype:\"beg\" for beginning of the item, \"end\" for the end of the item\nfound_item:the next closest found MediaItem \n",
        "body": "ultraschall.GetPreviousClosestItemEdge(${1:string tracks},${2:integer cursor_type},${3:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTNEXTMARKER lua": {
        "prefix": "ultraschall.GetClosestNextMarker",
        "scope": "lua",
        "description": "returns the markerindex(counted from all markers), the position and the name of the next closest marker in seconds.\nreturns -1 in case of an error\nPARAMETERS:\ncursor_type:previous closest marker related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the next closest marker. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the next closest markerindex (of all(!) markers)\nposition:the position of the next closest marker\nmarkertitle:the name of the next closest marker\n",
        "body": "ultraschall.GetClosestNextMarker(${1:integer cursor_type},${2:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTPREVIOUSMARKER lua": {
        "prefix": "ultraschall.GetClosestPreviousMarker",
        "scope": "lua",
        "description": "returns the markerindex(counted from all markers), the position and the name of the previous closest marker in seconds.\nPARAMETERS:\ncursor_type:previous closest marker related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the previous closest marker. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the previous closest markerindex (of all(!) markers)\nposition:the position of the previous closest marker\nmarkertitle:the name of the previous closest marker\n",
        "body": "ultraschall.GetClosestPreviousMarker(${1:integer cursor_type},${2:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTNEXTREGIONEDGE lua": {
        "prefix": "ultraschall.GetClosestNextRegionEdge",
        "scope": "lua",
        "description": "returns the regionindex(counted from all markers and regions), the position and the name of the next closest regionstart/end(depending on which is closer to time_position) in seconds.\nreturns -1 in case of an error\nPARAMETERS:\ncursor_type:previous closest regionstart/end related to the current position of \ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the next closest regionstart/end. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the next closest markerindex (of all(!) markers)\nposition:the position of the next closest region\nmarkertitle:the name of the next closest region\nedge_type:the type of the edge of the region, either \"beg\" or \"end\"\n",
        "body": "ultraschall.GetClosestNextRegionEdge(${1:integer cursor_type},${2:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTPREVIOUSREGIONEDGE lua": {
        "prefix": "ultraschall.GetClosestPreviousRegionEdge",
        "scope": "lua",
        "description": "returns the regionindex(counted from all markers and regions), the position and the name of the previous closest regionstart/end(depending on which is closer to time_position) in seconds.\nreturns -1 in case of an error\nPARAMETERS:\ncursor_type:previous closest regionstart/end related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the previous closest regionstart/end. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the previous closest markerindex (of all(!) markers)\nposition:the position of the previous closest marker\nmarkertitle:the name of the previous closest marker\nedge_type:the type of the edge of the region, either \"beg\" or \"end\"\n",
        "body": "ultraschall.GetClosestPreviousRegionEdge(${1:integer cursor_type},${2:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTGOTOPOINTS lua": {
        "prefix": "ultraschall.GetClosestGoToPoints",
        "scope": "lua",
        "description": "returns, what are the closest markers/regions/item starts/itemends to position and within the chosen tracks.\nreturns -1 in case of error\nPARAMETERS:\ntrackstring:tracknumbers, separated by a comma.\ntime_position:a time position in seconds, from where to check for the next/previous closest items/markers/regions.\ncheck_itemedge:true, look for itemedges as possible goto-points; false, do not\ncheck_marker:true, look for markers as possible goto-points; false, do not\ncheck_region:true, look for regions as possible goto-point; false, do not\nRETURNS:\nelementposition_prev:previous closest markers/regions/item starts/itemends\nelementtype_prev:type of the previous closest markers/regions/item starts/itemends\nnumber_prev:number of previous closest markers/regions/item starts/itemends\nelementposition_next:previous closest markers/regions/item starts/itemends\nelementtype_next:type of the previous closest markers/regions/item starts/itemends\nnumber_next:number of previous closest markers/regions/item starts/itemends\n",
        "body": "ultraschall.GetClosestGoToPoints(${1:string trackstring},${2:number time_position},${3:optional boolean check_itemedge},${4:optional boolean check_marker},${5:optional boolean check_region})$0"
    },
    "ULTRASCHALL.CENTERVIEWTOCURSOR lua": {
        "prefix": "ultraschall.CenterViewToCursor",
        "scope": "lua",
        "description": "centers the arrange-view around a given cursor\nreturns nil in case of an error\nPARAMETERS:\ncursortype:the cursortype to center\nposition:the position to center the arrangeview to; only used, when cursortype=4\n",
        "body": "ultraschall.CenterViewToCursor(${1:integer cursortype},${2:optional number position})$0"
    },
    "ULTRASCHALL.GETLASTCURSORPOSITION lua": {
        "prefix": "ultraschall.GetLastCursorPosition",
        "scope": "lua",
        "description": "Returns the last and current editcursor-position. Needs Ultraschall-API-background-scripts started first, see RunBackgroundHelperFeatures().\nHas an issue, when editcursor-position was changed using a modifier, like alt+click or shift+click! Because of that, you should use this only in defer-scripts.\nreturns -1, if Ultraschall-API-backgroundscripts weren't started yet.\nRETURNS:\nlast_editcursor_position:the last cursorposition before the current one; -1, in case of an error\nnew_editcursor_position:the new cursorposition; -1, in case of an error\nstatechangetime:the time, when the state has changed the last time\n",
        "body": "ultraschall.GetLastCursorPosition()$0"
    },
    "ULTRASCHALL.GETLASTPLAYSTATE lua": {
        "prefix": "ultraschall.GetLastPlayState",
        "scope": "lua",
        "description": "Returns the last and current playstate. Needs Ultraschall-API-background-scripts started first, see RunBackgroundHelperFeatures().\npossible states are STOP, PLAY, PLAYPAUSE, REC, RECPAUSE\nreturns -1, if Ultraschall-API-backgroundscripts weren't started yet.\nRETURNS:\nlast_play_state:the last playstate before the current one; -1, in case of an error\nnew_play_state:the new playstate; -1, in case of an error\nstatechangetime:the time, when the state has changed the last time\n",
        "body": "ultraschall.GetLastPlayState()$0"
    },
    "ULTRASCHALL.GETLASTLOOPSTATE lua": {
        "prefix": "ultraschall.GetLastLoopState",
        "scope": "lua",
        "description": "Returns the last and current loopstate. Needs Ultraschall-API-background-scripts started first, see RunBackgroundHelperFeatures().\nPossible states are LOOPED, UNLOOPED\nreturns -1, if Ultraschall-API-backgroundscripts weren't started yet.\nRETURNS:\nlast_loop_state:the last loopstate before the current one; -1, in case of an error\nnew_loop_state:the current loopstate; -1, in case of an error\nstatechangetime:the time, when the state has changed the last time\n",
        "body": "ultraschall.GetLastLoopState()$0"
    },
    "ULTRASCHALL.GETLOOPSTATE lua": {
        "prefix": "ultraschall.GetLoopState",
        "scope": "lua",
        "description": "Returns the current loop-state\nRETURNS:\nretval:0, loop is on; 1, loop is off\n",
        "body": "ultraschall.GetLoopState()$0"
    },
    "ULTRASCHALL.SETLOOPSTATE lua": {
        "prefix": "ultraschall.SetLoopState",
        "scope": "lua",
        "description": "Sets the current loop-state\nreturns false in case of an error\nPARAMETERS:\nstate:0, loop is on; 1, loop is off\nRETURNS:\nretval:true, if setting was successful; false, if setting was unsuccessful\n",
        "body": "ultraschall.SetLoopState(${1:integer state})$0"
    },
    "ULTRASCHALL.SCRUBBING_MOVECURSOR_GETTOGGLESTATE lua": {
        "prefix": "ultraschall.Scrubbing_MoveCursor_GetToggleState",
        "scope": "lua",
        "description": "Returns, if scrub is toggled on/off, for when moving editcursor via action or control surface, as set in Preferences -> Playback.\n",
        "body": "ultraschall.Scrubbing_MoveCursor_GetToggleState()$0"
    },
    "ULTRASCHALL.SCRUBBING_MOVECURSOR_TOGGLE lua": {
        "prefix": "ultraschall.Scrubbing_MoveCursor_Toggle",
        "scope": "lua",
        "description": "Toggles scrub on/off, for when moving editcursor via action or control surface, as set in Preferences -> Playback.\nreturns false in case of an error\nPARAMETERS:\ntoggle:true, toggles scrubbing on; false, toggles scrubbing off\nRETURNS:\nnew_scrubmode:this is the new value of the configvariable scrubmode, which is altered by this function\n",
        "body": "ultraschall.Scrubbing_MoveCursor_Toggle(${1:boolean toggle})$0"
    },
    "ULTRASCHALL.GETPROJECTFILENAME lua": {
        "prefix": "ultraschall.GetProjectFilename",
        "scope": "lua",
        "description": "Returns the filename of a currently opened project(-tab)\nreturns nil in case of an error\nPARAMETERS:\nproj:a currently opened project, whose filename you want to know\nRETURNS:\nprojectfilename_with_path:the filename of the project; \"\", project hasn't been saved yet; nil, in case of an error\n",
        "body": "ultraschall.GetProjectFilename(${1:ReaProject proj})$0"
    },
    "ULTRASCHALL.CHECKFORCHANGEDPROJECTTABS lua": {
        "prefix": "ultraschall.CheckForChangedProjectTabs",
        "scope": "lua",
        "description": "Returns if projecttabs have been changed due reordering, new projects or closed projects, since last calling this function.\nSet update=true to update Ultraschall's internal project-monitoring-list or it will only return the changes since starting the API in this script or since the last time you used this function with parameter update set to true!\nReturns false, -1 in case of error.\nPARAMETERS:\nupdate:true, update Ultraschall's internal projecttab-monitoring-list to the current state of all tabs\nRETURNS:\nretval:false, no changes in the projecttabs at all; true, either order, newprojects or closed project-changes\ncountReorderedProj:the number of reordered projects\nreorderedProj:ReaProjects, who got reordered within the tabs\ncountNewProj:the number of new projects\nnewProj:the new projects as ReaProjects\ncountClosedProj:the number of closed projects\nclosedProj:the closed projects as ReaProjects\ncountRenamedProjects:the number of projects, who got renamed by either saving under a new filename or loading of another project\nRenamesProjects:the renamed projects, by loading a new project or saving the project under another filename\n",
        "body": "ultraschall.CheckForChangedProjectTabs(${1:boolean update})$0"
    },
    "ULTRASCHALL.ISVALIDPROJECTSTATECHUNK lua": {
        "prefix": "ultraschall.IsValidProjectStateChunk",
        "scope": "lua",
        "description": "Checks, whether ProjectStateChunk is a valid ProjectStateChunk\nPARAMETERS:\nProjectStateChunk:the string to check, if it's a valid ProjectStateChunk\nRETURNS:\nretval:true, if it's a valid ProjectStateChunk; false, if not\n",
        "body": "ultraschall.IsValidProjectStateChunk(${1:string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECTSTATECHUNK lua": {
        "prefix": "ultraschall.GetProjectStateChunk",
        "scope": "lua",
        "description": "Gets the ProjectStateChunk of the current active project or a projectfile.\nImportant: when calling it too often in a row, this might fail and result in a timeout-error.\nI tried to circumvent this, but best practice is to wait 2-3 seconds inbetween calling this function.\nThis function also eats up a lot of resources, so be sparse with it in general!\nreturns nil if getting the ProjectStateChunk took too long\nPARAMETERS:\nprojectfilename_with_path:the filename of an rpp-projectfile, that you want to load as ProjectStateChunk; nil, to get the ProjectStateChunk from the currently active project\nkeepqrender:true, keeps the QUEUED_RENDER_OUTFILE and QUEUED_RENDER_ORIGINAL_FILENAME entries in the ProjectStateChunk, if existing; false or nil, remove them\nRETURNS:\nProjectStateChunk:the ProjectStateChunk of the current project; nil, if getting the ProjectStateChunk took too long\n",
        "body": "ultraschall.GetProjectStateChunk(${1:optional string projectfilename_with_path},${2:optional boolean keepqrender})$0"
    },
    "ULTRASCHALL.ENUMPROJECTS lua": {
        "prefix": "ultraschall.EnumProjects",
        "scope": "lua",
        "description": "returns, ReaProject-object and projectname of a requested, opened project.\nReturns nil in case of an error.\nPARAMETERS:\nidx:the project to request; 1(first project-tab) to n(last project-tab), 0 for current project; -1 for currently-rendering project\nRETURNS:\nretval:a ReaProject-object of the project you requested; nil, if not existing\nprojfn:the path+filename.rpp of the project. returns \"\" if no filename exists\n",
        "body": "ultraschall.EnumProjects(${1:integer idx})$0"
    },
    "ULTRASCHALL.GETPROJECTLENGTH lua": {
        "prefix": "ultraschall.GetProjectLength",
        "scope": "lua",
        "description": "Returns the position of the last itemedge, regionend, marker, time-signature-marker in the project.\nIt will return -1, if no such elements are found, means: last\\_markerpos=-1 if no marker has been found\nException when no items are found, it will return nil for last\\_itemedge\nYou can optimise the speed of the function, by setting the appropriate parameters to false.\nSo if you don't need the last itemedge, setting return\\_last\\_itemedge=false speeds up execution massively.\nTo do the same for projectfiles, use: GetProject\\_Length\nPARAMETERS:\nreturn_last_itemedge:true or nil, return the last itemedge; false, don't return it\nreturn_last_markerpos:true or nil, return the last marker/regionend-position; false, don't return it \nreturn_lat_timesigmarkerpos:true or nil, return the last timesignature-marker-position; false, don't return it\nRETURNS:\nlast_itemedge:the position of the last itemedge in the project; nil, if not found\nlast_regionedgepos:the position of the last regionend in the project; -1, if not found\nlast_markerpos:the position of the last marker in the project; -1, if not found \nlast_timesigmarker:the position of the last timesignature-marker in the project; -1, if not found\n",
        "body": "ultraschall.GetProjectLength(${1:optional boolean return_last_itemedge},${2:optional boolean return_last_markerpos},${3:optional boolean return_lat_timesigmarkerpos})$0"
    },
    "ULTRASCHALL.GETRECENTPROJECTS lua": {
        "prefix": "ultraschall.GetRecentProjects",
        "scope": "lua",
        "description": "returns all available recent projects, as listed in the File -> Recent projects-menu\nRETURNS:\ncount_of_RecentProjects:the number of available recent projects\nRecentProjectsFilenamesWithPath:the filenames of the recent projects\n",
        "body": "ultraschall.GetRecentProjects()$0"
    },
    "ULTRASCHALL.ISVALIDPROJECTBAYSTATECHUNK lua": {
        "prefix": "ultraschall.IsValidProjectBayStateChunk",
        "scope": "lua",
        "description": "checks, if ProjectBayStateChunk is a valid ProjectBayStateChunk\nreturns false in case of an error\nPARAMETERS:\nProjectBayStateChunk:a string, that you want to check for being a valid ProjectBayStateChunk\nRETURNS:\nretval:true, valid ProjectBayStateChunk; false, not a valid ProjectBayStateChunk\n",
        "body": "ultraschall.IsValidProjectBayStateChunk(${1:string ProjectBayStateChunk})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMS_FROMPROJECTBAYSTATECHUNK lua": {
        "prefix": "ultraschall.GetAllMediaItems_FromProjectBayStateChunk",
        "scope": "lua",
        "description": "returns all items from a ProjectBayStateChunk as MediaItemStateChunkArray\nreturns -1 in case of an error\nPARAMETERS:\nProjectBayStateChunk:a string, that you want to check for being a valid ProjectBayStateChunk\nRETURNS:\ncount:the number of items found in the ProjectBayStateChunk\n",
        "body": "ultraschall.GetAllMediaItems_FromProjectBayStateChunk(${1:string ProjectBayStateChunk})$0"
    },
    "ULTRASCHALL.ISTIMESELECTIONACTIVE lua": {
        "prefix": "ultraschall.IsTimeSelectionActive",
        "scope": "lua",
        "description": "Returns, if there's a time-selection and its start and endposition in a project.\nreturns false in case of an error\nPARAMETERS:\nProject:the project, whose time-selection-state you want to know; 0 or nil, the current project\nRETURNS:\nretval:true, there is a time-selection; false, there isn't a time-selection\nstart_of_timeselection:start of the time-selection\nend_of_timeselection:end of the time-selection\n",
        "body": "ultraschall.IsTimeSelectionActive(${1:optional ReaProject Project})$0"
    },
    "ULTRASCHALL.GETPROJECTSTATE_NUMBERSONLY lua": {
        "prefix": "ultraschall.GetProjectState_NumbersOnly",
        "scope": "lua",
        "description": "returns a state of the project or a ProjectStateChunk.\nIt only supports single-entry-states with numbers/integers, separated by spaces!\nAll other values will be set to nil and strings with spaces will produce weird results!\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the states; nil to use ProjectStateChunk\nstate:the state, whose attributes you want to retrieve\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nnumbertoggle:true or nil; converts all values to numbers; false, keep them as string versions\nRETURNS:\nvalues:all values found as numerical indexed array\n",
        "body": "ultraschall.GetProjectState_NumbersOnly(${1:string projectfilename_with_path},${2:string state},${3:optional string ProjectStateChunk},${4:optional boolean numbertoggle})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERCFG lua": {
        "prefix": "ultraschall.GetProject_RenderCFG",
        "scope": "lua",
        "description": "Returns the render-cfg-string2, that contains all render-settings for primary and secondary render-settings of a project from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry <RENDER_CFG\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_cfg:the renderstring, which contains all secondary-render-settings for a project/projectstatechunk\nrender_cfg2:the renderstring, which contains all secondary-render-settings for a project/projectstatechunk\n",
        "body": "ultraschall.GetProject_RenderCFG(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GROUPOVERRIDE lua": {
        "prefix": "ultraschall.GetProject_GroupOverride",
        "scope": "lua",
        "description": "Returns the group-override-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry GROUPOVERRIDE\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ngroup_override1:the group-override state\ngroup_override3:the group-override state\n",
        "body": "ultraschall.GetProject_GroupOverride(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_AUTOCROSSFADE lua": {
        "prefix": "ultraschall.GetProject_AutoCrossFade",
        "scope": "lua",
        "description": "Returns the autocrossfade-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry AUTOXFADE\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename\nRETURNS:\nautocrossfade_state:the autocrossfade-state\n",
        "body": "ultraschall.GetProject_AutoCrossFade(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_ENVATTACH lua": {
        "prefix": "ultraschall.GetProject_EnvAttach",
        "scope": "lua",
        "description": "Returns the EnvAttach-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry ENVATTACH\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file; nil, use parameter ProjectStateChunk instead\nProjectStateChunk:a projectstatechunk to read the value from; only used, projectfilename_with_path is nil\nRETURNS:\nenv_attach:the env-attach state\n",
        "body": "ultraschall.GetProject_EnvAttach(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_POOLEDENVATTACH lua": {
        "prefix": "ultraschall.GetProject_PooledEnvAttach",
        "scope": "lua",
        "description": "Returns the PooledEnvAttach-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry POOLEDENVATTACH\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file; nil, use parameter ProjectStateChunk instead\nProjectStateChunk:a projectstatechunk to read the value from; only used, projectfilename_with_path is nil\nRETURNS:\npooled_env_attach:the pooled-env-attach state\n",
        "body": "ultraschall.GetProject_PooledEnvAttach(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MIXERUIFLAGS lua": {
        "prefix": "ultraschall.GetProject_MixerUIFlags",
        "scope": "lua",
        "description": "Returns the MixerUI-state-flags from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry MIXERUIFLAGS\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nstate1:folders, receives, etc \nstate2:master-track, FX, Mixer\n",
        "body": "ultraschall.GetProject_MixerUIFlags(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PEAKGAIN lua": {
        "prefix": "ultraschall.GetProject_PeakGain",
        "scope": "lua",
        "description": "Returns the GetProject_PeakGain-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry PEAKGAIN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npeakgain_state:peakgain-state\n",
        "body": "ultraschall.GetProject_PeakGain(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_FEEDBACK lua": {
        "prefix": "ultraschall.GetProject_Feedback",
        "scope": "lua",
        "description": "Returns the GetProject_Feedback-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry FEEDBACK\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nfeedback_state:feedback-state\n",
        "body": "ultraschall.GetProject_Feedback(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PANLAW lua": {
        "prefix": "ultraschall.GetProject_PanLaw",
        "scope": "lua",
        "description": "Returns the GetProject_PanLaw-state from an RPP-Projectfile or a ProjectStateChunk, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db).\nIt's the entry PANLAW\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npanlaw_state:state of the panlaw, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db). 0.5(-6.02 db) to 1(default +0.0 db)\n",
        "body": "ultraschall.GetProject_PanLaw(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PROJOFFSETS lua": {
        "prefix": "ultraschall.GetProject_ProjOffsets",
        "scope": "lua",
        "description": "Returns the Project Offset-state from an RPP-Projectfile or a ProjectStateChunk, start time as well as start measure.\nas set in ProjectSettings->ProjectSettings->Project Start Time/Measure and the checkbox Base Ruler Marking Off This Measure-checkbox\nIt's the entry PROJOFFS\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nstart_time:the project-start-time in seconds\nstart_measure:starting with 0, unlike the Settingswindow, where the 0 becomes 1 as measure\nbase_ruler_marking_off_this_measure:0, checkbox unchecked; 1, checkbox checked\n",
        "body": "ultraschall.GetProject_ProjOffsets(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MAXPROJECTLENGTH lua": {
        "prefix": "ultraschall.GetProject_MaxProjectLength",
        "scope": "lua",
        "description": "Returns the maximum-project-length from an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Advanced->\nas set in ProjectSettings->ProjectSettings->Project Start Time/Measure.\nIt's the entry MAXPROJLEN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nlimit_project_length:checkbox \"Limit project length, stop playback/recording at:\" - 0 off, 1 on\nprojectlength_limit:projectlength-limit in seconds\n",
        "body": "ultraschall.GetProject_MaxProjectLength(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GRID lua": {
        "prefix": "ultraschall.GetProject_Grid",
        "scope": "lua",
        "description": "Returns the grid-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry GRID\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file\nRETURNS:\ngridstate1:gridstate1\ngridstate2:gridstate2\ngridstate3:gridstate3\ngridstate4:gridstate4\ngridstate5:gridstate5\ngridstate6:gridstate6\ngridstate7:gridstate7\ngridstate8:gridstate8\n",
        "body": "ultraschall.GetProject_Grid(${1:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.GETPROJECT_TIMEMODE lua": {
        "prefix": "ultraschall.GetProject_Timemode",
        "scope": "lua",
        "description": "Returns the timemode-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry TIMEMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nruler_timemode:ruler-timemode-state\ntimemode2:timemode-state\nshowntime:Transport shown time\ntimemode4:timemode-state\ntimemode5:timemode-state\ntimemode6:timemode-state\ntimemode7:timemode-state\n",
        "body": "ultraschall.GetProject_Timemode(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_VIDEOCONFIG lua": {
        "prefix": "ultraschall.GetProject_VideoConfig",
        "scope": "lua",
        "description": "Returns the videoconfig-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry VIDEO_CONFIG\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npreferredVidSizeX:preferred video size, x pixels\npreferredVidSizeY:preferred video size, y pixels\nsettingsflags:settings\n",
        "body": "ultraschall.GetProject_VideoConfig(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PANMODE lua": {
        "prefix": "ultraschall.GetProject_PanMode",
        "scope": "lua",
        "description": "Returns the panmode-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry PANMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npanmode_state:panmode-state\n",
        "body": "ultraschall.GetProject_PanMode(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_CURSORPOS lua": {
        "prefix": "ultraschall.GetProject_CursorPos",
        "scope": "lua",
        "description": "Returns the cursorposition-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry CURSOR\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ncursorpos:editcursorposition in seconds\n",
        "body": "ultraschall.GetProject_CursorPos(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_HORIZONTALZOOM lua": {
        "prefix": "ultraschall.GetProject_HorizontalZoom",
        "scope": "lua",
        "description": "Returns the horizontal-zoom-state from an RPP-Projectfile or a ProjectStateChunk.\nKeep in mind, that hzoomscrollpos and scrollbarfactor depend on each other. hzoomscrollpos is a smaller positioning-unit, while scrollbarfactor is the bigger positioning-unit.\nExperiment with it to get an idea.\nIt's the entry ZOOM\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nhzoom:horizontalscrollbarposition - 0 - 4294967296\nhzoomscrollpos:horizontalscrollbarposition - 0 - 4294967296\nscrollbarfactor:0 to 500837, counts up, when maximum hzoomscrollpos overflows\n",
        "body": "ultraschall.GetProject_HorizontalZoom(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_VERTICALZOOM lua": {
        "prefix": "ultraschall.GetProject_VerticalZoom",
        "scope": "lua",
        "description": "Returns the verticalzoom from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry VZOOMEX\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nvzoom:vertical zoomfactor(0-40)\n",
        "body": "ultraschall.GetProject_VerticalZoom(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_USERECCONFIG lua": {
        "prefix": "ultraschall.GetProject_UseRecConfig",
        "scope": "lua",
        "description": "Returns the rec-cfg-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry USE_REC_CFG\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrec_cfg:recording-cfg-state\n",
        "body": "ultraschall.GetProject_UseRecConfig(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RECMODE lua": {
        "prefix": "ultraschall.GetProject_RecMode",
        "scope": "lua",
        "description": "Returns the rec-mode-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RECMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrec_mode:recording-mode-state\n",
        "body": "ultraschall.GetProject_RecMode(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_SMPTESYNC lua": {
        "prefix": "ultraschall.GetProject_SMPTESync",
        "scope": "lua",
        "description": "Returns the smpte-sync-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry SMPTESYNC\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nsmptesync_state1:smptesync-state\nsmptesync_fps:framerate in fps\nsmptesync_resyncdrift:\"Re-synchronize if drift exceeds\" in ms (0 = never)\nsmptesync_skipdropframes:\"skip/drop frames if drift exceeds\" in ms(0 - never)\nsmptesync_syncseek:\"Synchronize by seeking ahead\" in ms (default = 1000)\nsmptesync_freewheel:\"Freewheel on missing time code for up to\" in ms(0 = forever)\nsmptesync_userinput:User Input-flag\nsmptesync_offsettimecode:Offset incoming timecode by in seconds\nsmptesync_stop_rec_drift:\"Stop recording if drift exceeds\" in ms(0 = never)\nsmptesync_state10:smptesync-state\ninteger smptesync_stop_rec_lacktime:\"stop recording on lack of timecode after\" in ms(0 = never)\n",
        "body": "ultraschall.GetProject_SMPTESync(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LOOP lua": {
        "prefix": "ultraschall.GetProject_Loop",
        "scope": "lua",
        "description": "Returns the loop-button-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry LOOP\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\n",
        "body": "ultraschall.GetProject_Loop(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LOOPGRAN lua": {
        "prefix": "ultraschall.GetProject_LoopGran",
        "scope": "lua",
        "description": "Returns the loop_gran-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry LOOPGRAN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nloopgran_state1:loopgran_state1\nloopgran_state2:loopgran_state2\n",
        "body": "ultraschall.GetProject_LoopGran(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RECPATH lua": {
        "prefix": "ultraschall.GetProject_RecPath",
        "scope": "lua",
        "description": "Returns the primary and secondary recording-path from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RECORD_PATH\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nprim_recpath:the primary recording path\nsec_recpath:the secondary recording path\n",
        "body": "ultraschall.GetProject_RecPath(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_APPLYFXCFG lua": {
        "prefix": "ultraschall.GetProject_ApplyFXCFG",
        "scope": "lua",
        "description": "Returns the audioformat-configuration, for fx-appliance-operation, as an encoded BASE64-string from an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Media->Format for Apply FX, Glue, Freeze, etc\nIt's the entry <APPLY_CFG\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\napplyfx_cfg_string:the file-format-configuration for fx-appliance as encoded string\n",
        "body": "ultraschall.GetProject_ApplyFXCFG(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERPATTERN lua": {
        "prefix": "ultraschall.GetProject_RenderPattern",
        "scope": "lua",
        "description": "Returns the render-pattern, that tells Reaper, how to automatically name the render-file, from an RPP-Projectfile or a ProjectStateChunk. If it contains nothing, you should check the Render_Pattern using GetProject_RenderFilename, as a render-pattern influences the rendering-filename as well.\nIt's the entry RENDER_PATTERN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_pattern:the pattern, with which the rendering-filename will be automatically created. Check also GetProject_RenderFilename\n",
        "body": "ultraschall.GetProject_RenderPattern(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERFREQNCHANS lua": {
        "prefix": "ultraschall.GetProject_RenderFreqNChans",
        "scope": "lua",
        "description": "Returns an unknown number, the render-frequency and rendernumber of channels from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RENDER_FMT\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nunknown:unknown number\nrendernum_chans:Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels\nrender_frequency:RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency\n",
        "body": "ultraschall.GetProject_RenderFreqNChans(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERSPEED lua": {
        "prefix": "ultraschall.GetProject_RenderSpeed",
        "scope": "lua",
        "description": "Returns the rendering-speed from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RENDER_1X\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_speed:render_speed \n",
        "body": "ultraschall.GetProject_RenderSpeed(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERRANGE lua": {
        "prefix": "ultraschall.GetProject_RenderRange",
        "scope": "lua",
        "description": "Returns the render-range, render-timestart, render-timeend, render-tail and render-taillength from an RPP-Projectfile or a ProjectStateChunk. To get RENDER_STEMS, refer GetProject_RenderStems\nIt's the entry RENDER_RANGE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nbounds:the bounds of the project to be rendered\ntime_start:TimeStart in milliseconds -2147483647 to 2147483647\ntime_end:TimeEnd in milliseconds 2147483647 to 2147483647\ntail:TailLength in milliseconds, valuerange 0 - 2147483647\ntail_length:TailLength in milliseconds, valuerange 0 - 2147483647\n",
        "body": "ultraschall.GetProject_RenderRange(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERRESAMPLE lua": {
        "prefix": "ultraschall.GetProject_RenderResample",
        "scope": "lua",
        "description": "Returns Resamplemode for a)Rendering and b)Playback as well as c)if both are combined from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RENDER_RESAMPLE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nresample_mode:Playback Resample Mode (as set in the Project-Settings)\nplayback_resample_mode:Playback Resample Mode (as set in the Project-Settings)\nproject_smplrate4mix_and_fx:Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\n",
        "body": "ultraschall.GetProject_RenderResample(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_ADDMEDIATOPROJECTAFTERRENDER lua": {
        "prefix": "ultraschall.GetProject_AddMediaToProjectAfterRender",
        "scope": "lua",
        "description": "Returns, if rendered media shall be added to the project afterwards as well as if likely silent files shall be rendered-state, from an RPP-Projectfile or a ProjectStateChunk.\nIt's the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox, as set in the Render to file-dialog.\nIt's the entry RENDER_ADDTOPROJ\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nstate:the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox \n",
        "body": "ultraschall.GetProject_AddMediaToProjectAfterRender(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERSTEMS lua": {
        "prefix": "ultraschall.GetProject_RenderStems",
        "scope": "lua",
        "description": "Returns the render-stems-state from an rpp-project-file or a ProjectStateChunk.\nIt's the entry RENDER_STEMS\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_stems:the state of Render Stems\n",
        "body": "ultraschall.GetProject_RenderStems(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERDITHERSTATE lua": {
        "prefix": "ultraschall.GetProject_RenderDitherState",
        "scope": "lua",
        "description": "Returns the render-dither-state from an rpp-project-file or a ProjectStateChunk.\nIt's the entry RENDER_DITHER\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrenderdither_state:the state of render dithering\n",
        "body": "ultraschall.GetProject_RenderDitherState(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TIMEBASE lua": {
        "prefix": "ultraschall.GetProject_TimeBase",
        "scope": "lua",
        "description": "Returns the timebase-state from an rpp-project-file or a ProjectStateChunk.\nIt's the entry TIMELOCKMODE x\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntimebase:the timebase for items/envelopes/markers as set in the project settings\n",
        "body": "ultraschall.GetProject_TimeBase(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPOTIMESIGNATURE lua": {
        "prefix": "ultraschall.GetProject_TempoTimeSignature",
        "scope": "lua",
        "description": "Returns the timebase for tempo/time-signature as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry TEMPOENVLOCKMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntempotimesignature:the timebase for tempo/time-signature as set in the project settings\n",
        "body": "ultraschall.GetProject_TempoTimeSignature(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_ITEMMIXBEHAVIOR lua": {
        "prefix": "ultraschall.GetProject_ItemMixBehavior",
        "scope": "lua",
        "description": "Returns the item mix behavior, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry ITEMMIX\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nitem_mix_behav_state:item mix behavior\n",
        "body": "ultraschall.GetProject_ItemMixBehavior(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_SAMPLERATE lua": {
        "prefix": "ultraschall.GetProject_SampleRate",
        "scope": "lua",
        "description": "Returns the take-lane-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry SAMPLERATE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nsample_rate:Checkbox: Project Sample Rate\nproject_sample_rate:Checkbox: Project Sample Rate\nforce_tempo_time_sig:Checkbox: Force Project Tempo/Time Signature changes to occur on whole samples \n",
        "body": "ultraschall.GetProject_SampleRate(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TRACKMIXINGDEPTH lua": {
        "prefix": "ultraschall.GetProject_TrackMixingDepth",
        "scope": "lua",
        "description": "Returns the track-mixing-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry INTMIXMODE\nReturns -1 in case of error, nil if it's set to 64bit(default)!\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntrack_mixing_depth:track mixing depth\n",
        "body": "ultraschall.GetProject_TrackMixingDepth(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TRACKSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_TrackStateChunk",
        "scope": "lua",
        "description": "Returns an RPPXML-trackstatechunk from an rpp-project-file or a ProjectStateChunk, with tracknumber idx. IDX is 1 for the first track in the project-file, 2 for the second, etc\nReturns -1 in case of error.\nUse GetProject_NumberOfTracks to get the number of tracks within an rpp-file.\nThe returned trackstatechunk can be inserted into the current project with InsertTrack_TrackStateChunk.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nidx:the tracknumber you want to have\ndeletetrackid:deletes the trackID in the trackstate-chunk, to avoid possible conflicts within a project, where it shall be imported to\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntrackstatechunk:an RPP-XML-Trackstate-chunk, that can be used by functions like reaper.SetTrackStateChunk()\n",
        "body": "ultraschall.GetProject_TrackStateChunk(${1:string projectfilename_with_path},${2:integer idx},${3:boolean deletetrackid},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_NUMBEROFTRACKS lua": {
        "prefix": "ultraschall.GetProject_NumberOfTracks",
        "scope": "lua",
        "description": "Returns the number of tracks within an rpp-project-file or a GetProject_NumberOfTracks.\nReturns -1 in case of error.\nNote: Huge projectfiles with thousands of items may take some seconds to load.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nnumber_of_tracks:the number of tracks within an projectfile\n",
        "body": "ultraschall.GetProject_NumberOfTracks(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_SELECTION lua": {
        "prefix": "ultraschall.GetProject_Selection",
        "scope": "lua",
        "description": "Returns the state of the checkbox Delay queued render to allow samples to load-checkbox and the length of the delay.\nIt's the entry RENDER_QDELAY\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nqdelay_checkstate:true, the checkbox is checked; false, it is unchecked\nqdelay_seconds:the length of the queued-render-delay in seconds\n",
        "body": "ultraschall.GetProject_Selection(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_QRENDERORIGINALPROJECT lua": {
        "prefix": "ultraschall.GetProject_QRenderOriginalProject",
        "scope": "lua",
        "description": "Returns the original-filename of a queue-render-projectfile. Will return empty string, if the queued-render-project hadn't been saved before it was added to the render-queue.\nIt's the entry QUEUED_RENDER_ORIGINAL_FILENAME\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nqrender_originalproject_file:the original-projectfilename of the queue-render-project\n",
        "body": "ultraschall.GetProject_QRenderOriginalProject(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_QRENDEROUTFILES lua": {
        "prefix": "ultraschall.GetProject_QRenderOutFiles",
        "scope": "lua",
        "description": "Returns the outfiles of the rendered files, stored in a queue-render-projectfile. This includes the path and files of the files, that will be rendered.\nIt's the entry QUEUED_RENDER_OUTFILE\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ncount_outfiles:the number of render-outfiles\nQRenderOutFilesList:the guids of the rendered outfiles\nQRenderOutFilesListGuid:the guids of the rendered outfiles\nAutoCloseWhenFinished:true, the render-dialog will be closed after render is finished; false, the render-dialog keeps open\nAutoIncrementFilename:true, autoincrement filename if the file already exists; false, don't autoincrement filename\nSaveCopyToOutfile:true, save a copy of the project as e.g. \"outfile.wav.RPP\"; false, don't save a copy of the project\n",
        "body": "ultraschall.GetProject_QRenderOutFiles(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RIPPLESTATE lua": {
        "prefix": "ultraschall.SetProject_RippleState",
        "scope": "lua",
        "description": "Sets the ripple-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nripple_state:0, no Ripple; 1, Ripple One Track; 2, Ripple All\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RippleState(${1:string projectfilename_with_path},${2:integer ripple_state},${3:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERQUEUEDELAY lua": {
        "prefix": "ultraschall.SetProject_RenderQueueDelay",
        "scope": "lua",
        "description": "Sets the render-queue-delay-time in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrenderqdelay:0 and higher, sets the checkbox \"Delay queued render to allow samples to load and the amount of time to wait in seconds\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RenderQueueDelay(${1:string projectfilename_with_path},${2:integer renderqdelay},${3:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_SELECTION lua": {
        "prefix": "ultraschall.SetProject_Selection",
        "scope": "lua",
        "description": "Sets the ripple-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstarttime:start of the second selection in seconds\nendtime:end of the second selection in seconds\nstarttime2:start of the second selection in seconds\nendtime2:end of the second selection in seconds\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_Selection(${1:string projectfilename_with_path},${2:number starttime},${3:number endtime},${4:number starttime2},${5:number endtime2},${6:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_GROUPOVERRIDE lua": {
        "prefix": "ultraschall.SetProject_GroupOverride",
        "scope": "lua",
        "description": "Sets the group-override-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ngroup_override1:the group-override state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_GroupOverride(${1:string projectfilename_with_path},${2:integer group_override1},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MIXERUIFLAGS lua": {
        "prefix": "ultraschall.SetProject_MixerUIFlags",
        "scope": "lua",
        "description": "Sets the Mixer-UI-state-flags in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstate_bitfield1:folders, receives, etc \nstate_bitfield2:master-track, FX, Mixer\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_MixerUIFlags(${1:string projectfilename_with_path},${2:integer state_bitfield1},${3:integer state_bitfield2},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PEAKGAIN lua": {
        "prefix": "ultraschall.SetProject_PeakGain",
        "scope": "lua",
        "description": "Sets the peak-gain-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npeakgain_state:peak-gain-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_PeakGain(${1:string projectfilename_with_path},${2:number peakgain_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_FEEDBACK lua": {
        "prefix": "ultraschall.SetProject_Feedback",
        "scope": "lua",
        "description": "Sets the feedback-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nfeedback_state:feedback-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_Feedback(${1:string projectfilename_with_path},${2:integer feedback_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PANLAW lua": {
        "prefix": "ultraschall.SetProject_PanLaw",
        "scope": "lua",
        "description": "Sets the panlaw-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npanlaw_state:state of the panlaw, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db). 0.5(-6.02 db) to 1(default +0.0 db)\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_PanLaw(${1:string projectfilename_with_path},${2:number panlaw_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PROJOFFSETS lua": {
        "prefix": "ultraschall.SetProject_ProjOffsets",
        "scope": "lua",
        "description": "Sets the project-offset-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nThe project-offset, as set in the ProjectSettings -> Project Time Start, Project start measure and Base Ruler Marking Off This Measure-checkbox\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstart_time:the project-start-time in seconds\nstart_measure:the start-measure; starting with 0, unlike in the Project-Settings-window, where the 0 becomes 1 as startmeasure\nbase_ruler_marking_off_this_measure:0, checkbox unchecked; 1, checkbox checked\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_ProjOffsets(${1:string projectfilename_with_path},${2:number start_time},${3:integer start_measure},${4:integer base_ruler_marking_off_this_measure},${5:optional ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MAXPROJECTLENGTH lua": {
        "prefix": "ultraschall.SetProject_MaxProjectLength",
        "scope": "lua",
        "description": "Sets the max-project-length-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nlimit_project_length:checkbox \"Limit project length, stop playback/recording at:\" - 0 off, 1 on\nprojectlength_limit:projectlength-limit in seconds\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_MaxProjectLength(${1:string projectfilename_with_path},${2:integer limit_project_length},${3:number projectlength_limit},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_GRID lua": {
        "prefix": "ultraschall.SetProject_Grid",
        "scope": "lua",
        "description": "Sets the setproject-grid-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ngridstate1:gridstate1\ngridstate2:gridstate2\ngridstate3:gridstate3\ngridstate4:gridstate4\ngridstate5:gridstate5\ngridstate6:gridstate6\ngridstate7:gridstate7\ngridstate8:gridstate8\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_Grid(${1:string projectfilename_with_path},${2:integer gridstate1},${3:integer gridstate2},${4:number gridstate3},${5:integer gridstate4},${6:number gridstate5},${7:integer gridstate6},${8:integer gridstate7},${9:number gridstate8},${10:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TIMEMODE lua": {
        "prefix": "ultraschall.SetProject_Timemode",
        "scope": "lua",
        "description": "Sets the timemode-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntimemode2:timemode-state\nshowntime:Transport shown time\ntimemode4:timemode-state\ntimemode5:timemode-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_Timemode(${1:string projectfilename_with_path},${2:integer timemode1},${3:integer timemode2},${4:integer showntime},${5:integer timemode4},${6:integer timemode5},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_VIDEOCONFIG lua": {
        "prefix": "ultraschall.SetProject_VideoConfig",
        "scope": "lua",
        "description": "Sets the video-config-settings, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npreferredVidSizeX:preferred video size, x pixels\npreferredVidSizeY:preferred video size, y pixels\nsettingsBitfield:settings\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_VideoConfig(${1:string projectfilename_with_path},${2:integer preferredVidSizeX},${3:integer preferredVidSizeY},${4:integer settingsBitfield},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PANMODE lua": {
        "prefix": "ultraschall.SetProject_PanMode",
        "scope": "lua",
        "description": "Sets the panmode-settings, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npanmode_state:panmode-state - ProjectSettings->Advanced->Pan law/mode->Pan mode\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_PanMode(${1:string projectfilename_with_path},${2:integer panmode_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_CURSORPOS lua": {
        "prefix": "ultraschall.SetProject_CursorPos",
        "scope": "lua",
        "description": "Sets the cursor-position in an rpp-project-file or a ProjectStateChunk\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ncursorpos:editcursorposition in seconds\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_CursorPos(${1:string projectfilename_with_path},${2:number cursorpos},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_HORIZONTALZOOM lua": {
        "prefix": "ultraschall.SetProject_HorizontalZoom",
        "scope": "lua",
        "description": "Sets the horizontal-zoom in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nhzoom:horizontalscrollbarposition - 0 - 4294967296\nhzoomscrollpos:horizontalscrollbarposition - 0 - 4294967296\nscrollbarfactor:0 to 500837, counts up, when maximum hzoomscrollpos overflows\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_HorizontalZoom(${1:string projectfilename_with_path},${2:number hzoom},${3:integer hzoomscrollpos},${4:integer scrollbarfactor},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_VERTICALZOOM lua": {
        "prefix": "ultraschall.SetProject_VerticalZoom",
        "scope": "lua",
        "description": "Sets the vertical-zoom from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nvzoom:vertical zoomfactor(0-40)\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_VerticalZoom(${1:string projectfilename_with_path},${2:integer vzoom},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_USERECCONFIG lua": {
        "prefix": "ultraschall.SetProject_UseRecConfig",
        "scope": "lua",
        "description": "Sets the UseRec-Config in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrec_cfg:recording-cfg-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_UseRecConfig(${1:string projectfilename_with_path},${2:integer rec_cfg},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RECMODE lua": {
        "prefix": "ultraschall.SetProject_RecMode",
        "scope": "lua",
        "description": "Sets the recording-mode-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrec_mode:recording mode\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RecMode(${1:string projectfilename_with_path},${2:integer rec_mode},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_SMPTESYNC lua": {
        "prefix": "ultraschall.SetProject_SMPTESync",
        "scope": "lua",
        "description": "Sets the TimeCodeSyncronization-SMPTE-Config in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nsmptesync_state1:smptesync-state\nsmptesync_fps:framerate in fps\nsmptesync_resyncdrift:\"Re-synchronize if drift exceeds\" in ms (0 = never)\nsmptesync_skipdropframes:\"skip/drop frames if drift exceeds\" in ms(0 - never)\nsmptesync_syncseek:\"Synchronize by seeking ahead\" in ms (default = 1000)\nsmptesync_freewheel:\"Freewheel on missing time code for up to\" in ms(0 = forever)\nsmptesync_userinput:User Input-flag\nsmptesync_offsettimecode:Offset incoming timecode by in seconds\nsmptesync_stop_rec_drift:\"Stop recording if drift exceeds\" in ms(0 = never)\nsmptesync_state10:smptesync-state\nsmptesync_stop_rec_lacktime:\"stop recording on lack of timecode after\" in ms(0 = never)\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_SMPTESync(${1:string projectfilename_with_path},${2:integer smptesync_state1},${3:number smptesync_fps},${4:integer smptesync_resyncdrift},${5:integer smptesync_skipdropframes},${6:integer smptesync_syncseek},${7:integer smptesync_freewheel},${8:integer smptesync_userinput},${9:number smptesync_offsettimecode},${10:integer smptesync_stop_rec_drift},${11:integer smptesync_state10},${12:integer smptesync_stop_rec_lacktime},${13:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_LOOP lua": {
        "prefix": "ultraschall.SetProject_Loop",
        "scope": "lua",
        "description": "Sets the UseRec-Config in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_Loop(${1:string projectfilename_with_path},${2:integer loopbutton_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_LOOPGRAN lua": {
        "prefix": "ultraschall.SetProject_LoopGran",
        "scope": "lua",
        "description": "Sets the Loop-Gran-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nloopgran_state1:loopgran_state1\nloopgran_state2:loopgran_state2\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_LoopGran(${1:string projectfilename_with_path},${2:integer loopgran_state1},${3:number loopgran_state2},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RECPATH lua": {
        "prefix": "ultraschall.SetProject_RecPath",
        "scope": "lua",
        "description": "Sets the primary and secondary recording-paths in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nprim_recpath:primary recording path\nsec_recpath:secondary recording path\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RecPath(${1:string projectfilename_with_path},${2:string prim_recpath},${3:string sec_recpath},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERCFG lua": {
        "prefix": "ultraschall.SetProject_RenderCFG",
        "scope": "lua",
        "description": "Sets the primary and secondary render-configuration as encoded string in an RPP-Projectfile or a ProjectStateChunk, as set in Render-Settings\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrendercfg_string:the secondary render-configuration as encoded string; use \"\" or nil to not set it\nrendercfg_string2:the secondary render-configuration as encoded string; use \"\" or nil to not set it\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RenderCFG(${1:string projectfilename_with_path},${2:string rendercfg_string},${3:string rendercfg_string2},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERFILENAME lua": {
        "prefix": "ultraschall.SetProject_RenderFilename",
        "scope": "lua",
        "description": "Sets the render-filename in an rpp-projectfile or a ProjectStateChunk. Set to \"\", if you want to set a render-pattern with SetProject_RenderPattern.\nThe rendername is influenced by the settings in the RENDER_PATTERN-entry in the RPP-file, see SetProject_RenderPattern to influence or remove the RENDER_PATTERN-entry(Removing RENDER_PATTERN may help when Reaper rendering it to the name given in parameter render_filename.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk insteadO\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RenderFilename(${1:string projectfilename_with_path},${2:string renderfilename},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERFREQNCHANS lua": {
        "prefix": "ultraschall.SetProject_RenderFreqNChans",
        "scope": "lua",
        "description": "Returns an unknown number, the render-frequency and rendernumber of channels from an RPP-Projectfile or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nunknown:unknown number\nrendernum_chans:Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels\nrender_frequency:RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RenderFreqNChans(${1:string projectfilename_with_path},${2:integer unknown},${3:integer rendernum_chans},${4:integer render_frequency},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERRANGE lua": {
        "prefix": "ultraschall.SetProject_RenderRange",
        "scope": "lua",
        "description": "Sets the render-range, render-timestart, render-timeend, render-tail and render-taillength in an RPP-Projectfile or a ProjectStateChunk.\nTo get RENDER_STEMS, refer GetProject_RenderStems\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nbounds:the bounds of the project to be rendered\ntime_start:TimeStart in milliseconds -2147483647 to 2147483647\ntime_end:TimeEnd in milliseconds 2147483647 to 2147483647\ntail:TailLength in milliseconds, valuerange 0 - 2147483647\ntail_length:TailLength in milliseconds, valuerange 0 - 2147483647\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RenderRange(${1:string projectfilename_with_path},${2:integer bounds},${3:number time_start},${4:number time_end},${5:integer tail},${6:integer tail_length},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERRESAMPLE lua": {
        "prefix": "ultraschall.SetProject_RenderResample",
        "scope": "lua",
        "description": "Resamplemode for a)Rendering and b)Playback as well as c)if both are combined from an RPP-Projectfile or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nresample_mode:Playback Resample Mode (as set in the Project-Settings)\nplayback_resample_mode:Playback Resample Mode (as set in the Project-Settings)\nproject_smplrate4mix_and_fx:Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RenderResample(${1:string projectfilename_with_path},${2:integer resample_mode},${3:integer playback_resample_mode},${4:integer project_smplrate4mix_and_fx},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_ADDMEDIATOPROJECTAFTERRENDER lua": {
        "prefix": "ultraschall.SetProject_AddMediaToProjectAfterRender",
        "scope": "lua",
        "description": "Sets, if rendered media shall be added to the project afterwards as well as if likely silent files shall be rendered-state, from an RPP-Projectfile or a ProjectStateChunk.\nIt's the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox, as set in the Render to file-dialog.\nIt's the entry RENDER_ADDTOPROJ\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstate:the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_AddMediaToProjectAfterRender(${1:string projectfilename_with_path},${2:integer state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERSTEMS lua": {
        "prefix": "ultraschall.SetProject_RenderStems",
        "scope": "lua",
        "description": "Sets the render-stems-state from an RPP-Projectfile or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrender_stems:the state of Render Stems\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_RenderStems(${1:string projectfilename_with_path},${2:integer render_stems},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TIMEBASE lua": {
        "prefix": "ultraschall.SetProject_TimeBase",
        "scope": "lua",
        "description": "Sets the timebase, as set in the project-settings, in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntimebase:the timebase for items/envelopes/markers as set in the project settings\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_TimeBase(${1:string projectfilename_with_path},${2:integer timebase},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TEMPOTIMESIGNATURE lua": {
        "prefix": "ultraschall.SetProject_TempoTimeSignature",
        "scope": "lua",
        "description": "Sets the timebase, as set in the project-settings, in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntempotimesignature:the timebase for tempo/time-signature as set in the project settings\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_TempoTimeSignature(${1:string projectfilename_with_path},${2:integer tempotimesignature},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_ITEMMIXBEHAVIOR lua": {
        "prefix": "ultraschall.SetProject_ItemMixBehavior",
        "scope": "lua",
        "description": "Sets the item mix behavior, as set in the project-settings, from an rpp-project-file.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file\nitem_mix_behav_state:item mix behavior\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_ItemMixBehavior(${1:string projectfilename_with_path},${2:integer item_mix_behav_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_DEFPITCHMODE lua": {
        "prefix": "ultraschall.SetProject_DefPitchMode",
        "scope": "lua",
        "description": "Sets the default-pitch-mode, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ndef_pitch_mode_state:the default pitch mode\nstretch_marker_mode:the stretch marker mode\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_DefPitchMode(${1:string projectfilename_with_path},${2:integer def_pitch_mode_state},${3:integer stretch_marker_mode},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TRACKMIXINGDEPTH lua": {
        "prefix": "ultraschall.SetProject_TrackMixingDepth",
        "scope": "lua",
        "description": "Sets the project-samplerate-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nmixingdepth:the track mixing depth\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_TrackMixingDepth(${1:string projectfilename_with_path},${2:integer mixingdepth},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_COUNTMARKERSANDREGIONS lua": {
        "prefix": "ultraschall.GetProject_CountMarkersAndRegions",
        "scope": "lua",
        "description": "returns the number of all markers, the number of regions and the number of markers(that are not regions) in the project.\nIt's the entry MARKER\nreturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename in which to count the markers\nRETURNS:\nnumber_of_markers_and_regions:the number of all markers and regions\nnumber_of_regions_only:the number of regions\nnumber_of_markers_only:the number of markers only\n",
        "body": "ultraschall.GetProject_CountMarkersAndRegions(${1:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.GETPROJECT_GETMARKER lua": {
        "prefix": "ultraschall.GetProject_GetMarker",
        "scope": "lua",
        "description": "returns the information of the marker idx in a projectfile.\nIt's the entry MARKER\nreturns false in case of error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename from where to get the marker\nidx:the number of the marker, you want to have the information of\nRETURNS:\nretval:true, in case of success; false in case of failure\nshownnumber:the number that is shown with the marker in the arrange-view\nmarkerposition:the position of the marker in seconds\nmarkertitle:the name of the marker. \"\" if no name is given.\nmarkercolor:the colorvalue of the marker\n",
        "body": "ultraschall.GetProject_GetMarker(${1:string projectfilename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.GETPROJECT_GETREGION lua": {
        "prefix": "ultraschall.GetProject_GetRegion",
        "scope": "lua",
        "description": "returns the information of the region idx in a projectfile.\nIt's the entry MARKER\nreturns false in case of error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename from where to get the region\nidx:the number of the marker, you want to have the information of\nRETURNS:\nretval:true, in case of success; false in case of failure\nshownnumber:the number that is shown with the region in the arrange-view\nstart_of_region:the startposition of the region in seconds\nend_of_region:the endposition of the region in seconds\nregionname:the name of the region. \"\" if no name is given.\nregioncolor:the colorvalue of the region\n",
        "body": "ultraschall.GetProject_GetRegion(${1:string projectfilename_with_path},${2:integer idx})$0"
    },
    "ULTRASCHALL.ISVALIDREAPROJECT lua": {
        "prefix": "ultraschall.IsValidReaProject",
        "scope": "lua",
        "description": "Returns, if parameter ReaProject is a valid ReaProject(means, an existing opened project) or not.\nreturns false in case of an error\nPARAMETERS:\nReaProject:the object that you want to check for being a valid ReaProject\nRETURNS:\nretval:true, if parameter ReaProject is a valid ReaProject; false, if parameter ReaProject isn't a valid ReaProject\n",
        "body": "ultraschall.IsValidReaProject(${1:ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.NEWPROJECTTAB lua": {
        "prefix": "ultraschall.NewProjectTab",
        "scope": "lua",
        "description": "Opens a new projecttab and optionally switches to it. Returns the newly created ReaProject.\nreturns nil in case of an error\nPARAMETERS:\nswitch_to_new_tab:true, switch to the newly created project-tab; false, stay in the \"old\" project-tab\nRETURNS:\nnewproject:the newly created project-object of the projecttab\n",
        "body": "ultraschall.NewProjectTab(${1:boolean switch_to_new_tab})$0"
    },
    "ULTRASCHALL.GETCURRENTTIMELENGTHOFFRAME lua": {
        "prefix": "ultraschall.GetCurrentTimeLengthOfFrame",
        "scope": "lua",
        "description": "Returns a project's length of a frame in seconds. Depends on the fps set in the Project's settings of ReaProject.\nReturns -1 in case of an error\nPARAMETERS:\nReaProject:the project to check for; use nil or 0 for the current project\nRETURNS:\nlength:the current length of a frame of ReaProject in seconds\n",
        "body": "ultraschall.GetCurrentTimeLengthOfFrame(${1:ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.GETLENGTHOFFRAMES lua": {
        "prefix": "ultraschall.GetLengthOfFrames",
        "scope": "lua",
        "description": "Returns the length of a number of frames of a ReaProject. Depends on the fps set in the Project's settings of ReaProject.\nReturns -1 in case of an error\nPARAMETERS:\nframes:the number of frames, whose length you would love to know\nReaProject:the project to check for; use nil or 0 for the current project\nRETURNS:\nlength:the current length of frames of ReaProject in seconds\n",
        "body": "ultraschall.GetLengthOfFrames(${1:integer frames},${2:ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.CONVERTOLDPROJECTTOCURRENTREAPERVERSION lua": {
        "prefix": "ultraschall.ConvertOldProjectToCurrentReaperVersion",
        "scope": "lua",
        "description": "Convert an old Reaper-project to the current Reaper-version.\nIt creates a backup-copy of the old version of the project.rpp to project.rpp~0\nAfter that, it will open the project and save it again, so it is saved with the newest version of Reaper.\nMaybe helpful, when you want to use the Ultraschall-API Get/SetProject-State-functions on older projects, where some states were saved differently.\nJust create a \"new\" version of it and use the aforementioned functions on the new project-version.\nReturns false in case of an error.\nPARAMETERS:\nfilename_with_path:the filename with path of the rpp-projectfile to be converted.\nRETURNS:\nretval:true, conversion was successfull; false, conversion wasn't successful(file doesn't exist or a copy can't be created)\n",
        "body": "ultraschall.ConvertOldProjectToCurrentReaperVersion(${1:string filename_with_path})$0"
    },
    "ULTRASCHALL.GETPROJECT_PROJECTBAY lua": {
        "prefix": "ultraschall.GetProject_ProjectBay",
        "scope": "lua",
        "description": "returns the ProjectBay-StateChunk, that holds MediaItems, that shall be retained in the \"background\" of the project, even if they are deleted from the project.\nThese MediaItems can be seen and set to retain from within the ProjectBay-window.\nIt's the entry <PROJBAY ... >\nreturns nil in case of an error\nPARAMETERS:\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nProjectBayStateChunk:the statechunk of the ProjectBay\n",
        "body": "ultraschall.GetProject_ProjectBay(${1:string ProjectStateChunk},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_METRONOME lua": {
        "prefix": "ultraschall.GetProject_Metronome",
        "scope": "lua",
        "description": "returns the Metronome-StateChunk, that holds metronome-settings.\nIt's the entry <METRONOME ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the metronome-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMetronomeStateChunk:the statechunk of the Metronome\n",
        "body": "ultraschall.GetProject_Metronome(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERPLAYSPEED lua": {
        "prefix": "ultraschall.GetProject_MasterPlayspeed",
        "scope": "lua",
        "description": "returns the Master-Playspeed-StateChunk, that holds Playspeed-settings of the master.\nIt's the entry <MASTERPLAYSPEEDENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-playspeed-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterPlayspeedStateChunk:the statechunk of the MasterPlaySpeed\n",
        "body": "ultraschall.GetProject_MasterPlayspeed(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPOENVEX lua": {
        "prefix": "ultraschall.GetProject_TempoEnvEx",
        "scope": "lua",
        "description": "returns the Tempo-StateChunk, that holds tempo-settings of the master.\nIt's the entry <TEMPOENVEX ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the tempo-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nTempoStateChunk:the statechunk of the Tempo\n",
        "body": "ultraschall.GetProject_TempoEnvEx(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_EXTENSIONS lua": {
        "prefix": "ultraschall.GetProject_Extensions",
        "scope": "lua",
        "description": "returns the Extensions-settings-StateChunk, that holds tempo-settings of the master.\nIt's the entry <EXTENSIONS ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the extension-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nExtensionsStateChunk:the statechunk of the Extensions-settings\n",
        "body": "ultraschall.GetProject_Extensions(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LOCK lua": {
        "prefix": "ultraschall.GetProject_Lock",
        "scope": "lua",
        "description": "returns the individual lock-settings of the project, as set in menu Options -> Locking -> Locking Settings\nIt's the entry LOCK\nIt is the one before(!) any\nstring projectfilename_with_path - the projectfile+path, from which to get the lock-state; nil to use ProjectStateChunk\noptional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file\ninteger lock_state - the lock-state, which is a bitfield\n- &1     - Time selection\n- &2     - Items (full)\n- &4     - Track envelopes\n- &8     - Markers\n- &16    - Regions\n- &32    - Time signature markers\n- &64    - Items (prevent left/right movement)\n- &128   - Items (prevent up/down movement)\n- &256   - Item edges\n- &512   - Item fade/volume handles\n- &1024  - Loop points locked\n- &2048  - Item envelopes\n- &4096  - Item stretch markers\n- &16384 - Enable locking\nProject-Management\nRPP-Files Get\nUS_Api_Functions\nModules/ultraschall_functions_ProjectManagement_ProjectFiles_Module.lua\nprojectmanagement, get, lock, projectstatechunk\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the lock-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nlock_state:the lock-state, which is a bitfield\n",
        "body": "ultraschall.GetProject_Lock(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GLOBALAUTO lua": {
        "prefix": "ultraschall.GetProject_GlobalAuto",
        "scope": "lua",
        "description": "returns the global-automation-settings of the project.\nIt's the entry GLOBAL_AUTO\nreturns nil in case of an error or if the setting isn't existing\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the global-automation-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nglobalauto_state:the global automation override state, this sets the same automation mode to all tracks!\n",
        "body": "ultraschall.GetProject_GlobalAuto(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPO lua": {
        "prefix": "ultraschall.GetProject_Tempo",
        "scope": "lua",
        "description": "returns the tempo-settings of the project, as set in the Project Settings -> Project Settings-tab\nIt's the entry TEMPO\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the tempo-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nbpm:the tempo of the project in bpm\nbeat:the beat of the project\ndenominator:the denominator for the beat\n",
        "body": "ultraschall.GetProject_Tempo(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PLAYRATE lua": {
        "prefix": "ultraschall.GetProject_Playrate",
        "scope": "lua",
        "description": "returns the tempo-settings of the project, as set in the Project Settings -> Project Settings-tab\nIt's the entry PLAYRATE\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the playrate-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nplayrate:the maximum playrate possible in the project; 0.01 to 10\npreserve_pitch:0, don't preserve pitch, when changing playrate; 1, preserve pitch, when changing playrate\nmin_playrate:the minimum playrate possible in the project; 0.01 to 10\nmax_playrate:the maximum playrate possible in the project; 0.01 to 10\n",
        "body": "ultraschall.GetProject_Playrate(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERAUTOMODE lua": {
        "prefix": "ultraschall.GetProject_MasterAutomode",
        "scope": "lua",
        "description": "returns the automation-mode of the master-track of the project, as set in the \"Envelopes for Master Track\"-dialog or the context-menu for the Master Track -> Set track automation mode -> ...\nIt's the entry MASTERAUTOMODE\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-automation-mode; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nautomode:the automation-mode, as set in the Envelopes for Master Track\n",
        "body": "ultraschall.GetProject_MasterAutomode(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERSEL lua": {
        "prefix": "ultraschall.GetProject_MasterSel",
        "scope": "lua",
        "description": "returns the master-track-selection-state of the master-track of the project.\nIt's the entry MASTER_SEL\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-selection; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nselection:the selection-state; 0, master-track unselected; 1, master-track selected\n",
        "body": "ultraschall.GetProject_MasterSel(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERFXBYP lua": {
        "prefix": "ultraschall.GetProject_MasterFXByp",
        "scope": "lua",
        "description": "returns the fx-bypass-state of the master-track of the project.\nIt's the entry MASTER_FX\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-fx-bypass-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nfx_byp_state:the fx-bypass-state; 0, master-track-fx bypassed; 1, master-track-fx normal\n",
        "body": "ultraschall.GetProject_MasterFXByp(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERMUTESOLO lua": {
        "prefix": "ultraschall.GetProject_MasterMuteSolo",
        "scope": "lua",
        "description": "returns the mute-solo-state of the master-track of the project.\nHas no exclusive-solo/mute-settings!\nIt's the entry MASTERMUTESOLO\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-mute-solo-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nmute_solo_state:the mute-solo-state; it is a bitfield\n",
        "body": "ultraschall.GetProject_MasterMuteSolo(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERNCHANS lua": {
        "prefix": "ultraschall.GetProject_MasterNChans",
        "scope": "lua",
        "description": "returns the number of output channels-settings and the vu-peak-metering-settings of the master-track of the project.\nIt's the entry MASTER_NCH\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-nchans; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nnumber_of_channels:the number of output-channels, as set in the \"Outputs for the Master Channel -> Track Channels\"-dialog\npeak_metering:2, Multichannel peak metering-setting, as set in the \"Master VU settings\"-dialog\n",
        "body": "ultraschall.GetProject_MasterNChans(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERTRACKHEIGHT lua": {
        "prefix": "ultraschall.GetProject_MasterTrackHeight",
        "scope": "lua",
        "description": "returns the master-trackheight-states of the master-track of the project.\nIt's the entry MASTERTRACKHEIGHT\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the mastertrackheight-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nheight_state:the current-height of the master-track, from 24 to 260\nheight_lock:0, height-lock is off; 1, height-lock is on\n",
        "body": "ultraschall.GetProject_MasterTrackHeight(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERTRACKCOLOR lua": {
        "prefix": "ultraschall.GetProject_MasterTrackColor",
        "scope": "lua",
        "description": "returns the master-color of the master-track of the project.\nIt's the entry MASTERPEAKCOL\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the mastertrack-color; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ncolor:the color for the master-track\n",
        "body": "ultraschall.GetProject_MasterTrackColor(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERTRACKVIEW lua": {
        "prefix": "ultraschall.GetProject_MasterTrackView",
        "scope": "lua",
        "description": "returns the master-view-state of the master-track of the project or a ProjectStateChunk.\nIt's the entry MASTERTRACKVIEW\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the trackview-states; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ntcp_visibility:0, Master-track is invisible in MCP; 1, Master-track is visible in MCP\nstate2:unknown\nstate3:unknown\nstate4:unknown\nstate5:unknown\nstate6:unknown\nstate7:unknown\nstate8:unknown\nstate9:unknown\nstate10:unknown\n",
        "body": "ultraschall.GetProject_MasterTrackView(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_COUNTMASTERHWOUTS lua": {
        "prefix": "ultraschall.GetProject_CountMasterHWOuts",
        "scope": "lua",
        "description": "returns the number of available hwouts in an rpp-project or ProjectStateChunk\nIt's the entry MASTERHWOUT\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to count the master-hwouts; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ncount_of_hwouts:the number of available hwouts in an rpp-project or ProjectStateChunk\n",
        "body": "ultraschall.GetProject_CountMasterHWOuts(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERHWOUT lua": {
        "prefix": "ultraschall.GetProject_MasterHWOut",
        "scope": "lua",
        "description": "returns the HWOut of the master-track of the project, as set in the \"Outputs for Master Track\"-dialog\nThere can be multiple HWOuts for the Master-Track.\nIt's the entry MASTERHWOUT\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-hwout-states; nil to use ProjectStateChunk\nidx:the number of the requested HWOut-setting; 1 for the first, etc.\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nstate1:unknown\nstate2:unknown\nvolume:volume of the HWOut; \npan:the panning; -1(left), 1(right), 0(center)\nmute:mute-state; 0, unmuted; 1, muted\nphase:phase-inversion; 0, normal phase; 1, inversed phase\noutput_channels:       -1 - None\nstate8:unknown\n",
        "body": "ultraschall.GetProject_MasterHWOut(${1:string projectfilename_with_path},${2:integer idx},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLUME lua": {
        "prefix": "ultraschall.GetProject_MasterVolume",
        "scope": "lua",
        "description": "returns the Master-volume-state of the master-track of the project.\nIt's the entry MASTER_VOLUME\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volume-states; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nvolume:Volume; 0(-inf dB) to 3.981071705535(+12dB);1 for 0dB\npan:the second pan_knob for pan-mode \"Dual Pan\" \npan_law:Pan_Law, as set in the \"Pan Law: Master Track\"-dialog; 1(0dB); 0.5(-6.02dB)\nstate4:unknown\npan_knob3:the second pan_knob for pan-mode \"Dual Pan\" \n",
        "body": "ultraschall.GetProject_MasterVolume(${1:string projectfilename_with_path},${2:integer idx},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERPANMODE lua": {
        "prefix": "ultraschall.GetProject_MasterPanMode",
        "scope": "lua",
        "description": "returns the master-panmode of the master-track of the project.\nIt's the entry MASTER_PANMODE\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-panmode; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\npanmode:the panmode for the master-track; \n",
        "body": "ultraschall.GetProject_MasterPanMode(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERWIDTH lua": {
        "prefix": "ultraschall.GetProject_MasterWidth",
        "scope": "lua",
        "description": "returns the master-width for the second pan-knob in stereo pan-modes, of the master-track of the project.\nIt's the entry MASTER_WIDTH\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the masterwidth-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\npan_knob_two:-1(left), 1(right), 0(center)\n",
        "body": "ultraschall.GetProject_MasterWidth(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERGROUPFLAGSSTATE lua": {
        "prefix": "ultraschall.GetProject_MasterGroupFlagsState",
        "scope": "lua",
        "description": "returns the state of the group-flags for the Master-Track, as set in the menu Track Grouping Parameters; from an rpp-projectfile or a ProjectStateChunk.\nReturns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 1 to 32. To get Groups 33 to 64, use GetTrackGroupFlags_HighState instead!\nIt's the entry MASTER_GROUP_FLAGS\nreturns -1 in case of failure\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the groups-state-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "ultraschall.GetProject_MasterGroupFlagsState(${1:string projectfilename_with_path},${2:optional stirng ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERGROUPFLAGSHIGHSTATE lua": {
        "prefix": "ultraschall.GetProject_MasterGroupFlagsHighState",
        "scope": "lua",
        "description": "returns the state of the group-high-flags for the Master-Track, as set in the menu Track Grouping Parameters; from an rpp-projectfile or a ProjectStateChunk.\nReturns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 1 to 32. To get Groups 33 to 64, use GetTrackGroupFlags_HighState instead!\nIt's the entry MASTER_GROUP_FLAGS_HIGH\nreturns -1 in case of failure\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the groupshigh-state-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "ultraschall.GetProject_MasterGroupFlagsHighState(${1:string projectfilename_with_path},${2:optional stirng ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GROUPDISABLED lua": {
        "prefix": "ultraschall.GetProject_GroupDisabled",
        "scope": "lua",
        "description": "returns the group-disabled-stated, of the master-track of the project.\nIt's the entry GROUPS_DISABLED\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the groups-disabled-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ndisabled1:the disabled groups; it is a bitfield, with &1 for group 1; &32 for group 32; if it's set, the accompanying group is disabled\ndisabled2:the disabled groups_high; it is a bitfield, with &1 for group 33; &32 for group 64; if it's set, the accompanying group is disabled\n",
        "body": "ultraschall.GetProject_GroupDisabled(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERHWVOLENVSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterHWVolEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-HWVolEnv-StateChunk, that holds MasterHWVolEnv-settings of the master.\nIt's the entry <MASTERHWVOLENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-hwvolenv-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterHWVolEnvStateChunk:the statechunk of the HWVolEnv\n",
        "body": "ultraschall.GetProject_MasterHWVolEnvStateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERFXLISTSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterFXListStateChunk",
        "scope": "lua",
        "description": "returns the Master-FX_List-StateChunk, that holds Master-FX-settings for the window as well as the FX themselves, of the master.\nIt's the entry <MASTERFXLIST ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-fxlist-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterFXListStateChunk:the statechunk of the Master-FX-list\n",
        "body": "ultraschall.GetProject_MasterFXListStateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENVSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterDualPanEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-DualPanEnv-StateChunk, that holds MasterDualPanEnv-settings of the master.\nIt's the entry <MASTERDUALPANENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-env-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterDualPanEnvStateChunk:the statechunk of the Master-DualPan-Env-state\n",
        "body": "ultraschall.GetProject_MasterDualPanEnvStateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENV2STATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterDualPanEnv2StateChunk",
        "scope": "lua",
        "description": "returns the Master-DualPanEnv2-StateChunk, that holds master-DualPanEnv2-settings of the master.\nIt's the entry <MASTERDUALPANENV2 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-env2-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\n",
        "body": "ultraschall.GetProject_MasterDualPanEnv2StateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENVLSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterDualPanEnvLStateChunk",
        "scope": "lua",
        "description": "returns the Master-DualPan-EnvL-StateChunk, that holds Master-DualPan-EnvL-settings of the master.\nIt's the entry <MASTERDUALPANENVL ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-envL-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterDualPanEnvLStateChunk:the statechunk of the Master-DualPan-EnvL-state\n",
        "body": "ultraschall.GetProject_MasterDualPanEnvLStateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENVL2STATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterDualPanEnvL2StateChunk",
        "scope": "lua",
        "description": "returns the Master-Dual-Pan-EnvL2-StateChunk, that holds Master-FX-Dual-Pan-EnvL2-settings of the master.\nIt's the entry <MASTERDUALPANENVL2 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-envL2-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterDualPanEnvL2StateChunk:the statechunk of the Master-DualPan-EnvL2-state\n",
        "body": "ultraschall.GetProject_MasterDualPanEnvL2StateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLENVSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterVolEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-Vol-Env-StateChunk, that holds Master-Vol-Env-settings of the master.\nIt's the entry <MASTERVOLENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volenv-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterVolEnvStateChunk:the statechunk of the Master-volenv-state\n",
        "body": "ultraschall.GetProject_MasterVolEnvStateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLENV2STATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterVolEnv2StateChunk",
        "scope": "lua",
        "description": "returns the Master-Vol-Env2-StateChunk, that holds Master-Vol-Env2-settings of the master.\nIt's the entry <MASTERVOLENV2 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volenv2-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterVolEnv2StateChunk:the statechunk of the Master-volenv2-state\n",
        "body": "ultraschall.GetProject_MasterVolEnv2StateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLENV3STATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterVolEnv3StateChunk",
        "scope": "lua",
        "description": "returns the Master-Vol-Env3-StateChunk, that holds Master-Vol-Env3-settings of the master.\nIt's the entry <MASTERVOLENV3 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volenv3-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterVolEnv3StateChunk:the statechunk of the Master-volenv3-state\n",
        "body": "ultraschall.GetProject_MasterVolEnv3StateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERHWPANENVSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_MasterHWPanEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-HW-pan-env-StateChunk, that holds Master-pan-env-settings of the master.\nIt's the entry <MASTERHWPANENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-HW-pan-env-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterHWPanEnvStateChunk:the statechunk of the Master-volenv3-state\n",
        "body": "ultraschall.GetProject_MasterHWPanEnvStateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERPANMODE_EX lua": {
        "prefix": "ultraschall.GetProject_MasterPanMode_Ex",
        "scope": "lua",
        "description": "returns the Master-HW-pan-mode-ex-StateChunk, that holds Master-pan-mode-ex-settings of the master.\nIt's the entry <MASTER_PANMODE_EX ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-HW-pan-env-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterHWPanModeEx_StateChunk:the statechunk of the Master-pan-mode-ex\n",
        "body": "ultraschall.GetProject_MasterPanMode_Ex(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPOENV_EXSTATECHUNK lua": {
        "prefix": "ultraschall.GetProject_TempoEnv_ExStateChunk",
        "scope": "lua",
        "description": "returns the TempoEnv_ExStateChunk, that holds TempoEnv_Ex-settings of an rpp-project or ProjectStateChunk.\nIt's the entry <TEMPOENVEX ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the tempo-env-ex-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nTempoEnv_ExStateChunk:the statechunk of the Tempo-Env-Ex\n",
        "body": "ultraschall.GetProject_TempoEnv_ExStateChunk(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LENGTH lua": {
        "prefix": "ultraschall.GetProject_Length",
        "scope": "lua",
        "description": "Returns the projectlength of an rpp-project-file.\nIt's eturning the position of the overall length, as well as the position of the last itemedge/regionedge/marker/time-signature-marker of the project.\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the filename of the project, that you want to know it's length of; nil, to use Parameter ProjectStateChunk instead\nProjectStateChunk:a ProjectStateChunk to count the length of; only available when projectfilename_with_path=nil\nRETURNS:\nlength:the length of the project\nlast_itemedge:the postion of the last itemedge in the project\nlast_marker_reg_edge:the position of the last marker/regionedge in the project\nlast_timesig_marker:the position of the last time-signature-marker in the project\n",
        "body": "ultraschall.GetProject_Length(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.CREATETEMPORARYFILEOFPROJECTFILE lua": {
        "prefix": "ultraschall.CreateTemporaryFileOfProjectfile",
        "scope": "lua",
        "description": "Creates a temporary copy of an rpp-projectfile, which can be altered and rendered again.\nMust be deleted by hand using os.remove(tempfile) after you're finished.\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the project to render; nil, for the currently opened project(needs to be saved first)\nRETURNS:\ntempfile:the temporary-file, that is a valid copy of the projectfilename_with_path\n",
        "body": "ultraschall.CreateTemporaryFileOfProjectfile(${1:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERPATTERN lua": {
        "prefix": "ultraschall.SetProject_RenderPattern",
        "scope": "lua",
        "description": "Sets the render-filename in an rpp-projectfile or a ProjectStateChunk. Set it to \"\", if you want to set the render-filename with SetProject_RenderFilename.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrender_pattern:the pattern, with which the rendering-filename will be automatically created. Check also GetProject_RenderFilename\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_RenderPattern(${1:string projectfilename_with_path},${2:string render_pattern},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERFILENAME lua": {
        "prefix": "ultraschall.GetProject_RenderFilename",
        "scope": "lua",
        "description": "Returns the render-filename from an RPP-Projectfile or a ProjectStateChunk. If it contains only a path or nothing, you should check the Render_Pattern using GetProject_RenderPattern, as a render-pattern influences the rendering-filename as well.\nIt's the entry RENDER_FILE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_filename:the filename for rendering, check also GetProject_RenderPattern\n",
        "body": "ultraschall.GetProject_RenderFilename(${1:string projectfilename_with_path},${2:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GROUPNAME lua": {
        "prefix": "ultraschall.GetProject_GroupName",
        "scope": "lua",
        "description": "Returns the name associated to a specific group of items. There can be more than one!\nIt is the GROUP-entry in the root of the ProjectStateChunk.\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nidx:the index of the item-group, whose name you want to know\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ngroupname:the associated groupname of the itemgroup; nil, no such group or no name is given(default Group idx)\n",
        "body": "ultraschall.GetProject_GroupName(${1:string projectfilename_with_path},${2:integer idx},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_LOCK lua": {
        "prefix": "ultraschall.SetProject_Lock",
        "scope": "lua",
        "description": "Sets the Locked-state of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry LOCK\nIt is the one before(!) any\nstring projectfilename_with_path - the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ninteger lock_state - the lock-state, which is a bitfield\n- &1     - Time selection\n- &2     - Items (full)\n- &4     - Track envelopes\n- &8     - Markers\n- &16    - Regions\n- &32    - Time signature markers\n- &64    - Items (prevent left/right movement)\n- &128   - Items (prevent up/down movement)\n- &256   - Item edges\n- &512   - Item fade/volume handles\n- &1024  - Loop points locked\n- &2048  - Item envelopes\n- &4096  - Item stretch markers\n- &16384 - Enable locking\noptional string ProjectStateChunk - a projectstatechunk, that you want to be changed\ninteger retval - -1 in case of error, 1 in case of success\nProject-Management\nRPP-Files Set\nUS_Api_Functions\nModules/ultraschall_functions_ProjectManagement_ProjectFiles_Module.lua\nprojectfiles, rpp, state, set, lock state\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nlock_state:the lock-state, which is a bitfield\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_Lock(${1:string projectfilename_with_path},${2:integer lock_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_GLOBALAUTO lua": {
        "prefix": "ultraschall.SetProject_GlobalAuto",
        "scope": "lua",
        "description": "Sets the global-auto-override-state of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry GLOBAL_AUTO\nThis sets the same automation mode to all tracks!\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nglobal_auto_state:the global automation override state, this sets the same automation mode to all tracks!\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_GlobalAuto(${1:string projectfilename_with_path},${2:integer global_auto_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TEMPO lua": {
        "prefix": "ultraschall.SetProject_Tempo",
        "scope": "lua",
        "description": "Sets the tempo, bpm, beat, denominator-state of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry TEMPO\nThey are set in the Project Settings -> \"Project BPM\" and \"Time signature\"\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nbpm:the tempo of the project in bpm\nbeat:the beat of the project \ndenominator:the denominator for the beat \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_Tempo(${1:string projectfilename_with_path},${2:integer bpm},${3:integer beat},${4:integer denominator},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PLAYRATE lua": {
        "prefix": "ultraschall.SetProject_Playrate",
        "scope": "lua",
        "description": "Sets the playrate of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry PLAYRATE\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nplayrate:the maximum playrate possible in the project; 0.01 to 10\npreserve_pitch:0, don't preserve pitch, when changing playrate; 1, preserve pitch, when chaning playrate \nmin_playrate:the minimum playrate possible in the project; 0.01 to 10\nmax_playrate:the maximum playrate possible in the project; 0.01 to 10\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_Playrate(${1:string projectfilename_with_path},${2:number playrate},${3:integer preserve_pitch},${4:number min_playrate},${5:number max_playrate},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERAUTOMODE lua": {
        "prefix": "ultraschall.SetProject_MasterAutomode",
        "scope": "lua",
        "description": "Sets the automation-mode for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTERAUTOMODE\nThis sets the same automation mode to all tracks!\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nautomode:the automation mode for the master-track\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterAutomode(${1:string projectfilename_with_path},${2:integer automode},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERSEL lua": {
        "prefix": "ultraschall.SetProject_MasterSel",
        "scope": "lua",
        "description": "Sets the selection-state for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_SEL\nThis sets the same automation mode to all tracks!\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nselection_state:the selection-state of the MasterTrack; 0, unselected; 1, selected\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterSel(${1:string projectfilename_with_path},${2:integer selection_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERMUTESOLO lua": {
        "prefix": "ultraschall.SetProject_MasterMuteSolo",
        "scope": "lua",
        "description": "Sets the mute/solo-state for the master-track of an rpp-projectfile or a ProjectStateChunk.\nHas no exclusive-solo/mute-settings!\nIt's the entry MASTERMUTESOLO\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nmute_solo_state:the mute-solo-state; it is a bitfield\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterMuteSolo(${1:string projectfilename_with_path},${2:integer mute_solo_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERFXBYP lua": {
        "prefix": "ultraschall.SetProject_MasterFXByp",
        "scope": "lua",
        "description": "Sets the fx-bypass-state for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_FX\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nfx_byp_state:the fx-bypass-state; 0, master-track-fx bypassed; 1, master-track-fx normal \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterFXByp(${1:string projectfilename_with_path},${2:integer fx_byp_state},${3:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERNCHANS lua": {
        "prefix": "ultraschall.SetProject_MasterNChans",
        "scope": "lua",
        "description": "Sets the number of channels and vu-meter-settings for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_NCH\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nnumber_of_channels:the number of output-channels, as set in the \"Outputs for the Master Channel -> Track Channels\"-dialog \npeak_metering:2, Multichannel peak metering-setting, as set in the \"Master VU settings\"-dialog \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterNChans(${1:string projectfilename_with_path},${2:integer number_of_channels},${3:integer peak_metering},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERTRACKHEIGHT lua": {
        "prefix": "ultraschall.SetProject_MasterTrackHeight",
        "scope": "lua",
        "description": "Sets the trackheight for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTERTRACKHEIGHT\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nheight_state:the current-height of the master-track, from 24 to 260 \nheight_lock:0, height-lock is off; 1, height-lock is on \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterTrackHeight(${1:string projectfilename_with_path},${2:integer height_state},${3:integer height_lock},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERTRACKCOLOR lua": {
        "prefix": "ultraschall.SetProject_MasterTrackColor",
        "scope": "lua",
        "description": "Sets the color for the master-track of an rpp-projectfile or a ProjectStateChunk.\nTo generate the correct color-value, use ConvertColor.\nNote: This color reverses red and blue component on Mac, so it looks different on Mac compared to Windows and Linux!\nIt's the entry MASTERPEAKCOL\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ncolor:the color-value of the MasterTrack\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterTrackColor(${1:string projectfilename_with_path},${2:integer color},${3:integer peak_metering},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERPANMODE lua": {
        "prefix": "ultraschall.SetProject_MasterPanMode",
        "scope": "lua",
        "description": "Sets the panmode for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_PANMODE\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npanmode:the panmode for the master-track;\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "ultraschall.SetProject_MasterPanMode(${1:string projectfilename_with_path},${2:integer panmode},${3:integer peak_metering},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERTRACKVIEW lua": {
        "prefix": "ultraschall.SetProject_MasterTrackView",
        "scope": "lua",
        "description": "Sets the master-view-state of the master-track of the project or a ProjectStateChunk.\nIt is the entry: MASTERTRACKVIEW\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntcp_visibility:0, Master-track is invisible in MCP; 1, Master-track is visible in MCP\nstate2:unknown\nstate3:unknown\nstate4:unknown\nstate5:unknown\nstate6:unknown\nstate7:unknown\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "ultraschall.SetProject_MasterTrackView(${1:string projectfilename_with_path},${2:integer tcp_visibility},${3:number state2},${4:number state3},${5:number state4},${6:integer state5},${7:integer state6},${8:integer state7},${9:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.AUTOSEARCHREAMOTESLAVES lua": {
        "prefix": "ultraschall.AutoSearchReaMoteSlaves",
        "scope": "lua",
        "description": "Auto-searches for new ReaMote-Slaves\n",
        "body": "ultraschall.AutoSearchReaMoteSlaves()$0"
    },
    "ULTRASCHALL.GETVERTICALZOOM lua": {
        "prefix": "ultraschall.GetVerticalZoom",
        "scope": "lua",
        "description": "Returns the vertical-zoom-factor.\nReturns -1 in case of error\nRETURNS:\nvertical_zoom_factor:the current vertical zoom-factor\n",
        "body": "ultraschall.GetVerticalZoom()$0"
    },
    "ULTRASCHALL.SETVERTICALZOOM lua": {
        "prefix": "ultraschall.SetVerticalZoom",
        "scope": "lua",
        "description": "Sets the vertical zoom factor.\nTo set it relative to the current vertical-zoom-value, use Reaper's own API-function [CSurf_OnZoom](Reaper_Api_Documentation.html#CSurf_OnZoom)\nReturns -1 in case of error.\nPARAMETERS:\nvertical_zoom_factor:the current vertical zoom-factor\nRETURNS:\nretval:-1, in case of error\n",
        "body": "ultraschall.SetVerticalZoom(${1:integer vertical_zoom_factor})$0"
    },
    "ULTRASCHALL.STOREARRANGEVIEWSNAPSHOT lua": {
        "prefix": "ultraschall.StoreArrangeviewSnapshot",
        "scope": "lua",
        "description": "Stores a new Arrangeview-snapshot, that includes the position, horizontal zoom, vertical zoom and vertical scroll.\nReturns -1 in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\ndescription:a description for this arrangeview-snapshot\nposition:true, store start and endposition of the current arrangeview; false, don't store start and endposition of current arrangeview(keep old position in slot, if existing)\nvzoom:true, store current vertical-zoom-factor; false, don't store current vertical-zoom-factor(keep old zoomfactor in slot, if existing)\nvscroll:true, store current vertical scroll-factor; false, don't store current vertival-scroll-factor\nRETURNS:\nretval:-1, in case of error\n",
        "body": "ultraschall.StoreArrangeviewSnapshot(${1:integer slot},${2:string description},${3:boolean position},${4:boolean vzoom},${5:boolean vscroll})$0"
    },
    "ULTRASCHALL.ISVALIDARRANGEVIEWSNAPSHOT lua": {
        "prefix": "ultraschall.IsValidArrangeviewSnapshot",
        "scope": "lua",
        "description": "Checks, if an Arrangeview-snapshot-slot is valid(means set).\nReturns false in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nRETURNS:\nretval:true, if Arrangeview-Snapshot is valid; false, if Arrangeview-Snapshot is not existing\n",
        "body": "ultraschall.IsValidArrangeviewSnapshot(${1:integer slot})$0"
    },
    "ULTRASCHALL.RETRIEVEARRANGEVIEWSNAPSHOT lua": {
        "prefix": "ultraschall.RetrieveArrangeviewSnapshot",
        "scope": "lua",
        "description": "Retrieves an Arrangeview-snapshot and returns the startposition, endposition and vertical and horizontal zoom-factor as well as the number vertical-scroll-factor..\nReturns false in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nRETURNS:\nretval:false, in case of error; true, in case of success\ndescription:a description for this arrangeview-snapshot\nstartposition:the startposition of the arrangeview\nendposition:the endposition of the arrangeview\nhzoomfactor:the horizontal zoomfactor\nvertical_scroll:the vertical scroll-value\n",
        "body": "ultraschall.RetrieveArrangeviewSnapshot(${1:integer slot})$0"
    },
    "ULTRASCHALL.RESTOREARRANGEVIEWSNAPSHOT lua": {
        "prefix": "ultraschall.RestoreArrangeviewSnapshot",
        "scope": "lua",
        "description": "Sets arrangeview to start/endposition and horizontal and vertical-zoom, as received from Arrangeview-Snapshot-slot. It returns the newly set start/endposition, vertical zoom, horizontal zoom and description of slot.\nReturns false in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nposition:nil or true, set arrange to stored start and endposition(and it's horizontal-zoom); false, set only horizontal-zoom\nvzoom:nil or true, set vertical-zoom; false, don't set vertical zoom\nhcentermode:decides, what shall be in the center of the zoomed horizontal view. Only available when position==false\nverticalscroll:true, sets vertical scroll-value as well; false, doesn't set vertical-scroll-value\nRETURNS:\nretval:false, in case of error; true, in case of success\ndescription:a description for this arrangeview-snapshot\nstartposition:the startposition of the arrangeview\nendposition:the endposition of the arrangeview\nhzoomfactor:the horizontal zoomfactor\nvertical_scroll_factor:the vertical-scroll-factor\n",
        "body": "ultraschall.RestoreArrangeviewSnapshot(${1:integer slot},${2:optional boolean position},${3:optional boolean vzoom},${4:optional integer hcentermode},${5:optional boolean verticalscroll})$0"
    },
    "ULTRASCHALL.DELETEARRANGEVIEWSNAPSHOT lua": {
        "prefix": "ultraschall.DeleteArrangeviewSnapshot",
        "scope": "lua",
        "description": "Deletes an ArrangeviewSnapshot-slot.\nReturns -1 if the slot is unset or slot is an invalid value.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nRETURNS:\nretval:-1 in case of an error; 0 in case of success\n",
        "body": "ultraschall.DeleteArrangeviewSnapshot(${1:integer slot})$0"
    },
    "ULTRASCHALL.SETIDEFONTSIZE lua": {
        "prefix": "ultraschall.SetIDEFontSize",
        "scope": "lua",
        "description": "Sets the fontsize of Reaper's IDE (ReaScript/Video Processor/JSFX)\nNew fontsize is valid for all IDE's opened after calling this function.\nReturns false in case of an error\nPARAMETERS:\nfontsize:the new font-size for Reaper's IDEs\nRETURNS:\nretval:true, if setting was successful; false, if not\n",
        "body": "ultraschall.SetIDEFontSize(${1:integer fontsize})$0"
    },
    "ULTRASCHALL.GETIDEFONTSIZE lua": {
        "prefix": "ultraschall.GetIDEFontSize",
        "scope": "lua",
        "description": "Returns the current fontsize of Reaper's IDE (ReaScript/Video Processor/JSFX)\n",
        "body": "ultraschall.GetIDEFontSize()$0"
    },
    "ULTRASCHALL.GETPLAYCURSORWIDTH lua": {
        "prefix": "ultraschall.GetPlayCursorWidth",
        "scope": "lua",
        "description": "Returns the width of the playcursor in pixels\nsee SetPlayCursorWidth for setting the playcursor-width.\nRETURNS:\nplay_cursor_width:the width of the playcursor in pixels\n",
        "body": "ultraschall.GetPlayCursorWidth()$0"
    },
    "ULTRASCHALL.SETPLAYCURSORWIDTH lua": {
        "prefix": "ultraschall.SetPlayCursorWidth",
        "scope": "lua",
        "description": "Sets a new playcursor-width.\nsee GetPlayCursorWidth for getting the playcursor-width.\nReturns false in case of an error\nPARAMETERS:\nplay_cursor_width:the new width of the playcursor\npersist:true, set the setting to reaper.ini so it persists after restarting Reaper; false, set it only for the time, until Reaper is restarted\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "ultraschall.SetPlayCursorWidth(${1:integer play_cursor_width},${2:boolean persist})$0"
    },
    "ULTRASCHALL.GETSCREENWIDTH lua": {
        "prefix": "ultraschall.GetScreenWidth",
        "scope": "lua",
        "description": "returns the width of the screen in pixels.\nreturns -1 in case of an error\nPARAMETERS:\nwant_workarea:true, returns workspace only; false, full monitor coordinates of the returned viewport; nil, will be seen as true\nRETURNS:\nwidth:the width of the screen in pixels\n",
        "body": "ultraschall.GetScreenWidth(${1:optional boolean want_workarea})$0"
    },
    "ULTRASCHALL.GETSCREENHEIGHT lua": {
        "prefix": "ultraschall.GetScreenHeight",
        "scope": "lua",
        "description": "returns the height of the screen in pixels.\nreturns -1 in case of an error\nPARAMETERS:\nwant_workarea:true, returns workspace only; false, full monitor coordinates of the returned viewport; nil, will be seen as true\n",
        "body": "ultraschall.GetScreenHeight(${1:optional boolean want_workarea})$0"
    },
    "ULTRASCHALL.SHOWMENU lua": {
        "prefix": "ultraschall.ShowMenu",
        "scope": "lua",
        "description": "Draws a menu at position x,y.\nEntries is the string, that contains the Menuentries, separated by |\nExample: \"Entry1|Entry2|Entry3\"\nEach field can start with a special character\n# grays out the entry\n! entry is checked\n> starts a new submenu, where every following entry will be part of the submenu\n< ends a submenu with this entry being the last one\nThese special characters can be combined, however, grayed out entries don't open submenus, even if they are shown as submenus.\nA field with nothing in it || creates a separator.\nThe returned number follows the numbering of the clickable(!) entries. Even if grayed out-entries can't be selected, they count as well.\nHowever, opening-submenu-entries and separators don't count as clickable.\nThat said, if you have one grayed out entry and one normal entry, the grayed out entry is 1, the normal entry(the only selectable one) is 2.\nThe following entry\nNormal1|>SubmenuOpener|Submenuentry1|\nSubmenuentry1\nSubmenuEntry2Closer\nGrayed Out\nOne last thing: the title does not count as entry!\nNote for Mac-users: y-coordinates are \"reversed\", so y=0 is at the bottom\nNote for Linux: does not work on Linux yet.\nreturns -1 in case of an error\nPARAMETERS:\nTitle:the title shown on top of the menu\nEntries:the individual entries. See above on how to create such an entry.\nx:the x-position of the menu\ny:the y-position of the menu\nRETURNS:\nretval:the selected entry; 0, nothing selected\n",
        "body": "ultraschall.ShowMenu(${1:string Title},${2:string Entries},${3:integer x},${4:integer y})$0"
    },
    "ULTRASCHALL.ISVALIDHWND lua": {
        "prefix": "ultraschall.IsValidHWND",
        "scope": "lua",
        "description": "Checks, if a HWND-handler is a valid one.\nReturns false in case of an error\nPARAMETERS:\nhwnd:the HWND-handler to check for\nRETURNS:\nretval:true, if running it was successful; false, if not\n",
        "body": "ultraschall.IsValidHWND(${1:HWND hwnd})$0"
    },
    "ULTRASCHALL.BROWSEFOROPENFILES lua": {
        "prefix": "ultraschall.BrowseForOpenFiles",
        "scope": "lua",
        "description": "Opens a filechooser-dialog which optionally allows selection of multiple files.\nUnlike Reaper's own GetUserFileNameForRead, this dialog allows giving non-existant files as well(for saving operations).\nReturns nil in case of an error\nPARAMETERS:\nwindowTitle:the title shown in the filechooser-dialog\ninitialFolder:the initial-folder opened in the filechooser-dialog\ninitialFile:the initial-file selected in the filechooser-dialog, good for giving default filenames\nextensionList:a list of extensions that can be selected in the selection-list.\nallowMultiple:true, allows selection of multiple files; false, only allows selection of single files\nRETURNS:\npath:the path, in which the selected file(s) lie; nil, in case of an error; \"\" if no file was selected\nnumber_of_files:the number of files selected; 0, if no file was selected\nfilearray:an array with all the selected files\n",
        "body": "ultraschall.BrowseForOpenFiles(${1:string windowTitle},${2:string initialFolder},${3:string initialFile},${4:string extensionList},${5:boolean allowMultiple})$0"
    },
    "ULTRASCHALL.HASHWNDCHILDWINDOWNAMES lua": {
        "prefix": "ultraschall.HasHWNDChildWindowNames",
        "scope": "lua",
        "description": "Returns, whether the given HWND has childhwnds with a certain name in them. This is good for checking for valid Reaper-windows.\nAs gfx.init()-windows can have the same as Reaper's original-windows, this function gives you the chance for aditional checks.\ngfx.init windows don't have child-hwnds and other applications probably have child-hwnds with different names.\nreturns false in case of an error\nPARAMETERS:\nhwnd:the HWND, whose child-hwnd-names you want to check\nchildwindownames:a string with the names of the child-HWNDs the parameter hwnd must have. It is a \\0-separated string, means, you put \\0 in between the child-Hwnd-names.\n",
        "body": "ultraschall.HasHWNDChildWindowNames(${1:HWND hwnd},${2:string childwindownames})$0"
    },
    "ULTRASCHALL.CLOSEREASCRIPTCONSOLE lua": {
        "prefix": "ultraschall.CloseReaScriptConsole",
        "scope": "lua",
        "description": "Closes the ReaConsole-window, if opened.\nReturns false in case of an error\nRETURNS:\nretval:true, if there is a mute-point; false, if there isn't one\n",
        "body": "ultraschall.CloseReaScriptConsole()$0"
    },
    "ULTRASCHALL.MB lua": {
        "prefix": "ultraschall.MB",
        "scope": "lua",
        "description": "Shows Messagebox with user-clickable buttons. Works like reaper.MB() but unlike reaper.MB, this function accepts omitting some parameters for quicker use.\nImportant: This works only on Windows, due some bug on Mac which I couldn't work out yet.\nYou can change the text in the buttons with button1_caption, button2_caption and button3_caption.\nReturns -1 in case of an error\nPARAMETERS:\nmsg:the message, that shall be shown in messagebox\ntitle:the title of the messagebox\ntype:which buttons shall be shown in the messagebox, in that order\nbutton1_caption:caption of the first button\nbutton2_caption:caption of the second button\nbutton3_caption:caption of the third button\n",
        "body": "ultraschall.MB(${1:string msg},${2:optional string title},${3:optional integer type},${4:optional string button1_caption},${5:optional string button2_caption},${6:optional string button3_caption})$0"
    },
    "ULTRASCHALL.GETTOPMOSTHWND lua": {
        "prefix": "ultraschall.GetTopmostHWND",
        "scope": "lua",
        "description": "returns the topmost-parent hwnd of a hwnd, as sometimes, hwnds are children of a higher hwnd. It also returns the number of parent hwnds available and a list of all parent hwnds for this hwnd.\nA hwnd is a window-handler, which contains all attributes of a certain window.\nreturns nil in case of an error\nPARAMETERS:\nhwnd:the HWND, whose topmost parent-HWND you want to have\nRETURNS:\nnumber_of_parent_hwnd:the number of parent hwnds, that are above the parameter hwnd\nall_parent_hwnds:all available parent hwnds, above the parameter hwnd, including the topmost-hwnd\n",
        "body": "ultraschall.GetTopmostHWND(${1:HWND hwnd})$0"
    },
    "ULTRASCHALL.GETREAPERWINDOWATTRIBUTES lua": {
        "prefix": "ultraschall.GetReaperWindowAttributes",
        "scope": "lua",
        "description": "returns many attributes of the Reaper Main-window, like position, size, active, visibility, childwindows\nA hwnd is a window-handler, which contains all attributes of a certain window.\nreturns nil in case of an error\nRETURNS:\nleft:the left position of the Reaper-window in pixels\ntop:the top position of the Reaper-window in pixels\nright:the right position of the Reaper-window in pixels\nbottom:the bottom position of the Reaper-window in pixels\nactive:true, if the window is active(any child-hwnd of the Reaper-window has focus currently); false, if not\nvisible:true, Reaper-window is visible; false, Reaper-window is not visible\ntitle:the current title of the Reaper-window\nnumber_of_childhwnds:the number of available child-hwnds that the Reaper-window currently has\nchildhwnds:a table with all child-hwnds in the following format:\n",
        "body": "ultraschall.GetReaperWindowAttributes()$0"
    },
    "ULTRASCHALL.WINDOWS_FIND lua": {
        "prefix": "ultraschall.Windows_Find",
        "scope": "lua",
        "description": "Returns all Reaper-window-HWND-handler, with a given title. Can be further used with the JS\\_Window\\_functions of the JS-function-plugin.\nDoesn't return IDE-windows! Use GetAllReaScriptIDEWindows to get them.\nreturns -1 in case of an error\n",
        "body": "ultraschall.Windows_Find(${1:string title},${2:boolean strict})$0"
    },
    "ULTRASCHALL.GETALLREASCRIPTIDEWINDOWS lua": {
        "prefix": "ultraschall.GetAllReaScriptIDEWindows",
        "scope": "lua",
        "description": "Returns the hwnds and all titles of all Reaper-IDE-windows currently opened.\nRETURNS:\ncount_ide_hwnds:the number of windows found\nide_hwnd_array:the hwnd-handler of all found windows\nide_titles:the titles of all found windows\n",
        "body": "ultraschall.GetAllReaScriptIDEWindows()$0"
    },
    "ULTRASCHALL.GETREASCRIPTCONSOLEWINDOW lua": {
        "prefix": "ultraschall.GetReaScriptConsoleWindow",
        "scope": "lua",
        "description": "Returns the hwnd of the ReaScript-Console-window, if opened.\nreturns nil when ReaScript-console isn't opened\nRETURNS:\nreascript_console_hwnd:the window-handler to the ReaScript-console, if opened\n",
        "body": "ultraschall.GetReaScriptConsoleWindow()$0"
    },
    "ULTRASCHALL.GETHWND_ARRANGEVIEWANDTIMELINE lua": {
        "prefix": "ultraschall.GetHWND_ArrangeViewAndTimeLine",
        "scope": "lua",
        "description": "Returns the HWND-Reaper-Windowhandler for the tracklist- and timeline-area in the arrange-view\nreturns nil in case of an error. Please report such an error, which means, that you should use ultraschall.ShowLastErrorMessage() to show that error and report the information requested(fruitful bugreports lead to a handwritten postcard as reward :) )\nRETURNS:\narrange_view:the HWND-window-handler for the tracklist-area of the arrangeview\ntimeline:the HWND-window-handler for the timeline/markerarea of the arrangeview\nTrackControlPanel:the HWND-window-handler for the track-control-panel(TCP)(may not work anymore in an upcoming Reaper-release!)\n",
        "body": "ultraschall.GetHWND_ArrangeViewAndTimeLine()$0"
    },
    "ULTRASCHALL.GETVERTICALSCROLL lua": {
        "prefix": "ultraschall.GetVerticalScroll",
        "scope": "lua",
        "description": "Gets the current vertical_scroll_value. The valuerange is dependent on the vertical zoom.\nRETURNS:\nvertical_scroll_factor:the vertical-scroll-factor\n",
        "body": "ultraschall.GetVerticalScroll()$0"
    },
    "ULTRASCHALL.SETVERTICALSCROLL lua": {
        "prefix": "ultraschall.SetVerticalScroll",
        "scope": "lua",
        "description": "Sets the absolute vertical-scroll-factor.\nThe possible value-range depends on the vertical-zoom.\nreturns false in case of an error or if scrolling is impossible(e.g. zoomed out fully)\nPARAMETERS:\nscrollposition:the vertical scrolling-position\nRETURNS:\nretval:true, if setting was successful; false, if setting was unsuccessful\n",
        "body": "ultraschall.SetVerticalScroll(${1:integer scrollposition})$0"
    },
    "ULTRASCHALL.SETVERTICALRELATIVESCROLL lua": {
        "prefix": "ultraschall.SetVerticalRelativeScroll",
        "scope": "lua",
        "description": "Sets the vertical-scroll-factor, relative to it's current position.\nThe possible value-range depends on the vertical-zoom.\nreturns false in case of an error or if scrolling is impossible(e.g. zoomed out fully)\nRETURNS:\nretval:true, if setting was successful; false, if setting was unsuccessful\n",
        "body": "ultraschall.SetVerticalRelativeScroll(${1:integer relative_scrollposition})$0"
    },
    "ULTRASCHALL.GETRENDERTOFILEHWND lua": {
        "prefix": "ultraschall.GetRenderToFileHWND",
        "scope": "lua",
        "description": "returns the HWND of the Render to File-dialog, if the window is opened.\nreturns nil if Render to File-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Render to File-dialog\n",
        "body": "ultraschall.GetRenderToFileHWND()$0"
    },
    "ULTRASCHALL.GETACTIONSHWND lua": {
        "prefix": "ultraschall.GetActionsHWND",
        "scope": "lua",
        "description": "returns the HWND of the Actions-dialog, if the window is opened.\nreturns nil if the Actions-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Actions-dialog\n",
        "body": "ultraschall.GetActionsHWND()$0"
    },
    "ULTRASCHALL.GETVIDEOHWND lua": {
        "prefix": "ultraschall.GetVideoHWND",
        "scope": "lua",
        "description": "returns the HWND of the Video window, if the window is opened.\ndue API-limitations on Mac and Linux: if more than one window called \"Video Window\" is opened, it will return -1\nI hope to find a workaround for that problem at some point...\nreturns nil if the Video Window is closed or can't be determined\nRETURNS:\nhwnd:the window-handler of the Video Window\n",
        "body": "ultraschall.GetVideoHWND()$0"
    },
    "ULTRASCHALL.GETRENDERQUEUEHWND lua": {
        "prefix": "ultraschall.GetRenderQueueHWND",
        "scope": "lua",
        "description": "returns the HWND of the Render-Queue-dialog, if the window is opened.\nreturns nil if the Render-Queue-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Render-Queue-dialog\n",
        "body": "ultraschall.GetRenderQueueHWND()$0"
    },
    "ULTRASCHALL.GETPROJECTSETTINGSHWND lua": {
        "prefix": "ultraschall.GetProjectSettingsHWND",
        "scope": "lua",
        "description": "returns the HWND of the Project Settings-dialog, if the window is opened.\nreturns nil if the Project-Settings-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Project Settings-dialog\n",
        "body": "ultraschall.GetProjectSettingsHWND()$0"
    },
    "ULTRASCHALL.GETPREFERENCESHWND lua": {
        "prefix": "ultraschall.GetPreferencesHWND",
        "scope": "lua",
        "description": "returns the HWND of the Preferences-dialog, if the window is opened.\nreturns nil if the Preferences-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Preferences-dialog\n",
        "body": "ultraschall.GetPreferencesHWND()$0"
    },
    "ULTRASCHALL.GETSAVELIVEOUTPUTTODISKHWND lua": {
        "prefix": "ultraschall.GetSaveLiveOutputToDiskHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Save live output to disk(bounce)\"-dialog, if the window is opened.\nreturns nil if the \"Save live output to disk(bounce)\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Save live output to disk(bounce)\"-dialog\n",
        "body": "ultraschall.GetSaveLiveOutputToDiskHWND()$0"
    },
    "ULTRASCHALL.GETCONSOLIDATETRACKSHWND lua": {
        "prefix": "ultraschall.GetConsolidateTracksHWND",
        "scope": "lua",
        "description": "returns the HWND of the Consolidate Tracks-dialog, if the window is opened.\nreturns nil if the Consolidate Tracks-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Consolidate Tracks-dialog\n",
        "body": "ultraschall.GetConsolidateTracksHWND()$0"
    },
    "ULTRASCHALL.GETEXPORTPROJECTMIDIHWND lua": {
        "prefix": "ultraschall.GetExportProjectMIDIHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Export Project MIDI\"-dialog, if the window is opened.\nreturns nil if the \"Export Project MIDI\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Export Project MIDI\"-dialog\n",
        "body": "ultraschall.GetExportProjectMIDIHWND()$0"
    },
    "ULTRASCHALL.GETPROJECTDIRECTORYCLEANUPHWND lua": {
        "prefix": "ultraschall.GetProjectDirectoryCleanupHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Project Directory Cleanup\"-dialog, if the window is opened.\nreturns nil if the \"Project Directory Cleanup\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Project Directory Cleanup\"-dialog\n",
        "body": "ultraschall.GetProjectDirectoryCleanupHWND()$0"
    },
    "ULTRASCHALL.GETBATCHFILEITEMCONVERTERHWND lua": {
        "prefix": "ultraschall.GetBatchFileItemConverterHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Batch File/Item Converter\"-dialog, if the window is opened.\nreturns nil if the \"Batch File/Item Converter\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Batch File/Item Converter\"-dialog\n",
        "body": "ultraschall.GetBatchFileItemConverterHWND()$0"
    },
    "ULTRASCHALL.MOVECHILDWITHINPARENTHWND lua": {
        "prefix": "ultraschall.MoveChildWithinParentHWND",
        "scope": "lua",
        "description": "Moves a childhwnd within the coordinates of its parenthwnd.\nGood for moving gui-elements around without having to deal with screen-coordinates.\nYou can decide, whether the new position shall be relative to its old position or absolute within the parenthwnd-position.\nThe parent-hwnd must not be necessarily the parenthwnd of the childhwnd, so you can move the childhwnd relative to other hwnds as well, but\nkeep in mind, that the childhwnd is only seeable within the boundaries of it's own parenthwnd!\nReturns nil in case of an error\nPARAMETERS:\nparenthwnd:the parenthwnd of the childhwnd, within whose dimensions you want to move the childhwnd\nchildhwnd:the childhwnd, that you want to move\nrelative:true, new position will be relative to the old position; false, new position will be absolute within the boundaries of the parenthwnd\nleft:the new x-position of the childhwnd in pixels\ntop:the new y-position of the childhwnd in pixels\nwidth:the new width of the childhwnd in pixels; when relative=true then 0 keeps the old width; when relative=false then 0 is width of 0 pixels\nheight:the new height of the childhwnd in pixels; when relative=true then 0 keeps the old height; when relative=false then 0 is height of 0 pixels\nRETURNS:\nnewxpos:the new x-position on the screen in pixels\nnewypos:the new y-position on the screen in pixels\nnewrightpos:the new right-position on the screen in pixels\nnewbottompos:the new bottom-position on the screen in pixels\nnewwidth:the new width of the childhwnd in pixels\nnewheight:the new height of the childhwnd in pixels\n",
        "body": "ultraschall.MoveChildWithinParentHWND(${1:hwnd parenthwnd},${2:hwnd childhwnd},${3:boolean relative},${4:integer left},${5:integer top},${6:integer width},${7:integer height})$0"
    },
    "ULTRASCHALL.GETCHILDSIZEWITHINPARENTHWND lua": {
        "prefix": "ultraschall.GetChildSizeWithinParentHWND",
        "scope": "lua",
        "description": "Returns the position, height and width of a childhwnd, relative to the position of parenthwnd\nReturns nil in case of an error\nPARAMETERS:\nparenthwnd:the parenthwnd of the childhwnd, whose position will be the base for position-calculation of the childhwnd\nchildhwnd:the childhwnd, whose dimensions you want to get, relative to the position of the parenthwnd\nRETURNS:\nxpos:the x-position of the childhwnd relative to the position of the parenthwnd in pixels\nypos:the y-position of the childhwnd relative to the position of the parenthwnd in pixels\nwidth:the width of the childhwnd in pixels\nheight:the height of the childhwnd in pixels\n",
        "body": "ultraschall.GetChildSizeWithinParentHWND(${1:hwnd parenthwnd},${2:hwnd childhwnd})$0"
    },
    "ULTRASCHALL.GETCHECKBOXSTATE lua": {
        "prefix": "ultraschall.GetCheckboxState",
        "scope": "lua",
        "description": "Gets the checked-state of a checkbox-hwnd.\nThis function will not check, whether the hwnd is an actual checkbox!\nReturns nil in case of an error\nPARAMETERS:\nhwnd:the hwnd-handler of the checkbox\nRETURNS:\nretval:true, checkbox is checked; false, checkbox isn't checked\n",
        "body": "ultraschall.GetCheckboxState(${1:HWND hwnd})$0"
    },
    "ULTRASCHALL.SETCHECKBOXSTATE lua": {
        "prefix": "ultraschall.SetCheckboxState",
        "scope": "lua",
        "description": "Sets the checked-state of a checkbox-hwnd.\nThis function will not check, whether the hwnd is an actual checkbox!\nReturns nil in case of an error\nPARAMETERS:\nhwnd:the hwnd-handler of the checkbox\nstate:true, checkbox will be checked; false, checkbox will be unchecked\nRETURNS:\nretval:0, in case of success\n",
        "body": "ultraschall.SetCheckboxState(${1:HWND hwnd},${2:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDERINGTOFILEHWND lua": {
        "prefix": "ultraschall.GetRenderingToFileHWND",
        "scope": "lua",
        "description": "Gets the HWND of the Rendering to File-dialog, which is displayed while Reaper is rendering.\nreturns nil in case of an error\nRETURNS:\nrendertofile_dialog:the HWND of the render to file-dialog; nil, in case of an error\n",
        "body": "ultraschall.GetRenderingToFileHWND()$0"
    },
    "ULTRASCHALL.CONVERTSCREEN2CLIENTXCOORDINATE_REAPERWINDOW lua": {
        "prefix": "ultraschall.ConvertScreen2ClientXCoordinate_ReaperWindow",
        "scope": "lua",
        "description": "Converts an x-screencoordinate into a x-coordinate within the Reaper-Main-Window.\nDue to Api-limitations, if the Reaper-window is too small, the position might be wrong up to about 74 pixels!\nreturns -1 in case of error\nPARAMETERS:\nXscreencoordinate:the screen-coordinate, you want to have converted to.\nRETURNS:\nXclientcoordinate:coordinate within the main Reaper-window. Negative, if the coordinate is left of the edge of the window; -1, in case of error\n",
        "body": "ultraschall.ConvertScreen2ClientXCoordinate_ReaperWindow(${1:integer Xscreencoordinate})$0"
    },
    "ULTRASCHALL.CONVERTCLIENT2SCREENXCOORDINATE_REAPERWINDOW lua": {
        "prefix": "ultraschall.ConvertClient2ScreenXCoordinate_ReaperWindow",
        "scope": "lua",
        "description": "Converts an x-clientcoordinate from within the main Reaper-window into a x-screencoordinate.\nDue to Api-limitations, if the Reaper-window is too small, the position might be wrong up to about 74 pixels!\nreturns -1 in case of error\nPARAMETERS:\nXclientcoordinate:the screen-coordinate, you want to have converted to. Negative, if left of the left edge of the main Reaper-window.\nRETURNS:\nXscreencoordinate:coordinate within the screen.\n",
        "body": "ultraschall.ConvertClient2ScreenXCoordinate_ReaperWindow(${1:integer Xclientcoordinate})$0"
    },
    "ULTRASCHALL.SETREAPERWINDOWTOSIZE lua": {
        "prefix": "ultraschall.SetReaperWindowToSize",
        "scope": "lua",
        "description": "Sets the Reaper-Window to the size of w and h. The x and y-windowposition will be retained.\nReturns -1 in case of error.\nRETURNS:\nretval:-1 in case of error\n",
        "body": "ultraschall.SetReaperWindowToSize(${1:integer width},${2:integer height})$0"
    },
    "ULTRASCHALL.CONVERTYCOORDSMAC2WIN lua": {
        "prefix": "ultraschall.ConvertYCoordsMac2Win",
        "scope": "lua",
        "description": "Converts the y-coordinate between Windows/Linux and MacOS-based systems.\nNote: MacOS y-coordinates begin at the bottom of the screen, while Windows and Linux y-coordinates begin at the top.\nWith this function, you can convert between these two coordinate-systems\nreturns nil in case of error\nPARAMETERS:\nycoord:the y-coordinate to convert in pixels\nheight:the height of the screen in pixels, which is the base for the conversion; nil, uses current screenheight\nRETURNS:\nconv_ycoord:the converted coordinate in pixels\n",
        "body": "ultraschall.ConvertYCoordsMac2Win(${1:integer ycoord},${2:optional integer height})$0"
    },
    "ULTRASCHALL.GETMEDIAEXPLORERHWND lua": {
        "prefix": "ultraschall.GetMediaExplorerHWND",
        "scope": "lua",
        "description": "returns the HWND of the Media Explorer, if the window is opened.\nreturns nil if Media Explorer is closed\nRETURNS:\nhwnd:the window-handler of the Media Explorer\n",
        "body": "ultraschall.GetMediaExplorerHWND()$0"
    },
    "ULTRASCHALL.GETTIMEBYMOUSEXPOSITION lua": {
        "prefix": "ultraschall.GetTimeByMouseXPosition",
        "scope": "lua",
        "description": "Returns the projectposition at x-mouseposition.\nReturns nil in case of an error\nPARAMETERS:\nxposition:the x-position in pixels, from which you would love to have the projectposition\nRETURNS:\nposition:the projectposition at x-coordinate in seconds\n",
        "body": "ultraschall.GetTimeByMouseXPosition(${1:integer xposition})$0"
    },
    "ULTRASCHALL.SHOWTRACKINPUTMENU lua": {
        "prefix": "ultraschall.ShowTrackInputMenu",
        "scope": "lua",
        "description": "Opens a TrackInput-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaTrack:the MediaTrack, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowTrackInputMenu(${1:integer x},${2:integer y},${3:optional MediaTrack MediaTrack},${4:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWTRACKPANELMENU lua": {
        "prefix": "ultraschall.ShowTrackPanelMenu",
        "scope": "lua",
        "description": "Opens a TrackPanel-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaTrack:the MediaTrack, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowTrackPanelMenu(${1:integer x},${2:integer y},${3:optional MediaTrack MediaTrack},${4:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWTRACKAREAMENU lua": {
        "prefix": "ultraschall.ShowTrackAreaMenu",
        "scope": "lua",
        "description": "Opens a TrackArea-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowTrackAreaMenu(${1:integer x},${2:integer y},${3:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWTRACKROUTINGMENU lua": {
        "prefix": "ultraschall.ShowTrackRoutingMenu",
        "scope": "lua",
        "description": "Opens a TrackRouting-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaTrack:the MediaTrack, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowTrackRoutingMenu(${1:integer x},${2:integer y},${3:optional MediaTrack MediaTrack},${4:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWRULERMENU lua": {
        "prefix": "ultraschall.ShowRulerMenu",
        "scope": "lua",
        "description": "Opens a Ruler-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowRulerMenu(${1:integer x},${2:integer y},${3:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWMEDIAITEMMENU lua": {
        "prefix": "ultraschall.ShowMediaItemMenu",
        "scope": "lua",
        "description": "Opens a MediaItem-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaItem:the MediaItem, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowMediaItemMenu(${1:integer x},${2:integer y},${3:optional MediaItem MediaItem},${4:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWENVELOPEMENU lua": {
        "prefix": "ultraschall.ShowEnvelopeMenu",
        "scope": "lua",
        "description": "Opens a Track/TakeEnvelope-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowEnvelopeMenu(${1:integer x},${2:integer y},${3:optional TrackEnvelope TrackEnvelope},${4:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWENVELOPEPOINTMENU lua": {
        "prefix": "ultraschall.ShowEnvelopePointMenu",
        "scope": "lua",
        "description": "Opens a Track/TakeEnvelope-Point-context menu\nReturns false in case of error.\nPARAMETERS:\nx:the envelope-point, which shall be influenced by the context-menu\ny:y position of the context-menu in pixels\nPointidx:the envelope-point, which shall be influenced by the context-menu\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowEnvelopePointMenu(${1:integer x},${2:integer y},${3:integer Pointidx},${4:optional TrackEnvelope TrackEnvelope},${5:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWENVELOPEPOINTMENU_AUTOMATIONITEM lua": {
        "prefix": "ultraschall.ShowEnvelopePointMenu_AutomationItem",
        "scope": "lua",
        "description": "Opens a Track/TakeEnvelope-Point-context menu for AutomationItems\nReturns false in case of error.\nPARAMETERS:\nx:the envelope-point, which shall be influenced by the context-menu\ny:y position of the context-menu in pixels\nPointidx:the envelope-point, which shall be influenced by the context-menu\nAutomationIDX:the automation item-id within this Envelope, beginning with 1 for the first\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowEnvelopePointMenu_AutomationItem(${1:integer x},${2:integer y},${3:integer Pointidx},${4:integer AutomationIDX},${5:optional TrackEnvelope TrackEnvelope},${6:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWAUTOMATIONITEMMENU lua": {
        "prefix": "ultraschall.ShowAutomationItemMenu",
        "scope": "lua",
        "description": "Opens an AutomationItem-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nAutomationIDX:the automation item-id within this Envelope which shall be influenced by the menu-selection of the opened context-menu, beginning with 1 for the first\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "ultraschall.ShowAutomationItemMenu(${1:integer x},${2:integer y},${3:integer AutomationIDX},${4:optional TrackEnvelope TrackEnvelope},${5:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.GETSAVEPROJECTASHWND lua": {
        "prefix": "ultraschall.GetSaveProjectAsHWND",
        "scope": "lua",
        "description": "returns the HWND of the Save As-dialog, if the window is opened.\nreturns nil if the Save As-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Save As-dialog\n",
        "body": "ultraschall.GetSaveProjectAsHWND()$0"
    },
    "ULTRASCHALL.SETHELPDISPLAYMODE lua": {
        "prefix": "ultraschall.SetHelpDisplayMode",
        "scope": "lua",
        "description": "sets the help-display-mode, as shown in the area beneath the track control panels.\nreturns false in case of an error\nPARAMETERS:\nhelpcontent:0, No information display  \nmouseediting:true, show mouse editing-help; false, don't show mouse editing-help\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "ultraschall.SetHelpDisplayMode(${1:integer helpcontent},${2:boolean mouseediting})$0"
    },
    "ULTRASCHALL.GETHELPDISPLAYMODE lua": {
        "prefix": "ultraschall.GetHelpDisplayMode",
        "scope": "lua",
        "description": "gets the current help-display-mode, as shown in the area beneath the track control panels.\nRETURNS:\nhelpcontent:0, No information display  \nmouseediting:true, show mouse editing-help; false, don't show mouse editing-help\n",
        "body": "ultraschall.GetHelpDisplayMode()$0"
    },
    "ULTRASCHALL.WIRINGDIAGRAM_SETOPTIONS lua": {
        "prefix": "ultraschall.WiringDiagram_SetOptions",
        "scope": "lua",
        "description": "sets the current wiring-display-options\nPARAMETERS:\nshow_send_wires:only show send wires on track mouseover; true, it's set; false, it's unset\nshow_routing_controls:show routing controls when creating send/hardware output; true, it's set; false, it's unset\nshow_hardware_outputs:only show hardware output/input wires on track mouseover; true, it's set; false, it's unset\nRETURNS:\nretval:true, setting was successful; false, setting was not successful\n",
        "body": "ultraschall.WiringDiagram_SetOptions(${1:boolean show_send_wires},${2:boolean show_routing_controls},${3:boolean show_hardware_outputs})$0"
    },
    "ULTRASCHALL.WIRINGDIAGRAM_GETOPTIONS lua": {
        "prefix": "ultraschall.WiringDiagram_GetOptions",
        "scope": "lua",
        "description": "gets the current wiring-display-options\nRETURNS:\nshow_send_wires:only show send wires on track mouseover; true, it's set; false, it's unset\nshow_routing_controls:show routing controls when creating send/hardware output; true, it's set; false, it's unset\nshow_hardware_outputs:only show hardware output/input wires on track mouseover; true, it's set; false, it's unset\n",
        "body": "ultraschall.WiringDiagram_GetOptions()$0"
    },
    "ULTRASCHALL.GETTCPWIDTH lua": {
        "prefix": "ultraschall.GetTCPWidth",
        "scope": "lua",
        "description": "Returns the current width of the TrackControlPanel.\nRETURNS:\nwidth:the width of the TCP\n",
        "body": "ultraschall.GetTCPWidth()$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_FLAC lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_FLAC",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for flac.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nencoding_depth:the encoding-depth of the flac in bits(16 to 24)\ncompression:the data-compression speed from fastest and worst efficiency(0) to slowest but best efficiency(8); default is 5\n",
        "body": "ultraschall.GetRenderCFG_Settings_FLAC(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_AIFF lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_AIFF",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for aiff.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nbitdepth:the bitdepth of the AIFF-file(8, 16, 24, 32)\nEmbedBeatLength:Embed beat length if exact-checkbox; true, checked; false, unchecked\n",
        "body": "ultraschall.GetRenderCFG_Settings_AIFF(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_AUDIOCD lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_AudioCD",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for AudioCD.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\ntrackmode:the trackmode\nuse_markers_hashes:Only use markers starting with #-checkbox; only available when trackmode=0, otherwise it will be ignored\nleadin_silence_tracks:the leadin-silence for tracks in milliseconds(0 to 2147483647)\nleadin_silence_disc:the leadin-silence for discs in milliseconds(0 to 2147483647)\nburn_cd_after_render:burn cd image after render-checkbox\n",
        "body": "ultraschall.GetRenderCFG_Settings_AudioCD(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3 lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MP3",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:the encoding-mode\nenc_quality:the encoding-quality\nvbr_quality:target-quality for VBR; 0(best 100%) to 9(worst 10%); 4, when Mode is set to  ABR, CBR or Maximum bitrate/quality\nabr_bitrate:the average bitrate for ABR in kbps\ncbr_bitrate:the bitrate for CBR in kbps\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "ultraschall.GetRenderCFG_Settings_MP3(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3MAXQUALITY lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MP3MaxQuality",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 with maximum quality-settings.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nretval:0, the renderstring is a valid MP3-MaxQuality-setting; -1, it is not a valid renderstring for MP3-MaxQuality\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "ultraschall.GetRenderCFG_Settings_MP3MaxQuality(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3CBR lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MP3CBR",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 CBR.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\ncbr_bitrate:the bitrate for CBR in kbps\nenc_quality:the encoding-quality\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "ultraschall.GetRenderCFG_Settings_MP3CBR(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3VBR lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MP3VBR",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 VBR.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nenc_quality:the encoding-quality\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "ultraschall.GetRenderCFG_Settings_MP3VBR(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3ABR lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MP3ABR",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 ABR.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nbitrate:  the encoding quality for the mp3\nenc_quality:the encoding-quality\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "ultraschall.GetRenderCFG_Settings_MP3ABR(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_OGG lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_OGG",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for OGG.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:the mode for the ogg-file; 0, VBR; 1, CBR; 2, ABR \nVBR_quality:the quality for VBR-mode; a floating-value between 0 and 1\nCBR_KBPS:the bitrate for CBR-mode; 0 to 4294967295 \nABR_KBPS:the maximum bitrate for ABR-mode; 0 to 4294967295\nABR_KBPS_MIN:the minimum bitrate for ABR-mode; 0 to 4294967295\nABR_KBPS_MAX:the maximum bitrate for ABR-mode; 0 to 4294967295\n",
        "body": "ultraschall.GetRenderCFG_Settings_OGG(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_OPUS lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_OPUS",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for Opus.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:the Mode for the Opus-file; 0, VBR; 1, CVBR; 2, HARDCBR \nBitrate:the kbps of the opus-file; between 1 and 256 \nComplexity:the complexity-setting between 0(lowest quality) and 10(highest quality, slow encoding) \nchannel_audio:true, Encode 3-8 channel audio as 2.1-7.1(LFE) -> checked; false, DON'T Encode 3-8 channel audio as 2.1-7.1(LFE) -> unchecked\nper_channel:true, kbps per channel (6-256); false, kbps combined for all channels \n",
        "body": "ultraschall.GetRenderCFG_Settings_OPUS(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_GIF lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_GIF",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for Gif.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nWidth:the width of the gif in pixels; 1 to 2147483647 pixels\nHeight:the height of the gif in pixels; 1 to 2147483647 pixels\nMaxFramerate:the maximum framerate of the gif\nPreserveAspectRatio:Preserve aspect ratio (black bars, if necessary)-checkbox; true, checked; false, unchecked\nIgnoreLowBits:Ignore changed in low bits of color (0-7, 0 = full quality)-inputbox\nTransparency:Encode transparency (bad for normal video, good for some things possibly)-checkbox; true, checked; false, unchecked\n",
        "body": "ultraschall.GetRenderCFG_Settings_GIF(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_LCF lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_LCF",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for LCF.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nWidth:the width of the gif in pixels; 1 to 2147483647 pixels\nHeight:the height of the gif in pixels; 1 to 2147483647 pixels\nMaxFramerate:the maximum framerate of the gif\nPreserveAspectRatio:Preserve aspect ratio (black bars, if necessary)-checkbox; true, checked; false, unchecked\nTweakSettings:the tweak-settings for LCF, default is \"t20 x128 y16\"\n",
        "body": "ultraschall.GetRenderCFG_Settings_LCF(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_WAV lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_WAV",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for WAV.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nBitDepth:the bitdepth of the WAV-file\nLargeFiles:how shall Reaper treat large WAV-files\nBWFChunk:The \"Write BWF ('bext') chunk\" and \"Include project filename in BWF data\" - checkboxes\nIncludeMarkers: The include markerlist-dropdownlist\nEmbedProjectTempo:Embed project tempo (use with care)-checkbox; true, checked; false, unchecked \n",
        "body": "ultraschall.GetRenderCFG_Settings_WAV(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_WAVPACK lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_WAVPACK",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for WAVPACK.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:0, Normal; 1, Fast; 2, High; 3, Very High(slowest) \nBitdepth:  the bitdepth of the WAVPACK-file\nWritemarkers:Write markers as cues-checkboxes\nWriteBWFChunk:the Write BWF chunk-checkbox; true, checked; false, unchecked \nIncludeFilenameBWF:the include project filename in BWF data-checkbox; true, checked; false, unchecked \n",
        "body": "ultraschall.GetRenderCFG_Settings_WAVPACK(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_WEBMVIDEO lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_WebMVideo",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for WEBM_Video.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVIDKBPS: the video-bitrate of the video in kbps\nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "ultraschall.GetRenderCFG_Settings_WebMVideo(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MKV_VIDEO lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MKV_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MKV-Video.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVIDEO_CODEC:the used VideoCodec for the MKV-video\nMJPEG_quality:the MJPEG-quality of the MKV-video, if VIDEO_CODEC=2\nAUDIO_CODEC:the audio-codec of the MKV-video\nWIDTH:the width of the video in pixels\nHEIGHT:the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "ultraschall.GetRenderCFG_Settings_MKV_Video(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_AVI_VIDEO lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_AVI_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for AVI_Video.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVIDEO_CODEC:the used VideoCodec for the AVI-video\nMJPEG_quality:the MJPEG-quality of the AVI-video, if VIDEO_CODEC=1\nAUDIO_CODEC:the audio-codec of the avi-video\nWIDTH:the width of the video in pixels\nHEIGHT:the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "ultraschall.GetRenderCFG_Settings_AVI_Video(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_QTMOVMP4_VIDEO lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_QTMOVMP4_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for QT/MOV/MP4-video.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMJPEG_quality:the MJPEG-quality of the video\nAUDIO_CODEC:the audio-codec of the video\nWIDTH:the width of the video in pixels\nHEIGHT:the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "ultraschall.GetRenderCFG_Settings_QTMOVMP4_Video(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_DDP lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_DDP",
        "scope": "lua",
        "description": "Returns, if a renderstring is a valid DDP-render-string\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nretval:true, if renderstring is of the format DDP; false, if not\n",
        "body": "ultraschall.GetRenderCFG_Settings_DDP(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_GIF lua": {
        "prefix": "ultraschall.CreateRenderCFG_GIF",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the GIF-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nWidth:the width of the gif in pixels; 1 to 2147483647\nHeight:the height of the gif in pixels; 1 to 2147483647 \nMaxFPS:the maximum framerate of the gif in fps; 0.01 to 2000.01 supported by the Ultraschall API\nAspectRatio:Preserve aspect ratio-checkbox; true, checked; false, unchecked\nIgnoreLowBits:Ignore changes in low bits of color-inputbox, 0-7\nEncodeTransparency:Encode transparency-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected GIF-settings\n",
        "body": "ultraschall.CreateRenderCFG_GIF(${1:integer Width},${2:integer Height},${3:number MaxFPS},${4:boolean AspectRatio},${5:integer IgnoreLowBits},${6:boolean EncodeTransparency})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_LCF lua": {
        "prefix": "ultraschall.CreateRenderCFG_LCF",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the LCF-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nWidth:the width of the lcf in pixels; 1 to 2147483647\nHeight:the height of the lcf in pixels; 1 to 2147483647 \nMaxFPS:the maximum framerate of the lcf in fps; 0.01 to 2000.01 supported by the Ultraschall API\nAspectRatio:Preserve aspect ratio-checkbox; true, checked; false, unchecked\nLCFoptionstweak:a 64bytes string, which can hold tweak-settings for lcf; default is \"t20 x128 y16\"; this function does not check for these options to be valid!\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected LCF-settings\n",
        "body": "ultraschall.CreateRenderCFG_LCF(${1:integer Width},${2:integer Height},${3:number MaxFPS},${4:boolean AspectRatio},${5:optional string LCFoptionstweak})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_WEBMVIDEO lua": {
        "prefix": "ultraschall.CreateRenderCFG_WebMVideo",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the WebM-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVIDKBPS:the video-bitrate of the video in kbps; 1 to 2147483647\nAUDKBPS:the audio-bitrate of the video in kbps; 1 to 2147483647\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected WebM-Video-settings\n",
        "body": "ultraschall.CreateRenderCFG_WebMVideo(${1:integer VIDKBPS},${2:integer AUDKBPS},${3:integer WIDTH},${4:integer HEIGHT},${5:integer FPS},${6:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MKV_VIDEO lua": {
        "prefix": "ultraschall.CreateRenderCFG_MKV_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the MKV-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for the video;\nMJPEG_quality:set here the MJPEG-quality in percent, when VideoCodec=3; otherwise just set it to 0\nAudioCodec:the audiocodec to use for the video\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MKV-Video-settings\n",
        "body": "ultraschall.CreateRenderCFG_MKV_Video(${1:integer VideoCodec},${2:integer MJPEG_quality},${3:integer AudioCodec},${4:integer WIDTH},${5:integer HEIGHT},${6:integer FPS},${7:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_QTMOVMP4_VIDEO lua": {
        "prefix": "ultraschall.CreateRenderCFG_QTMOVMP4_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the QT/MOV/MP4-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for the video;\nMJPEG_quality:set here the MJPEG-quality in percent\nAudioCodec:the audiocodec to use for the video\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected QT/MOV/MP4-Video-settings\n",
        "body": "ultraschall.CreateRenderCFG_QTMOVMP4_Video(${1:integer VideoCodec},${2:integer MJPEG_quality},${3:integer AudioCodec},${4:integer WIDTH},${5:integer HEIGHT},${6:integer FPS},${7:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_AVI_VIDEO lua": {
        "prefix": "ultraschall.CreateRenderCFG_AVI_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the AVI-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for the video;\nMJPEG_quality:set here the MJPEG-quality in percent when VideoCodec=2, otherwise just set it to 0\nAudioCodec:the audiocodec to use for the video\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected QT/MOV/MP4-Video-settings\n",
        "body": "ultraschall.CreateRenderCFG_AVI_Video(${1:integer VideoCodec},${2:integer MJPEG_quality},${3:integer AudioCodec},${4:integer WIDTH},${5:integer HEIGHT},${6:integer FPS},${7:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP4MAC_VIDEO lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MP4Mac_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP4 for Mac_Video(stream optimised and non-stream optimised).\nThis is Mac-OS only!\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nStream:true, mp4-video would be stream-optimized; false, mp4-video would not be stream-optimized\nVIDKBPS: the video-bitrate of the video in kbps\nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "ultraschall.GetRenderCFG_Settings_MP4Mac_Video(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MOVMAC_VIDEO lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_MOVMac_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MOV for Mac_Video.\nThis is MacOS-only.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVideoCodec:the videocodec used for this setting\nVIDKBPS: the video-bitrate of the video in kbps\nMJPEG_quality:when VideoCodec==3, then MJPEG is used; given in percent\nAudioCodec:the audiocodec used \nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "ultraschall.GetRenderCFG_Settings_MOVMac_Video(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_M4AMAC lua": {
        "prefix": "ultraschall.GetRenderCFG_Settings_M4AMac",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for M4A for Mac_Video(even though this stores only audio-files).\nThis is MacOS-only.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nAUDKBPS: the audio-bitrate of the audio in kbps\nWIDTH:the width of the audio in pixels\nHEIGHT: the height of the audio in pixels\nFPS:the fps of the audio; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "ultraschall.GetRenderCFG_Settings_M4AMac(${1:string rendercfg})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP4MAC_VIDEO lua": {
        "prefix": "ultraschall.CreateRenderCFG_MP4MAC_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the MP4-Mac-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nOnly available on MacOS!\nReturns nil in case of an error\nPARAMETERS:\nVIDKBPS:the video-bitrate for the video; 0 to 2147483647kbps\nAUDKBPS:the audio-bitrate for the video; 0 to 2147483647kbps\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP4-Mac-Video-settings\n",
        "body": "ultraschall.CreateRenderCFG_MP4MAC_Video(${1:boolean stream},${2:integer VIDKBPS},${3:integer AUDKBPS},${4:integer WIDTH},${5:integer HEIGHT},${6:integer FPS},${7:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_M4AMAC lua": {
        "prefix": "ultraschall.CreateRenderCFG_M4AMAC",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the M4A-Mac-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nOnly available on MacOS!\nReturns nil in case of an error\nPARAMETERS:\nAUDKBPS:the audio-bitrate for the video; 0 to 2147483647 kbps\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected M4A-Mac-settings\n",
        "body": "ultraschall.CreateRenderCFG_M4AMAC(${1:integer AUDKBPS},${2:integer WIDTH},${3:integer HEIGHT},${4:integer FPS},${5:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MOVMAC_VIDEO lua": {
        "prefix": "ultraschall.CreateRenderCFG_MOVMAC_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the MOV-Mac-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nOnly available on MacOS!\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for this setting\nVIDKBPS: the video-bitrate of the video in kbps\nMJPEG_quality:when VideoCodec==3, then MJPEG is used; given in percent\nAudioCodec:the audiocodec used \nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP4-Mac-Video-settings\n",
        "body": "ultraschall.CreateRenderCFG_MOVMAC_Video(${1:integer VideoCodec},${2:integer VIDKBPS},${3:integer MJPEG_quality},${4:integer AudioCodec},${5:integer AUDKBPS},${6:integer WIDTH},${7:integer HEIGHT},${8:integer FPS},${9:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.GETRENDERTABLE_PROJECT lua": {
        "prefix": "ultraschall.GetRenderTable_Project",
        "scope": "lua",
        "description": "Returns all stored render-settings for the current project, as a handy table.\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - true, closes rendering to file-dialog after render; false, doesn't close it\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; true, checked; false, unchecked\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; true, checked; false, unchecked\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns nil in case of an error\nRETURNS:\nRenderTable:a table with all of the current project's render-settings\n",
        "body": "ultraschall.GetRenderTable_Project()$0"
    },
    "ULTRASCHALL.GETRENDERTABLE_PROJECTFILE lua": {
        "prefix": "ultraschall.GetRenderTable_ProjectFile",
        "scope": "lua",
        "description": "Returns all stored render-settings in a projectfile, as a handy table.\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - close rendering to file-dialog after render; always true, as this isn't stored in projectfiles\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checkbox is checked; false, checkbox is unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; always true(checked), as this isn't stored in projectfiles\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; always false, as this is not stored in projectfiles\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile, whose render-settings you want to get\nRETURNS:\nRenderTable:a table with all of the current project's render-settings\n",
        "body": "ultraschall.GetRenderTable_ProjectFile(${1:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.GETOUTPUTFORMAT_RENDERCFG lua": {
        "prefix": "ultraschall.GetOutputFormat_RenderCfg",
        "scope": "lua",
        "description": "Returns the output-format set in a render-cfg-string, as stored in rpp-files and the render-presets file reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nRenderstring:the render-cfg-string from a rpp-projectfile or the reaper-render.ini\nReaProject:a ReaProject, whose renderformat you want to know; only available, when Renderstring=nil\nRETURNS:\noutputformat:the outputformat, set in the render-cfg-string\nrenderstring:the renderstringm which is either the renderstring you've passed or the one from the ReaProject you passed as second parameter\n",
        "body": "ultraschall.GetOutputFormat_RenderCfg(${1:string Renderstring},${2:optional ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_OPUS lua": {
        "prefix": "ultraschall.CreateRenderCFG_Opus",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the Opus-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nMode:the Mode for the Opus-file; 0, VBR; 1, CVBR; 2, HARDCBR\nKbps:the kbps of the opus-file; Ultraschall-Api supports between 1 and 10256 \nComplexity:the complexity-setting between 0(lowest quality) and 10(highest quality, slow encoding)\nchannel_audio:true, Encode 3-8 channel audio as 2.1-7.1(LFE); false, DON'T Encode 3-8 channel audio as 2.1-7.1(LFE) \nper_channel:true, kbps per channel (6-256); false, kbps combined for all channels \nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected Opus-settings\n",
        "body": "ultraschall.CreateRenderCFG_Opus(${1:integer Mode},${2:integer Kbps},${3:integer Complexity},${4:optional boolean channel_audio},${5:optional boolean per_channel})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_OGG lua": {
        "prefix": "ultraschall.CreateRenderCFG_OGG",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the OGG-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nFor all mode-settings that you don't need(kbps or quality), you can safely set them to 1.\nReturns nil in case of an error\nPARAMETERS:\nMode:the mode for the ogg-file; 0, VBR; 1, CBR; 2, ABR\nVBR_Quality:the quality for VBR-mode; a floating-value between 0 and 1\nCBR_KBPS:the bitrate for CBR-mode; 0 to 2048\nABR_KBPS:the maximum-bitrate for ABR-mode; 0 to 2048\nABR_KBPS_MIN:the minimum-bitrate for ABR-mode; 0 to 2048\nABR_KBPS_MAX:the maximum-bitrate for ABR-mode; 0 to 2048\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected OGG-settings\n",
        "body": "ultraschall.CreateRenderCFG_OGG(${1:integer Mode},${2:number VBR_Quality},${3:integer CBR_KBPS},${4:integer ABR_KBPS},${5:integer ABR_KBPS_MIN},${6:integer ABR_KBPS_MAX})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_DDP lua": {
        "prefix": "ultraschall.CreateRenderCFG_DDP",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the DDP-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected DDP-settings\n",
        "body": "ultraschall.CreateRenderCFG_DDP()$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_FLAC lua": {
        "prefix": "ultraschall.CreateRenderCFG_FLAC",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the FLAC-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nBitrate:the bitrate of the flac-file; \nEncSpeed:the encoding speed; 0(fastest) to 8(slowest); 5(default)\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected FLAC-settings\n",
        "body": "ultraschall.CreateRenderCFG_FLAC(${1:integer Bitrate},${2:integer EncSpeed})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_WAVPACK lua": {
        "prefix": "ultraschall.CreateRenderCFG_WAVPACK",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the WAVPACK-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nMode:0, Normal; 1, Fast; 2, High; 3, Very High(slowest)\nBitdepth:the bitdepth of the WAVPACK-file\nWritemarkers:Write markers as cues-checkboxes\nWriteBWFChunk:the Write BWF chunk-checkbox; true, checked; false, unchecked\nIncludeFilenameBWF:the include project filename in BWF data-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected WAVPACK-settings\n",
        "body": "ultraschall.CreateRenderCFG_WAVPACK(${1:integer Mode},${2:integer Bitdepth},${3:integer Writemarkers},${4:boolean WriteBWFChunk},${5:boolean IncludeFilenameBWF})$0"
    },
    "ULTRASCHALL.ISVALIDRENDERTABLE lua": {
        "prefix": "ultraschall.IsValidRenderTable",
        "scope": "lua",
        "description": "returns, if the table RenderTable is a valid RenderTable.\nReturns false in case of an error; the error-message contains the faulty table-entry.\nPARAMETERS:\nRenderTable:the table, that you want to check for validity\nRETURNS:\nretval:true, RenderTable is a valid RenderTable; false, it is not a valid RenderTable\n",
        "body": "ultraschall.IsValidRenderTable(${1:RenderTable RenderTable})$0"
    },
    "ULTRASCHALL.APPLYRENDERTABLE_PROJECT lua": {
        "prefix": "ultraschall.ApplyRenderTable_Project",
        "scope": "lua",
        "description": "Sets all stored render-settings from a RenderTable as the current project-settings.\nNote: On Reaper 6.10, you cannot set AddToProj and NoSilentRender simultaneously due a bug in Reaper; is fixed in higher versions.\nExpected table is of the following structure:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - true, close rendering to file-dialog after render; false, don't close it\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; true, checked; false, unchecked\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; true, checked; false, unchecked\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns false in case of an error\nPARAMETERS:\nRenderTable:a RenderTable, that contains all render-dialog-settings\napply_rendercfg_string:true or nil, apply it as well; false, don't apply it\nRETURNS:\nretval:true, setting the render-settings was successful; false, it wasn't successful\n",
        "body": "ultraschall.ApplyRenderTable_Project(${1:RenderTable RenderTable},${2:optional boolean apply_rendercfg_string})$0"
    },
    "ULTRASCHALL.APPLYRENDERTABLE_PROJECTFILE lua": {
        "prefix": "ultraschall.ApplyRenderTable_ProjectFile",
        "scope": "lua",
        "description": "Sets all stored render-settings from a RenderTable as the current project-settings.\nExpected table is of the following structure:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - close rendering to file-dialog after render; ignored, as this can't be set in projectfiles\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle);\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; ignored, as this can't be stored in projectfiles\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; ignored, as this can't be stored in projectfiles\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns false in case of an error\nPARAMETERS:\nRenderTable:a RenderTable, that contains all render-dialog-settings\nprojectfilename_with_path:the rpp-projectfile, to which you want to apply the RenderTable; nil, to use parameter ProjectStateChunk instead\napply_rendercfg_string:true or nil, apply it as well; false, don't apply it\nProjectStateChunk:the ProjectStateChunkk, to which you want to apply the RenderTable\nRETURNS:\nretval:true, setting the render-settings was successful; false, it wasn't successful\nProjectStateChunk:the altered project/ProjectStateChunk as a string\n",
        "body": "ultraschall.ApplyRenderTable_ProjectFile(${1:RenderTable RenderTable},${2:string projectfilename_with_path},${3:optional boolean apply_rendercfg_string},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETRENDER_SAVECOPYOFPROJECT lua": {
        "prefix": "ultraschall.GetRender_SaveCopyOfProject",
        "scope": "lua",
        "description": "Gets the current state of the \"Save copy of project to outfile.wav.RPP\"-checkbox from the Render to File-dialog.\nReturns false in case of an error\nRETURNS:\nretval:true, checkbox is checked; false, checkbox is unchecked\n",
        "body": "ultraschall.GetRender_SaveCopyOfProject()$0"
    },
    "ULTRASCHALL.SETRENDER_QUEUEDELAY lua": {
        "prefix": "ultraschall.SetRender_QueueDelay",
        "scope": "lua",
        "description": "Sets the \"Delay queued render to allow samples to load\"-checkbox of the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nlength:the number of seconds the delay shall be\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.SetRender_QueueDelay(${1:boolean state},${2:integer length})$0"
    },
    "ULTRASCHALL.SETRENDER_SAVECOPYOFPROJECT lua": {
        "prefix": "ultraschall.SetRender_SaveCopyOfProject",
        "scope": "lua",
        "description": "Sets the \"Save copy of project to outfile.wav.RPP\"-checkbox of the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.SetRender_SaveCopyOfProject(${1:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDER_QUEUEDELAY lua": {
        "prefix": "ultraschall.GetRender_QueueDelay",
        "scope": "lua",
        "description": "Gets the current checkstate of the \"Delay queued render to allow samples to load\"-checkbox from the Render to File-dialog,\nas well as the length of the queue-render-delay.\nRETURNS:\nlength:the number of seconds the delay shall be\n",
        "body": "ultraschall.GetRender_QueueDelay()$0"
    },
    "ULTRASCHALL.SETRENDER_PROJECTSAMPLERATEFORMIX lua": {
        "prefix": "ultraschall.SetRender_ProjectSampleRateForMix",
        "scope": "lua",
        "description": "Sets the \"Use project sample rate for mixing and FX/synth processing\"-checkbox of the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.SetRender_ProjectSampleRateForMix(${1:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDER_PROJECTSAMPLERATEFORMIX lua": {
        "prefix": "ultraschall.GetRender_ProjectSampleRateForMix",
        "scope": "lua",
        "description": "Gets the current state of the \"Use project sample rate for mixing and FX/synth processing\"-checkbox from the Render to File-dialog.\n",
        "body": "ultraschall.GetRender_ProjectSampleRateForMix()$0"
    },
    "ULTRASCHALL.SETRENDER_AUTOINCREMENTFILENAME lua": {
        "prefix": "ultraschall.SetRender_AutoIncrementFilename",
        "scope": "lua",
        "description": "Gets the current state of the \"Silently increment filenames to avoid overwriting\"-checkbox from the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.SetRender_AutoIncrementFilename(${1:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDER_AUTOINCREMENTFILENAME lua": {
        "prefix": "ultraschall.GetRender_AutoIncrementFilename",
        "scope": "lua",
        "description": "Gets the current state of the \"Silently increment filenames to avoid overwriting\"-checkbox from the Render to File-dialog.\n",
        "body": "ultraschall.GetRender_AutoIncrementFilename()$0"
    },
    "ULTRASCHALL.GETRENDERPRESET_NAMES lua": {
        "prefix": "ultraschall.GetRenderPreset_Names",
        "scope": "lua",
        "description": "Returns all render-preset-names for a) Bounds and output pattern/filename b) Options and format c) both presets, who share the same name\nRETURNS:\nbounds_presets:the number of found bounds and output-pattern-presets\nbounds_names:the names of all found bounds and output-pattern-presets\noptions_format_presets:the number of found options and format-presets\noptions_format_names:the names of all found options and format-presets\nboth_presets:the number of found presets, who both share the same name\nboth_names:the names of all found presets, who both share the same name\n",
        "body": "ultraschall.GetRenderPreset_Names()$0"
    },
    "ULTRASCHALL.GETRENDERPRESET_RENDERTABLE lua": {
        "prefix": "ultraschall.GetRenderPreset_RenderTable",
        "scope": "lua",
        "description": "returns a rendertable, that contains all settings of a specific render-preset.\nuse GetRenderPreset_Names to get the available render-preset-names.\nSome settings aren't stored in Presets and will get default values:\nTailMS=0, SilentlyIncrementFilename=false, AddToProj=false, SaveCopyOfProject=false, RenderQueueDelay=false, RenderQueueDelaySeconds=false, NoSilentRender=false\nreturned table if of the following format:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; always false, as this isn't stored in render-presets\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - close rendering to file-dialog after rendering; always true, as this isn't stored in render-presets\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; can't be set in render-presets, therefore always set to false\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; always false, as this isn't stored in render-presets\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay; always 0, as this isn't stored in render-presets\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; always false, as this isn't stored in render-presets\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; always true, as this isn't stored in Presets\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail; always 0, as this isn't stored in render-presets\nReturns nil in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to get\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to get\nRETURNS:\nRenderTable:a render-table, which contains all settings from a render-preset\n",
        "body": "ultraschall.GetRenderPreset_RenderTable(${1:string Bounds_Name},${2:string Options_and_Format_Name})$0"
    },
    "ULTRASCHALL.DELETERENDERPRESET_BOUNDS lua": {
        "prefix": "ultraschall.DeleteRenderPreset_Bounds",
        "scope": "lua",
        "description": "deletes a Bounds-render-preset from Reaper's render-presets.\nThis deletes all(!) occurrences of the Bounds-render-preset with the same name.\nThough, you shouldn't store multiple Bounds-render-presets with the same name into reaper-render.ini in the first place.\nuse GetRenderPreset_Names to get the available render-preset-names.\nReturns false in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to get\nRETURNS:\nretval:true, deleting was successful; false, deleting was unsuccessful\n",
        "body": "ultraschall.DeleteRenderPreset_Bounds(${1:string Bounds_Name})$0"
    },
    "ULTRASCHALL.DELETERENDERPRESET_FORMATOPTIONS lua": {
        "prefix": "ultraschall.DeleteRenderPreset_FormatOptions",
        "scope": "lua",
        "description": "deletes a Render-Format-Options-render-preset from Reaper's render-presets.\nThis deletes all(!) occurrences of the Render-Format-Options-render-preset with the same name.\nThough, you shouldn't store multiple Render-Format-Options-render-preset with the same name into reaper-render.ini in the first place.\nuse GetRenderPreset_Names to get the available render-preset-names.\nReturns false in case of an error\nPARAMETERS:\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to get\nRETURNS:\nretval:true, deleting was successful; false, deleting was unsuccessful\n",
        "body": "ultraschall.DeleteRenderPreset_FormatOptions(${1:string Options_and_Format_Name})$0"
    },
    "ULTRASCHALL.ADDRENDERPRESET lua": {
        "prefix": "ultraschall.AddRenderPreset",
        "scope": "lua",
        "description": "adds a new render-preset into reaper-render.ini.\nThis function will check, whether the chosen names are already in use.\nAdded render-presets are available after (re-)opening in the Render to File-dialog\nNote: You can choose, whether to include only Bounds, only RenderFormatOptions of both. The Bounds and the RenderFormatOptions store different parts of the render-presets.\nSome settings aren't stored in Presets and will get default values:\nTailMS=0, SilentlyIncrementFilename=false, AddToProj=false, SaveCopyOfProject=false, RenderQueueDelay=false, RenderQueueDelaySeconds=false, NoSilentRender=false\nBounds_Name stores only:\nRenderTable[\"Bounds\"] - the bounds-dropdownlist,\n0, Custom time range\n1, Entire project\n2, Time selection\n3, Project regions\n4, Selected Media Items(in combination with Source 32)\n5, Selected regions\nRenderTable[\"Startposition\"] - the startposition of the render\nRenderTable[\"Endposition\"] - the endposition of the render\nRenderTable[\"Source\"] - the source dropdownlist, includes\n0, Master mix\n1, Master mix + stems\n3, Stems (selected tracks)\n8, Region render matrix\n32, Selected media items\n64, selected media items via master\n128, selected tracks via master\n\"0\"    - unknown, default setting is 0\nRenderTable[\"RenderPattern\"] - the renderpattern, which hold also the wildcards\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked?\n&1, custom time bounds\n&2, entire project\n&4, time selection\n&8, all project regions\n&16, selected media items\n&32, selected project regions\nOptions_and_Format_Name stores only:\nRenderTable[\"SampleRate\"] - the samplerate, with which to render; 0, use project-settings\nRenderTable[\"Channels\"] - the number of channels for the output-file\nRenderTable[\"OfflineOnlineRendering\"] - the offline/online-dropdownlist\n0, Full-speed Offline\n1, 1x Offline\n2, Online Render\n3, Online Render(Idle)\n4, Offline Render(Idle);\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist;\n0, Medium (64pt Sinc)\n1, Low (Linear Interpolation)\n2, Lowest (Point Sampling)\n3, Good (192pt Sinc)\n4, Better (348 pt Sinc)\n5, Fast (IIR + Linear Interpolation)\n6, Fast (IIRx2 + Linear Interpolation)\n7, Fast (16pt Sinc)\n8, HQ (512 pt)\n9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"Dither\"] - the Dither/Noise shaping-checkboxes:\n&1, dither master mix\n&2, noise shaping master mix\n&4, dither stems\n&8, dither noise shaping stems\nRenderTable[\"MultiChannelFiles\"] - multichannel-files-checkbox\nRenderTable[\"OnlyMonoMedia\"] - only mono media-checkbox\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides-checkbox\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers-checkbox\nRenderTable[\"RenderString\"] - the render-cfg-string, which holds the render-outformat-settings\nRenderTable[\"RenderString2\"] - the render-cfg-string, which holds the secondary render-outformat-settings\nReturns false in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to add; nil, to not add a new Bounds-render-preset\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to add; to not add a new Render-Format-Options-render-preset\nRenderTable:the RenderTable, which holds all information for inclusion into the Render-Preset\nRETURNS:\nretval:true, adding was successful; false, adding was unsuccessful\n",
        "body": "ultraschall.AddRenderPreset(${1:string Bounds_Name},${2:string Options_and_Format_Name},${3:RenderTable RenderTable})$0"
    },
    "ULTRASCHALL.SETRENDERPRESET lua": {
        "prefix": "ultraschall.SetRenderPreset",
        "scope": "lua",
        "description": "sets an already existing render-preset in reaper-render.ini.\nThis function will check, whether the chosen names aren't given yet in any preset.\nChanged render-presets are updated after (re-)opening in the Render to File-dialog\nNote: You can choose, whether to include only Bounds, only RenderFormatOptions of both. The Bounds and the RenderFormatOptions store different parts of the render-presets.\nSome settings aren't stored in Presets and will get default values:\nTailMS=0, SilentlyIncrementFilename=false, AddToProj=false, SaveCopyOfProject=false, RenderQueueDelay=false, RenderQueueDelaySeconds=false, NoSilentRender=false\nBounds_Name stores only:\nRenderTable[\"Bounds\"] - the bounds-dropdownlist,\n0, Custom time range\n1, Entire project\n2, Time selection\n3, Project regions\n4, Selected Media Items(in combination with Source 32)\n5, Selected regions\nRenderTable[\"Startposition\"] - the startposition of the render\nRenderTable[\"Endposition\"] - the endposition of the render\nRenderTable[\"Source\"]+RenderTable[\"MultiChannelFiles\"]+RenderTable[\"OnlyMonoMedia\"] - the source dropdownlist, includes\n0, Master mix\n1, Master mix + stems\n3, Stems (selected tracks)\n&4, Multichannel tracks to multichannel files\n8, Region render matrix\n&16, Tracks with only mono media to mono files\n32, Selected media items\n64, selected media items via master\n128, selected tracks via master\n\"0\"    - unknown, default setting is 0\nRenderTable[\"RenderPattern\"] - the renderpattern, which hold also the wildcards\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked?\n&1, custom time bounds\n&2, entire project\n&4, time selection\n&8, all project regions\n&16, selected media items\n&32, selected project regions\nOptions_and_Format_Name stores only:\nRenderTable[\"SampleRate\"] - the samplerate, with which to render; 0, use project-settings\nRenderTable[\"Channels\"] - the number of channels for the output-file\nRenderTable[\"OfflineOnlineRendering\"] - the offline/online-dropdownlist\n0, Full-speed Offline\n1, 1x Offline\n2, Online Render\n3, Online Render(Idle)\n4, Offline Render(Idle);\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist;\n0, Medium (64pt Sinc)\n1, Low (Linear Interpolation)\n2, Lowest (Point Sampling)\n3, Good (192pt Sinc)\n4, Better (348 pt Sinc)\n5, Fast (IIR + Linear Interpolation)\n6, Fast (IIRx2 + Linear Interpolation)\n7, Fast (16pt Sinc)\n8, HQ (512 pt)\n9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"Dither\"] - the Dither/Noise shaping-checkboxes:\n&1, dither master mix\n&2, noise shaping master mix\n&4, dither stems\n&8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides-checkbox\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers-checkbox\nRenderTable[\"RenderString\"] - the render-cfg-string, which holds the render-outformat-settings\nRenderTable[\"RenderString2\"] - the render-cfg-string, which holds the secondary render-outformat-settings; \"\" to remove it from this preset\nReturns false in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to add; nil, to not add a new Bounds-render-preset\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to add; to not add a new Render-Format-Options-render-preset\nRenderTable:the RenderTable, which holds all information for inclusion into the Render-Preset\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "ultraschall.SetRenderPreset(${1:string Bounds_Name},${2:string Options_and_Format_Name},${3:RenderTable RenderTable})$0"
    },
    "ULTRASCHALL.RENDERPROJECT_RENDERTABLE lua": {
        "prefix": "ultraschall.RenderProject_RenderTable",
        "scope": "lua",
        "description": "Renders a projectfile or the current active project, using the settings from a RenderTable.\nExpected RenderTable is of the following structure:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - true, close rendering to file-dialog after render; false, don't close it\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; true, checked; false, unchecked\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; true, checked; false, unchecked\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename with path of the rpp-file that you want to render; nil, to render the current active project\nRenderTable:the RenderTable with all render-settings, that you want to apply; nil, use the project's existing settings\nAddToProj:true, add the rendered files to the project; nil or false, don't add them; \nCloseAfterRender:true or nil, closes rendering to file-dialog after rendering is finished; false, keep it open\nSilentlyIncrementFilename:true or nil, silently increment filename, when file already exists; false, ask for overwriting\nRETURNS:\ncount:the number of files that have been rendered\nMediaItemStateChunkArray:the MediaItemStateChunks of all the rendered files\nFilearray:filenames with path of all rendered files\n",
        "body": "ultraschall.RenderProject_RenderTable(${1:optional string projectfilename_with_path},${2:optional RenderTable RenderTable},${3:optional boolean AddToProj},${4:optional boolean CloseAfterRender},${5:optional boolean SilentlyIncrementFilename})$0"
    },
    "ULTRASCHALL.GETRENDERQUEUEDPROJECTS lua": {
        "prefix": "ultraschall.GetRenderQueuedProjects",
        "scope": "lua",
        "description": "Gets the number and names of files currently in the render-queue\nRETURNS:\nFilecount:the number of project-files in the render-queue\nFilearray:filenames with path of all queued-projectfiles\n",
        "body": "ultraschall.GetRenderQueuedProjects()$0"
    },
    "ULTRASCHALL.RENDERPROJECT_RENDERQUEUE lua": {
        "prefix": "ultraschall.RenderProject_RenderQueue",
        "scope": "lua",
        "description": "Renders a specific project from the render-queue.\nSee GetRenderQueuedProjects to get the names of the currently existing render-queue-projects, where the filename-order reflects the index needed for this function.\nreturns false in case of an error\nPARAMETERS:\nindex:the index of the render-queued-project; beginning with 1; -1 to render all projects in the render-queue\nRETURNS:\nretval:false, a problem occurred; true, rendering went through; returns true as well, when rendering is aborted!\n",
        "body": "ultraschall.RenderProject_RenderQueue(${1:integer index})$0"
    },
    "ULTRASCHALL.RENDERPROJECT lua": {
        "prefix": "ultraschall.RenderProject",
        "scope": "lua",
        "description": "Renders a project, using a specific render-cfg-string.\nTo get render-cfg-strings, see functions starting with CreateRenderCFG_, like CreateRenderCFG_AIFF, CreateRenderCFG_DDP, CreateRenderCFG_FLAC, CreateRenderCFG_OGG, CreateRenderCFG_Opus, etc.\nWill use the render-settings currently set in projectfilename_with_path/the currently active project, except bound(set to Custom time range), render file and render-pattern, as they are set by this function!\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the project to render; nil, for the currently opened project\nrenderfilename_with_path:the filename with path of the output-file. If you give the wrong extension, Reaper will exchange it by the correct one.\nstartposition:the startposition of the render-area in seconds; \nendposition:the endposition of the render-area in seconds; \noverwrite_without_asking:true, overwrite an existing renderfile; false, don't overwrite an existing renderfile\nrenderclosewhendone:true, automatically close the render-window after rendering; false, keep rendering window open after rendering; nil, use current settings\nfilenameincrease:true, silently increase filename, if it already exists; false, ask before overwriting an already existing outputfile; nil, use current settings\nrendercfg:just like rendercfg, but for the secondary render-format\nrendercfg2:just like rendercfg, but for the secondary render-format\nRETURNS:\nretval:-1, in case of error; 0, in case of success\nrenderfilecount:the number of rendered files\nMediaItemStateChunkArray:the MediaItemStateChunks of all rendered files, with the one in entry 1 being the rendered master-track(when rendering stems+master)\nFilearray:the filenames of the rendered files, including their paths. The filename in entry 1 is the one of the mastered track(when rendering stems+master)\n",
        "body": "ultraschall.RenderProject(${1:string projectfilename_with_path},${2:string renderfilename_with_path},${3:number startposition},${4:number endposition},${5:boolean overwrite_without_asking},${6:boolean renderclosewhendone},${7:boolean filenameincrease},${8:optional string rendercfg},${9:optional string rendercfg2})$0"
    },
    "ULTRASCHALL.RENDERPROJECT_REGIONS lua": {
        "prefix": "ultraschall.RenderProject_Regions",
        "scope": "lua",
        "description": "Renders a region of a project, using a specific render-cfg-string.\nTo get render-cfg-strings, see CreateRenderCFG_AIFF, CreateRenderCFG_DDP, CreateRenderCFG_FLAC, CreateRenderCFG_OGG, CreateRenderCFG_Opus\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the project to render; nil, for the currently opened project\nrenderfilename_with_path:the filename of the output-file. \nregion:when addregionname==true, this parameter allows you to set a separator between renderfilename_with_path and regionname. \naddregionname:when addregionname==true, this parameter allows you to set a separator between renderfilename_with_path and regionname. \noverwrite_without_asking:true, overwrite an existing renderfile; false, don't overwrite an existing renderfile\nrenderclosewhendone:true, automatically close the render-window after rendering; false, keep rendering window open after rendering; nil, use current settings\nfilenameincrease:true, silently increase filename, if it already exists; false, ask before overwriting an already existing outputfile; nil, use current settings\nrendercfg:the render-cfg-string for secondary render-format\naddregionnameseparator:when addregionname==true, this parameter allows you to set a separator between renderfilename_with_path and regionname. \nrendercfg2:the render-cfg-string for secondary render-format\nRETURNS:\nretval:-1, in case of error; 0, in case of success\nrenderfilecount:the number of rendered files\nMediaItemStateChunkArray:the MediaItemStateChunks of all rendered files, with the one in entry 1 being the rendered master-track(when rendering stems)\nFilearray:the filenames of the rendered files, including their paths. The filename in entry 1 is the one of the mastered track(when rendering stems)\n",
        "body": "ultraschall.RenderProject_Regions(${1:string projectfilename_with_path},${2:string renderfilename_with_path},${3:integer region},${4:boolean addregionname},${5:boolean overwrite_without_asking},${6:boolean renderclosewhendone},${7:boolean filenameincrease},${8:string rendercfg},${9:optional string addregionnameseparator},${10:optional string rendercfg2})$0"
    },
    "ULTRASCHALL.ADDSELECTEDITEMSTORENDERQUEUE lua": {
        "prefix": "ultraschall.AddSelectedItemsToRenderQueue",
        "scope": "lua",
        "description": "Adds the selected MediaItems to the render-queue.\nreturns false in case of an error\nPARAMETERS:\nrender_items_individually:false or nil, render all selected MediaItems in one render-queued-project; true, render all selected MediaItems individually as separate Queued-projects\nrender_items_through_master:false or nil, just render the MediaItems; true, render the MediaItems through the Master-channel\nRenderTables:a RenderTable to apply for the renders in the render-queue\nRETURNS:\nretval:true, adding was successful; false, adding was unsuccessful\nnum_queued_projects:the number of newly created projects in the render-queue\n",
        "body": "ultraschall.AddSelectedItemsToRenderQueue(${1:optional boolean render_items_individually},${2:optional boolean render_items_through_master},${3:optional RenderTable RenderTables})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3MAXQUALITY lua": {
        "prefix": "ultraschall.CreateRenderCFG_MP3MaxQuality",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with highest quality-settings. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nPARAMETERS:\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the renderstring for MP3 with maximum quality\n",
        "body": "ultraschall.CreateRenderCFG_MP3MaxQuality(${1:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3VBR lua": {
        "prefix": "ultraschall.CreateRenderCFG_MP3VBR",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with variable bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nvbr_quality:the variable-bitrate quality; 1(for 10%) to 10(for 100%)\nquality:the encoding speed for the mp3\nno_joint_stereo:the \"Do not allow joint stereo\"-checkbox; true, checked; false, unchecked; default is unchecked\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP3-VBR-settings\n",
        "body": "ultraschall.CreateRenderCFG_MP3VBR(${1:integer vbr_quality},${2:integer quality},${3:optional boolean no_joint_stereo},${4:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3ABR lua": {
        "prefix": "ultraschall.CreateRenderCFG_MP3ABR",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with average bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nbitrate:the encoding quality for the mp3\nquality:the encoding speed for the mp3\nno_joint_stereo:the \"Do not allow joint stereo\"-checkbox; true, checked; false, unchecked; default is unchecked\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP3-ABR-settings\n",
        "body": "ultraschall.CreateRenderCFG_MP3ABR(${1:integer bitrate},${2:integer quality},${3:optional boolean no_joint_stereo},${4:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3CBR lua": {
        "prefix": "ultraschall.CreateRenderCFG_MP3CBR",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with constant bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nbitrate:the encoding quality for the mp3\nquality:the encoding speed for the mp3\nno_joint_stereo:the \"Do not allow joint stereo\"-checkbox; true, checked; false, unchecked; default is unchecked\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP3-CBR-settings\n",
        "body": "ultraschall.CreateRenderCFG_MP3CBR(${1:integer bitrate},${2:integer quality},${3:optional boolean no_joint_stereo},${4:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_WAV lua": {
        "prefix": "ultraschall.CreateRenderCFG_WAV",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the WAV-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nBitDepth:the bitdepth of the WAV-file\nLargeFiles:how shall Reaper treat large WAV-files\nBWFChunk:Write BWF ('bext') chunk and Include project filename in BWF data - checkboxes\nIncludeMarkers:The include markerlist-dropdownlist\nEmbedProjectTempo:Embed project tempo (use with care)-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected WAV-settings\n",
        "body": "ultraschall.CreateRenderCFG_WAV(${1:integer BitDepth},${2:integer LargeFiles},${3:integer BWFChunk},${4:integer IncludeMarkers},${5:boolean EmbedProjectTempo})$0"
    },
    "ULTRASCHALL.GETLASTUSEDRENDERPATTERNS lua": {
        "prefix": "ultraschall.GetLastUsedRenderPatterns",
        "scope": "lua",
        "description": "returns the last 12 used render-patterns, that have been used for rendering by any project in Reaper.\nRETURNS:\nlast_render_patterns:a table, which holds the last 12 used render-patterns, used by any project in Reaper\n",
        "body": "ultraschall.GetLastUsedRenderPatterns()$0"
    },
    "ULTRASCHALL.GETLASTRENDERPATHS lua": {
        "prefix": "ultraschall.GetLastRenderPaths",
        "scope": "lua",
        "description": "returns the last 20 used render-output-paths, that have been used for rendering by any project in Reaper.\nRETURNS:\nlast_render_paths:a table, which holds the last 20 used render-output-paths, used by any project in Reaper\n",
        "body": "ultraschall.GetLastRenderPaths()$0"
    },
    "ULTRASCHALL.ISREAPERRENDERING lua": {
        "prefix": "ultraschall.IsReaperRendering",
        "scope": "lua",
        "description": "Returns, if Reaper is currently rendering and the rendering position and projectlength of the rendered project\nRETURNS:\nretval:true, Reaper is rendering; false, Reaper does not render\nrender_position:the current rendering-position of the rendering project\nrender_projectlength:the length of the currently rendering project\nproj:the project currently rendering\nqueue_render:true, if a project from the queued-folder is currently being rendered; false, if not; a hint if queued-rendering is currently active\n",
        "body": "ultraschall.IsReaperRendering()$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_AIFF lua": {
        "prefix": "ultraschall.CreateRenderCFG_AIFF",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the AIFF-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nbits:the bitdepth of the aiff-file; 8, 16, 24 and 32 are supported\nEmbedBeatLength:Embed beat length if exact-checkbox; true, checked; false or nil, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected AIFF-settings\n",
        "body": "ultraschall.CreateRenderCFG_AIFF(${1:integer bits},${2:optional boolean EmbedBeatLength})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_AUDIOCD lua": {
        "prefix": "ultraschall.CreateRenderCFG_AudioCD",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the AudioCD-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nYou can also check, whether to burn the created cd-image after rendering.\nReturns nil in case of an error\nPARAMETERS:\ntrackmode:Track mode-dropdownlist: 1, Markers define new track; 2, Regions define tracks (other areas ignored); 3, One Track\nonly_markers_starting_with_hash:Only use markers starting with #-checkbox; true, checked; false, unchecked\nleadin_silence_tracks:Lead-in silence for tracks-inputbox, in milliseconds\nleadin_silence_disc:Extra lead-in silence for disc-inputbox, in milliseconds\nburncd_image_after_render:Burn CD image after render-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected AudioCD-image-settings\n",
        "body": "ultraschall.CreateRenderCFG_AudioCD(${1:integer trackmode},${2:boolean only_markers_starting_with_hash},${3:integer leadin_silence_tracks},${4:integer leadin_silence_disc},${5:boolean burncd_image_after_render})$0"
    },
    "ULTRASCHALL.GETRENDER_EMBEDSTRETCHMARKERS lua": {
        "prefix": "ultraschall.GetRender_EmbedStretchMarkers",
        "scope": "lua",
        "description": "Gets the current state of the \"Embed stretch markers/transient guides\"-checkbox from the Render to File-dialog.\n",
        "body": "ultraschall.GetRender_EmbedStretchMarkers()$0"
    },
    "ULTRASCHALL.SETRENDER_EMBEDSTRETCHMARKERS lua": {
        "prefix": "ultraschall.SetRender_EmbedStretchMarkers",
        "scope": "lua",
        "description": "Sets the new state of the \"Embed stretch markers/transient guides\"-checkbox from the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.SetRender_EmbedStretchMarkers(${1:boolean state})$0"
    },
    "ULTRASCHALL.RENDER_LOOP lua": {
        "prefix": "ultraschall.Render_Loop",
        "scope": "lua",
        "description": "Renders a part of a project using 2 passes. Good for rendering loops, including wetloops.\nThe first pass will be set by FirstStart and FirstStart. This is the one for possible fx-buildups(reverbs, etc).\nThe second pass will be set by SecondStart and SecondEnd. This is the one, which \"crops\" the first-pass to its correct length.\nYou can also influence the second pass by setting fadein and fadeout, including the fadein/fadeout-shape.\nThat way, you can control, how the beginning and the end of the loop-item sounds.\nSecondStart and SecondEnd are in relation of the original source project. SecondStart is from the beginning of the source-project, NOT FirstStart!\nreturns -1 in case of an error\nPARAMETERS:\nRenderTable:the RenderTable, which holds the render-settings for the second pass\nRenderFilename:the filename with path of the final rendered file\nAutoIncrement:true, autoincrement the filename(if it already exists); false, ask before rendering(if file already exists)\nFirstStart:the beginning of the first-pass-render in seconds\nFirstEnd:the end of the first-pass-render in seconds\nSecondStart:the beginning of the second-pass-render in seconds\nSecondEnd:the end of the second-pass-render in seconds\nFadeIn:the shape of the fade-in-curve; fadein shape, 0..6, 0=linear\nFadeOut:the shape of the fade-out-curve; fadeout shape, 0..6, 0=linear\nFadeInShape:the shape of the fade-in-curve; fadein shape, 0..6, 0=linear\nFadeOutShape:the shape of the fade-out-curve; fadeout shape, 0..6, 0=linear\nRETURNS:\ncount:the number of rendered files\nMediaItemStateChunkArray:all MediaItemStateChunks within an array\nFilearray:all rendered filenames including path\n",
        "body": "ultraschall.Render_Loop(${1:table RenderTable},${2:string RenderFilename},${3:boolean AutoIncrement},${4:number FirstStart},${5:number FirstEnd},${6:number SecondStart},${7:number SecondEnd},${8:number FadeIn},${9:number FadeOut},${10:integer FadeInShape},${11:integer FadeOutShape})$0"
    },
    "ULTRASCHALL.GETALLTHEMELAYOUTNAMES lua": {
        "prefix": "ultraschall.GetAllThemeLayoutNames",
        "scope": "lua",
        "description": "returns all layout-names and values of the current theme\nthe table ThemeLayoutNames is of the following format:\nThemeLayoutNames[parameter_index][\"layout section\"] - the name of the layout-section of the parameter\nThemeLayoutNames[parameter_index][\"value\"] - the value of the parameter\nThemeLayoutNames[parameter_index][\"description\"] - the description of the parameter\nreturns nil in case of an error\nRETURNS:\nindex:the number of theme-layout-parameters available\n",
        "body": "ultraschall.GetAllThemeLayoutNames()$0"
    },
    "ULTRASCHALL.GETALLTHEMELAYOUTPARAMETERS lua": {
        "prefix": "ultraschall.GetAllThemeLayoutParameters",
        "scope": "lua",
        "description": "returns all theme-layout-parameter attributes of the current theme\nthe table ThemeLayoutParameters is of the following format:\nThemeLayoutParameters[parameter_index][\"name\"] - the name of the parameter\nThemeLayoutParameters[parameter_index][\"description\"] - the description of the parameter\nThemeLayoutParameters[parameter_index][\"value\"] - the value of the parameter\nThemeLayoutParameters[parameter_index][\"value default\"] - the defult value of the parameter\nThemeLayoutParameters[parameter_index][\"value min\"] - the minimum value of the parameter\nThemeLayoutParameters[parameter_index][\"value max\"] - the maximum value of the parameter\nreturns nil in case of an error\nRETURNS:\nindex:the number of theme-layout-parameters available\nThemeLayoutParameters:a table with all theme-layout-parameter available in the current theme\n",
        "body": "ultraschall.GetAllThemeLayoutParameters()$0"
    },
    "ULTRASCHALL.ISVALIDTRACKSTRING lua": {
        "prefix": "ultraschall.IsValidTrackString",
        "scope": "lua",
        "description": "checks, whether a given trackstring is a valid one. Will also return all valid numbers, from trackstring, that can be used as tracknumbers, as an array.\nreturns false in case of an error\nPARAMETERS:\ntrackstring:the trackstring to check, if it's a valid one\nRETURNS:\nvalid:true, is a valid trackstring; false, is not a valid trackstring\ncount:the number of entries found in trackstring\nindividual_tracknumbers:an array that contains all available tracknumbers\n",
        "body": "ultraschall.IsValidTrackString(${1:string trackstring})$0"
    },
    "ULTRASCHALL.ISVALIDTRACKSTATECHUNK lua": {
        "prefix": "ultraschall.IsValidTrackStateChunk",
        "scope": "lua",
        "description": "returns, if a TrackStateChunk is a valid statechunk\nreturns false in case of an error\nPARAMETERS:\nTrackStateChunk:a string to check, if it's a valid TrackStateChunk\nRETURNS:\nvalid:true, if the string is a valid statechunk; false, if not a valid statechunk\n",
        "body": "ultraschall.IsValidTrackStateChunk(${1:string TrackStateChunk})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING lua": {
        "prefix": "ultraschall.CreateTrackString",
        "scope": "lua",
        "description": "returns a string with the all numbers from firstnumber to lastnumber, separated by a ,\ne.g. firstnumber=4, lastnumber=8 -> 4,5,6,7,8\nreturns nil in case of an error\nPARAMETERS:\nfirstnumber:the number, with which the string starts\nlastnumber:the number, with which the string ends\nstep:how many numbers shall be skipped inbetween. Can lead to a different lastnumber, when step is not 1! nil or invalid value=1\nRETURNS:\ntrackstring:a string with all tracknumbers, separated by a ,\n",
        "body": "ultraschall.CreateTrackString(${1:integer firstnumber},${2:integer lastnumber},${3:optional integer step})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_SELECTEDTRACKS lua": {
        "prefix": "ultraschall.CreateTrackString_SelectedTracks",
        "scope": "lua",
        "description": "Creates a string with all numbers from selected tracks, separated by a ,\nReturns an empty string, if no tracks are selected.\nRETURNS:\ntrackstring:a string with the tracknumbers, separated by a string\n",
        "body": "ultraschall.CreateTrackString_SelectedTracks()$0"
    },
    "ULTRASCHALL.INSERTTRACK_TRACKSTATECHUNK lua": {
        "prefix": "ultraschall.InsertTrack_TrackStateChunk",
        "scope": "lua",
        "description": "Creates a new track at the end of the project and sets it's trackstate, using the parameter trackstatechunk.\nReturns true, if it succeeded and the newly created MediaTrack.\nPARAMETERS:\ntrackstatechunk:the rpp-xml-Trackstate-Chunk, as created by reaper.GetTrackStateChunk or GetProject_TrackStateChunk\nRETURNS:\nretval:true, if creation succeeded, false if not\nMediaTrack:the newly created track, as MediaItem-trackobject\n",
        "body": "ultraschall.InsertTrack_TrackStateChunk(${1:string trackstatechunk})$0"
    },
    "ULTRASCHALL.REMOVEDUPLICATETRACKSINTRACKSTRING lua": {
        "prefix": "ultraschall.RemoveDuplicateTracksInTrackstring",
        "scope": "lua",
        "description": "Sorts tracknumbers in trackstring and throws out duplicates. It also throws out entries, that are no numbers.\nReturns the \"cleared\" trackstring as string and as array, as well as the number of entries.\nReturns -1 in case of failure.\nPARAMETERS:\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:-1 in case of error, 1 in case of success\ntrackstring:the \"cleared\" trackstring as an array\ntrackstringarray:the \"cleared\" trackstring as an array\nnumber_of_entries:the number of entries in the trackstring\n",
        "body": "ultraschall.RemoveDuplicateTracksInTrackstring(${1:string trackstring})$0"
    },
    "ULTRASCHALL.ISTRACKOBJECTTRACKNUMBER lua": {
        "prefix": "ultraschall.IsTrackObjectTracknumber",
        "scope": "lua",
        "description": "returns true, if MediaTrack has the tracknumber \"tracknumber\"; false if not.\nReturns nil in case of error.\nPARAMETERS:\ntrack:the tracknumber you want to check for\ntracknumber:the tracknumber you want to check for\nRETURNS:\nretval:true if track is tracknumber, false if not\ntracknumber:the number of track, so in case of false, you know it's number\n",
        "body": "ultraschall.IsTrackObjectTracknumber(${1:MediaTrack track},${2:integer tracknumber})$0"
    },
    "ULTRASCHALL.INVERSETRACKSTRING lua": {
        "prefix": "ultraschall.InverseTrackstring",
        "scope": "lua",
        "description": "returns a newtrackstring with numbers, that are NOT in trackstring, in the range between 0 and limit\nreturns -1 in case of error\nPARAMETERS:\ntrackstring:the tracknumbers, separated with a ,\nlimit:the maximum tracknumber to include. Use reaper.CountTracks(0) function to use the maximum tracks in current project\nRETURNS:\ninv_trackstring:the tracknumbers, that are NOT in the parameter trackstring, from 0 to limit\n",
        "body": "ultraschall.InverseTrackstring(${1:string trackstring},${2:integer limit})$0"
    },
    "ULTRASCHALL.COUNTITEMSINTRACKSTATECHUNK lua": {
        "prefix": "ultraschall.CountItemsInTrackStateChunk",
        "scope": "lua",
        "description": "returns the number of items in a trackstatechunk\nreturns -1 in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nRETURNS:\ncountitems:number of items in the trackstatechunk\n",
        "body": "ultraschall.CountItemsInTrackStateChunk(${1:string trackstatechunk})$0"
    },
    "ULTRASCHALL.GETITEMSTATECHUNKFROMTRACKSTATECHUNK lua": {
        "prefix": "ultraschall.GetItemStateChunkFromTrackStateChunk",
        "scope": "lua",
        "description": "Returns a mediaitemstatechunk of the idx'th item in trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nidx:the number of the item you want to have returned as mediaitemstatechunk\nRETURNS:\nretval:true in case of success, false in case of error\nmediaitemstatechunk:number of items in the trackstatechunk\n",
        "body": "ultraschall.GetItemStateChunkFromTrackStateChunk(${1:string trackstatechunk},${2:integer idx})$0"
    },
    "ULTRASCHALL.ADDMEDIAITEMSTATECHUNK_TO_TRACKSTATECHUNK lua": {
        "prefix": "ultraschall.AddMediaItemStateChunk_To_TrackStateChunk",
        "scope": "lua",
        "description": "Adds the item mediaitemstatechunk into trackstatechunk and returns this altered trackstatechunk.\nreturns nil in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nmediaitemstatechunk:a mediaitemstatechunk, as returned by reaper's api function reaper.GetItemStateChunk\nRETURNS:\ntrackstatechunk:the new trackstatechunk with mediaitemstatechunk added\n",
        "body": "ultraschall.AddMediaItemStateChunk_To_TrackStateChunk(${1:string trackstatechunk},${2:string mediaitemstatechunk})$0"
    },
    "ULTRASCHALL.REMOVEMEDIAITEM_TRACKSTATECHUNK lua": {
        "prefix": "ultraschall.RemoveMediaItem_TrackStateChunk",
        "scope": "lua",
        "description": "Deletes the idx'th item from trackstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nidx:the number of the item you want to delete\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the idx'th item deleted\n",
        "body": "ultraschall.RemoveMediaItem_TrackStateChunk(${1:string trackstatechunk},${2:integer idx})$0"
    },
    "ULTRASCHALL.REMOVEMEDIAITEMBYIGUID_TRACKSTATECHUNK lua": {
        "prefix": "ultraschall.RemoveMediaItemByIGUID_TrackStateChunk",
        "scope": "lua",
        "description": "Deletes the item with the iguid IGUID from trackstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nIGUID:the IGUID of the item you want to delete\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the IGUID-item deleted\n",
        "body": "ultraschall.RemoveMediaItemByIGUID_TrackStateChunk(${1:string trackstatechunk},${2:string IGUID})$0"
    },
    "ULTRASCHALL.REMOVEMEDIAITEMBYGUID_TRACKSTATECHUNK lua": {
        "prefix": "ultraschall.RemoveMediaItemByGUID_TrackStateChunk",
        "scope": "lua",
        "description": "Deletes the item with the guid GUID from trackstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nGUID:the GUID of the item you want to delete\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the GUID-item deleted\n",
        "body": "ultraschall.RemoveMediaItemByGUID_TrackStateChunk(${1:string trackstatechunk},${2:string GUID})$0"
    },
    "ULTRASCHALL.ONLYTRACKSINBOTHTRACKSTRINGS lua": {
        "prefix": "ultraschall.OnlyTracksInBothTrackstrings",
        "scope": "lua",
        "description": "returns a new trackstring, that contains only the tracknumbers, that are in trackstring1 and trackstring2.\nreturns -1 in case of error\nPARAMETERS:\ntrackstring1:a string with the tracknumbers, separated by commas\ntrackstring2:a string with the tracknumbers, separated by commas\nRETURNS:\nretval:-1 in case of error, 1 in case of success\ntrackstring:the \"cleared\" trackstring as an array\ntrackstringarray:the \"cleared\" trackstring as an array\nnumber_of_entries:the number of entries in the trackstring\n",
        "body": "ultraschall.OnlyTracksInBothTrackstrings(${1:string trackstring1},${2:string trackstring2})$0"
    },
    "ULTRASCHALL.ONLYTRACKSINONETRACKSTRING lua": {
        "prefix": "ultraschall.OnlyTracksInOneTrackstring",
        "scope": "lua",
        "description": "returns a new trackstring, that contains only the tracknumbers, that are in either trackstring1 or trackstring2, NOT in both!\nreturns -1 in case of error\nPARAMETERS:\ntrackstring1:a string with the tracknumbers, separated by commas\ntrackstring2:a string with the tracknumbers, separated by commas\nRETURNS:\nretval:-1 in case of error, 1 in case of success\ntrackstring:the \"cleared\" trackstring as an array\ntrackstringarray:the \"cleared\" trackstring as an array\nnumber_of_entries:the number of entries in the trackstring\n",
        "body": "ultraschall.OnlyTracksInOneTrackstring(${1:string trackstring1},${2:string trackstring2})$0"
    },
    "ULTRASCHALL.SETMEDIAITEMSTATECHUNK_IN_TRACKSTATECHUNK lua": {
        "prefix": "ultraschall.SetMediaItemStateChunk_in_TrackStateChunk",
        "scope": "lua",
        "description": "Overwrites the idx'th item from trackstatechunk with mediaitemstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nidx:the number of the item you want to delete\nmediaitemstatechunk:a mediaitemstatechunk, as returned by reaper's api function reaper.GetItemStateChunk\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the idx'th item replaced\n",
        "body": "ultraschall.SetMediaItemStateChunk_in_TrackStateChunk(${1:string trackstatechunk},${2:integer idx},${3:string mediaitemstatechunk})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSFROMTRACKSTATECHUNK lua": {
        "prefix": "ultraschall.GetAllMediaItemsFromTrackStateChunk",
        "scope": "lua",
        "description": "Returns a MediaItemStateChunkArray with all items in trackstatechunk.\nreturns -1 in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by functions like reaper.GetTrackStateChunk\nRETURNS:\ncount:number of MediaItemStateChunks in the returned array. -1 in case of error\nMediaItemStateChunkArray:an array with all MediaItemStateChunks from trackstatechunk\n",
        "body": "ultraschall.GetAllMediaItemsFromTrackStateChunk(${1:string trackstatechunk})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_ALLTRACKS lua": {
        "prefix": "ultraschall.CreateTrackString_AllTracks",
        "scope": "lua",
        "description": "Returns a trackstring with all tracknumbers from the current project.\nReturns an empty string, if no track is available.\nRETURNS:\ntrackstring:a string with all tracknumbers, separated by commas.\n",
        "body": "ultraschall.CreateTrackString_AllTracks()$0"
    },
    "ULTRASCHALL.GETTRACKLENGTH lua": {
        "prefix": "ultraschall.GetTrackLength",
        "scope": "lua",
        "description": "Returns the length of a track, that means, the end of the last item in track Tracknumber.\nWill return -1, in case of error\nPARAMETERS:\nTracknumber:the tracknumber, whose length you want to know\nRETURNS:\nlength:the length of the track in seconds\n",
        "body": "ultraschall.GetTrackLength(${1:integer Tracknumber})$0"
    },
    "ULTRASCHALL.GETLENGTHOFALLMEDIAITEMS_TRACK lua": {
        "prefix": "ultraschall.GetLengthOfAllMediaItems_Track",
        "scope": "lua",
        "description": "Returns the length of all MediaItems in track, combined.\nWill return -1, in case of error\nPARAMETERS:\nTracknumber:the tracknumber, whose length you want to know; 1, track 1; 2, track 2, etc\nRETURNS:\nlength:the length of all MediaItems in the track combined, in seconds\n",
        "body": "ultraschall.GetLengthOfAllMediaItems_Track(${1:integer Tracknumber})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOTRACK lua": {
        "prefix": "ultraschall.ApplyActionToTrack",
        "scope": "lua",
        "description": "Applies action to the tracks, given by trackstring\nThe action given must support applying itself to selected tracks.\nReturns false in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers, separated by a comma; 1 for the first track, 2 for the second\nRETURNS:\nretval:true, running action was successful; false, running the action was unsuccessful\n",
        "body": "ultraschall.ApplyActionToTrack(${1:string trackstring},${2:string/number actioncommandid})$0"
    },
    "ULTRASCHALL.INSERTTRACKATINDEX lua": {
        "prefix": "ultraschall.InsertTrackAtIndex",
        "scope": "lua",
        "description": "Inserts one or more tracks at index.\nReturns nil in case of an error\nPARAMETERS:\nindex:the index, at which to include the new tracks; 0, for including before the first track\nnumber_of_tracks:the number of tracks that you want to create; 0 for including before track 1; number of tracks+1, include new tracks after last track\nwantdefaults:true, set the tracks with default settings/fx/etc; false, create new track without any defaults\nRETURNS:\ntrackarray:an array with the MediaTrack-objects of all newly created tracks\nnew_track_count:the number of newly created tracks\ntrackarray_newtracks:an array with the MediaTrack-objects of all newly created tracks\n",
        "body": "ultraschall.InsertTrackAtIndex(${1:integer index},${2:integer number_of_tracks},${3:boolean wantdefaults})$0"
    },
    "ULTRASCHALL.MOVETRACKS lua": {
        "prefix": "ultraschall.MoveTracks",
        "scope": "lua",
        "description": "Moves tracks in trackstring to position targetindex. You can also set, if the tracks shall become folders.\nMultiple tracks in trackstring will be put together, so track 2, 4, 6 would become 1, 2, 3, when moved above the first track!\nReturns false in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers of the tracks you want to move, separated by commas\ntargetindex:the index, to which to move the tracks; 0, move tracks before track 1; number of tracks+1, move after the last track\nmakepreviousfolder:make tracks a folder or not\nRETURNS:\nretval:true, moving was successful; false, moving wasn't successful\n",
        "body": "ultraschall.MoveTracks(${1:string trackstring},${2:integer targetindex},${3:integer makepreviousfolder})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_ARMEDTRACKS lua": {
        "prefix": "ultraschall.CreateTrackString_ArmedTracks",
        "scope": "lua",
        "description": "Gets a trackstring with tracknumbers of all armed tracks in it.\nReturns \"\" if no track is armed.\nRETURNS:\ntrackstring:a trackstring with the tracknumbers of all armed tracks as comma separated csv-string, eg: \"1,3,4,7\"\n",
        "body": "ultraschall.CreateTrackString_ArmedTracks()$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_UNARMEDTRACKS lua": {
        "prefix": "ultraschall.CreateTrackString_UnarmedTracks",
        "scope": "lua",
        "description": "Gets a trackstring with tracknumbers of all unarmed tracks in it.\nReturns \"\" if all tracks are armed.\nRETURNS:\ntrackstring:a trackstring with the tracknumbers of all unarmed tracks as comma separated csv-string, eg: \"1,3,4,7\"\n",
        "body": "ultraschall.CreateTrackString_UnarmedTracks()$0"
    },
    "ULTRASCHALL.CREATETRACKSTRINGBYGUID lua": {
        "prefix": "ultraschall.CreateTrackStringByGUID",
        "scope": "lua",
        "description": "returns a trackstring with all tracks, as given by the GUIDs in the comma-separated-csv-string guid_csv_string.\nreturns \"\" in case of an error, like no track available or an invalid string\nPARAMETERS:\nguid_csv_string:a comma-separated csv-string, that includes all GUIDs of all track to be included in the trackstring.\nRETURNS:\ntrackstring:a string with all the tracknumbers of the tracks given as GUIDs in guid_csv_string\n",
        "body": "ultraschall.CreateTrackStringByGUID(${1:string guid_csv_string})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRINGBYTRACKNAMES lua": {
        "prefix": "ultraschall.CreateTrackStringByTracknames",
        "scope": "lua",
        "description": "returns a trackstring with all tracks, as given by the tracknames in the newline(!)-separated-csv-string guid_csv_string.\nreturns \"\" in case of an error, like no track available or an invalid string\nPARAMETERS:\ntracknames_csv_string:a newline(!)-separated csv-string, that includes all tracknames of all track to be included in the trackstring. Tracknames are case sensitive!\nRETURNS:\ntrackstring:a string with all the tracknumbers of the tracks given as tracknames in tracknames_csv_string\n",
        "body": "ultraschall.CreateTrackStringByTracknames(${1:string tracknames_csv_string})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRINGBYMEDIATRACKS lua": {
        "prefix": "ultraschall.CreateTrackStringByMediaTracks",
        "scope": "lua",
        "description": "returns a trackstring with all tracks, as given in the array MediaTrackArray\nreturns \"\" in case of an error, like no track available or an invalid string\nPARAMETERS:\nMediaTrackArray:an array, that includes all MediaTrack-objects to be included in the trackstring; a nil-entry is seen as the end of the array\nRETURNS:\ntrackstring:a string with all the tracknumbers of the MediaTrack-objects given in parameter MediaTrackArray\n",
        "body": "ultraschall.CreateTrackStringByMediaTracks(${1:array MediaTrackArray})$0"
    },
    "ULTRASCHALL.GETTRACKNUMBERBYGUID lua": {
        "prefix": "ultraschall.GetTracknumberByGuid",
        "scope": "lua",
        "description": "returns the tracknumber and track of a guid. The track must be in the currently active project!\nSupports the returned guids by reaper.BR_GetMediaTrackGUID and reaper.GetTrackGUID.\nreturns -1 in case of an error\nRETURNS:\ntracknumber:the number of the track; 0, for master track; 1, for track 1; 2, for track 2, etc. -1, in case of an error\ntr:the MediaTrack-object of the requested track; nil, if no track is found\n",
        "body": "ultraschall.GetTracknumberByGuid(${1:string guid})$0"
    },
    "ULTRASCHALL.DELETETRACKS_TRACKSTRING lua": {
        "prefix": "ultraschall.DeleteTracks_TrackString",
        "scope": "lua",
        "description": "deletes all tracks in trackstring\nReturns false in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers, separated by commas\nRETURNS:\nretval:true, setting it was successful; false, setting it was unsuccessful\n",
        "body": "ultraschall.DeleteTracks_TrackString(${1:string trackstring})$0"
    },
    "ULTRASCHALL.ANYTRACKMUTE lua": {
        "prefix": "ultraschall.AnyTrackMute",
        "scope": "lua",
        "description": "returns true, if any track is muted, otherwise returns false.\nPARAMETERS:\nmaster:true, include the master-track as well; false, don't include master-track\nRETURNS:\nretval:true, if any track is muted; false, if not\n",
        "body": "ultraschall.AnyTrackMute(${1:optional boolean master})$0"
    },
    "ULTRASCHALL.ANYTRACKRECARMED lua": {
        "prefix": "ultraschall.AnyTrackRecarmed",
        "scope": "lua",
        "description": "Returns true, if any track is recarmed.\nRETURNS:\nretval:true, at least one track is recarmed; false, no track is recarmed\n",
        "body": "ultraschall.AnyTrackRecarmed()$0"
    },
    "ULTRASCHALL.ANYTRACKPHASED lua": {
        "prefix": "ultraschall.AnyTrackPhased",
        "scope": "lua",
        "description": "Returns true, if any track has phase-invert activated.\nRETURNS:\nretval:true, at least one track has an activated phase-invert; false, no track is phase-inverted\n",
        "body": "ultraschall.AnyTrackPhased()$0"
    },
    "ULTRASCHALL.ANYTRACKRECMONITORED lua": {
        "prefix": "ultraschall.AnyTrackRecMonitored",
        "scope": "lua",
        "description": "Returns true, if any track has monitoring of recinput activated.\nRETURNS:\nretval:true, at least one track has an activated rec-monitoring; false, no track is rec-monitored\n",
        "body": "ultraschall.AnyTrackRecMonitored()$0"
    },
    "ULTRASCHALL.ANYTRACKHIDDENTCP lua": {
        "prefix": "ultraschall.AnyTrackHiddenTCP",
        "scope": "lua",
        "description": "Returns true, if any track is hidden in Track Control Panel.\nPARAMETERS:\nmaster:true, include the master-track; false, don't include the master-track\nRETURNS:\nretval:true, at least one track is hidden in TCP; false, no track is hidden\n",
        "body": "ultraschall.AnyTrackHiddenTCP(${1:optional boolean master})$0"
    },
    "ULTRASCHALL.ANYTRACKHIDDENMCP lua": {
        "prefix": "ultraschall.AnyTrackHiddenMCP",
        "scope": "lua",
        "description": "Returns true, if any track is hidden in Mixer Control Panel.\nPARAMETERS:\nmaster:true, include the master-track; false, don't include the master-track\nRETURNS:\nretval:true, at least one track is hidden in MCP; false, no track is hidden\n",
        "body": "ultraschall.AnyTrackHiddenMCP(${1:optional boolean master})$0"
    },
    "ULTRASCHALL.ANYTRACKFREEITEMPOSITIONINGMODE lua": {
        "prefix": "ultraschall.AnyTrackFreeItemPositioningMode",
        "scope": "lua",
        "description": "Returns true, if any track has free item positioning mode(freemode) activated.\nRETURNS:\nretval:true, at least one track has freemode activated; false, no track has freemode-activated\n",
        "body": "ultraschall.AnyTrackFreeItemPositioningMode()$0"
    },
    "ULTRASCHALL.ANYTRACKFXBYPASS lua": {
        "prefix": "ultraschall.AnyTrackFXBypass",
        "scope": "lua",
        "description": "Returns true, if any track has fx-bypass activated.\nPARAMETERS:\nmaster:true, include the master-track; false, don't include the master-track\nRETURNS:\nretval:true, at least one track has fx bypass activated; false, no track has fx-bypass activated\n",
        "body": "ultraschall.AnyTrackFXBypass(${1:optional boolean master})$0"
    },
    "ULTRASCHALL.SETTRACK_LASTTOUCHED lua": {
        "prefix": "ultraschall.SetTrack_LastTouched",
        "scope": "lua",
        "description": "Sets a track to be last touched track.\nreturns false in case of an error\nPARAMETERS:\ntrack:the track, which you want to set as last touched track\nRETURNS:\nretval:true, setting was successful; false, setting was not successful\n",
        "body": "ultraschall.SetTrack_LastTouched(${1:integer track})$0"
    },
    "ULTRASCHALL.GETTRACKBYTRACKNAME lua": {
        "prefix": "ultraschall.GetTrackByTrackName",
        "scope": "lua",
        "description": "returns all tracks with a certain name.\nYou can set case-sensitivity, whether pattern-matchin is possible and whether the name shall be used strictly.\nFor instance, if you want to look for a track named exactly \"JaM.-Enlightened\" you set case_sensitive=false and escaped_strict=2. That way, tracks names \"JaM.*Enlightened\" will be ignored.\nreturns -1 in case of an error\nPARAMETERS:\ntrackname:the trackname to look for\ncase_sensitive:true, take care of case-sensitivity; false, don't take case-sensitivity into account\nescaped_strict:0, use trackname as matching-pattern, will find all tracknames following the pattern(Ja.-m -> Jam, Jam123Police, JaABBAm)\nRETURNS:\nnumber_of_found_tracks:the number of found tracks\nfound_tracks:the found tracks as table\nfound_tracknames:the found tracknames\n",
        "body": "ultraschall.GetTrackByTrackName(${1:string trackname},${2:boolean case_sensitive},${3:integer escaped_strict})$0"
    },
    "ULTRASCHALL.COLLAPSETRACKHEIGHT lua": {
        "prefix": "ultraschall.CollapseTrackHeight",
        "scope": "lua",
        "description": "Collapses the height of a track to the minimum height as set by the theme\nreturns false in case of an error\nPARAMETERS:\ntrack:the track, which you want to collapse in height\nRETURNS:\nretval:true, collapsing was successful; false, collapsing was not successful\n",
        "body": "ultraschall.CollapseTrackHeight(${1:integer track})$0"
    },
    "ULTRASCHALL.SETTRACK_TRACKHEIGHT_FORCE lua": {
        "prefix": "ultraschall.SetTrack_Trackheight_Force",
        "scope": "lua",
        "description": "Sets the trackheight of a track. Forces trackheight beyond limits set by the theme.\nreturns false in case of an error\nPARAMETERS:\ntrack:the trackheight in pixels, 0 and higher\nRETURNS:\nretval:true, collapsing was successful; false, collapsing was not successful\n",
        "body": "ultraschall.SetTrack_Trackheight_Force(${1:integer track},${2:integer trackheight})$0"
    },
    "ULTRASCHALL.GETTRACKHWOUT lua": {
        "prefix": "ultraschall.GetTrackHWOut",
        "scope": "lua",
        "description": "Returns the settings of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, which you can choose with idx.\nIt's the entry HWOUT\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOut you want, 0 for Master Track\nidx:the id-number of the HWOut, beginning with 1 for the first HWOut-Settings\nTrackStateChunk:a TrackStateChunk, whose HWOUT-entries you want to get\nRETURNS:\noutputchannel:outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels\npost_pre_fader:0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination \"Controls for Track\"-dialogue\nvolume:volume, as set in the Destination \"Controls for Track\"-dialogue; see MKVOL2DB to convert it into a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:mute, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nphase:Phase, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nsource:source, as set in the Destination \"Controls for Track\"-dialogue\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nautomationmode:automation mode, as set in the Destination \"Controls for Track\"-dialogue\n",
        "body": "ultraschall.GetTrackHWOut(${1:integer tracknumber},${2:integer idx},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKAUXSENDRECEIVES lua": {
        "prefix": "ultraschall.GetTrackAUXSendReceives",
        "scope": "lua",
        "description": "Returns the settings of the Send/Receive, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, which you can choose with idx.\nRemember, if you want to get the sends of a track, you need to check the recv_tracknumber-returnvalues of the OTHER(!) tracks, as you can only get the receives. With the receives checked, you know, which track sends.\nIt's the entry AUXRECV\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose Send/Receive you want\nidx:the id-number of the Send/Receive, beginning with 1 for the first Send/Receive-Settings\nTrackStateChunk:a TrackStateChunk, whose AUXRECV-entries you want to get\nRETURNS:\nrecv_tracknumber:Tracknumber, from where to receive the audio from\npost_pre_fader:0-PostFader, 1-PreFX, 3-Pre-Fader\nvolume:Volume; see MKVOL2DB to convert it into a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:Mute this send(1) or not(0)\nmono_stereo:Mono(1), Stereo(0)\nphase:Phase of this send on(1) or off(0)\nchan_src:Audio-Channel Source\nsnd_chan:send to channel\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmidichanflag:All Midi Tracks\nautomation:Automation Mode\n",
        "body": "ultraschall.GetTrackAUXSendReceives(${1:integer tracknumber},${2:integer idx},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.COUNTTRACKHWOUTS lua": {
        "prefix": "ultraschall.CountTrackHWOuts",
        "scope": "lua",
        "description": "Counts and returns the number of existing HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber.\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOUTs you want to count. 0 for Master Track; -1, to use optional parameter TrackStateChunk instead\nTrackStateChunk:the TrackStateChunk, whose hwouts you want to count; only when tracknumber=-1\nRETURNS:\ncount_HWOuts:the number of HWOuts in tracknumber\n",
        "body": "ultraschall.CountTrackHWOuts(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.COUNTTRACKAUXSENDRECEIVES lua": {
        "prefix": "ultraschall.CountTrackAUXSendReceives",
        "scope": "lua",
        "description": "Counts and returns the number of existing Send/Receives/Routing-settings, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber.\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose Send/Receive you want; -1, if you want to pass a TrackStateChunk instead\nTrackStateChunk:the TrackStateChunk, whose hwouts you want to count; only when tracknumber=-1\nRETURNS:\ncount_SendReceives:the number of Send/Receives-Settings in tracknumber\n",
        "body": "ultraschall.CountTrackAUXSendReceives(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.ADDTRACKHWOUT lua": {
        "prefix": "ultraschall.AddTrackHWOut",
        "scope": "lua",
        "description": "Adds a setting of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber.\nThis function does not check the parameters for plausability, so check your settings twice!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOut you want. 0 for Master Track; -1, use parameter TrackStateChunk instead\noutputchannel:outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels\npost_pre_fader:0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination \"Controls for Track\"-dialogue\nvolume:volume, as set in the Destination \"Controls for Track\"-dialogue; see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:mute, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nphase:Phase, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nsource:source, as set in the Destination \"Controls for Track\"-dialogue\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nautomationmode:automation mode, as set in the Destination \"Controls for Track\"-dialogue\nTrackStateChunk:a TrackStateChunk into which to add the hwout-setting; only available, when tracknumber=-1\nRETURNS:\nretval:true, if it worked; false if it didn't\nTrackStateChunk:an altered TrackStateChunk into which you added the new hwout-setting\n",
        "body": "ultraschall.AddTrackHWOut(${1:integer tracknumber},${2:integer outputchannel},${3:integer post_pre_fader},${4:number volume},${5:number pan},${6:integer mute},${7:integer phase},${8:integer source},${9:number pan_law},${10:integer automationmode},${11:optional parameter TrackStateChunk})$0"
    },
    "ULTRASCHALL.ADDTRACKAUXSENDRECEIVES lua": {
        "prefix": "ultraschall.AddTrackAUXSendReceives",
        "scope": "lua",
        "description": "Adds a setting of Send/Receive, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one.\nRemember, if you want to set the sends of a track, you need to add it to the track, that shall receive, not the track that sends! Set recv_tracknumber in the track that receives with the tracknumber that sends, and you've set it successfully.\nDue to the complexity of send/receive-settings, this function does not check, whether the parameters are plausible. So check twice, whether the added sends/receives appear, as they might not appear!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:Tracknumber, from where to receive the audio from\nrecv_tracknumber:Tracknumber, from where to receive the audio from\npost_pre_fader:0-PostFader, 1-PreFX, 3-Pre-Fader\nvolume:Volume, see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:Mute this send(1) or not(0)\nmono_stereo:Mono(1), Stereo(0)\nphase:Phase of this send on(1) or off(0)\nchan_src:Audio-Channel Source\nsnd_chan:send to channel\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmidichanflag:All Midi Tracks\nautomation:Automation Mode\nTrackStateChunk:the TrackStateChunk, to which you want to add a new receive-routing\nRETURNS:\nretval:true if it worked, false if it didn't.\nTrackStateChunk:an altered TrackStateChunk into which you added a new receive/routing; only available, when tracknumber=-1\n",
        "body": "ultraschall.AddTrackAUXSendReceives(${1:integer tracknumber},${2:integer recv_tracknumber},${3:integer post_pre_fader},${4:number volume},${5:number pan},${6:integer mute},${7:integer mono_stereo},${8:integer phase},${9:integer chan_src},${10:integer snd_chan},${11:number pan_law},${12:integer midichanflag},${13:integer automation},${14:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.DELETETRACKHWOUT lua": {
        "prefix": "ultraschall.DeleteTrackHWOut",
        "scope": "lua",
        "description": "Deletes the idxth HWOut-Setting of tracknumber.\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOUTs you want to delete. 0 for Master Track. -1, if you want to use the parameter TrackStateChunk instead\nidx:the number of the HWOut-setting, that you want to delete; -1, to delete all HWOuts from this track\nTrackStateChunk:the TrackStateChunk, from which you want to delete HWOut-entries\nRETURNS:\nretval:true if it worked, false if it didn't.\nTrackStateChunk:the altered TrackStateChunk, from which you deleted HWOut-entries; only available, when tracknumber=-1\n",
        "body": "ultraschall.DeleteTrackHWOut(${1:integer tracknumber},${2:integer idx},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.DELETETRACKAUXSENDRECEIVES lua": {
        "prefix": "ultraschall.DeleteTrackAUXSendReceives",
        "scope": "lua",
        "description": "Deletes the idxth Send/Receive-Setting of tracknumber.\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose Send/Receive you want; -1, if you want to use the parameter TrackStateChunk\nidx:the number of the send/receive-setting, that you want to delete; -1, deletes all AuxReceives on this track\nTrackStateChunk:a TrackStateChunk, from which you want to delete Send/Receive-entries; only available, when tracknumber=-1\nRETURNS:\nretval:true if it worked, false if it didn't.\n",
        "body": "ultraschall.DeleteTrackAUXSendReceives(${1:integer tracknumber},${2:integer idx},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKHWOUT lua": {
        "prefix": "ultraschall.SetTrackHWOut",
        "scope": "lua",
        "description": "Sets a setting of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, so choose the one you want to change with idx.\nTo retain old-settings, use nil with the accompanying parameters.\nThis function does not check the parameters for plausability, so check your settings twice, or the HWOut-setting might disappear with faulty parameters!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOut you want. 0 for Master Track\nidx:the number of the HWOut-setting, you want to change\noutputchannel:outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels\npost_pre_fader:0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination \"Controls for Track\"-dialogue\nvolume:volume, as set in the Destination \"Controls for Track\"-dialogue; see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:mute, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nphase:Phase, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nsource:source, as set in the Destination \"Controls for Track\"-dialogue\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nautomationmode:automation mode, as set in the Destination \"Controls for Track\"-dialogue\nTrackStateChunk:sets an HWOUT-entry in a TrackStateChunk\nRETURNS:\nretval:true, if it worked; false if it didn't\nTrackStateChunk:an altered TrackStateChunk, in which you've set a send/receive-setting; only available when track=-1\n",
        "body": "ultraschall.SetTrackHWOut(${1:integer tracknumber},${2:integer idx},${3:integer outputchannel},${4:integer post_pre_fader},${5:number volume},${6:number pan},${7:integer mute},${8:integer phase},${9:integer source},${10:number pan_law},${11:integer automationmode},${12:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKAUXSENDRECEIVES lua": {
        "prefix": "ultraschall.SetTrackAUXSendReceives",
        "scope": "lua",
        "description": "Alters a setting of Send/Receive, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, so choose the right one with idx.\nYou can keep the old-setting by using nil as a parametervalue.\nRemember, if you want to set the sends of a track, you need to add it to the track, that shall receive, not the track that sends! Set recv_tracknumber in the track that receives with the tracknumber that sends, and you've set it successfully.\nDue to the complexity of send/receive-settings, this function does not check, whether the parameters are plausible. So check twice, whether the change sends/receives still appear, as they might disappear with faulty settings!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:Tracknumber, from where to receive the audio from\nidx:the send/receive-setting, you want to set\nrecv_tracknumber:Tracknumber, from where to receive the audio from\npost_pre_fader:0-PostFader, 1-PreFX, 3-Pre-Fader\nvolume:Volume; see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:Mute this send(1) or not(0)\nmono_stereo:Mono(1), Stereo(0)\nphase:Phase of this send on(1) or off(0)\nchan_src:Audio-Channel Source\nsnd_chan:send to channel\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmidichanflag:All Midi Tracks\nautomation:Automation Mode\nTrackStateChunk:a TrackStateChunk, whose AUXRECV-entries you want to set\nRETURNS:\nretval:true if it worked, false if it didn't.\nTrackStateChunk:an altered TrackStateChunk, whose AUXRECV-entries you've altered\n",
        "body": "ultraschall.SetTrackAUXSendReceives(${1:integer tracknumber},${2:integer idx},${3:integer recv_tracknumber},${4:integer post_pre_fader},${5:number volume},${6:number pan},${7:integer mute},${8:integer mono_stereo},${9:integer phase},${10:integer chan_src},${11:integer snd_chan},${12:number pan_law},${13:integer midichanflag},${14:integer automation},${15:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.CLEARROUTINGMATRIX lua": {
        "prefix": "ultraschall.ClearRoutingMatrix",
        "scope": "lua",
        "description": "Clears all routing-matrix-settings or optionally part of them\nreturns false in case of an error\nPARAMETERS:\nClearHWOuts:nil or true, clear all HWOuts; false, keep the HWOuts intact\nClearAuxRecvs:nil or true, clear all Send/Receive-settings; false, keep the Send/Receive-settings intact\nClearTrackMasterSends:nil or true, clear all send to master-checkboxes; false, keep them intact\nClearMasterTrack:nil or true, include the Mastertrack as well; false, don't include it\nundo:true, set undo point; false or nil, don't set undo point\nRETURNS:\nretval:true, clearing was successful; false, clearing was unsuccessful\n",
        "body": "ultraschall.ClearRoutingMatrix(${1:boolean ClearHWOuts},${2:boolean ClearAuxRecvs},${3:boolean ClearTrackMasterSends},${4:boolean ClearMasterTrack},${5:boolean undo})$0"
    },
    "ULTRASCHALL.APPLYALLHWOUTS lua": {
        "prefix": "ultraschall.ApplyAllHWOuts",
        "scope": "lua",
        "description": "Takes a table, as returned by GetAllHWOuts with all HWOut-settings of all tracks and applies it to all tracks.\nWhen you set option to 2, the individual entries will be applied to the tracks, that have the guids stored in table\ntable[tracknumber][\"TrackID\"], otherwise, this function will apply it to track0 to trackn, which is the same as table[\"number\\_of_tracks\"].\nThat way, you can create RoutingSnapshots, that will stay in the right tracks, even if they are ordered differently or when tracks have been added/deleted.\nThis influences the MasterTrack as well!\nexpected table is of structure:\ntable[\"HWOuts\"]=true                              - signals, this is a HWOuts-table; don't change that!\ntable[\"number\\_of_tracks\"]                         - the number of tracks in this table, from track 0(master) to track n\ntable[tracknumber][\"HWOut_count\"]                 - the number of HWOuts of tracknumber, beginning with 1\ntable[tracknumber][\"TrackID\"]                     - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\ntable[tracknumber][HWOutIndex][\"outputchannel\"]   - the number of outputchannels of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"post\\_pre_fader\"] - the setting of post-pre-fader of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"volume\"]          - the volume of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\"]             - the panning of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"mute\"]            - the mute-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"phase\"]           - the phase-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"source\"]          - the source/input of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\\_law\"]         - pan-law, default is -1\ntable[tracknumber][HWOutIndex][\"automationmode\"]  - the automation-mode of this HWOutIndex of tracknumber\nSee GetTrackHWOut for more details on the individual settings, stored in the entries.\nreturns false in case of an error\nPARAMETERS:\nAllHWOuts:a table with all AllHWOut-entries of the current project\noption:nil or 1, HWOuts will be applied to Track 0(MasterTrack) to table[\"number_of_tracks\"]; 2, HWOuts will be applied to the tracks with the guid TrackID\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.ApplyAllHWOuts(${1:table AllHWOuts},${2:optional integer option})$0"
    },
    "ULTRASCHALL.APPLYALLAUXSENDRECEIVES lua": {
        "prefix": "ultraschall.ApplyAllAUXSendReceives",
        "scope": "lua",
        "description": "takes a table, as returned by GetAllAUXSendReceive with all AUXSendReceive-settings of all tracks and applies it to all tracks.\nWhen you set option to 2, the individual entries will be applied to the tracks, that have the guids stored in table\ntable[tracknumber][\"TrackID\"], otherwise, this function will apply it to track1 to trackn, which is the same as table[\"number\\_of_tracks\"].\nThat way, you can create RoutingSnapshots, that will stay in the right tracks, even if they are ordered differently or when tracks have been added/deleted.\nexpected table is of structure:\ntable[\"AllAUXSendReceive\"]=true                               - signals, this is an AllAUXSendReceive-table. Don't alter!\ntable[\"number\\_of_tracks\"]                                     - the number of tracks in this table, from track 1 to track n\ntable[tracknumber][\"AUXSendReceives_count\"]                   - the number of AUXSendReceives of tracknumber, beginning with 1\ntable[tracknumber][\"TrackID\"]                                 - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\ntable[tracknumber][AUXSendReceivesIndex][\"recv\\_tracknumber\"] - the track, from which to receive audio in this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"recv\\_track\\_guid\"] - the guid of the receive-track; with that, you can be sure to get the right receive-track, even if trackorder changes\ntable[tracknumber][AUXSendReceivesIndex][\"post\\_pre_fader\"]   - the setting of post-pre-fader of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"volume\"]            - the volume of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\"]               - the panning of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mute\"]              - the mute-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mono\\_stereo\"]      - the mono/stereo-button-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"phase\"]             - the phase-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"chan\\_src\"]         - the audiochannel-source of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"snd\\_src\"]          - the send-to-channel-target of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\\_law\"]           - pan-law, default is -1\ntable[tracknumber][AUXSendReceivesIndex][\"midichanflag\"]      - the Midi-channel of this AUXSendReceivesIndex of tracknumber, leave it 0\ntable[tracknumber][AUXSendReceivesIndex][\"automation\"]        - the automation-mode of this AUXSendReceivesIndex  of tracknumber\nSee GetTrackAUXSendReceives for more details on the individual settings, stored in the entries.\nreturns false in case of an error\nPARAMETERS:\nAllAUXSendReceives:a table with all AllAUXSendReceive-entries of the current project\noption:nil or 1, AUXRecvs will be applied to Track 1 to table[\"number_of_tracks\"]; 2, AUXRecvs will be applied to the tracks with the guid TrackID\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.ApplyAllAUXSendReceives(${1:table AllAUXSendReceives},${2:optional integer option})$0"
    },
    "ULTRASCHALL.GETALLMAINSENDSTATES lua": {
        "prefix": "ultraschall.GetAllMainSendStates",
        "scope": "lua",
        "description": "returns a table with all MainSend-settings of all tracks, excluding master-track.\nThe MainSend-settings are the settings, if a certain track sends it's signal to the Master Track\nreturned table is of structure:\nTable[\"number\\_of_tracks\"]            - The number of tracks in this table, from track 1 to track n\nTable[\"MainSend\"]=true               - signals, this is an AllMainSends-table\ntable[tracknumber][\"TrackID\"]        - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\nTable[tracknumber][\"MainSendOn\"]     - Send to Master on(1) or off(1)\nTable[tracknumber][\"ParentChannels\"] - the parent channels of this track\nSee GetTrackMainSendState for more details on the individual settings, stored in the entries.\nRETURNS:\nAllMainSends:a table with all AllMainSends-entries of the current project.\ninteger number_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "ultraschall.GetAllMainSendStates()$0"
    },
    "ULTRASCHALL.APPLYALLMAINSENDSTATES lua": {
        "prefix": "ultraschall.ApplyAllMainSendStates",
        "scope": "lua",
        "description": "takes a table, as returned by GetAllMainSendStates with all MainSend-settings of all tracks and applies it to all tracks.\nThe MainSend-settings are the settings, if a certain track sends it's signal to the Master Track.\nWhen you set option to 2, the individual entries will be applied to the tracks, that have the guids stored in table\ntable[tracknumber][\"TrackID\"], otherwise, this function will apply it to track0 to trackn, which is the same as table[\"number\\_of_tracks\"].\nThat way, you can create RoutingSnapshots, that will stay in the right tracks, even if they are ordered differently or when tracks have been added/deleted.\nThis influences the MasterTrack as well!\nexpected table is of structure:\nTable[\"number\\_of_tracks\"]            - The number of tracks in this table, from track 1 to track n\nTable[\"MainSend\"]=true               - signals, this is an AllMainSends-table\ntable[tracknumber][\"TrackID\"]        - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\nTable[tracknumber][\"MainSendOn\"]     - Send to Master on(1) or off(1)\nTable[tracknumber][\"ParentChannels\"] - the parent channels of this track\nSee GetTrackMainSendState for more details on the individual settings, stored in the entries.\nreturns false in case of an error\nPARAMETERS:\noption:nil or 1, MainSend-settings will be applied to Track 1 to table[\"number_of_tracks\"]; 2, MasterSends will be applied to the tracks with the guid stored in table[tracknumber][\"TrackID\"].\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "ultraschall.ApplyAllMainSendStates(${1:table AllMainSendsTable},${2:optional integer option})$0"
    },
    "ULTRASCHALL.AREHWOUTSTABLESEQUAL lua": {
        "prefix": "ultraschall.AreHWOutsTablesEqual",
        "scope": "lua",
        "description": "Compares two HWOuts-tables, as returned by GetAllHWOuts](#GetAllHWOuts) or [GetAllHWOuts2\nif option=2 then it will also compare, if the stored track-guids are the equal. Otherwise, it will only check the individual settings, even if the guids are different between the two tables.\nreturns false in case of an error\nPARAMETERS:\nAllHWOuts:a table with all HWOut-settings of all tracks, that you want to compare to AllHWOuts\nAllHWOuts2:a table with all HWOut-settings of all tracks, that you want to compare to AllHWOuts\noption:nil or 1, to compare everything, except the stored TrackGuids; 2, include comparing the stored TrackGuids as well\nRETURNS:\nboolean retval:true, if the two tables are equal HWOuts; false, if not\n",
        "body": "ultraschall.AreHWOutsTablesEqual(${1:table AllHWOuts},${2:table AllHWOuts2},${3:optional integer option})$0"
    },
    "ULTRASCHALL.AREMAINSENDSTABLESEQUAL lua": {
        "prefix": "ultraschall.AreMainSendsTablesEqual",
        "scope": "lua",
        "description": "Compares two AllMainSends-tables, as returned by GetAllMainSendStates](#GetAllMainSendStates) or [GetAllMainSendStates2\nif option=2 then it will also compare, if the stored track-guids are the equal. Otherwise, it will only check the individual settings, even if the guids are different between the two tables.\nreturns false in case of an error\nPARAMETERS:\nAllMainSends:a table with all AllMainSends-settings of all tracks, that you want to compare to AllMainSends\nAllMainSends2:a table with all AllMainSends-settings of all tracks, that you want to compare to AllMainSends\noption:nil or 1, to compare everything, except the stored TrackGuids; 2, include comparing the stored TrackGuids as well\nRETURNS:\nboolean retval:true, if the two tables are equal AllMainSends; false, if not\n",
        "body": "ultraschall.AreMainSendsTablesEqual(${1:table AllMainSends},${2:table AllMainSends2},${3:optional integer option})$0"
    },
    "ULTRASCHALL.AREAUXSENDRECEIVESTABLESEQUAL lua": {
        "prefix": "ultraschall.AreAUXSendReceivesTablesEqual",
        "scope": "lua",
        "description": "Compares two AllAUXSendReceives-tables, as returned by GetAllAUXSendReceives](#GetAllAUXSendReceives) or [GetAllAUXSendReceives2\nif option=2 then it will also compare, if the stored track-guids are the equal. Otherwise, it will only check the individual settings, even if the guids are different between the two tables.\nreturns false in case of an error\nPARAMETERS:\nAllAUXSendReceives:a table with all AllAUXSendReceives-settings of all tracks, that you want to compare to AllAUXSendReceives\nAllAUXSendReceives2:a table with all AllAUXSendReceives-settings of all tracks, that you want to compare to AllAUXSendReceives\noption:nil or 1, to compare everything, except the stored TrackGuids; 2, include comparing the stored TrackGuids as well\nRETURNS:\nboolean retval:true, if the two tables are equal AllMainSends; false, if not\n",
        "body": "ultraschall.AreAUXSendReceivesTablesEqual(${1:table AllAUXSendReceives},${2:table AllAUXSendReceives2},${3:optional integer option})$0"
    },
    "ULTRASCHALL.GETTRACKSTATECHUNK_TRACKNUMBER lua": {
        "prefix": "ultraschall.GetTrackStateChunk_Tracknumber",
        "scope": "lua",
        "description": "returns the trackstatechunk for track tracknumber\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber, 0 for master track, 1 for track 1, 2 for track 2, etc.    \nRETURNS:\nretval:true in case of success; false in case of error\ntrackstatechunk:the trackstatechunk for track tracknumber\n",
        "body": "ultraschall.GetTrackStateChunk_Tracknumber(${1:integer tracknumber})$0"
    },
    "ULTRASCHALL.GETTRACKSTATE_NUMBERSONLY lua": {
        "prefix": "ultraschall.GetTrackState_NumbersOnly",
        "scope": "lua",
        "description": "returns a state of a TrackStateChunk.\nIt only supports single-entry-states with numbers/integers, separated by spaces!\nAll other values will be set to nil and strings with spaces will produce weird results!\nreturns nil in case of an error\nPARAMETERS:\nstate:the state, whose attributes you want to retrieve\nTrackStateChunk:a statechunk of a track\nfunctionname:if this function is used within specific gettrackstate-functions, pass here the \"host\"-functionname, so error-messages will reflect that\nnumbertoggle:true or nil; converts all values to numbers; false, keep them as string versions\nRETURNS:\nvalues:all values found as numerical indexed array\n",
        "body": "ultraschall.GetTrackState_NumbersOnly(${1:string state},${2:optional string TrackStateChunk},${3:optional string functionname},${4:optional boolean numbertoggle})$0"
    },
    "ULTRASCHALL.GETTRACKNAME lua": {
        "prefix": "ultraschall.GetTrackName",
        "scope": "lua",
        "description": "returns name of the track.\nIt's the entry NAME\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\ntrackname:the name of the track\n",
        "body": "ultraschall.GetTrackName(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKPEAKCOLORSTATE lua": {
        "prefix": "ultraschall.GetTrackPeakColorState",
        "scope": "lua",
        "description": "returns state of the PeakColor-number, which is the trackcolor. Will be returned as string, to avoid losing trailing or preceding zeros.\nIt's the entry PEAKCOL\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nPeakColorState:the color of the track\n",
        "body": "ultraschall.GetTrackPeakColorState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKBEATSTATE lua": {
        "prefix": "ultraschall.GetTrackBeatState",
        "scope": "lua",
        "description": "returns Track-BeatState.\nIt's the entry BEAT\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nBeatState:-1 - Project time base; 0 - Time; 1 - Beats position, length, rate; 2 - Beats position only\n",
        "body": "ultraschall.GetTrackBeatState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMUTESOLOSTATE lua": {
        "prefix": "ultraschall.GetTrackMuteSoloState",
        "scope": "lua",
        "description": "returns states of Mute and Solo-Buttons.\nIt's the entry MUTESOLO\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMute:Mute set to 0 - Mute off, 1 - Mute On\nSolo:SoloDefeat set to 0 - off, 1 - on\nSoloDefeat:SoloDefeat set to 0 - off, 1 - on\n",
        "body": "ultraschall.GetTrackMuteSoloState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKIPHASESTATE lua": {
        "prefix": "ultraschall.GetTrackIPhaseState",
        "scope": "lua",
        "description": "returns state of the IPhase. If the Phase-button is pressed, it will return 1, else it will return 0.\nIt's the entry IPHASE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nIPhase:state of the phase-button; 0, normal phase; 1, inverted phase(180\u00b0)\n",
        "body": "ultraschall.GetTrackIPhaseState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKBUSCOMPSTATE lua": {
        "prefix": "ultraschall.GetTrackBusCompState",
        "scope": "lua",
        "description": "returns BusCompState, if the tracks in a folder are compacted or not.\nIt's the entry BUSCOMP\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nBusCompState1:0 - no compacting, 1 - compacted tracks, 2 - minimized tracks\nBusCompState2:0 - unknown,1 - unknown\nBusCompState3:0 - unknown,1 - unknown\nBusCompState4:0 - unknown,1 - unknown\nBusCompState5:0 - unknown,1 - unknown\n",
        "body": "ultraschall.GetTrackBusCompState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKSHOWINMIXSTATE lua": {
        "prefix": "ultraschall.GetTrackShowInMixState",
        "scope": "lua",
        "description": "returns Show in Mix-state.\nIt's the entry SHOWINMIX\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMCPvisible:0 invisible, 1 visible\nMCP_FX_visible:0 visible, 1 FX-Parameters visible, 2 invisible\nMCPTrackSendsVisible:0 & 1.1 and higher TrackSends in MCP visible, every other number makes them invisible\nTCPvisible:0 track is invisible in TCP, 1 track is visible in TCP\nShowInMix5:unknown\nShowInMix6:unknown\nShowInMix7:unknown\nShowInMix8:unknown\n",
        "body": "ultraschall.GetTrackShowInMixState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKFREEMODESTATE lua": {
        "prefix": "ultraschall.GetTrackFreeModeState",
        "scope": "lua",
        "description": "returns if the track has track free item positioning enabled(1) or not(0).\nIt's the entry FREEMODE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nFreeModeState:1 - enabled, 0 - not enabled\n",
        "body": "ultraschall.GetTrackFreeModeState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKRECSTATE lua": {
        "prefix": "ultraschall.GetTrackRecState",
        "scope": "lua",
        "description": "returns Track Rec State.\nIt's the entry REC\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nArmState:returns 1(armed) or 0(unarmed)\nInputChannel:returns the InputChannel\nMonitorInput:0 monitor off, 1 monitor on, 2 monitor on tape audio style\nRecInput:returns rec-input type\nMonitorWhileRec:Monitor Trackmedia when recording, 0 is off, 1 is on\npresPDCdelay:preserve PDC delayed monitoring in media items\nRecordingPath:recording path used \n",
        "body": "ultraschall.GetTrackRecState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKHEIGHTSTATE lua": {
        "prefix": "ultraschall.GetTrackHeightState",
        "scope": "lua",
        "description": "returns height of the track.\nIt's the entry TRACKHEIGHT\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nheight:0, don't lock the trackheight; 1, lock the trackheight\nheightstate2:0 - use height, 1 - compact the track and ignore the height\n",
        "body": "ultraschall.GetTrackHeightState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKINQSTATE lua": {
        "prefix": "ultraschall.GetTrackINQState",
        "scope": "lua",
        "description": "Gets INQ-state, mostly the quantize-settings for MIDI, as set in the \"Track: View track recording settings (MIDI quantize, file format/path) for last touched track\"-dialog (action 40604)\nIt's the entry INQ\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nquantMIDI: quantize MIDI; 0 or 1\nquantPOS: quantize to position; -1,prev; 0, nearest; 1, next\nquantNoteOffs: quantize note-offs; 0 or 1\nquantToFractBeat: quantize to (fraction of beat)\nquantStrength: quantize strength; -128 to 127\nswingStrength: swing strength; -128 to 127\nquantRangeMin: quantize range minimum; -128 to 127\ninteger quantRangeMax: quantize range maximum; -128 to 127\n",
        "body": "ultraschall.GetTrackINQState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKNCHANSSTATE lua": {
        "prefix": "ultraschall.GetTrackNChansState",
        "scope": "lua",
        "description": "returns the number of channels for this track, as set in the routing.\nIt's the entry NCHAN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nchannelnumber:number of channels for this track\n",
        "body": "ultraschall.GetTrackNChansState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKBYPFXSTATE lua": {
        "prefix": "ultraschall.GetTrackBypFXState",
        "scope": "lua",
        "description": "returns the off/bypass(0) or nobypass(1) state of the FX-Chain\nIt's the entry FX\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nFXState:off/bypass(0) or nobypass(1)\n",
        "body": "ultraschall.GetTrackBypFXState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKPERFSTATE lua": {
        "prefix": "ultraschall.GetTrackPerfState",
        "scope": "lua",
        "description": "returns TrackPerformance-state\nIt's the entry PERF\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nTrackPerfState:TrackPerformance-state\n",
        "body": "ultraschall.GetTrackPerfState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDIOUTSTATE lua": {
        "prefix": "ultraschall.GetTrackMIDIOutState",
        "scope": "lua",
        "description": "returns MIDI_Out-State, as set in the Routing-Settings\nIt's the entry MIDIOUT\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiOutState:MIDI_Out-State, as set in the Routing-Settings\n",
        "body": "ultraschall.GetTrackMIDIOutState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMAINSENDSTATE lua": {
        "prefix": "ultraschall.GetTrackMainSendState",
        "scope": "lua",
        "description": "returns, if Main-Send is on(1) or off(0) and the ParentChannels(0-63), as set in the Routing-Settings.\nIt's the entry MAINSEND\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMainSendOn:Main-Send is on(1) or off(0)\nParentChannels:ParentChannels(0-63)\n",
        "body": "ultraschall.GetTrackMainSendState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKGROUPFLAGSSTATE lua": {
        "prefix": "ultraschall.GetTrackGroupFlagsState",
        "scope": "lua",
        "description": "returns the state of the group-flags, as set in the menu Track Grouping Parameters. Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 1 to 32. To get Groups 33 to 64, use GetTrackGroupFlags_HighState instead!\nIt's the entry GROUP_FLAGS\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "ultraschall.GetTrackGroupFlagsState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKGROUPFLAGS_HIGHSTATE lua": {
        "prefix": "ultraschall.GetTrackGroupFlags_HighState",
        "scope": "lua",
        "description": "returns the state of the group-flags, as set in the menu Track Grouping Parameters. Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 33(2^0=1) and 35(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 33(2^0) to 64(2^31). To get Groups 1 to 32, use GetTrackGroupFlagsState instead!\nIt's the entry GROUP_FLAGS_HIGH\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "ultraschall.GetTrackGroupFlags_HighState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKLOCKSTATE lua": {
        "prefix": "ultraschall.GetTrackLockState",
        "scope": "lua",
        "description": "returns, if the track-controls of this track are locked(1) or not(nil).\nIt's the entry LOCK\nOnly the LOCK within TrackStateChunks, but not MediaItemStateChunks\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nlockedstate:locked(1) or not(nil)\n",
        "body": "ultraschall.GetTrackLockState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKLAYOUTNAMES lua": {
        "prefix": "ultraschall.GetTrackLayoutNames",
        "scope": "lua",
        "description": "returns the current selected layouts for TrackControlPanel and MixerControlPanel for this track as strings. Returns nil, if default is set.\nIt's the entry LAYOUTS\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nTCP_Layoutname:name of the TCP-Layoutname\nMCP_Layoutname:name of the MCP-Layoutname\n",
        "body": "ultraschall.GetTrackLayoutNames(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKAUTOMODESTATE lua": {
        "prefix": "ultraschall.GetTrackAutomodeState",
        "scope": "lua",
        "description": "returns, if the automation-mode for envelopes of this track\nIt's the entry AUTOMODE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nautomodestate:is set to 0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch.\n",
        "body": "ultraschall.GetTrackAutomodeState(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKICON_FILENAME lua": {
        "prefix": "ultraschall.GetTrackIcon_Filename",
        "scope": "lua",
        "description": "returns the filename with path for the track-icon of the current track. Returns nil, if no trackicon has been set.\nIt's the entry TRACKIMGFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nfilename_with_path:filename with path for the current track-icon.\n",
        "body": "ultraschall.GetTrackIcon_Filename(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKRECCFG lua": {
        "prefix": "ultraschall.GetTrackRecCFG",
        "scope": "lua",
        "description": "returns the Rec-configuration-string, with which recordings are made. Returns nil, if no reccfg exists.\nIt's the entry\nstring reccfg - the string, that encodes the recording configuration of the track.\ninteger reccfgnr - the number of the recording-configuration of the track;\n- 0, use default project rec-setting\n- 1, use track-customized rec-setting, as set in the \"Track: View track recording settings (MIDI quantize, file format/path) for last touched track\"-dialog (action 40604)\ninteger tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\noptional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track\nTrack Management\nGet Track States\nUS_Api_Functions\nModules/ultraschall_functions_TrackManagement_TrackStates_Module.lua\ntrackmanagement, state, get, reccfg, trackstatechunk\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nreccfg:the number of the recording-configuration of the track; \n",
        "body": "ultraschall.GetTrackRecCFG(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDIINPUTCHANMAP lua": {
        "prefix": "ultraschall.GetTrackMidiInputChanMap",
        "scope": "lua",
        "description": "returns the state of the MIDIInputChanMap for the current track, as set in the Input-MIDI->Map Input to Channel menu. 0 for channel 1, 2 for channel 2, etc. Nil, if not existing.\nIt's the entry MIDI_INPUT_CHANMAP\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiInputChanMap_state:0 for channel 1, 1 for channel 2, ... 15 for channel 16; nil, source channel.\n",
        "body": "ultraschall.GetTrackMidiInputChanMap(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDICTL lua": {
        "prefix": "ultraschall.GetTrackMidiCTL",
        "scope": "lua",
        "description": "returns linked to Midi channel and an unknown value. Nil if not existing.\nIt's the entry MIDICTL\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nLinkedToMidiChannel:linked to midichannel\nunknown:unknown\n",
        "body": "ultraschall.GetTrackMidiCTL(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKWIDTH lua": {
        "prefix": "ultraschall.GetTrackWidth",
        "scope": "lua",
        "description": "returns width of the track. 1 if set to +100%.\nNote for TrackStateChunk-enthusiasts: When set to +100%, it is not stored in the TrackStateChunk\nIt's the entry WIDTH\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nwidth:width of the track, from -1(-100%) to 1(+100%)\n",
        "body": "ultraschall.GetTrackWidth(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKPANMODE lua": {
        "prefix": "ultraschall.GetTrackPanMode",
        "scope": "lua",
        "description": "returns Panmode of the track.\nIt's the entry PANMODE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nPanMode:the Panmode of the track\n",
        "body": "ultraschall.GetTrackPanMode(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDICOLORMAPFN lua": {
        "prefix": "ultraschall.GetTrackMidiColorMapFn",
        "scope": "lua",
        "description": "returns MidiColorMap-Filename of the track. Nil if not existing.\nIt's the entry MIDICOLORMAPFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiColorMapFn:the MidiColorMap-Filename; nil if not existing\n",
        "body": "ultraschall.GetTrackMidiColorMapFn(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDIBANKPROGFN lua": {
        "prefix": "ultraschall.GetTrackMidiBankProgFn",
        "scope": "lua",
        "description": "returns MidiBankProg-Filename of the track. Nil if not existing.\nIt's the entry MIDIBANKPROGFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiBankProgFn:the MidiBankProg-Filename; nil if not existing\n",
        "body": "ultraschall.GetTrackMidiBankProgFn(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDITEXTSTRFN lua": {
        "prefix": "ultraschall.GetTrackMidiTextStrFn",
        "scope": "lua",
        "description": "returns MidiTextStrFn-Filename of the track. Nil if not existing.\nIt's the entry MIDIEXTSTRFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiTextStrFn:the MidiTextStrFn-Filename; nil if not existing\n",
        "body": "ultraschall.GetTrackMidiTextStrFn(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKID lua": {
        "prefix": "ultraschall.GetTrackID",
        "scope": "lua",
        "description": "returns TrackID of the track.\nIt's the entry TRACKID\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nTrackID:the TrackID as GUID\n",
        "body": "ultraschall.GetTrackID(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKSCORE lua": {
        "prefix": "ultraschall.GetTrackScore",
        "scope": "lua",
        "description": "returns Score of the track.\nIt's the entry SCORE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nScore1:unknown \nScore2:unknown\nScore3:unknown\nnumber Score4:unknown\n",
        "body": "ultraschall.GetTrackScore(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKVOLPAN lua": {
        "prefix": "ultraschall.GetTrackVolPan",
        "scope": "lua",
        "description": "returns Vol and Pan-states of the track.\nIt's the entry VOLPAN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nVol:Volume Settings\nPan:Override Default Pan Track Law\nOverridePanLaw:Override Default Pan Track Law\nunknown:unknown\nunknown2:unknown\n",
        "body": "ultraschall.GetTrackVolPan(${1:integer tracknumber},${2:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKNAME lua": {
        "prefix": "ultraschall.SetTrackName",
        "scope": "lua",
        "description": "Set the name of a track or a trackstatechunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nname:new name of the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackName(${1:integer tracknumber},${2:string name},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKPEAKCOLORSTATE lua": {
        "prefix": "ultraschall.SetTrackPeakColorState",
        "scope": "lua",
        "description": "Set the color of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\ncolorvalue:the color for the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackPeakColorState(${1:integer tracknumber},${2:integer colorvalue},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKBEATSTATE lua": {
        "prefix": "ultraschall.SetTrackBeatState",
        "scope": "lua",
        "description": "Set the timebase for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nbeatstate:tracktimebase for this track; -1 - Project time base, 0 - Time, 1 - Beats position, length, rate, 2 - Beats position only\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackBeatState(${1:integer tracknumber},${2:integer beatstate},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKAUTORECARMSTATE lua": {
        "prefix": "ultraschall.SetTrackAutoRecArmState",
        "scope": "lua",
        "description": "Set the AutoRecArmState for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nautorecarmstate:autorecarmstate - 1 - autorecarm on, <> than 1 - off\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackAutoRecArmState(${1:integer tracknumber},${2:integer autorecarmstate},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMUTESOLOSTATE lua": {
        "prefix": "ultraschall.SetTrackMuteSoloState",
        "scope": "lua",
        "description": "Set the Track Mute/Solo/Solodefeat for a track or a TrackStateChunk.\nHas no real effect on master track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMute:Mute set to 0 - Mute off, 1 - Mute On\nSolo:SoloDefeat set to 0 - off, 1 - on\nSoloDefeat:SoloDefeat set to 0 - off, 1 - on\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackMuteSoloState(${1:integer tracknumber},${2:integer Mute},${3:integer Solo},${4:integer SoloDefeat},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKIPHASESTATE lua": {
        "prefix": "ultraschall.SetTrackIPhaseState",
        "scope": "lua",
        "description": "Sets IPhase, the Phase-Buttonstate of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\niphasestate:0-off, <> than 0-on\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackIPhaseState(${1:integer tracknumber},${2:integer iphasestate},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKISBUSSTATE lua": {
        "prefix": "ultraschall.SetTrackIsBusState",
        "scope": "lua",
        "description": "Sets ISBUS-state of the track or a TrackStateChunk; if it's a folder track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nbusstate1:track is last track in folder(no tracks of subfolders follow)\nbusstate2:track is last track in folder(no tracks of subfolders follow)\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackIsBusState(${1:integer tracknumber},${2:integer busstate1},${3:integer busstate2},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKBUSCOMPSTATE lua": {
        "prefix": "ultraschall.SetTrackBusCompState",
        "scope": "lua",
        "description": "Sets BUSCOMP-state of the track or a TrackStateChunk; This is the state, if tracks in a folder are compacted or not.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackBusCompState(${1:integer tracknumber},${2:integer buscompstate1},${3:integer buscompstate2},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKSHOWINMIXSTATE lua": {
        "prefix": "ultraschall.SetTrackShowInMixState",
        "scope": "lua",
        "description": "Sets SHOWINMIX, that sets visibility of track or TrackStateChunk in MCP and TCP.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMCPvisible:0 invisible, 1 visible\nMCP_FX_visible:0 visible, 1 FX-Parameters visible, 2 invisible\nTCPvisible:0 track is invisible in TCP, 1 track is visible in TCP\nShowInMix5:unknown\nShowInMix6:unknown\nShowInMix7:unknown\nShowInMix8:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackShowInMixState(${1:integer tracknumber},${2:integer MCPvisible},${3:number MCP_FX_visible},${4:number MCP_TrackSendsVisible},${5:integer TCPvisible},${6:number ShowInMix5},${7:integer ShowInMix6},${8:integer ShowInMix7},${9:integer ShowInMix8},${10:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKFREEMODESTATE lua": {
        "prefix": "ultraschall.SetTrackFreeModeState",
        "scope": "lua",
        "description": "Sets FREEMODE-state of a track or a TrackStateChunk; enables Track-Free Item Positioning.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nfreemodestate:0 - off, 1 - on\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackFreeModeState(${1:integer tracknumber},${2:integer freemodestate},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKRECSTATE lua": {
        "prefix": "ultraschall.SetTrackRecState",
        "scope": "lua",
        "description": "Sets REC, that sets the Recording-state of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nArmState:set to 1(armed) or 0(unarmed)\nInputChannel:the InputChannel\nRecInput:the rec-input type\nMonitorWhileRec:Monitor Trackmedia when recording, 0 is off, 1 is on\npresPDCdelay:preserve PDC delayed monitoring in media items\nRecordingPath:0 Primary Recording-Path only, 1 Secondary Recording-Path only, 2 Primary Recording Path and Secondary Recording Path(for invisible backup)\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackRecState(${1:integer tracknumber},${2:integer ArmState},${3:integer InputChannel},${4:integer MonitorInput},${5:integer RecInput},${6:integer MonitorWhileRec},${7:integer presPDCdelay},${8:integer RecordingPath},${9:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKVUSTATE lua": {
        "prefix": "ultraschall.SetTrackVUState",
        "scope": "lua",
        "description": "Sets VU-state of a track or a TrackStateChunk; the way metering shows.\nHas no real effect on master track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nVUState: 0 MultiChannelMetering is off, 2 MultichannelMetering is on, 3 Metering is off;seems to have no effect on MasterTrack\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackVUState(${1:integer tracknumber},${2:integer VUState},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKHEIGHTSTATE lua": {
        "prefix": "ultraschall.SetTrackHeightState",
        "scope": "lua",
        "description": "Sets TRACKHEIGHT-state; the height and compacted state of the track or a TrackStateChunk.\nHas no visible effect on the master-track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nheight:0, trackheight is not locked; 1, trackheight is locked\nlockedtrackheight:0, trackheight is not locked; 1, trackheight is locked\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackHeightState(${1:integer tracknumber},${2:integer height},${3:integer heightstate2},${4:integer lockedtrackheight},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKINQSTATE lua": {
        "prefix": "ultraschall.SetTrackINQState",
        "scope": "lua",
        "description": "Sets INQ-state, mostly the quantize-settings for MIDI, of a track or a TrackStateChunk, as set in the \"Track: View track recording settings (MIDI quantize, file format/path) for last touched track\"-dialog (action 40604)\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nquantMIDI: quantize MIDI; 0 or 1\nquantPOS: quantize to position; -1,prev; 0, nearest; 1, next\nquantNoteOffs: quantize note-offs; 0 or 1\nquantToFractBeat: quantize to (fraction of beat)\nquantStrength: quantize strength; -128 to 127\nswingStrength: swing strength; -128 to 127\nquantRangeMin: quantize range minimum; -128 to 127\nquantRangeMax: quantize range maximum; -128 to 127\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackINQState(${1:integer tracknumber},${2:integer quantMIDI},${3:integer quantPOS},${4:integer quantNoteOffs},${5:number quantToFractBeat},${6:integer quantStrength},${7:integer swingStrength},${8:integer quantRangeMin},${9:integer quantRangeMax},${10:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKNCHANSSTATE lua": {
        "prefix": "ultraschall.SetTrackNChansState",
        "scope": "lua",
        "description": "Sets NCHAN-state; the number of channels in this track or a TrackStateChunk, as set in the routing.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nNChans:2 to 64, counted every second channel (2,4,6,8,etc) with stereo-tracks. Unknown, if Multichannel and Mono-tracks count differently.\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackNChansState(${1:integer tracknumber},${2:integer NChans},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKBYPFXSTATE lua": {
        "prefix": "ultraschall.SetTrackBypFXState",
        "scope": "lua",
        "description": "Sets FX, FX-Bypass-state of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nFXBypassState:0 bypass, 1 activate fx; has only effect, if FX or instruments are added to this track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackBypFXState(${1:integer tracknumber},${2:integer FXBypassState},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKPERFSTATE lua": {
        "prefix": "ultraschall.SetTrackPerfState",
        "scope": "lua",
        "description": "Sets PERF, the TrackPerformance-State of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nPerf:performance-state\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackPerfState(${1:integer tracknumber},${2:integer Perf},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDIOUTSTATE lua": {
        "prefix": "ultraschall.SetTrackMIDIOutState",
        "scope": "lua",
        "description": "Sets MIDIOUT, the state of MIDI out for this track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackMIDIOutState(${1:integer tracknumber},${2:integer MIDIOutState},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMAINSENDSTATE lua": {
        "prefix": "ultraschall.SetTrackMainSendState",
        "scope": "lua",
        "description": "Sets MAINSEND, as set in the routing-settings, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMainSendOn:on(1) or off(0)\nParentChannels:the ParentChannels(0-64), interpreted as beginning with ParentChannels to ParentChannels+NCHAN\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk, if tracknumber=-1\n",
        "body": "ultraschall.SetTrackMainSendState(${1:integer tracknumber},${2:integer MainSendOn},${3:integer ParentChannels},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKLOCKSTATE lua": {
        "prefix": "ultraschall.SetTrackLockState",
        "scope": "lua",
        "description": "Sets LOCK-State, as set by the menu entry Lock Track Controls, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nLockedState:1 - locked, 0 - unlocked\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackLockState(${1:integer tracknumber},${2:integer LockedState},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKLAYOUTNAMES lua": {
        "prefix": "ultraschall.SetTrackLayoutNames",
        "scope": "lua",
        "description": "Sets LAYOUTS, the MCP and TCP-layout by name of the layout as defined in the theme, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nTCP_Layoutname:name of the TrackControlPanel-Layout from the theme to use\nMCP_Layoutname:name of the MixerControlPanel-Layout from the theme to use\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackLayoutNames(${1:integer tracknumber},${2:string TCP_Layoutname},${3:string MCP_Layoutname},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKAUTOMODESTATE lua": {
        "prefix": "ultraschall.SetTrackAutomodeState",
        "scope": "lua",
        "description": "Sets AUTOMODE-State, as set by the menu entry Set Track Automation Mode, for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nautomodestate:0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackAutomodeState(${1:integer tracknumber},${2:integer automodestate},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKICON_FILENAME lua": {
        "prefix": "ultraschall.SetTrackIcon_Filename",
        "scope": "lua",
        "description": "Sets TRACKIMGFN, the trackicon-filename with path, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nIconfilename_with_path:filename+path of the imagefile to use as the trackicon; \"\", to remove track-icon\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackIcon_Filename(${1:integer tracknumber},${2:string Iconfilename_with_path},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDIINPUTCHANMAP lua": {
        "prefix": "ultraschall.SetTrackMidiInputChanMap",
        "scope": "lua",
        "description": "Sets MIDI_INPUT_CHANMAP, as set in the Input-MIDI->Map Input to Channel menu, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nInputChanMap:0 for channel 1, 2 for channel 2, etc. -1 if not existing; nil, to remove MidiInputChanMap\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackMidiInputChanMap(${1:integer tracknumber},${2:integer InputChanMap},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDICTL lua": {
        "prefix": "ultraschall.SetTrackMidiCTL",
        "scope": "lua",
        "description": "sets MIDICTL-state, the linkage to Midi-Channels of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nLinkedToMidiChannel:unknown; nil, to remove this setting completely\nunknown:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackMidiCTL(${1:integer tracknumber},${2:integer LinkedToMidiChannel},${3:integer unknown},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKID lua": {
        "prefix": "ultraschall.SetTrackID",
        "scope": "lua",
        "description": "sets the track-id, which must be a valid GUID, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nguid:a valid GUID. Can be generated with the native Reaper-function reaper.genGuid()\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackID(${1:integer tracknumber},${2:string guid},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDICOLORMAPFN lua": {
        "prefix": "ultraschall.SetTrackMidiColorMapFn",
        "scope": "lua",
        "description": "sets the filename+path to the MIDI-ColorMap-graphicsfile of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMIDI_ColorMapFN:filename+path to the MIDI-ColorMap-file; \"\", to remove it\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackMidiColorMapFn(${1:integer tracknumber},${2:string MIDI_ColorMapFN},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDIBANKPROGFN lua": {
        "prefix": "ultraschall.SetTrackMidiBankProgFn",
        "scope": "lua",
        "description": "sets the filename+path to the MIDI-Bank-Prog-file of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMIDIBankProgFn:filename+path to the MIDI-Bank-Prog-file; \"\", to remove it\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackMidiBankProgFn(${1:integer tracknumber},${2:string MIDIBankProgFn},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDITEXTSTRFN lua": {
        "prefix": "ultraschall.SetTrackMidiTextStrFn",
        "scope": "lua",
        "description": "sets the filename+path to the MIDI-Text-Str-file of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMIDITextStrFn:filename+path to the MIDI-Text-Str-file; \"\", to remove it\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackMidiTextStrFn(${1:integer tracknumber},${2:string MIDITextStrFn},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKPANMODE lua": {
        "prefix": "ultraschall.SetTrackPanMode",
        "scope": "lua",
        "description": "sets the panmode for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\npanmode:the Panmode of the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackPanMode(${1:integer tracknumber},${2:integer panmode},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKWIDTH lua": {
        "prefix": "ultraschall.SetTrackWidth",
        "scope": "lua",
        "description": "sets the width of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nwidth:width of the track, from -1(-100%) to 1(+100%)\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackWidth(${1:integer tracknumber},${2:number width},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKSCORE lua": {
        "prefix": "ultraschall.SetTrackScore",
        "scope": "lua",
        "description": "sets the SCORE of a track or a TrackStateChunk.\nset unknown1 to unknown4 to 0 to remove the entry from the TrackStateChunk\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nunknown1:unknown\nunknown2:unknown\nunknown3:unknown\nunknown4:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackScore(${1:integer tracknumber},${2:integer unknown1},${3:integer unknown2},${4:number unknown3},${5:number unknown4},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKVOLPAN lua": {
        "prefix": "ultraschall.SetTrackVolPan",
        "scope": "lua",
        "description": "sets the VOLPAN-state of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1, if you want to use parameter TrackStateChunk\nVol:Volume Settings; -Inf dB(0) to +12dB (3.98107170553497)\nPan:Override Default Pan Track Law; 0dB(1) to -144dB(0.00000006309573)\nOverridePanLaw:Override Default Pan Track Law; 0dB(1) to -144dB(0.00000006309573)\nunknown:unknown\nunknown2:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackVolPan(${1:integer tracknumber},${2:number Vol},${3:number Pan},${4:number OverridePanLaw},${5:number unknown},${6:number unknown2},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKRECCFG lua": {
        "prefix": "ultraschall.SetTrackRecCFG",
        "scope": "lua",
        "description": "sets the RECCFG of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nreccfg_string: the string, that encodes the recording configuration of the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackRecCFG(${1:integer tracknumber},${2:string reccfg_string},${3:integer reccfg_nr},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETALLLOCKEDTRACKS lua": {
        "prefix": "ultraschall.GetAllLockedTracks",
        "scope": "lua",
        "description": "returns a trackstring with all tracknumbers of tracks, that are locked, as well as one with all tracknumbers of tracks, that are unlocked.\nreturns an empty locked_trackstring, if none is locked, returns an empty unlocked_trackstring if all are locked.\nRETURNS:\nlocked_trackstring:the tracknumbers of all tracks, that are NOT locked; empty string if all are locked\nunlocked_trackstring:the tracknumbers of all tracks, that are NOT locked; empty string if all are locked\n",
        "body": "ultraschall.GetAllLockedTracks()$0"
    },
    "ULTRASCHALL.GETALLSELECTEDTRACKS lua": {
        "prefix": "ultraschall.GetAllSelectedTracks",
        "scope": "lua",
        "description": "returns a trackstring with all tracknumbers of tracks, that are selected, as well as one with all tracknumbers of tracks, that are unselected.\nreturns an empty selected_trackstring, if none is selected, returns an empty unselected_trackstring if all are selected.\nRETURNS:\nselected_trackstring:the tracknumbers of all tracks, that are NOT selected; empty string if all are selected\nunselected_trackstring:the tracknumbers of all tracks, that are NOT selected; empty string if all are selected\n",
        "body": "ultraschall.GetAllSelectedTracks()$0"
    },
    "ULTRASCHALL.SETALLTRACKSSELECTED lua": {
        "prefix": "ultraschall.SetAllTracksSelected",
        "scope": "lua",
        "description": "Sets all tracks selected(if selected is true) of unselected(if selected is false)\nreturns -1 in case of error\nPARAMETERS:\nselected:true, if all tracks shall be selected, false if all shall be deselected\nRETURNS:\nretval:returns -1 in case of error\n",
        "body": "ultraschall.SetAllTracksSelected(${1:boolean selected})$0"
    },
    "ULTRASCHALL.SETTRACKSSELECTED lua": {
        "prefix": "ultraschall.SetTracksSelected",
        "scope": "lua",
        "description": "Sets tracks in trackstring selected. If reset is set to true, then the previous selection will be discarded.\nreturns -1 in case of error\nPARAMETERS:\ntrackstring:a string with the tracknumbers, separated by a comma; nil or \"\", deselects all\nreset:true, any previous selection will be discarded; false, it will be kept\nRETURNS:\nretval:returns -1 in case of error\n",
        "body": "ultraschall.SetTracksSelected(${1:string trackstring},${2:boolean reset})$0"
    },
    "ULTRASCHALL.SETTRACKSTOLOCKED lua": {
        "prefix": "ultraschall.SetTracksToLocked",
        "scope": "lua",
        "description": "sets tracks in trackstring locked.\nreturns false in case or error, true in case of success\nPARAMETERS:\ntrackstring:the tracknumbers, separated with a ,\nreset:reset lockedstate of other tracks\nRETURNS:\nretval:true in case of success, false in case of error\n",
        "body": "ultraschall.SetTracksToLocked(${1:string trackstring},${2:boolean reset})$0"
    },
    "ULTRASCHALL.SETTRACKSTOUNLOCKED lua": {
        "prefix": "ultraschall.SetTracksToUnlocked",
        "scope": "lua",
        "description": "sets tracks in trackstring unlocked.\nreturns false in case or error, true in case of success\nPARAMETERS:\ntrackstring:the tracknumbers, separated with a ,\nRETURNS:\nretval:true in case of success, false in case of error\n",
        "body": "ultraschall.SetTracksToUnlocked(${1:string trackstring})$0"
    },
    "ULTRASCHALL.SETTRACKSTATECHUNK_TRACKNUMBER lua": {
        "prefix": "ultraschall.SetTrackStateChunk_Tracknumber",
        "scope": "lua",
        "description": "Sets the trackstatechunk for track tracknumber. Undo flag is a performance/caching hint.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber, 0 for master track, 1 for track 1, 2 for track 2, etc.\ntrackstatechunk:the trackstatechunk, you want to set this track with\nundo:Undo flag is a performance/caching hint.\nRETURNS:\nretval:true in case of success; false in case of error\n",
        "body": "ultraschall.SetTrackStateChunk_Tracknumber(${1:integer tracknumber},${2:string trackstatechunk},${3:boolean undo})$0"
    },
    "ULTRASCHALL.SETTRACKGROUPFLAGSSTATE lua": {
        "prefix": "ultraschall.SetTrackGroupFlagsState",
        "scope": "lua",
        "description": "Set the GroupFlags-state of a track or trackstatechunk.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table can contain up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to set Volume Master(table entry 1) to checked in Group 1(2^0=1) and 3(2^2=4):\ngroups_bitfield_table[1]=groups_bitfield_table[1]+1+4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThis function will work only for Groups 1 to 32. To set Groups 33 to 64, use SetTrackGroupFlags_HighState instead!\nReturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\ngroups_bitfield_table:an array with all bitfields with all groupflag-settings\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackGroupFlagsState(${1:integer tracknumber},${2:array groups_bitfield_table},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKGROUPFLAGS_HIGHSTATE lua": {
        "prefix": "ultraschall.SetTrackGroupFlags_HighState",
        "scope": "lua",
        "description": "Set the GroupFlags-state of a track or trackstatechunk.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table can contain up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to set Volume Master(table entry 1) to checked in Group 33(2^0=1) and 35(2^2=4):\ngroups_bitfield_table[1]=groups_bitfield_table[1]+1+4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThis function will work only for Groups 33(2^0) to 64(2^31). To set Groups 1 to 32, use SetTrackGroupFlagsState instead!\nReturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\ngroups_bitfield_table:an array with all bitfields with all groupflag-settings\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "ultraschall.SetTrackGroupFlags_HighState(${1:integer tracknumber},${2:array groups_bitfield_table},${3:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.PAUSE_FOLLOW_ONE_CYCLE lua": {
        "prefix": "ultraschall.pause_follow_one_cycle",
        "scope": "lua",
        "description": "Skips auto-follow-off-checking-script for one cycle.\nFollowMode in Ultraschall turns on Autoscrolling in a useable way. In addition, under certain circumstances, followmode will be turned off automatically.\nIf you experience this but want to avoid the follow-off-functionality, use this function.\nThis function is only relevant, if you want to develop scripts that work perfectly within the Ultraschall.fm-extension.\n",
        "body": "ultraschall.pause_follow_one_cycle()$0"
    },
    "ULTRASCHALL.ISTRACKSOUNDBOARD lua": {
        "prefix": "ultraschall.IsTrackSoundboard",
        "scope": "lua",
        "description": "Returns, if this track is a soundboard-track, means, contains an Ultraschall-Soundboard-plugin.\nOnly relevant in Ultraschall-installations\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\nretval:true, it is an Ultraschall-Soundboard-track; false, it is not\n",
        "body": "ultraschall.IsTrackSoundboard(${1:integer tracknumber})$0"
    },
    "ULTRASCHALL.ISTRACKSTUDIOLINK lua": {
        "prefix": "ultraschall.IsTrackStudioLink",
        "scope": "lua",
        "description": "Returns, if this track is a StudioLink-track, means, contains a StudioLink-Plugin\nOnly relevant in Ultraschall-installations\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\nretval:true, it is a StudioLink-track; false, it is not\n",
        "body": "ultraschall.IsTrackStudioLink(${1:integer tracknumber})$0"
    },
    "ULTRASCHALL.ISTRACKSTUDIOLINKONAIR lua": {
        "prefix": "ultraschall.IsTrackStudioLinkOnAir",
        "scope": "lua",
        "description": "Returns, if this track is a StudioLinkOnAir-track, means, contains a StudioLinkOnAir-Plugin\nOnly relevant in Ultraschall-installations\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\nretval:true, it is a StudioLinkOnAir-track; false, it is not\n",
        "body": "ultraschall.IsTrackStudioLinkOnAir(${1:integer tracknumber})$0"
    },
    "ULTRASCHALL.GETTYPEOFTRACK lua": {
        "prefix": "ultraschall.GetTypeOfTrack",
        "scope": "lua",
        "description": "Returns the tracktype of a specific track. Will return the type of the first valid SoundBoard, StudioLink, StudioLinkOnAir-plugin in the track-fx-chain.\nIf there are multiple valid plugins and therefore types, the second retval multiple will be set to true, else to false.\nOnly relevant in Ultraschall-installations\nreturns \"\", false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\ntype:Either \"StudioLink\", \"StudioLinkOnAir\", \"SoundBoard\" or \"Other\". \"\", in case of an error\nmultiple:true, the track has other valid plugins as well; false, it is a \"pure typed\" track\n",
        "body": "ultraschall.GetTypeOfTrack(${1:integer tracknumber})$0"
    },
    "ULTRASCHALL.GETALLAUXSENDRECEIVES2 lua": {
        "prefix": "ultraschall.GetAllAUXSendReceives2",
        "scope": "lua",
        "description": "returns a table with all AUX-SendReceive-settings of all tracks, excluding master-track\nlike GetAllAUXSendReceives, but returns the type of a track as well\nreturned table is of structure:\ntable[\"AllAUXSendReceive\"]=true                               - signals, this is an AllAUXSendReceive-table. Don't alter!\ntable[\"number\\_of_tracks\"]                                     - the number of tracks in this table, from track 1 to track n\ntable[tracknumber][\"type\"]                                    - type of the track, SoundBoard, StudioLink, StudioLinkOnAir or Other\ntable[tracknumber][\"AUXSendReceives_count\"]                   - the number of AUXSendReceives of tracknumber, beginning with 1\ntable[tracknumber][AUXSendReceivesIndex][\"recv\\_tracknumber\"] - the track, from which to receive audio in this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"post\\_pre_fader\"]   - the setting of post-pre-fader of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"volume\"]            - the volume of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\"]               - the panning of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mute\"]              - the mute-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mono\\_stereo\"]      - the mono/stereo-button-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"phase\"]             - the phase-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"chan\\_src\"]         - the audiochannel-source of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"snd\\_src\"]          - the send-to-channel-target of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\\_law\"]           - pan-law, default is -1\ntable[tracknumber][AUXSendReceivesIndex][\"midichanflag\"]      - the Midi-channel of this AUXSendReceivesIndex of tracknumber, leave it 0\ntable[tracknumber][AUXSendReceivesIndex][\"automation\"]        - the automation-mode of this AUXSendReceivesIndex  of tracknumber\nSee GetTrackAUXSendReceives for more details on the individual settings, stored in the entries.\nRETURNS:\nAllAUXSendReceives:a table with all SendReceive-entries of the current project.\nnumber_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "ultraschall.GetAllAUXSendReceives2()$0"
    },
    "ULTRASCHALL.GETALLHWOUTS2 lua": {
        "prefix": "ultraschall.GetAllHWOuts2",
        "scope": "lua",
        "description": "returns a table with all HWOut-settings of all tracks, including master-track(track index: 0)\nlike GetAllHWOuts but includes the type of a track as well\nreturned table is of structure:\ntable[\"HWOuts\"]=true                              - signals, this is a HWOuts-table; don't change that!\ntable[\"number\\_of_tracks\"]                         - the number of tracks in this table, from track 0(master) to track n\ntable[tracknumber][\"type\"]                        - type of the track, SoundBoard, StudioLink, StudioLinkOnAir or Other\ntable[tracknumber][\"HWOut_count\"]                 - the number of HWOuts of tracknumber, beginning with 1\ntable[tracknumber][HWOutIndex][\"outputchannel\"]   - the number of outputchannels of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"post\\_pre_fader\"] - the setting of post-pre-fader of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"volume\"]          - the volume of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\"]             - the panning of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"mute\"]            - the mute-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"phase\"]           - the phase-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"source\"]          - the source/input of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\\law\"]         - pan-law, default is -1\ntable[tracknumber][HWOutIndex][\"automationmode\"]  - the automation-mode of this HWOutIndex of tracknumber\nSee GetTrackHWOut for more details on the individual settings, stored in the entries.\nRETURNS:\nAllHWOuts:a table with all HWOuts of the current project.\nnumber_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "ultraschall.GetAllHWOuts2()$0"
    },
    "ULTRASCHALL.GETALLMAINSENDSTATES2 lua": {
        "prefix": "ultraschall.GetAllMainSendStates2",
        "scope": "lua",
        "description": "returns a table with all MainSend-settings of all tracks, excluding master-track.\nlike GetAllMainSendStates, but includes the type of the track as well.\nThe MainSend-settings are the settings, if a certain track sends it's signal to the Master Track\nreturned table is of structure:\nTable[\"number\\_of_tracks\"]            - The number of tracks in this table, from track 1 to track n\nTable[tracknumber][\"type\"]           - type of the track, SoundBoard, StudioLink, StudioLinkOnAir or Other\nTable[tracknumber][\"MainSend\"]       - Send to Master on(1) or off(1)\nTable[tracknumber][\"ParentChannels\"] - the parent channels of this track\nSee GetTrackMainSendState for more details on the individual settings, stored in the entries.\nRETURNS:\nAllMainSends:a table with all AllMainSends-entries of the current project.\ninteger number_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "ultraschall.GetAllMainSendStates2()$0"
    },
    "ULTRASCHALL.DELETEUSEXTERNALSTATE lua": {
        "prefix": "ultraschall.DeleteUSExternalState",
        "scope": "lua",
        "description": "Deletes an external state from the ultraschall.ini\nReturns false in case of error.\nPARAMETERS:\nsection:the section, in which the to be deleted-key is located\nkey:the key to delete\nfilename:set this to a filename, if you don't want to use ultraschall.ini; it will be stored into the resource-path of Reaper, so no path needed\nRETURNS:\nretval:false in case of error; true in case of success\n",
        "body": "ultraschall.DeleteUSExternalState(${1:string section},${2:string key},${3:optional string filename})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_STOPALLSOUNDS lua": {
        "prefix": "ultraschall.Soundboard_StopAllSounds",
        "scope": "lua",
        "description": "Stops all sounds currently playing in the Ultraschall-SoundBoard\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\n",
        "body": "ultraschall.Soundboard_StopAllSounds()$0"
    },
    "ULTRASCHALL.SOUNDBOARD_TOGGLEPLAYPAUSE lua": {
        "prefix": "ultraschall.Soundboard_TogglePlayPause",
        "scope": "lua",
        "description": "Toggles between Play and Pause of a certain player in the Ultraschall-SoundBoard\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nPARAMETERS:\nplayerindex:the player of the SoundBoard; from 1-24\n",
        "body": "ultraschall.Soundboard_TogglePlayPause(${1:integer playerindex})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_TOGGLEPLAYSTOP lua": {
        "prefix": "ultraschall.Soundboard_TogglePlayStop",
        "scope": "lua",
        "description": "Toggles between Play and Stop of a certain player in the Ultraschall-SoundBoard\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nPARAMETERS:\nplayerindex:the player of the SoundBoard; from 1-24\n",
        "body": "ultraschall.Soundboard_TogglePlayStop(${1:integer playerindex})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_PLAY lua": {
        "prefix": "ultraschall.Soundboard_Play",
        "scope": "lua",
        "description": "Starts playing of a certain player in the Ultraschall-SoundBoard\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nPARAMETERS:\nplayerindex:the player of the SoundBoard; from 1-24\n",
        "body": "ultraschall.Soundboard_Play(${1:integer playerindex})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_STOP lua": {
        "prefix": "ultraschall.Soundboard_Stop",
        "scope": "lua",
        "description": "Stops playing of a certain player in the Ultraschall-SoundBoard\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nPARAMETERS:\nplayerindex:the player of the SoundBoard; from 1-24\n",
        "body": "ultraschall.Soundboard_Stop(${1:integer playerindex})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_TOGGLEPLAY_FADEOUTSTOP lua": {
        "prefix": "ultraschall.Soundboard_TogglePlay_FadeOutStop",
        "scope": "lua",
        "description": "Toggles between Play and FadeOut with Stop of a certain player in the Ultraschall-SoundBoard\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nPARAMETERS:\nplayerindex:the player of the SoundBoard; from 1-24\n",
        "body": "ultraschall.Soundboard_TogglePlay_FadeOutStop(${1:integer playerindex})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_PLAYLIST_CURRENTINDEX lua": {
        "prefix": "ultraschall.Soundboard_PlayList_CurrentIndex",
        "scope": "lua",
        "description": "Returns the position within the playlist of the Ultraschall Soundboard.\nPlaylist means, the player within all players of the Ultraschall-Soundboard.\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nFor other playlist-related functions, see also SoundBoard\\_PlayList\\_SetIndex](#SoundBoard_PlayList_SetIndex), [SoundBoard\\_PlayList\\_Next](#SoundBoard_PlayList_Next) and [SoundBoard\\_PlayList\\_Previous\nRETURNS:\ncurrent_playlist_position:the position in the playlist\n",
        "body": "ultraschall.Soundboard_PlayList_CurrentIndex()$0"
    },
    "ULTRASCHALL.SOUNDBOARD_PLAYLIST_SETINDEX lua": {
        "prefix": "ultraschall.Soundboard_PlayList_SetIndex",
        "scope": "lua",
        "description": "sets a new playerindex within the playlist of the Ultraschall-Soundboard.\nYou can optionally start the player and stop all others currently playing.\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nFor other playlist-related functions, see also Soundboard\\_PlayList\\_CurrentIndex](#Soundboard_PlayList_CurrentIndex), [SoundBoard\\_PlayList\\_Next](#SoundBoard_PlayList_Next) and [SoundBoard\\_PlayList\\_Previous\nPARAMETERS:\nplayerindex:the player of the SoundBoard; from 1-24\nplay:true, start playing of this player immediately; nil or false, don't start playing\nstop_all_others:true, stop all other players currently playing; nil or false, don't stop anything\n",
        "body": "ultraschall.Soundboard_PlayList_SetIndex(${1:integer playerindex},${2:optional boolean play},${3:optional boolean stop_all_others})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_PLAYLIST_NEXT lua": {
        "prefix": "ultraschall.Soundboard_PlayList_Next",
        "scope": "lua",
        "description": "Stops current player and starts the next player within the playlist of the Ultraschall-Soundboard.\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nFor other playlist-related functions, see also Soundboard\\_PlayList\\_CurrentIndex](#Soundboard_PlayList_CurrentIndex), [SoundBoard\\_PlayList\\_SetIndex](#SoundBoard_PlayList_SetIndex) and [SoundBoard\\_PlayList\\_Previous\n",
        "body": "ultraschall.Soundboard_PlayList_Next()$0"
    },
    "ULTRASCHALL.SOUNDBOARD_PLAYLIST_PREVIOUS lua": {
        "prefix": "ultraschall.Soundboard_PlayList_Previous",
        "scope": "lua",
        "description": "Stops current player and starts the previous player within the playlist of the Ultraschall-Soundboard.\nWhen the previous would be before the first, it will not do anything.\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nFor other playlist-related functions, see also Soundboard\\_PlayList\\_CurrentIndex](#Soundboard_PlayList_CurrentIndex), [SoundBoard\\_PlayList\\_SetIndex](#SoundBoard_PlayList_SetIndex) and [SoundBoard\\_PlayList\\_Next.\n",
        "body": "ultraschall.Soundboard_PlayList_Previous()$0"
    },
    "ULTRASCHALL.SOUNDBOARD_PLAYFADEIN lua": {
        "prefix": "ultraschall.Soundboard_PlayFadeIn",
        "scope": "lua",
        "description": "Starts a sound with a fade-in of a certain player in the Ultraschall-SoundBoard\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nPARAMETERS:\nplayerindex:the player of the SoundBoard; from 1-24\n",
        "body": "ultraschall.Soundboard_PlayFadeIn(${1:integer playerindex})$0"
    },
    "ULTRASCHALL.WEBINTERFACE_GETINSTALLEDINTERFACES lua": {
        "prefix": "ultraschall.WebInterface_GetInstalledInterfaces",
        "scope": "lua",
        "description": "Returns the currently installed web-interface-pages.\nWill return Reaper's default ones(resources-folder/Plugins/reaper_www_root/) as well as your customized ones(resources-folder/reaper_www_root/)\nRETURNS:\nreapers_count_of_webinterface:the number of factory-default webinterfaces, installed by Reaper\nreapers_webinterface_filenames_with_path:the filenames with path of the webinterfaces(can be .htm or .html)\nreapers_webinterface_titles:the titles of the webinterfaces, as shown in the titlebar of the browser\nusers_count_of_webinterface:the number of user-customized webinterfaces\nusers_webinterface_filenames_with_path:the filenames with path of the webinterfaces(can be .htm or .html)\nusers_webinterface_titles:the titles of the webinterfaces, as shown in the titlebar of the browser\n",
        "body": "ultraschall.WebInterface_GetInstalledInterfaces()$0"
    },
    "ULTRASCHALL.DOCS_CONVERTPLAINTEXTTOHTML_WR lua": {
        "prefix": "ultraschallwr.Docs_ConvertPlainTextToHTML",
        "scope": "lua",
        "description": "Converts a plaintext into HTML.\nConverts newlines to , Double Spaces to \u00a0\u00a0 and Tabs to\nreturns nil in case of an error\nRETURNS:\nhtml_text:the html-version of the text\n",
        "body": "${1:local }${2:string html_text} = ultraschall.Docs_ConvertPlainTextToHTML(${3:string String})$0"
    },
    "ULTRASCHALL.DOCS_REMOVEINDENT_WR lua": {
        "prefix": "ultraschallwr.Docs_RemoveIndent",
        "scope": "lua",
        "description": "unindents an indented text from a US_DocBloc.\nThere are different styles of unindentation:\nas_typed - keeps the text, as it is\nminus_starts_line - will throw away everything from start of the line until(and including) the firt - in it\npreceding_spaces - will remove all spaces/tabs in the beginning of each line\ndefault - will take the indentation of the first line and apply it to each of the following lines\nthat means, indentation relative to the first line is kept\nreturns nil in case of an error\nPARAMETERS:\nString:the string, which shall be unindented\nindenttype:the type of indentation you want to remove\nRETURNS:\nunindented_text:the string, from which the indentation was removed\n",
        "body": "${1:local }${2:string unindented_text} = ultraschall.Docs_RemoveIndent(${3:string String},${4:string indenttype})$0"
    },
    "ULTRASCHALL.DOCS_GETALLUSDOCBLOCSFROMSTRING_WR lua": {
        "prefix": "ultraschallwr.Docs_GetAllUSDocBlocsFromString",
        "scope": "lua",
        "description": "returns all US_DocBloc-elements from a string.\nreturns nil in case of an error\nPARAMETERS:\nString:a string, from which to retrieve the US_DocBlocs\nRETURNS:\nfound_usdocblocs:the individual US_DocBlocs found in the string\nall_found_usdocblocs:the individual US_DocBlocs found in the string\n",
        "body": "${1:local }${2:integer found_usdocblocs},${3:array all_found_usdocblocs} = ultraschall.Docs_GetAllUSDocBlocsFromString(${4:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_SLUG_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Slug",
        "scope": "lua",
        "description": "returns the slug from an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the slug from\nRETURNS:\nslug:the slug, as stored in the USDocBloc\n",
        "body": "${1:local }${2:string slug} = ultraschall.Docs_GetUSDocBloc_Slug(${3:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_TITLE_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Title",
        "scope": "lua",
        "description": "returns the title from an US_DocBloc-element.\nThere can be multiple titles, e.g. in multiple languages\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the title from\nindex:the index of the title to get, starting with 1 for the first title\nRETURNS:\ntitle:the title, as stored in the USDocBloc\nspok_lang:the language, in which the title is stored\n",
        "body": "${1:local }${2:string title},${3:string spok_lang} = ultraschall.Docs_GetUSDocBloc_Title(${4:string String},${5:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_DESCRIPTION_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Description",
        "scope": "lua",
        "description": "returns the description-text from an US_DocBloc-element.\nThere can be multiple descriptions, e.g. in multiple languages\nIt will remove automatically indentation(as requested by the description-tag of the US_DocBloc), if unindent_description==true.\nIf no indentation is requested by the description-tag, it will assume default(the indentation of the first line will be applied to all other lines).\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the description from\nunindent_description:true, will remove indentation as given in the description-tag; false, return the text as it is\nindex:the index of the description to get, starting with 1 for the first description\nRETURNS:\ndescription:the description-text found in the USDocBloc in the string\nmarkup_type:the markup-type the description is written in\nmarkup_version:the version of the markup-language, in which the description is written in\nindent:the indentation of the text; can be either\nlanguage:the language, in which the description is written in; \"\", if not set\nprog_lang:the programming-language, in which the description is written in; \", if not set\n",
        "body": "${1:local }${2:string description},${3:string markup_type},${4:string markup_version},${5:string indent},${6:optional string language},${7:optional string prog_lang} = ultraschall.Docs_GetUSDocBloc_Description(${8:string String},${9:boolean unindent_description},${10:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_TARGETDOCUMENT_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_TargetDocument",
        "scope": "lua",
        "description": "returns the target-document from an US_DocBloc-element.\nThe target-document is the document, into which the converted DocBloc shall be stored into.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the target-document-entry from\nRETURNS:\ntarget_document:the target-document, into which the converted US_DocBloc shall be stored into\n",
        "body": "${1:local }${2:string target_document} = ultraschall.Docs_GetUSDocBloc_TargetDocument(${3:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_SOURCEDOCUMENT_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_SourceDocument",
        "scope": "lua",
        "description": "returns the source-document from an US_DocBloc-element.\nThe source-document is the document, into which the converted DocBloc shall be stored into.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the source-document-entry from\nRETURNS:\nsource_document:the source-document, into which the converted US_DocBloc shall be stored into\n",
        "body": "${1:local }${2:string source_document} = ultraschall.Docs_GetUSDocBloc_SourceDocument(${3:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_CHAPTERCONTEXT_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_ChapterContext",
        "scope": "lua",
        "description": "returns the chapters and subchapters, in which the US_DocBloc shall be stored into\nA US_DocBloc can have multiple chapter-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the source-document-entry from\nindex:the index of the chapter-entries, starting with 1 for the first\nRETURNS:\ncount:the number of chapters found\nchapters:the chapternams as an array\nspok_lang:the language of the chapters; \"\", if no language is given\n",
        "body": "${1:local }${2:integer count},${3:array chapters},${4:string spok_lang} = ultraschall.Docs_GetUSDocBloc_ChapterContext(${5:string String},${6:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_TAGS_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Tags",
        "scope": "lua",
        "description": "returns the tags of an US_DocBloc-entry\nA US_DocBloc can have multiple tag-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the tags-entry from\nindex:the index of the tags-entries, starting with 1 for the first\nRETURNS:\ncount:the number of tags found\ntags:the tags as an array\nspok_lang:the language of the tags; \"\" if no language is given\n",
        "body": "${1:local }${2:integer count},${3:array tags},${4:string spok_lang} = ultraschall.Docs_GetUSDocBloc_Tags(${5:string String},${6:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_PARAMS_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Params",
        "scope": "lua",
        "description": "returns the parameters of an US_DocBloc-entry\nA US_DocBloc can have multiple parameter-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the parameter-entry from\nunindent_description:true, will remove indentation as given in the parameter-tag; false, return the text as it is\nindex:the index of the parameter-entries, starting with 1 for the first\nRETURNS:\nparmcount:the number of parameters found\nParams:all parameters found, as an array\nmarkuptype:the markuptype found; if no markuptype is given, it returns \"plaintext\"\nmarkupversion:the version of the markuptype found; \"\", if not given\nprog_lang:the programming-language used in these parameters; \"\", if not given\nspok_lang:the spoken-language used in these parameters; \"\", if not given\nindent:the type of indentation you want to remove\n",
        "body": "${1:local }${2:integer parmcount},${3:table Params},${4:string markuptype},${5:string markupversion},${6:string prog_lang},${7:string spok_lang},${8:string indent} = ultraschall.Docs_GetUSDocBloc_Params(${9:string String},${10:boolean unindent_description},${11:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_RETVALS_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Retvals",
        "scope": "lua",
        "description": "returns the retvals of an US_DocBloc-entry\nA US_DocBloc can have multiple retvals-entries, e.g. for multiple languages.\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the retvals-entry from\nunindent_description:true, will remove indentation as given in the retvals-tag; false, return the text as it is\nindex:the index of the retvals-entries, starting with 1 for the first\nRETURNS:\nretvalscount:the number of retvals found\nretvals:all retvals found, as an array\nmarkuptype:the markuptype found; if no markuptype is given, it returns \"plaintext\"\nmarkupversion:the version of the markuptype found; \"\", if not given\nprog_lang:the programming-language used in these retvals; \"\", if not given\nspok_lang:the spoken-language used in these retvals; \"\", if not given\nindent:the type of indentation you want to remove\n",
        "body": "${1:local }${2:integer retvalscount},${3:table retvals},${4:string markuptype},${5:string markupversion},${6:string prog_lang},${7:string spok_lang},${8:string indent} = ultraschall.Docs_GetUSDocBloc_Retvals(${9:string String},${10:boolean unindent_description},${11:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_FUNCTIONCALL_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Functioncall",
        "scope": "lua",
        "description": "returns the functioncall-entries from an US_DocBloc-element\nThere can be multiple functioncall-entries, e.g. for multiple programming-languages\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the functioncall-entry from\nindex:the index of the functioncall, if there are multiple ones; beginning with 1\nRETURNS:\nfunctioncall:the functioncall, as stored in the USDocBloc\nprog_lang:the used programming language\n",
        "body": "${1:local }${2:string functioncall},${3:string prog_lang} = ultraschall.Docs_GetUSDocBloc_Functioncall(${4:string String},${5:integer index})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_REQUIRES_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_Requires",
        "scope": "lua",
        "description": "returns the requires-entries from an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the requires-entry from\nRETURNS:\ncount:the number of required elements found in the require-tag\nrequires:like requires, but the index is the required element, while the value is the versionnumber, e.g requires_alt[\"Reaper\"]=\"5.978\"\nrequires_alt:like requires, but the index is the required element, while the value is the versionnumber, e.g requires_alt[\"Reaper\"]=\"5.978\"\n",
        "body": "${1:local }${2:integer count},${3:array requires},${4:array requires_alt} = ultraschall.Docs_GetUSDocBloc_Requires(${5:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_PREVIOUSCHAPTER_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_PreviousChapter",
        "scope": "lua",
        "description": "returns the slug of the previous chapter of an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the slug of the previous chapter from\nRETURNS:\nprevious_chapter:the slug of the previous-chapter, as stored in the USDocBloc\n",
        "body": "${1:local }${2:string previous_chapter} = ultraschall.Docs_GetUSDocBloc_PreviousChapter(${3:string String})$0"
    },
    "ULTRASCHALL.DOCS_GETUSDOCBLOC_NEXTCHAPTER_WR lua": {
        "prefix": "ultraschallwr.Docs_GetUSDocBloc_NextChapter",
        "scope": "lua",
        "description": "returns the slug of the next chapter of an US_DocBloc-element\nreturns nil in case of an error\nPARAMETERS:\nString:a string which hold a US_DocBloc to retrieve the slug of the next chapter from\nRETURNS:\nnext_chapter:the slug of the next-chapter, as stored in the USDocBloc\n",
        "body": "${1:local }${2:string next_chapter} = ultraschall.Docs_GetUSDocBloc_NextChapter(${3:string String})$0"
    },
    "ULTRASCHALL.COUNTPROJECTTABS_WR lua": {
        "prefix": "ultraschallwr.CountProjectTabs",
        "scope": "lua",
        "description": "Counts the number of opened project tabs.\nRETURNS:\nnumber_of_projecttabs:the number of projecttabs currently opened\n",
        "body": "${1:local }${2:integer number_of_projecttabs} = ultraschall.CountProjectTabs()$0"
    },
    "ULTRASCHALL.GETPROJECT_TABS_WR lua": {
        "prefix": "ultraschallwr.GetProject_Tabs",
        "scope": "lua",
        "description": "Returns the ReaProject-objects, as well as the filenames of all opened project-tabs.\nRETURNS:\nnumber_of_projecttabs:the number of projecttabs currently opened\nprojecttablist:an array, that holds all ReaProjects as well as the projectfilenames\n",
        "body": "${1:local }${2:integer number_of_projecttabs},${3:array projecttablist} = ultraschall.GetProject_Tabs()$0"
    },
    "ULTRASCHALL.GETAPIVERSION_WR lua": {
        "prefix": "ultraschallwr.GetApiVersion",
        "scope": "lua",
        "description": "returns the version, release-date and if it's a beta-version plus the currently installed hotfix\nRETURNS:\nversionnumber:a number, that you can use for comparisons like, \"if requestedversion>versionnumber then\"\nmajorversion:the current Api-major-version\ndate:the release-date of the currently installed hotfix ($ResourceFolder/ultraschall_api/ultraschall_hotfixes.lua); XX_XXX_XXXX if no hotfix is installed currently\nsubversion:a subversion-number of a major-version\ntagline:the tagline of the current release\nbuildnumber:the build-number of the current release\n",
        "body": "${1:local }${2:number versionnumber},${3:string majorversion},${4:string date},${5:string subversion},${6:string tagline},${7:string buildnumber} = ultraschall.GetApiVersion()$0"
    },
    "ULTRASCHALL.SUPPRESSERRORMESSAGES_WR lua": {
        "prefix": "ultraschallwr.SuppressErrorMessages",
        "scope": "lua",
        "description": "Allows you to suppress error-messages.\nIf you pass true, all error messages will be suppressed, until you run the function again passing false.\nNote: You should supress error-messages only temprarily and \"unsuppress\" them again, after your critical stuff is finished.\nOtherwise, someone using your functions will have no error-messages to debug with.\nReturns false, if parameter isn't boolean. Unlike most other function, this will never create an error-message!\nPARAMETERS:\nflag:true, suppress error-messages; false, don't suppress error-messages\nRETURNS:\nretval:true, setting was successful; false, you didn't pass a boolean as parameter\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SuppressErrorMessages(${3:boolean flag})$0"
    },
    "ULTRASCHALL.ADDERRORMESSAGE_WR lua": {
        "prefix": "ultraschallwr.AddErrorMessage",
        "scope": "lua",
        "description": "Adds a new errormessage to the Ultraschall-Api-Error-messagesystem. Returns the number of the errormessage.\nIntended for your own 3rd party-functions for the API, to give the user more feedback about errors than just a cryptic errorcode.\nreturns false in case of failure\nPARAMETERS:\nfunctionname:the function, where the error happened\nparametername:the parameter, that caused the problem\nerrormessage:a longer description of what cause the problem and a hint to a possible solution\nerrorcode:a number, that represents the error-message. Will be -1 by default, if not given.\nRETURNS:\nretval:true, if it worked; false if it didn't\nerrorcount:the number of the errormessage within the Ultraschall-Api-Error-messagesystem; nil, if errormessages are suppressed currently\n",
        "body": "${1:local }${2:boolean retval},${3:integer errorcount} = ultraschall.AddErrorMessage(${4:string functionname},${5:string parametername},${6:string errormessage},${7:integer errorcode})$0"
    },
    "ULTRASCHALL.TOGGLEIDE_ERRORMESSAGES_WR lua": {
        "prefix": "ultraschallwr.ToggleIDE_Errormessages",
        "scope": "lua",
        "description": "Toggles or sets, if the error-messaging system shall output it's errors to Reaper's IDE(true) or not(false).\nWhen set true, it will show the errormessages at the bottom of the IDE, as you are used by Reaper's own functions.\nPARAMETERS:\ntogglevalue:true, if errormessages shall be shown at the bottom of the IDE, false if not. If omitted, it toggles what was set before.\nRETURNS:\nretval:true, if errors will be shown at the bottom of the IDE; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ToggleIDE_Errormessages(${3:optional boolean togglevalue})$0"
    },
    "ULTRASCHALL.READERRORMESSAGE_WR lua": {
        "prefix": "ultraschallwr.ReadErrorMessage",
        "scope": "lua",
        "description": "Reads an error-message within the Ultraschall-ErrorMessagesystem.\nReturns a boolean value, the functionname, the errormessage, the \"you've already read this message\"-status, the date and a timestamp of the creation of the errormessage.\nreturns false in case of failure\nPARAMETERS:\nerrornumber:the number of the error, beginning with 1. Use CountErrorMessages to get the current number of error-messages.\nRETURNS:\nretval:true, if it worked; false if it didn't\nerrcode:the errorcode of this message, as set by the function that created this errormessage; -1 is default value\nfunctionname:the name of the function, where the problem happened\nparmname:the parameter, that was used wrong by the programmer; \"\" if no parameter was involved in this error\nerrormessage:the message of the problem with a possible hint to a solution\nerr_creation_date:the date_time of when the error-message was created\nerr_creation_timestamp:the timestamp of when the error-message was created. Usually seconds, since system got started\n",
        "body": "${1:local }${2:boolean retval},${3:integer errcode},${4:string functionname},${5:string parmname},${6:string errormessage},${7:string lastreadtime},${8:string err_creation_date},${9:string err_creation_timestamp} = ultraschall.ReadErrorMessage(${10:integer errornumber})$0"
    },
    "ULTRASCHALL.DELETEERRORMESSAGE_WR lua": {
        "prefix": "ultraschallwr.DeleteErrorMessage",
        "scope": "lua",
        "description": "Deletes an error-message within the Ultraschall-ErrorMessagesystem.\nreturns false in case of failure\nPARAMETERS:\nerrornumber:the number of the error to delete, beginning with 1. Use CountErrorMessages to get the current number of error-messages.\nRETURNS:\nretval:true, if such an error exists; false if it didn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteErrorMessage(${3:integer errornumber})$0"
    },
    "ULTRASCHALL.GETLASTERRORMESSAGE_WR lua": {
        "prefix": "ultraschallwr.GetLastErrorMessage",
        "scope": "lua",
        "description": "Reads the last error-message stored in the Ultraschall-ErrorMessagesystem.\nReturns a boolean value, the functionname, the errormessage, the date and a timestamp of the creation of the errormessage, the unread-status as well as the error-message-number.\nreturns false in case of failure\nRETURNS:\nretval:true, if it worked; false if it didn't\nerrcode:the errorcode of this message, as set by the function that created this errormessage; -1 is default value\nfunctionname:the name of the function, where the problem happened\nparmname:the parameter, that was used wrong by the programmer; \"\" if no parameter was involved in this error\nerrormessage:the message of the problem with a possible hint to a solution\nerr_creation_date:the date_time of when the error-message was created\nerr_creation_timestamp:the timestamp of when the error-message was created. Usually seconds, since system got started\nerrorcounter:the error-message-number within the Ultraschall-Error-Message-System\n",
        "body": "${1:local }${2:boolean retval},${3:integer errcode},${4:string functionname},${5:string parmname},${6:string errormessage},${7:string lastreadtime},${8:string err_creation_date},${9:string err_creation_timestamp},${10:integer errorcounter} = ultraschall.GetLastErrorMessage()$0"
    },
    "ULTRASCHALL.DELETELASTERRORMESSAGE_WR lua": {
        "prefix": "ultraschallwr.DeleteLastErrorMessage",
        "scope": "lua",
        "description": "Deletes the last error-message and returns a boolean value.\nreturns false in case of failure\nRETURNS:\nretval:true, if it worked; false if it didn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteLastErrorMessage()$0"
    },
    "ULTRASCHALL.DELETEALLERRORMESSAGES_WR lua": {
        "prefix": "ultraschallwr.DeleteAllErrorMessages",
        "scope": "lua",
        "description": "Deletes all error-messages and returns a boolean value.\nreturns false in case of failure\nRETURNS:\nretval:true, if it worked; false if it didn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteAllErrorMessages()$0"
    },
    "ULTRASCHALL.GETLASTERRORMESSAGE2_WR lua": {
        "prefix": "ultraschallwr.GetLastErrorMessage2",
        "scope": "lua",
        "description": "Returns an array with the last \"count\" errormessages. 1 for the last, 2 for the last 2, etc.\nSet setread to false, if you want to retain the unread status of the error-messages.\nreturns false in case of failure\nPARAMETERS:\ncount:the number of the last few errors, you want to get returned. Use CountErrorMessages to get the current number of error-messages.\nRETURNS:\nretval:true, if it worked; false if it didn't\nErrorMessages:an array, that contains all values for the chosen number of errormessages.\n",
        "body": "${1:local }${2:boolean retval},${3:array ErrorMessages} = ultraschall.GetLastErrorMessage2(${4:integer count},${5:boolean setread})$0"
    },
    "ULTRASCHALL.COUNTERRORMESSAGES_WR lua": {
        "prefix": "ultraschallwr.CountErrorMessages",
        "scope": "lua",
        "description": "Returns the current count of errormessages in the system available.\nRETURNS:\nerrorcounter:the number of errormessages currently available in the error-message-system. Includes read and unread ones.\n",
        "body": "${1:local }${2:integer errorcounter} = ultraschall.CountErrorMessages()$0"
    },
    "ULTRASCHALL.GETLASTERRORMESSAGE_FUNCNAME_WR lua": {
        "prefix": "ultraschallwr.GetLastErrorMessage_Funcname",
        "scope": "lua",
        "description": "Returns the last errormessage, a certain function added to the Error-Messaging-System.\nSets read-state of the error-message to the date-time of accessing it.\nreturns -1 in case of error\nPARAMETERS:\nfunctionname:the name of the function, whose last error message you want to retrieve\nRETURNS:\nerrorindex:the index of the error within the Error-Messaging-System\nparametername:the parameter that produced the problem, or \"\" if no parameter was involved\nerrormessage:the errormessage\nerrorcode:the errorcode the error has\n",
        "body": "${1:local }${2:integer errorindex},${3:string parametername},${4:string errormessage},${5:integer errorcode} = ultraschall.GetLastErrorMessage_Funcname(${6:string functionname})$0"
    },
    "ULTRASCHALL.COUNTERRORMESSAGE_FUNCNAME_WR lua": {
        "prefix": "ultraschallwr.CountErrorMessage_Funcname",
        "scope": "lua",
        "description": "Returns the number of available errormessages for functionname, existing in the Error-Messaging-System.\nreturns -1 in case of error\nPARAMETERS:\nfunctionname:the name of the function, whose error messages you want to count\nRETURNS:\nnumber_of_errormessages:the number of errormessages functionname has left in the Error-Messaging-System\n",
        "body": "${1:local }${2:integer number_of_errormessages} = ultraschall.CountErrorMessage_Funcname(${3:string functionname})$0"
    },
    "ULTRASCHALL.GETERRORMESSAGE_FUNCNAME_WR lua": {
        "prefix": "ultraschallwr.GetErrorMessage_Funcname",
        "scope": "lua",
        "description": "Returns a specific errormessage specified by index, functionname added to the Error-Messaging-System.\nSets read-state of the error-message to the date-time of accessing it.\nreturns -1 in case of error\nPARAMETERS:\nfunctionname:the name of the function, whose last error message you want to retrieve\nindex:the index of the error-message for functionname\nRETURNS:\nerrorindex:the index of the error within the Error-Messaging-System\nparametername:the parameter that produced the problem, or \"\" if no parameter was involved\nerrormessage:the errormessage\nerrorcode:the errorcode the error has\n",
        "body": "${1:local }${2:integer errorindex},${3:string parametername},${4:string errormessage},${5:integer errorcode} = ultraschall.GetErrorMessage_Funcname(${6:string functionname},${7:integer index})$0"
    },
    "ULTRASCHALL.WINTERLYSNOWFLAKES_WR lua": {
        "prefix": "ultraschallwr.WinterlySnowflakes",
        "scope": "lua",
        "description": "Exchanges the gfx.update()-function with a variant, that displays falling snowflakes everytime it is called.\nreturns -1 in case of error\nPARAMETERS:\ntoggle:true, toggles falling snow on; false, toggles falling snow off\nfalling_speed:the falling speed of the snowflakes, 1.3 is recommended\nnumber_snowflakes:the number of falling snowflakes at the same time on screen; 2000 is recommended\nRETURNS:\nretval:returns -1 in case of a'JS_Window_ListFind' n error; 1, in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.WinterlySnowflakes(${3:boolean toggle},${4:number falling_speed},${5:integer number_snowflakes})$0"
    },
    "ULTRASCHALL.CHECKACTIONCOMMANDIDFORMAT_WR lua": {
        "prefix": "ultraschallwr.CheckActionCommandIDFormat",
        "scope": "lua",
        "description": "Checks, whether an action command id is a valid commandid(which is a number) or a valid _action_command_id (which is a string with an _underscore in the beginning).\nDoes not check, whether this action_command_id is a useable one, only if it's \"syntax\" is correct!\nreturns falsein case of an error\nPARAMETERS:\n:the ActionCommandID you want to check; either a number or an action_command_id with an underscore at the beginning\nRETURNS:\nretval:true, valid action_command_id; false, not a valid action_command_id\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.CheckActionCommandIDFormat(${3:action_command_id})$0"
    },
    "ULTRASCHALL.RUNCOMMAND_WR lua": {
        "prefix": "ultraschallwr.RunCommand",
        "scope": "lua",
        "description": "runs a command by its ActionCommandID(instead of the CommandID-number)\nreturns -1 in case of error\nPARAMETERS:\nactioncommand_id:the ActionCommandID of the Command/Script/Action you want to run; must be either a number or the ActionCommandID beginning with an underscore _\nRETURNS:\nretval:-1, in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.RunCommand(${3:string actioncommand_id})$0"
    },
    "ULTRASCHALL.CONVERTSTRINGTOBITS_WR lua": {
        "prefix": "ultraschallwr.ConvertStringToBits",
        "scope": "lua",
        "description": "converts a string into its bit-representation and returns that as a handy table\nreturns -1 in case of an error\nPARAMETERS:\nmessage:the string, which you want to convert into its bit representation\nRETURNS:\nnumber_of_bits:the number of bits in the string, -1, in case of an error\nbitarray:the individual bits as a handy table\n",
        "body": "${1:local }${2:integer number_of_bits},${3:array bitarray} = ultraschall.ConvertStringToBits(${4:string message})$0"
    },
    "ULTRASCHALL.CONVERTBITSTOSTRING_WR lua": {
        "prefix": "ultraschallwr.ConvertBitsToString",
        "scope": "lua",
        "description": "converts a table of bit-representation into a string\nEvery entry in the table must be either 0 or 1. If there are too few bits to fill up a byte, the missing bits will be seen as trailing 0-bits.\nreturns nil in case of an error\nPARAMETERS:\nbitarray:the individual bits in a table, which will be converted into a string-representation\nRETURNS:\nmessage:the converted bits as string-representation\n",
        "body": "${1:local }${2:string message} = ultraschall.ConvertBitsToString(${3:array bitarray})$0"
    },
    "ULTRASCHALL.FLOATCOMPARE_WR lua": {
        "prefix": "ultraschallwr.FloatCompare",
        "scope": "lua",
        "description": "Compares two floatvalues and allows to set the precision to copmare against.\nSo, if you want to compare 5.1 and 5.2, using precision=0.2 returns true(is equal), precision=0.1 returns false(isn't equal).\nReturns nil in case of failure.\nPARAMETERS:\na:the first float-number to compare\nb:the precision of the fraction, like 0.1 or 0.0063\nprecision:the precision of the fraction, like 0.1 or 0.0063\nRETURNS:\nretval:true, numbers are equal; false, numbers aren't equal\ndiff:the difference between numbers a and b\n",
        "body": "${1:local }${2:boolean retval},${3:number diff} = ultraschall.FloatCompare(${4:number a},${5:number b},${6:number precision})$0"
    },
    "ULTRASCHALL.ESCAPEMAGICCHARACTERS_STRING_WR lua": {
        "prefix": "ultraschallwr.EscapeMagicCharacters_String",
        "scope": "lua",
        "description": "Escapes the magic characters(needed for pattern matching), so the string can be fed as is into string.match-functions.\nThat way, characters like . or - or * etc do not trigger pattern-matching behavior but are used as regular . or - or * etc.\nreturns nil in case of an error\nPARAMETERS:\nsourcestring:the string, whose magic characters you want to escape for future use\nRETURNS:\nescaped_string:the string with all magic characters escaped\n",
        "body": "${1:local }${2:string escaped_string} = ultraschall.EscapeMagicCharacters_String(${3:string sourcestring})$0"
    },
    "ULTRASCHALL.ACTIONSLIST_GETSELECTEDACTIONS_WR lua": {
        "prefix": "ultraschallwr.ActionsList_GetSelectedActions",
        "scope": "lua",
        "description": "returns the selected entries from the actionlist, when opened.\nThe order of the tables of found actions, ActionCommandIDs and ToggleStates is the same in all of the three tables.\nThey also reflect the order of userselection in the ActionList itself from top to bottom of the ActionList.\nreturns -1 in case of an error\nRETURNS:\nnum_found_actions:the number of selected actions; -1, if not opened\nsectionID:the id of the section, from which the selected actions are from\nsectionName:the name of the selected section\nselected_actions:the texts of the found actions as a handy table\nCmdIDs:the ActionCommandIDs of the found actions as a handy table; all of them are strings, even the numbers, but can be converted using Reaper's own function reaper.NamedCommandLookup\nToggleStates:the current toggle-states of the selected actions; 1, on; 0, off; -1, no such toggle state available\n",
        "body": "${1:local }${2:integer num_found_actions},${3:integer sectionID},${4:string sectionName},${5:table selected_actions},${6:table CmdIDs},${7:table ToggleStates} = ultraschall.ActionsList_GetSelectedActions()$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDEROUTPUTPATH_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderOutputPath",
        "scope": "lua",
        "description": "returns the output-directory for rendered files of a project.\nDoesn't return the correct output-directory for queued-projects!\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename with path, whose renderoutput-directories you want to know\nRETURNS:\nrender_output_directory:the output-directory for projects\n",
        "body": "${1:local }${2:string render_output_directory} = ultraschall.GetProject_RenderOutputPath(${3:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.RESOLVERENDERPATTERN_WR lua": {
        "prefix": "ultraschallwr.ResolveRenderPattern",
        "scope": "lua",
        "description": "resolves a render-pattern into its render-filename(without extension).\nreturns nil in case of an error\nPARAMETERS:\nrender_pattern:the render-pattern, that you want to resolve into its render-filename\nRETURNS:\nresolved_renderpattern:the resolved renderpattern, that is used for a render-filename.\n",
        "body": "${1:local }${2:string resolved_renderpattern} = ultraschall.ResolveRenderPattern(${3:string render_pattern})$0"
    },
    "ULTRASCHALL.SETREASCRIPTCONSOLE_FONTSTYLE_WR lua": {
        "prefix": "ultraschallwr.SetReaScriptConsole_FontStyle",
        "scope": "lua",
        "description": "If the ReaScript-console is opened, you can change the font-style of it.\nYou can choose between 19 different styles, with 3 being of fixed character length. It will change the next time you output text to the ReaScriptConsole.\nIf you close and reopen the Console, you need to set the font-style again!\nYou can only have one style active in the console!\nReturns false in case of an error\nRETURNS:\nretval:true, displaying was successful; false, displaying wasn't successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetReaScriptConsole_FontStyle(${3:integer style})$0"
    },
    "ULTRASCHALL.READSUBTITLES_VTT_WR lua": {
        "prefix": "ultraschallwr.ReadSubtitles_VTT",
        "scope": "lua",
        "description": "parses a webvtt-subtitle-file and returns its contents as table\nreturns nil in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the webvtt-file\nRETURNS:\nKind:the type of the webvtt-file, like: captions\nLanguage:the language of the webvtt-file\nCaptions_Counter:the number of captions in the file\nCaptions:the Captions as a table of the format:\n",
        "body": "${1:local }${2:string Kind},${3:string Language},${4:integer Captions_Counter},${5:table Captions} = ultraschall.ReadSubtitles_VTT(${6:string filename_with_path})$0"
    },
    "ULTRASCHALL.GFX_DRAWTHICKROUNDRECT_WR lua": {
        "prefix": "ultraschallwr.GFX_DrawThickRoundRect",
        "scope": "lua",
        "description": "draws a round-rectangle with a custom thickness.\nYou shouldn't redraw with it too often, as it eats many ressources\nreturns false in case of an error\nPARAMETERS:\nx:the x position of the rectangle\ny:the y position of the rectangle\nw:the width of the rectangle\nh:the thickness of the rectangle's edges\nthickness:the thickness of the rectangle's edges\nroundness:the angle of the rectangle's corners\nantialias:true, draw antialiased; false, simply draw aliased\nRETURNS:\nretval:true, drawing was successful; false, drawing wasn't successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GFX_DrawThickRoundRect(${3:integer x},${4:integer y},${5:integer w},${6:integer h},${7:number thickness},${8:number roundness},${9:boolean antialias})$0"
    },
    "ULTRASCHALL.GFX_BLITFRAMEBUFFER_WR lua": {
        "prefix": "ultraschallwr.GFX_BlitFramebuffer",
        "scope": "lua",
        "description": "blits a framebuffer at position 0,0. If the gfx-window is smaller than the contents of the framebuffer, it will resize it before blitting to window size, retaining the correct aspect-ratio.\nMostly intended for debugging-purposes, when you want to track, if a certain framebuffer contains, what you expect it to contain.\nreturns false in case of an error\nPARAMETERS:\nframebufferidx:the indexnumber of the framebuffer to blit; 0 to 1023; -1 is the displaying framebuffer\nshowidx:true, displays the id-number of the framebuffer in the top-left corner; false, does not display framebuffer-idx\nRETURNS:\nretval:true, drawing was successful; false, drawing wasn't successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GFX_BlitFramebuffer(${3:integer framebufferidx},${4:optional boolean showidx})$0"
    },
    "ULTRASCHALL.GFX_INIT_WR lua": {
        "prefix": "ultraschallwr.GFX_Init",
        "scope": "lua",
        "description": "Opens a new graphics window and returns its HWND-windowhandler object.\nPARAMETERS:\n\"name\":the name of the window, which will be shown in the title of the window\nwidth: the width of the window; minmum is 50\nheight: the height of the window; minimum is 16\ndockstate:&1=0, undocked; &1=1, docked\nxpos:x-position of the window in pixels; minimum is -80; nil, to center it horizontally\nypos:y-position of the window in pixels; minimum is -15; nil, to center it vertically\nRETURNS:\nretval: 1.0, if window is opened\nhwnd:the window-handler of the newly created window; can be used with JS_Window_xxx-functions of the JS-extension-plugin\n",
        "body": "${1:local }${2:integer retval},${3:HWND hwnd} = ultraschall.GFX_Init(${4:string \"name\"},${5:optional integer width},${6:optional integer height},${7:optional integer dockstate},${8:optional integer xpos},${9:optional integer ypos})$0"
    },
    "ULTRASCHALL.GFX_GETWINDOWHWND_WR lua": {
        "prefix": "ultraschallwr.GFX_GetWindowHWND",
        "scope": "lua",
        "description": "Returns the HWND of the currently opened gfx-window. You need to use ultraschall.GFX_Init(), otherwise\nit will contain the message \"Please, use ultraschall.GFX_Init() for window-creation, not gfx.init(!), to retrieve the HWND of the gfx-window.\"\nRETURNS:\nhwnd:the window-handler of the opened gfx-window; will contain a helpermessage, if you didn't use ultraschall.GFX_Init() for window creation.\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GFX_GetWindowHWND()$0"
    },
    "ULTRASCHALL.GFX_GETMOUSECAP_WR lua": {
        "prefix": "ultraschallwr.GFX_GetMouseCap",
        "scope": "lua",
        "description": "Checks mouseclick/wheel-behavior, since last time calling this function and returns it's state.\nAllows you to get click, doubleclick, dragging, including the appropriate coordinates and mousewheel-states.\nMuch more convenient, than fiddling around with gfx.mouse_cap\nNote: After doubleclicked, this will not return mouse-clicked-states, until the mouse-button is released. So any mouse-clicks during that can be only gotten from the retval mouse_cap.\nThis is to prevent automatic mouse-dragging after double-clicks.\nPARAMETERS:\ndoubleclick_wait:the timeframe, in which a second click is recognized as double-click, in defer-cycles. 30 is approximately 1 second; nil, will use 15(default)\ndrag_wait:the timeframe, after which a mouseclick without moving the mouse is recognized as dragging, in defer-cycles. 30 is approximately 1 second; nil, will use 5(default)\nRETURNS:\nclickstate:either \"\" for not clicked, \"CLK\" for clicked, \"DBLCLK\" for doubleclick or \"DRAG\" for dragging\nspecific_clickstate:either \"\" for not clicked, \"CLK\" for clicked, \"DBLCLK\" for doubleclick or \"DRAG\" for dragging\nmouse_cap:the mouse_cap, a bitfield of mouse and keyboard modifier states\nclick_x:the x position, when the mouse has been clicked the last time\nclick_y:the y position, when the mouse has been clicked the last time\ndrag_x:the x-position of the mouse-dragging-coordinate; is like click_x for non-dragging mousestates\ndrag_y:the y-position of the mouse-dragging-coordinate; is like click_y for non-dragging mousestates\nmouse_wheel:the mouse_wheel-delta, since the last time calling this function\nmouse_hwheel:the mouse_horizontal-wheel-delta, since the last time calling this function\n",
        "body": "${1:local }${2:string clickstate},${3:string specific_clickstate},${4:integer mouse_cap},${5:integer click_x},${6:integer click_y},${7:integer drag_x},${8:integer drag_y},${9:integer mouse_wheel},${10:integer mouse_hwheel} = ultraschall.GFX_GetMouseCap(${11:optional integer doubleclick_wait},${12:optional integer drag_wait})$0"
    },
    "ULTRASCHALL.GFX_BLITIMAGECENTERED_WR lua": {
        "prefix": "ultraschallwr.GFX_BlitImageCentered",
        "scope": "lua",
        "description": "Blits a centered image at the position given by parameter x and y. That means, the center of the image will be at x and y.\nAll the rest basically works like the regular gfx.blit-function.\nreturns false in case of an error\nPARAMETERS:\nx:influences rotation\ny:influences rotation\nscale:the scale-factor; 1, for normal size; smaller or bigger than 1 make image smaller or bigger\nsrcx:the x-coordinate-offset in the source-image\nsrcy:the y-coordinate-offset in the source-image\nsrcw:the width-offset in the source-image\nsrch:the height-offset in the source-image\ndestx:the x-coordinate of the blitting destination\ndesty:the y-coordinate of the blitting destination\ndestw:the width of the blitting destination; may lead to stretched images\ndesth:the height of the blitting destination; may lead to stretched images\nrotxoffs:influences rotation\nrotyoffs:influences rotation\nRETURNS:\nretval:true, blitting was successful; false, blitting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GFX_BlitImageCentered(${3:integer image},${4:integer x},${5:integer y},${6:number scale},${7:number rotate},${8:optional number srcx},${9:optional number srcy},${10:optional number srcw},${11:optional number srch},${12:optional integer destx},${13:optional integer desty},${14:optional integer destw},${15:optional integer desth},${16:optional integer rotxoffs},${17:optional integer rotyoffs})$0"
    },
    "ULTRASCHALL.GFX_GETDROPFILE_WR lua": {
        "prefix": "ultraschallwr.GFX_GetDropFile",
        "scope": "lua",
        "description": "returns the files drag'n'dropped into a gfx-window, including the mouseposition within the gfx-window, where the files have been dropped.\nif changed==true, then the filelist is updated, otherwise this function returns the last dropped files again.\nNote: when the same files will be dropped, changed==true will also be dropped with only the mouse-position updated.\nThat way, dropping the same files in differen places is recognised by this function.\nCall repeatedly in every defer-cycle to get the latest files and coordinates.\nImportant: Don't use Reaper's own gfx.dropfile while using this, as this could intefere with this function.\nRETURNS:\nchanged:true, new files have been dropped since last time calling this function; false, no new files have been dropped\nnum_dropped_files:the number of dropped files; -1, if no files have beend dropped at all\ndropped_files:an array with all filenames+path of the dropped files\ndrop_mouseposition_x:the x-mouseposition within the gfx-window, where the files have been dropped; -10000, if no files have been dropped yet\ndrop_mouseposition_y:the y-mouseposition within the gfx-window, where the files have been dropped; -10000, if no files have been dropped yet\n",
        "body": "${1:local }${2:boolean changed},${3:integer num_dropped_files},${4:array dropped_files},${5:integer drop_mouseposition_x},${6:integer drop_mouseposition_y} = ultraschall.GFX_GetDropFile()$0"
    },
    "ULTRASCHALL.VID_VIDEOUISTATECOORDS2PIXELS_WR lua": {
        "prefix": "ultraschallwr.VID_VideoUIStateCoords2Pixels",
        "scope": "lua",
        "description": "converts the ui_state-coordinates of the Video-Processor into pixel-coordinates within the Video Window\nYou should add x and y-position of the Video-Processor-window, to get the actual screen-coordinates.\nreturns nil in case of an error\nPARAMETERS:\nuistate_x:the x-coordinate, that the function ui_get_state within the videoprocessor returns\nuistate_y:the y-coordinate, that the function ui_get_state within the videoprocessor returns\nvideowindow_width:the current width of the Video Window\nvideowindow_height:the current height of the Video Window\nRETURNS:\nx_coordinate:the converted x-coordinate\ny_coordinate:the converted y-coordinate\n",
        "body": "${1:local }${2:integer x_coordinate},${3:integer y_coordinate} = ultraschall.VID_VideoUIStateCoords2Pixels(${4:number uistate_x},${5:number uistate_y},${6:integer videowindow_width},${7:integer videowindow_height})$0"
    },
    "ULTRASCHALL.VID_PIXELS2VIDEOUISTATECOORDS_WR lua": {
        "prefix": "ultraschallwr.VID_Pixels2VideoUIStateCoords",
        "scope": "lua",
        "description": "converts the ui_state-coordinates of the Video-Processor into pixel-coordinates within the Video Window\nYou should add x and y-position of the Video-Processor-window, to get the actual screen-coordinates.\nreturns nil in case of an error\nPARAMETERS:\nx:the x-coordinate within the Video-Window\ny:the y-coordinate within the Video-Window\nvideowindow_width:the current width of the Video Window\nvideowindow_height:the current height of the Video Window\n",
        "body": "${1:local }${2:number uistate_x},${3:number uistate_y} = ultraschall.VID_Pixels2VideoUIStateCoords(${4:integer x},${5:integer y},${6:integer videowindow_width},${7:integer videowindow_height})$0"
    },
    "ULTRASCHALL.GETHWINPUTS_ALIASNAMES_WR lua": {
        "prefix": "ultraschallwr.GetHWInputs_Aliasnames",
        "scope": "lua",
        "description": "Returns the aliasnames and their associated channels of the currently selected audio-device.\nThe returned table is of the format\ntable[index][1] - the name of the alias\ntable[index][2] - the hardware-input-channel, associated to this aliasname\nRETURNS:\nnumber_of_aliases:the number of aliases available\naliases:a table, that contains all alias-names and their associated Hardware-Input-channels\n",
        "body": "${1:local }${2:integer number_of_aliases},${3:table aliases} = ultraschall.GetHWInputs_Aliasnames()$0"
    },
    "ULTRASCHALL.GETHWOUTPUTS_ALIASNAMES_WR lua": {
        "prefix": "ultraschallwr.GetHWOutputs_Aliasnames",
        "scope": "lua",
        "description": "Returns the aliasnames and their associated channels of the currently selected audio-device.\nThe returned table is of the format\ntable[index][1] - the name of the alias\ntable[index][2] - the hardware-output-channel, associated to this aliasname\nRETURNS:\nnumber_of_aliases:the number of aliases available\naliases:a table, that contains all alias-names and their associated Hardware-Output-channels\n",
        "body": "${1:local }${2:integer number_of_aliases},${3:table aliases} = ultraschall.GetHWOutputs_Aliasnames()$0"
    },
    "ULTRASCHALL.GETPROJECT_AUTOMATIONITEMSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_AutomationItemStateChunk",
        "scope": "lua",
        "description": "returns the idx'th automation-item from a ProjectStateChunk.\nIt's the entry <POOLEDENV\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the automation-item-statechunk; nil to use ProjectStateChunk\nidx:the number of the requested automation-item from the ProjectStateChunk with 1 for the first AutomItem.\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nAutomationItemStateChunk:the statechunk of the idx'th automation-item\n",
        "body": "${1:local }${2:string AutomationItemStateChunk} = ultraschall.GetProject_AutomationItemStateChunk(${3:string projectfilename_with_path},${4:integer idx},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_COUNTAUTOMATIONITEMS_WR lua": {
        "prefix": "ultraschallwr.GetProject_CountAutomationItems",
        "scope": "lua",
        "description": "returns the number of automation-items available in a ProjectStateChunk.\nIt's the entry <POOLEDENV\nreturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the automation-item-count; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file; only used, when projectfilename_with_path=nil\nRETURNS:\nautomation_items_count:the number of automation-items\n",
        "body": "${1:local }${2:integer automation_items_count} = ultraschall.GetProject_CountAutomationItems(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.AUTOMATIONITEMS_GETALL_WR lua": {
        "prefix": "ultraschallwr.AutomationItems_GetAll",
        "scope": "lua",
        "description": "Returns all automation items from the current project as a handy table\nThe format of the table is as follows:\nAutomationItems[automationitem_idx][\"Track\"] - the track, in which the automation item is located\nAutomationItems[automationitem_idx][\"EnvelopeObject\"] - the envelope, in which the automationitem is located\nAutomationItems[automationitem_idx][\"EnvelopeName\"] - the name of the envelope\nAutomationItems[automationitem_idx][\"AutomationItem_Index\"] - the index of the automation with EnvelopeObject\nAutomationItems[automationitem_idx][\"AutomationItem_PoolID\"] - the pool-Id of the automation item\nAutomationItems[automationitem_idx][\"AutomationItem_Position\"] - the position of the automation item in seconds\nAutomationItems[automationitem_idx][\"AutomationItem_Length\"] - the length of the automation item in seconds\nAutomationItems[automationitem_idx][\"AutomationItem_Startoffset\"] - the startoffset of the automation item in seconds\nAutomationItems[automationitem_idx][\"AutomationItem_Playrate\"]- the playrate of the automation item\nAutomationItems[automationitem_idx][\"AutomationItem_Baseline\"]- the baseline of the automation item, between 0 and 1\nAutomationItems[automationitem_idx][\"AutomationItem_Amplitude\"]- the amplitude of the automation item, between -1 and +1\nAutomationItems[automationitem_idx][\"AutomationItem_LoopSource\"]- the loopsource-state of the automation item; 0, unlooped; 1, looped\nAutomationItems[automationitem_idx][\"AutomationItem_UISelect\"]- the selection-state of the automation item; 0, unselected; nonzero, selected\nAutomationItems[automationitem_idx][\"AutomationItem_Pool_QuarteNoteLength\"]- the quarternote-length\nRETURNS:\nnumber_of_automationitems:the number of automation-items found in the current project\nAutomationItems_Table:all found automation-items as a handy table(see description for details)\n",
        "body": "${1:local }${2:integer number_of_automationitems},${3:table AutomationItems_Table} = ultraschall.AutomationItems_GetAll()$0"
    },
    "ULTRASCHALL.AUTOMATIONITEM_DELETE_WR lua": {
        "prefix": "ultraschallwr.AutomationItem_Delete",
        "scope": "lua",
        "description": "Deletes an Automation-Item, optionally preserves the points who are added to the underlying envelope.\nreturns false in case of an error\nPARAMETERS:\nenv:the TrackEnvelope, in which the automation-item to be deleted is located\nautomationitem_idx:the automationitem that shall be deleted; 0, for the first one\npreservepoints:true, keepthe envelopepoints and add them to the underlying envelope; nil or false, just delete the AutomationItem\nRETURNS:\nretval:true, deleting was successful; false, deleting was not successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AutomationItem_Delete(${3:TrackEnvelope env},${4:integer automationitem_idx},${5:optional boolean preservepoints})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSFROMCLIPBOARD_WR lua": {
        "prefix": "ultraschallwr.GetMediaItemsFromClipboard",
        "scope": "lua",
        "description": "Returns the number of mediaitems and a MediaItemStateChunkArray of the mediaitems, as stored in the clipboard.\nIt does it by pasting the items at the end of the project, getting them and deleting them again.\nUse sparsely and with care, as it uses a lot of resources!\nRETURNS:\ncount:the number of items in the clipboard\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemStateChunkArray} = ultraschall.GetMediaItemsFromClipboard()$0"
    },
    "ULTRASCHALL.GETSTRINGFROMCLIPBOARD_SWS_WR lua": {
        "prefix": "ultraschallwr.GetStringFromClipboard_SWS",
        "scope": "lua",
        "description": "Returns the content of the clipboard as a string. Uses the SWS-function reaper.CF_GetClipboard, but does everything for you, that is needed for proper use of this function.\nRETURNS:\nclipboard_string:the content of the clipboard as a string\n",
        "body": "${1:local }${2:string clipboard_string} = ultraschall.GetStringFromClipboard_SWS()$0"
    },
    "ULTRASCHALL.PUTMEDIAITEMSTOCLIPBOARD_MEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.PutMediaItemsToClipboard_MediaItemArray",
        "scope": "lua",
        "description": "Puts the items in MediaItemArray into the clipboard.\nReturns false in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, that shall be put into the clipboard\nRETURNS:\nretval:true, if successful; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.PutMediaItemsToClipboard_MediaItemArray(${3:MediaItemArray MediaItemArray})$0"
    },
    "ULTRASCHALL.CONVERTCOLOR_WR lua": {
        "prefix": "ultraschallwr.ConvertColor",
        "scope": "lua",
        "description": "converts r, g, b-values to native-system-color. Works like reaper's ColorToNative, but doesn't need |0x1000000 added.\nreturns color-value 0, and retval=false in case of an error\nPARAMETERS:\nr:the blue colorvalue\ng:the blue colorvalue\nb:the blue colorvalue\nRETURNS:\ncolorvalue:the native-system-color; 0 to 33554431\n",
        "body": "${1:local }${2:integer colorvalue},${3:boolean retval} = ultraschall.ConvertColor(${4:integer r},${5:integer g},${6:integer b})$0"
    },
    "ULTRASCHALL.CONVERTCOLORREVERSE_WR lua": {
        "prefix": "ultraschallwr.ConvertColorReverse",
        "scope": "lua",
        "description": "converts a native-system-color to r, g, b-values.\nreturns 0,0,0,false in case of an error\nPARAMETERS:\ncolorvalue:the native-system-color; 0 to 33554431\nRETURNS:\nr:true, color-conversion was successful; false, color-conversion was unsuccessful\ng:the blue colorvalue\nb:true, color-conversion was successful; false, color-conversion was unsuccessful\nretval:true, color-conversion was successful; false, color-conversion was unsuccessful\n",
        "body": "${1:local }${2:integer r},${3:integer g},${4:integer b},${5:boolean retval} = ultraschall.ConvertColorReverse(${6:integer colorvalue})$0"
    },
    "ULTRASCHALL.RGB2GRAYSCALE_WR lua": {
        "prefix": "ultraschallwr.RGB2Grayscale",
        "scope": "lua",
        "description": "converts rgb to a grayscale value. Works native on Mac as well on Windows, no color conversion needed.\nreturns nil in case of an error\nPARAMETERS:\nred:red-value between 0 and 255.\ngreen:red-value between 0 and 255.\nblue:red-value between 0 and 255.\nRETURNS:\ngraycolor:the gray color-value, generated from red,blue and green.\n",
        "body": "${1:local }${2:integer graycolor} = ultraschall.RGB2Grayscale(${3:integer red},${4:integer green},${5:integer blue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORTOGFX_WR lua": {
        "prefix": "ultraschallwr.ConvertColorToGFX",
        "scope": "lua",
        "description": "converts red,green,blue,alpha-values from 0-255 range to 0-1 range, so these values can be used by Reaper-Lua's gfx.functions().\nsupports negative-values up from -255 to +255, so you can use the function as well for subtraction of colorvalues.\nreturns nil in case of error\nPARAMETERS:\nr:the alpha-color-value between -255 and +255\ng:the alpha-color-value between -255 and +255\nb:the blue-color-value between -255 and +255\na:the alpha-color-value between -255 and +255\nRETURNS:\nr:the converted alpha-value between -1 and +1\ng:the converted green-value between -1 and +1\nb:the converted alpha-value between -1 and +1\na:the converted alpha-value between -1 and +1\n",
        "body": "${1:local }${2:number r},${3:number g},${4:number b},${5:number a} = ultraschall.ConvertColorToGFX(${6:integer r},${7:integer g},${8:integer b},${9:integer a})$0"
    },
    "ULTRASCHALL.CONVERTGFXTOCOLOR_WR lua": {
        "prefix": "ultraschallwr.ConvertGFXToColor",
        "scope": "lua",
        "description": "converts red,green,blue,alpha-values from 0-1 range to 0-255 range, so these values can be used by Reaper's normal color-value-functions.\nsupports negative-values up from -1 to +1, so you can use the function as well for subtraction of colorvalues.\nreturns nil in case of error\nPARAMETERS:\nr:the converted alpha-value between -1 and +1\ng:the converted green-value between -1 and +1\nb:the converted alpha-value between -1 and +1\na:the converted alpha-value between -1 and +1\nRETURNS:\nr:the alpha-color-value between -255 and +255\ng:the alpha-color-value between -255 and +255\nb:the blue-color-value between -255 and +255\na:the alpha-color-value between -255 and +255\n",
        "body": "${1:local }${2:integer r},${3:integer g},${4:integer b},${5:integer a} = ultraschall.ConvertGFXToColor(${6:number r},${7:number g},${8:number b},${9:number a})$0"
    },
    "ULTRASCHALL.CREATECOLORTABLE_WR lua": {
        "prefix": "ultraschallwr.CreateColorTable",
        "scope": "lua",
        "description": "Returns a colortable to be used by color-graphics-functions.\nThe colorvalue for start and end can be 0 to 255 or the other way round 255 to 0\nCan be used by ApplyColorTableToTrackColors\nreturns nil in case of an error\nPARAMETERS:\nstartr:start redvalue, between 0 and 255\nstartg:start greenvalue, between 0 and 255 \nstartb:start bluevalue, between 0 and 255\nendr:end redvalue, between 0 and 255\nendg:end greenvalue, between 0 and 255\nendb:end bluevalue, between 0 and 255\nnumber_of_steps:the number of steps from the lowest to the highest r,g,b-color start/end-values\nRETURNS:\nColorTable:a colortable for the colors with the number of steps of your choice; \n",
        "body": "${1:local }${2:array ColorTable} = ultraschall.CreateColorTable(${3:integer startr},${4:integer startg},${5:integer startb},${6:integer endr},${7:integer endg},${8:integer endb},${9:integer number_of_steps})$0"
    },
    "ULTRASCHALL.CREATESONICRAINBOOMCOLORTABLE_WR lua": {
        "prefix": "ultraschallwr.CreateSonicRainboomColorTable",
        "scope": "lua",
        "description": "Returns a colortable in Ultraschall's standard-trackcolor-setting \"Sonic Rainboom\"-style.\nCan be used by ApplyColorTableToTrackColors\nRETURNS:\nColorTable:a colortable with all values for Ultraschall's track-color \"Sonic Rainboom\"\n",
        "body": "${1:local }${2:array ColorTable} = ultraschall.CreateSonicRainboomColorTable()$0"
    },
    "ULTRASCHALL.ISVALIDCOLORTABLE_WR lua": {
        "prefix": "ultraschallwr.IsValidColorTable",
        "scope": "lua",
        "description": "Checks for valid color-tables.\nreturns false in case of an error\nPARAMETERS:\nColorTable:a table to check for being a valid ColorTable\nRETURNS:\nretval:true, if it's a valid ColorTable; false, if it's not a valid ColorTable\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidColorTable(${3:array ColorTable})$0"
    },
    "ULTRASCHALL.APPLYCOLORTABLETOTRACKCOLORS_WR lua": {
        "prefix": "ultraschallwr.ApplyColorTableToTrackColors",
        "scope": "lua",
        "description": "Apply a ColorTable to Tracks, to colorize MediaTracks\nColorTables can be created by CreateColorTable\nreturns false in case of an error\nPARAMETERS:\nColorTable:the ColorTable to apply to the MediaTrackColors\nSpread:0, apply ColorTable once; will return false, if fewer colors are in ColorTable available than tracks in the project\nStartTrack:the first track to colorize; nil, to use the first track in project\nEndTrack:the last track to colorize; nil, to use the last track in project\nRETURNS:\nretval:true, adjusting track-colors was successful; false, adjusting track-colors was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyColorTableToTrackColors(${3:array ColorTable},${4:integer Spread},${5:integer StartTrack},${6:integer EndTrack})$0"
    },
    "ULTRASCHALL.APPLYCOLORTABLETOITEMCOLORS_WR lua": {
        "prefix": "ultraschallwr.ApplyColorTableToItemColors",
        "scope": "lua",
        "description": "Apply a ColorTable to MediaItems in a MediaItemArray, to colorize MediaItems\nColorTables can be created by CreateColorTable\nreturns false in case of an error\nPARAMETERS:\nColorTable:the ColorTable to apply to the MediaItemColors\nSpread:0, apply ColorTable once; will return false, if fewer colors are in ColorTable available than items in the MediaItemArray\nMediaItemArray:an array with all the MediaItems to colorize\nRETURNS:\nretval:true, adjusting item-colors was successful; false, adjusting item-colors was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyColorTableToItemColors(${3:array ColorTable},${4:integer Spread},${5:MediaItemArray MediaItemArray})$0"
    },
    "ULTRASCHALL.CHANGECOLORBRIGHTNESS_WR lua": {
        "prefix": "ultraschallwr.ChangeColorBrightness",
        "scope": "lua",
        "description": "Changes brightness of a colorvalue. If you only set bright_r without setting bright_g and bright_b, then the value for bright_r will affect g and b as well.\nIf a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.\nreturns color-value 0,0,0 and retval=false in case of an error\nPARAMETERS:\nr:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\ng:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nb:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nbright_r:the change in brightness for the red-color; positive, brighter; negative, darker\nbright_g:the change in brightness for the green-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nbright_b:the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used\nRETURNS:\nred:the new red-value\ngreen:the new green-value\nblue:the new blue-value\nretval:true, color-calculation was successful; false, color-calculation was unsuccessful\n",
        "body": "${1:local }${2:integer red},${3:integer green},${4:integer blue},${5:boolean retval} = ultraschall.ChangeColorBrightness(${6:integer r},${7:integer g},${8:integer b},${9:integer bright_r},${10:optional integer bright_g},${11:optional integer bright_b})$0"
    },
    "ULTRASCHALL.CHANGECOLORCONTRAST_WR lua": {
        "prefix": "ultraschallwr.ChangeColorContrast",
        "scope": "lua",
        "description": "Changes contrast of a colorvalue.\nMinimum will set the new minimal, Maximum will set the new maximum-brightness-level.\nIf you set Minimum to 0 and Maximum to 255, contrast will not change.\nThe lower you set Minimum/Maximum, the darker it becomes; the higher, the brighter it becomes.\nThe farther away Minimum is from Maximum, the stronger the contrast becomes; the closer Minimum is to Maximum, the weaker the contrast becomes.\nIf you only set Minimum\\_r and Maximum\\_r, then these values will be applied to g and b too.\nIf you omit/set to nil a Maximum-value; it's default value will be 255.\nIf a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.\nreturns color-value 0,0,0 and retval=false in case of an error\nPARAMETERS:\nr:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\ng:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\nb:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\nMinimum_r:the new minimum brightness of the contrast-range of the red-color\nMaximum_r:the new maximum brightness of the contrast-range of the red-color; if nil, it will be seen as 255\nMinimum_g:the new minimum brightness of the contrast-range of the green-color; if nil, it will use the value of Minimum_r\nMaximum_g:the new maximum brightness of the contrast-range of the green-color; if nil, it will be seen as 255\nMinimum_b:the new minimum brightness of the contrast-range of the blue-color; if nil, it will use the value of Minimum_r\nMaximum_b:the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255\nRETURNS:\nred:the new red-value\ngreen:the new green-value\nblue:the new blue-value\nretval:true, color-calculation was successful; false, color-calculation was unsuccessful\n",
        "body": "${1:local }${2:integer red},${3:integer green},${4:integer blue},${5:boolean retval} = ultraschall.ChangeColorContrast(${6:integer r},${7:integer g},${8:integer b},${9:integer Minimum_r},${10:optional integer Maximum_r},${11:optional integer Minimum_g},${12:optional integer Maximum_g},${13:optional integer Minimum_b},${14:optional integer Maximum_b})$0"
    },
    "ULTRASCHALL.CHANGECOLORSATURATION_WR lua": {
        "prefix": "ultraschallwr.ChangeColorSaturation",
        "scope": "lua",
        "description": "Changes saturation of a colorvalue by delta.\nIf a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.\nreturns color-value 0,0,0 and retval=false in case of an error\nPARAMETERS:\nr:the saturation/desaturation-value; negative, desaturates color; positive, saturates color\ng:the saturation/desaturation-value; negative, desaturates color; positive, saturates color\nb:the blue-value to be changed\ndelta:the saturation/desaturation-value; negative, desaturates color; positive, saturates color\nRETURNS:\nred:the new red-value\ngreen:the new green-value\nblue:the new blue-value\nmedian:the median-value, calculated from the the old red, green and blue, values (red+green+blue)/3, which is the basis for the brightness of the unsaturated value\nretval:true, color-calculation was successful; false, color-calculation was unsuccessful\n",
        "body": "${1:local }${2:integer red},${3:integer green},${4:integer blue},${5:number median},${6:boolean retval} = ultraschall.ChangeColorSaturation(${7:integer r},${8:integer g},${9:integer b},${10:integer delta})$0"
    },
    "ULTRASCHALL.CONVERTCOLORTOMAC_WR lua": {
        "prefix": "ultraschallwr.ConvertColorToMac",
        "scope": "lua",
        "description": "Converts a colorvalue to the correct-native-colorvalue for Mac, no matter if you're using Mac, Windows or Linux.\nreturns 0, false in case of an error\nPARAMETERS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nRETURNS:\nmac_colorvalue:the Mac-native-colorvalue\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "${1:local }${2:integer mac_colorvalue},${3:boolean retval} = ultraschall.ConvertColorToMac(${4:integer red},${5:integer green},${6:integer blue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORTOWIN_WR lua": {
        "prefix": "ultraschallwr.ConvertColorToWin",
        "scope": "lua",
        "description": "Converts a colorvalue to the correct-native-colorvalue for Windows/Linux, no matter if you're using Mac, Windows or Linux.\nreturns 0, false in case of an error\nPARAMETERS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nRETURNS:\nwin_linux_colorvalue:the Windows/Linux-native-colorvalue\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "${1:local }${2:integer win_linux_colorvalue},${3:boolean retval} = ultraschall.ConvertColorToWin(${4:integer red},${5:integer green},${6:integer blue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORFROMMAC_WR lua": {
        "prefix": "ultraschallwr.ConvertColorFromMac",
        "scope": "lua",
        "description": "Converts a native-colorvalue to the correct rgb-color-values for Mac, no matter if you're using Mac, Windows or Linux.\nreturns 0, 0, 0, false in case of an error\nPARAMETERS:\nmac_colorvalue:the Mac-native-colorvalue\nRETURNS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "${1:local }${2:integer red},${3:integer green},${4:integer blue},${5:boolean retval} = ultraschall.ConvertColorFromMac(${6:integer mac_colorvalue})$0"
    },
    "ULTRASCHALL.CONVERTCOLORFROMWIN_WR lua": {
        "prefix": "ultraschallwr.ConvertColorFromWin",
        "scope": "lua",
        "description": "Converts a native-colorvalue to the correct rgb-color-values for Windows/Linux, no matter if you're using Mac, Windows or Linux.\nreturns 0, 0, 0, false in case of an error\nPARAMETERS:\nwin_colorvalue:the Windows/Linux-native-colorvalue\nRETURNS:\nred:the red-value of the color\ngreen:the green-value of the color\nblue:the blue-value of the color\nretval:true, if conversion succeeded; false, if conversion failed\n",
        "body": "${1:local }${2:integer red},${3:integer green},${4:integer blue},${5:boolean retval} = ultraschall.ConvertColorFromWin(${6:integer win_colorvalue})$0"
    },
    "ULTRASCHALL.SETINIFILEEXTERNALSTATE_WR lua": {
        "prefix": "ultraschallwr.SetIniFileExternalState",
        "scope": "lua",
        "description": "Sets an external state into ini_filename_with_path. Returns false, if it doesn't work.\nPARAMETERS:\nsection:section of the external state. No = allowed!\nkey:key of the external state. No = allowed!\nvalue:value for the key\nRETURNS:\nretval:true, if setting the state was successful; false, if setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetIniFileExternalState(${3:string section},${4:string key},${5:string value},${6:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.GETINIFILEEXTERNALSTATE_WR lua": {
        "prefix": "ultraschallwr.GetIniFileExternalState",
        "scope": "lua",
        "description": "Gets an external state from ini_filename_with_path. Returns -1, if the file does not exist or parameters are invalid.\nPARAMETERS:\nsection:section of the external state\nkey:key of the external state. No = allowed!\nRETURNS:\nvalue:the value stored in a section->key in a configuration-file\n",
        "body": "${1:local }${2:string value} = ultraschall.GetIniFileExternalState(${3:string section},${4:string key},${5:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTINIFILEEXTERNALSTATE_SEC_WR lua": {
        "prefix": "ultraschallwr.CountIniFileExternalState_sec",
        "scope": "lua",
        "description": "Count external-state-[sections] from an ini-configurationsfile.\nReturns -1, if the file does not exist.\nPARAMETERS:\nini_filename_with_path:filename of the ini-file\nRETURNS:\nsectioncount:number of sections within an ini-configuration-file\n",
        "body": "${1:local }${2:integer sectioncount} = ultraschall.CountIniFileExternalState_sec(${3:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTINIFILEEXTERNALSTATE_KEY_WR lua": {
        "prefix": "ultraschallwr.CountIniFileExternalState_key",
        "scope": "lua",
        "description": "Count external-state-keys within a specific section, in a ini_filename_with_path.\nReturns -1, if file does not exist.\nPARAMETERS:\nsection:the section within the ini-filename\nini_filename_with_path:filename of the ini-file\nRETURNS:\nkeyscount:number of keys with section within an ini-configuration-file\n",
        "body": "${1:local }${2:integer keyscount} = ultraschall.CountIniFileExternalState_key(${3:string section},${4:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEINIFILEEXTERNALSTATE_SEC_WR lua": {
        "prefix": "ultraschallwr.EnumerateIniFileExternalState_sec",
        "scope": "lua",
        "description": "Returns the numberth section in an ini_filename_with_path.\nReturns nil, in case of an error.\nPARAMETERS:\nnumber_of_section:the section within the ini-filename; 1, for the first section\nini_filename_with_path:filename of the ini-file\nRETURNS:\nsectionname:the name of the numberth section in the ini-file\n",
        "body": "${1:local }${2:string sectionname} = ultraschall.EnumerateIniFileExternalState_sec(${3:integer number_of_section},${4:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEINIFILEEXTERNALSTATE_KEY_WR lua": {
        "prefix": "ultraschallwr.EnumerateIniFileExternalState_key",
        "scope": "lua",
        "description": "Returns the numberth key within a section in an ini_filename_with_path.\nReturns nil, in case of an error.\nPARAMETERS:\nsection:the name of the section\nnumber:the number of the key within a section within the ini-filename, with 1 for the first key in the section\nini_filename_with_path:filename of the ini-file\nRETURNS:\nkeyname:the name of the numberth key within section in the ini-file\n",
        "body": "${1:local }${2:string keyname} = ultraschall.EnumerateIniFileExternalState_key(${3:string section},${4:integer number},${5:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTSECTIONSBYPATTERN_WR lua": {
        "prefix": "ultraschallwr.CountSectionsByPattern",
        "scope": "lua",
        "description": "Counts the number of sections within an ini-file, that fit a specific pattern.\nUses \"pattern\"-string to determine, how often a section with a certain pattern exists. Good for sections, that have a number in them, like [section1], [section2], [section3].\nReturns the number of sections, that include that pattern as well as a string, that includes the names of all such sections, separated by a comma.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns -1, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nini_filename_with_path:filename of the ini-file\nRETURNS:\nnumber_of_sections:the number of sections, that fit the pattern\nsectionnames:a string, like: [section1],[section8],[section99]\n",
        "body": "${1:local }${2:integer number_of_sections},${3:string sectionnames} = ultraschall.CountSectionsByPattern(${4:string pattern},${5:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKEYSBYPATTERN_WR lua": {
        "prefix": "ultraschallwr.CountKeysByPattern",
        "scope": "lua",
        "description": "Counts the number of keys within an ini-file, that fit a specific pattern.\nUses \"pattern\"-string to determine, how often a key with a certain pattern exists. Good for keys, that have a number in them, like key1, key2, key3.\nReturns the number of keys, that include the pattern, as well as a string with all [sections] that contain keys= with a pattern, separated by a , i.e. [section1],key1=,key2=,key3=,[section2],key1=,key4=\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns -1, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nini_filename_with_path:filename of the ini-file\nRETURNS:\nnumber_of_keys:the number of keys, that fit the pattern\nsections_and_keys:a string, like: [section1],Key1=,Key2=,Key3=[section2],Key7=\n",
        "body": "${1:local }${2:integer number_of_keys},${3:string sections_and_keys} = ultraschall.CountKeysByPattern(${4:string pattern},${5:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTVALUESBYPATTERN_WR lua": {
        "prefix": "ultraschallwr.CountValuesByPattern",
        "scope": "lua",
        "description": "Counts the number of values within an ini-file, that fit a specific pattern.\nUses \"pattern\"-string to determine, how often a value with a certain pattern exists. Good for values, that have a number in them, like value1, value2, value3\nReturns the number of values, that include that pattern as well as a string, that contains the [sections] and the keys= and values , the latter that contain the pattern, separated by a comma\ne.g. [section1], key1=, value, key4=, value, [section4], key2=, value\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns -1, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nini_filename_with_path:filename of the ini-file\nRETURNS:\nnumber_of_values:the number of values, that fit the pattern\n",
        "body": "${1:local }${2:integer number_of_values},${3:string sections_and_keys} = ultraschall.CountValuesByPattern(${4:string pattern},${5:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATESECTIONSBYPATTERN_WR lua": {
        "prefix": "ultraschallwr.EnumerateSectionsByPattern",
        "scope": "lua",
        "description": "Returns the numberth section within an ini-file, that fits the pattern, e.g. the third section containing \"hawaii\" in it.\nUses \"pattern\"-string to determine if a section contains a certain pattern. Good for sections, that have a number in them, like section1, section2, section3\nReturns the section that includes that pattern as a string, numbered by id.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns nil, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nid:the number of section, that contains pattern\nini_filename_with_path:filename of the ini-file\nRETURNS:\nsectionname:a string, that contains the sectionname\n",
        "body": "${1:local }${2:string sectionname} = ultraschall.EnumerateSectionsByPattern(${3:string pattern},${4:integer id},${5:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEKEYSBYPATTERN_WR lua": {
        "prefix": "ultraschallwr.EnumerateKeysByPattern",
        "scope": "lua",
        "description": "Returns the numberth key within a section in an ini-file, that fits the pattern, e.g. the third key containing \"hawaii\" in it.\nUses \"pattern\"-string to determine if a key contains a certain pattern. Good for keys, that have a number in them, like key1=, key2=, key3=\nReturns the key that includes that pattern as a string, numbered by id.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns nil, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nsection:the section, in which to look for the key\nid:the number of key, that contains pattern\nini_filename_with_path:filename of the ini-file\nRETURNS:\nkeyname:a string, that contains the keyname\n",
        "body": "${1:local }${2:string keyname} = ultraschall.EnumerateKeysByPattern(${3:string pattern},${4:string section},${5:integer id},${6:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.ENUMERATEVALUESBYPATTERN_WR lua": {
        "prefix": "ultraschallwr.EnumerateValuesByPattern",
        "scope": "lua",
        "description": "Returns the numberth value(and it's accompanying key) within a section in an ini-file, that fits the pattern, e.g. the third value containing \"hawaii\" in it.\nUses \"pattern\"-string to determine if a value contains a certain pattern. Good for values, that have a number in them, like value1, value2, value3\nReturns the value that includes that pattern as a string, numbered by id, as well as it's accompanying key.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nReturns nil, in case of an error.\nPARAMETERS:\npattern:the pattern itself. Case sensitive.\nsection:the section, in which to look for the key\nid:the number of key, that contains pattern\nini_filename_with_path:filename of the ini-file\nRETURNS:\nvalue:the value that contains the pattern\nkeyname:a string, that contains the keyname\n",
        "body": "${1:local }${2:string value},${3:string keyname} = ultraschall.EnumerateValuesByPattern(${4:string pattern},${5:string section},${6:string id},${7:string ini_filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKBINIACTIONS_WR lua": {
        "prefix": "ultraschallwr.CountKBIniActions",
        "scope": "lua",
        "description": "Count the number of \"ACT\"-Actions of the Reaper-kb.ini-file.\nReturns -1, if no such file exists.\nRETURNS:\nactions:number of actions in the reaper-kb.ini\n",
        "body": "${1:local }${2:integer actions} = ultraschall.CountKBIniActions(${3:string filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKBINISCRIPTS_WR lua": {
        "prefix": "ultraschallwr.CountKBIniScripts",
        "scope": "lua",
        "description": "Count the number of \"SCR\"-Scripts of the Reaper-kb.ini-file.\nReturns -1, if no such file exists.\nRETURNS:\nscripts:number of scripts in the reaper-kb.ini\n",
        "body": "${1:local }${2:integer scripts} = ultraschall.CountKBIniScripts(${3:string filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTKBINIKEYS_WR lua": {
        "prefix": "ultraschallwr.CountKBIniKeys",
        "scope": "lua",
        "description": "Count the number of \"KEY\"-Keybindings of the Reaper-kb.ini-file.\nReturns -1, if no such file exists.\nRETURNS:\nkeys:number of keys in the reaper-kb.ini\n",
        "body": "${1:local }${2:integer keys} = ultraschall.CountKBIniKeys(${3:string filename_with_path})$0"
    },
    "ULTRASCHALL.GETKBINIACTIONS_WR lua": {
        "prefix": "ultraschallwr.GetKBIniActions",
        "scope": "lua",
        "description": "Get the states of \"ACT\"-Action number idx. Returns consolidate, section, ActionCommandID, description, ActionsToBeExecuted.\nReturns -1, if no such entry or file exists.\nPARAMETERS:\nfilename_with_path:path and filename of the reaper-kb.ini\nidx:the number of the action to get, beginning with 1 for the first one\nRETURNS:\nconsolidate:consolidate-state\nsection:the section, in which this action is executed\nActionCommandID:the ActionCommandID given to this Action\ndescription:the description of this action\nActionsToBeExecuted:the actions that are run, the ActionCommandIDs beginning with _, multiple ActionCommandIDs are separated by whitespaces\n",
        "body": "${1:local }${2:integer consolidate},${3:integer section},${4:string ActionCommandID},${5:string description},${6:string ActionsToBeExecuted} = ultraschall.GetKBIniActions(${7:string filename_with_path},${8:integer idx})$0"
    },
    "ULTRASCHALL.GETKBINISCRIPTS_WR lua": {
        "prefix": "ultraschallwr.GetKBIniScripts",
        "scope": "lua",
        "description": "Get the states of \"SCR\"-Scripts number idx. Returns terminateinstance, section, ActionCommandID, description, scriptfile.\nReturns -1, if no such entry or file exists.\nPARAMETERS:\nfilename_with_path:path and filename of the reaper-kb.ini\nidx:the number of the action to get, beginning with 1 for the first one\nRETURNS:\nterminateinstance:the state of terminating instances\nsection:the section, in which this action is executed\nActionCommandID:the ActionCommandID given to this Action\ndescription:the description of this action\nscriptfile:the filename of the script that shall be run\n",
        "body": "${1:local }${2:integer terminateinstance},${3:integer section},${4:string ActionCommandID},${5:string description},${6:string scriptfile} = ultraschall.GetKBIniScripts(${7:string filename_with_path},${8:integer idx})$0"
    },
    "ULTRASCHALL.GETKBINIKEYS_WR lua": {
        "prefix": "ultraschallwr.GetKBIniKeys",
        "scope": "lua",
        "description": "Get the states of \"KEY\"-Keybinding-number idx, for MIDI/Key-bindings. Returns keytype_modifier_midichan, key_midinote, ActionCommandID, section.\nFor a detailed description in how KEY-entries work, refer to Reaper-Filetype-Descriptions.html#Reaper-kb.ini.\nReturns -1, if no such entry or file exists.\nDoes not return OSC-keybindings, as they are stored in OSC/reaper-osc-actions.ini !\nreturns -1 in case of an error\nPARAMETERS:\nfilename_with_path:path and filename of the reaper-kb.ini\nidx:the number of the action to get, beginning with 1 for the first one\nRETURNS:\nkeytype_modifier_midichan:Type of Keytype, modifier or midichannel\nkey_midinote:the key(like ASCII-Codes) or midinote. \nActionCommandID:the ActionCommandID associated with this shortcut.\nsection:the section, in which this shortcut is used\n",
        "body": "${1:local }${2:integer keytype_modifier_midichan},${3:integer key_midinote},${4:string ActionCommandID},${5:integer section} = ultraschall.GetKBIniKeys(${6:string filename_with_path},${7:integer idx})$0"
    },
    "ULTRASCHALL.GETKBINIACTIONSID_BYACTIONCOMMANDID_WR lua": {
        "prefix": "ultraschallwr.GetKBIniActionsID_ByActionCommandID",
        "scope": "lua",
        "description": "Returns the indexnumber(s) of actions by ActionCommandIDs within a reaper-kb.ini.\nReturns -1, if no such entry or file exists.\nPARAMETERS:\n:the ActionCommandID\n:the ActionCommandID\nRETURNS:\nretval:the ids of actions with ActionCommandID, separated by a ,\n",
        "body": "${1:local }${2:string retval} = ultraschall.GetKBIniActionsID_ByActionCommandID(${3:filename_with_path},${4:ActionCommandID})$0"
    },
    "ULTRASCHALL.GETKBINISCRIPTS_BYACTIONCOMMANDID_WR lua": {
        "prefix": "ultraschallwr.GetKBIniScripts_ByActionCommandID",
        "scope": "lua",
        "description": "Returns the indexnumber(s) of scripts by ActionCommandIDs within a reaper-kb.ini.\nReturns nil, if no such entry or file exists.\nPARAMETERS:\n:the ActionCommandID\n:the ActionCommandID\nRETURNS:\nretval:the ids of scripts with ActionCommandID, separated by a ,\n",
        "body": "${1:local }${2:string retval} = ultraschall.GetKBIniScripts_ByActionCommandID(${3:filename_with_path},${4:ActionCommandID})$0"
    },
    "ULTRASCHALL.GETKBINIKEYS_BYACTIONCOMMANDID_WR lua": {
        "prefix": "ultraschallwr.GetKBIniKeys_ByActionCommandID",
        "scope": "lua",
        "description": "Returns the indexnumber(s) of keys by ActionCommandIDs within a reaper-kb.ini.\nReturns nil, if no such entry or file exists.\nPARAMETERS:\n:the ActionCommandID\n:the ActionCommandID\nRETURNS:\nretval:the ids of keys with ActionCommandID, separated by a ,\n",
        "body": "${1:local }${2:string retval} = ultraschall.GetKBIniKeys_ByActionCommandID(${3:filename_with_path},${4:ActionCommandID})$0"
    },
    "ULTRASCHALL.SETKBINIACTIONS_WR lua": {
        "prefix": "ultraschallwr.SetKBIniActions",
        "scope": "lua",
        "description": "Adds or sets(if it already exists) an \"ACT\"-action of a reaper-kb.ini.\nReturns true/false when adding or setting worked/didn't work, as well as the action-number within the reaper-kb.ini\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nconsolidate:consolidation state of this action\nsection:section, in which this action is started\nActionCommandID:the ActionCommandIDs for the actions, that are triggered by this action; unlike CommandID-numbers, every ActionCommandID must begin with _ ; will not be checked vor valid ones!\nDescription:a description for this action\nActionCommandIDs:the ActionCommandIDs for the actions, that are triggered by this action; unlike CommandID-numbers, every ActionCommandID must begin with _ ; will not be checked vor valid ones!\nreplace:true if an already existing entry shall be replaced, false if not\nRETURNS:\nretval:true, if adding/setting worked, false if it didn't\nactionnumber:the entrynumber within the reaper-kb.ini of this action\n",
        "body": "${1:local }${2:boolean retval},${3:integer actionnumber} = ultraschall.SetKBIniActions(${4:string filename_with_path},${5:integer consolidate},${6:integer section},${7:string ActionCommandID},${8:string Description},${9:string ActionCommandIDs},${10:boolean replace})$0"
    },
    "ULTRASCHALL.SETKBINISCRIPTS_WR lua": {
        "prefix": "ultraschallwr.SetKBIniScripts",
        "scope": "lua",
        "description": "Adds or sets(if it already exists) an \"SCR\"-script of a reaper-kb.ini.\nReturns true/false when adding or setting worked/didn't work, as well as the script-number within the reaper-kb.ini\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nterminate:state of handling mulitple running scripts\nsection:section, in which this script is started\nActionCommandID:the ActionCommandID of this action\nDescription:a description for this script\nScriptname:the name of the ReaScript, like .lua or .eel or .py\nreplace:true if an already existing entry shall be replaced, false if not\nRETURNS:\nretval:true, if adding/setting worked, false if it didn't\nscriptnumber:the entrynumber within the reaper-kb.ini of this script\n",
        "body": "${1:local }${2:boolean retval},${3:integer scriptnumber} = ultraschall.SetKBIniScripts(${4:string filename_with_path},${5:integer terminate},${6:integer section},${7:string ActionCommandID},${8:string Description},${9:string Scriptname},${10:boolean replace})$0"
    },
    "ULTRASCHALL.SETKBINIKEYS_WR lua": {
        "prefix": "ultraschallwr.SetKBIniKeys",
        "scope": "lua",
        "description": "Adds or sets(if it already exists) a \"KEY\"-key of a reaper-kb.ini.\nReturns true/false when adding or setting worked/didn't work, as well as the keybinding-number within the reaper-kb.ini.\nAdditional keybindings cannot share the same keytype_modifier_midichan, key_midinote and section at the same time, as every such keybind must be unique.\nFor a detailed description in how KEY-entries work, refer to Reaper-Filetype-Descriptions.html#Reaper-kb.ini.\nDoes not support OSC-keybindings, as they are stored in OSC/reaper-osc-actions.ini !\nNeeds a restart of Reaper for this change to take effect!\nreturns false in case of an error\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nkeytype_modifier_midichan:Type of Keytype, modifier or midichannel\nkey_midinote:the key(like ASCII-Codes) or midinote. \nActionCommandID:the ActionCommandID associated with this shortcut.\nsection:the section, in which this shortcut is used\nreplace:true if an already existing entry shall be replaced, false if not\nRETURNS:\nretval:true, if adding/setting worked, false if it didn't\n",
        "body": "${1:local }${2:boolean retval},${3:integer keynumber} = ultraschall.SetKBIniKeys(${4:string filename_with_path},${5:integer keytype_modifier_midichan},${6:integer key_midinote},${7:string ActionCommandID},${8:integer section},${9:boolean replace})$0"
    },
    "ULTRASCHALL.DELETEKBINIACTIONS_WR lua": {
        "prefix": "ultraschallwr.DeleteKBIniActions",
        "scope": "lua",
        "description": "Deletes an \"ACT\"-action of a reaper-kb.ini.\nReturns true/false when deleting worked/didn't work.\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nidx:indexnumber of the action within the reaper-kb.ini\nRETURNS:\nretval:true, if deleting worked, false if it didn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteKBIniActions(${3:string filename_with_path},${4:integer idx})$0"
    },
    "ULTRASCHALL.DELETEKBINISCRIPTS_WR lua": {
        "prefix": "ultraschallwr.DeleteKBIniScripts",
        "scope": "lua",
        "description": "Deletes an \"SCR\"-script of a reaper-kb.ini.\nReturns true/false when deleting worked/didn't work.\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nidx:indexnumber of the script within the reaper-kb.ini\nRETURNS:\nretval:true, if deleting worked, false if it didn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteKBIniScripts(${3:string filename_with_path},${4:integer idx})$0"
    },
    "ULTRASCHALL.DELETEKBINIKEYS_WR lua": {
        "prefix": "ultraschallwr.DeleteKBIniKeys",
        "scope": "lua",
        "description": "Deletes a \"KEY\"-keybinding of a reaper-kb.ini.\nReturns true/false when deleting worked/didn't work.\nNeeds a restart of Reaper for this change to take effect!\nPARAMETERS:\nfilename_with_path:filename with path for the reaper-kb.ini\nidx:indexnumber of the keybinding within the reaper-kb.ini\nRETURNS:\nretval:true, if deleting worked, false if it didn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteKBIniKeys(${3:string filename_with_path},${4:integer idx})$0"
    },
    "ULTRASCHALL.SETINIFILEVALUE_WR lua": {
        "prefix": "ultraschallwr.SetIniFileValue",
        "scope": "lua",
        "description": "Sets a value of a key in an ini-file\nreturns -1 in case of an error\nPARAMETERS:\nsection:the section, in which the key-value-pair is located\nkey:the key whose value you want to change\nvalue:the new value for this key-value-pair\ninifile:the ini-file, in which you want to set the key-value-store\nRETURNS:\nretval:-1, in case of an error; 1, in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetIniFileValue(${3:string section},${4:string key},${5:string value},${6:string inifile})$0"
    },
    "ULTRASCHALL.QUERYKEYBOARDSHORTCUTBYKEYID_WR lua": {
        "prefix": "ultraschallwr.QueryKeyboardShortcutByKeyID",
        "scope": "lua",
        "description": "Returns the name of the shortcut of the modifier-key-values, as stored in the KEY-entries within the reaper-kb.ini\nThat way, you can take a KEY-entry from the reaper-kb.ini, like\nKEY 1 65 _Ultraschall_Play_From_Editcursor_Position 0\nExtract the modifier and key-values(1 and 65 in the example) and pass them to this function.\nYou will get returned \"A\" as 1 and 65 is the keyboard-shortcut-code for the A-key.\nOnly necessary for those, who try to read keyboard-shortcuts directly from the reaper-kb.ini to display them in some way.\nreturns nil in case of an error\nPARAMETERS:\nmodifier:the modifier value, which is the first one after KEY in a KEY-entry in the reaper-kb.ini-file\nkey:the key value, which is the second one after KEY in a KEY-entry in the reaper-kb.ini-file\nRETURNS:\nShortcutname:the actual name of the shortcut, like \"A\" or \"F1\" or \"Ctrl+Alt+Shift+Win+PgUp\".\n",
        "body": "${1:local }${2:string Shortcutname} = ultraschall.QueryKeyboardShortcutByKeyID(${3:integer modifier},${4:integer key})$0"
    },
    "ULTRASCHALL.GETSETCONFIGACIDIMPORT_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAcidImport",
        "scope": "lua",
        "description": "Gets/Sets the value of \"When importing media\"-dropdownlist, as set in the Media with embedded tempo information-section in Preferences -> Video/REX/Misc\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"acidimport\", as well as the reaper.ini-entry \"REAPER -> acidimport\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAcidImport(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGACTIONMENU_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigActionMenu",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Show recent actions\"-entry, as set in the Actions-menu.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"actionmenu\", as well as the reaper.ini-entry \"REAPER -> actionmenu\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigActionMenu(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGADJRECLAT_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAdjRecLat",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Use audio driver reported latency\"-checkbox, as set in Preferences -> Recording\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"adjreclat\", as well as the reaper.ini-entry \"REAPER -> adjreclat\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAdjRecLat(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGADJRECMANLAT_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAdjRecManLat",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Output manual offset-samples\"-inputbox, as set in Preferences -> Recording\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"adjrecmanlat\", as well as the reaper.ini-entry \"REAPER -> adjrecmanlat\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value; 0 to 2147483647; in samples\nsetting:the current/new setting-value; 0 to 2147483647; in samples\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value; 0 to 2147483647; in samples\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAdjRecManLat(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAFXCFG_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAfxCfg",
        "scope": "lua",
        "description": "Gets/Sets the value of the audioformat for \"Apply FX, Glue, Freeze, etc\", as set in the Project Settings->Media-dialog\nOnly sets the format, not the individual format-settings(like bitrate, etc)!\nTo keep the setting for new projects as standard-setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"afxcfg\", as well as the reaper.ini-entry \"REAPER -> afxcfg\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the new set audioformat\nsetting:the new set audioformat\npersist:true, this setting will be standard-setting for new projects after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/newly set audioformat \n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAfxCfg(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGALLSTEREOPAIRS_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAllStereoPairs",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Show non-standard stereo channel pairs(i.e Input2/Input3 etc)\"-checkbox in the Channel naming/mapping-section, as set in Preferences -> Audio\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"allstereopairs\", as well as the reaper.ini-entry \"REAPER -> allstereopairs\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAllStereoPairs(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGALWAYSALLOWKB_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAlwaysAllowKB",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Allow keyboard commands even when mouse-editing\"-checkbox, as set in Preferences -> General ->Advanced UI/system tweaks\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"alwaysallowkb\", as well as the reaper.ini-entry \"REAPER -> alwaysallowkb\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value; 0 to 1\nsetting:the current/new setting-value; 0 to 1\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value; 0(don't allow) to 1(allow)\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAlwaysAllowKB(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAPPLYFXTAIL_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigApplyFXTail",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Tail length when using Apply FX to items\"-inputbox in milliseconds, as set in Preferences -> Media\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"applyfxtail\", as well as the reaper.ini-entry \"REAPER -> applyfxtail\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value; 0 to 2147483647\nsetting:the current/new setting-value; 0 to 2147483647\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value; 0 to 2147483647\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigApplyFXTail(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGADJRECMANLATIN_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAdjRecManLatIn",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Input manual offset-samples\"-inputbox, as set in Preferences -> Recording\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"adjrecmanlatin\", as well as the reaper.ini-entry \"REAPER -> adjrecmanlatin\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAdjRecManLatIn(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOPRSHIFT_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAudioPrShift",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Preserve pitch in audio items when changing master playrate\", as set in the contextmenu of the master-playrate in the transport-area as well as toggled by action 40671(all sections)\nThis is a project-setting. That means, setting persist to true will have an effect on new projects create, but only after you restarted Reaper!\nThis alters the configuration-variable \"audioprshift\", as well as the reaper.ini-entry \"REAPER -> audioprshift\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept for new projects, but only after restart of Reaper; false, old standard-project-setting will be kept\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAudioPrShift(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOCLOSESTOP_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAudioCloseStop",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Close audio device when stopped and active(less responsive)\"-checkbox, as set in Preferences -> Audio\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"audioclosestop\", as well as the reaper.ini-entry \"REAPER -> audioclosestop\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAudioCloseStop(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOTHREADPR_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAudioThreadPr",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Audio thread priority\"-dropdownlist, as set in Preferences -> Device\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"audiothreadpr\", as well as the reaper.ini-entry \"REAPER -> audiothreadpr\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAudioThreadPr(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUDIOCLOSETRACKWNDS_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAudioCloseTrackWnds",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Allow snap grid/track envelope/routing windows to stay open\"-checkbox in Preferences -> General -> Advanced UI/system tweaks.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"autoclosetrackwnds\", as well as the reaper.ini-entry \"REAPER -> autoclosetrackwnds\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAudioCloseTrackWnds(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOMUTE_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAutoMute",
        "scope": "lua",
        "description": "Gets/Sets the value of \"Automute-dropdownlist in the section Mute\"-settings, as set in Preferences -> Mute/Solo\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"automute\", as well as the reaper.ini-entry \"REAPER -> automute\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAutoMute(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOMUTEFLAGS_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAutoMuteFlags",
        "scope": "lua",
        "description": "Sets the \"Reset on playback start\"-checkbox in section Mute-settings, as set in Preferences -> Mute/Solo\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"automuteflags\", as well as the reaper.ini-entry \"REAPER -> automuteflags\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAutoMuteFlags(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOSAVEINT_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAutoSaveInt",
        "scope": "lua",
        "description": "Sets the \"Every x minutes\"-inputbox from the Project saving-section, as set in Preferences -> Project.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"autosaveint\", as well as the reaper.ini-entry \"REAPER -> autosaveint\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAutoSaveInt(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.GETSETCONFIGAUTOSAVEMODE_WR lua": {
        "prefix": "ultraschallwr.GetSetConfigAutoSaveMode",
        "scope": "lua",
        "description": "Sets the \"Every x minutes\"-dropdownlist from the Project saving-section, as set in Preferences -> Project.\nTo keep the setting after restart of Reaper, set persist=true\nThis alters the configuration-variable \"autosavemode\", as well as the reaper.ini-entry \"REAPER -> autosavemode\"\nreturns -1 in case of an error\nPARAMETERS:\nset:the current/new setting-value\nsetting:the current/new setting-value\npersist:true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper\nRETURNS:\nretval:the current/new setting-value\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetSetConfigAutoSaveMode(${3:boolean set},${4:integer setting},${5:boolean persist})$0"
    },
    "ULTRASCHALL.SETRENDER_OFFLINEONLINEMODE_WR lua": {
        "prefix": "ultraschallwr.SetRender_OfflineOnlineMode",
        "scope": "lua",
        "description": "sets the current mode of the offline/online-render-dropdownlist from the Render to File-dialog\nReturns false in case of an error\nPARAMETERS:\nmode:the mode, that you want to set\nRETURNS:\nretval:true, setting it was successful; false, setting it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRender_OfflineOnlineMode(${3:integer mode})$0"
    },
    "ULTRASCHALL.GETRENDER_OFFLINEONLINEMODE_WR lua": {
        "prefix": "ultraschallwr.GetRender_OfflineOnlineMode",
        "scope": "lua",
        "description": "gets the current mode of the offline/online-render-dropdownlist from the Render to File-dialog\nRETURNS:\nmode:the mode, that is set\n",
        "body": "${1:local }${2:integer mode} = ultraschall.GetRender_OfflineOnlineMode()$0"
    },
    "ULTRASCHALL.GETRENDER_RESAMPLEMODE_WR lua": {
        "prefix": "ultraschallwr.GetRender_ResampleMode",
        "scope": "lua",
        "description": "gets the current mode of the \"Resample mode (if needed)\"-dropdownlist from the Render to File-dialog\nRETURNS:\nmode:the mode, that is set\n",
        "body": "${1:local }${2:integer mode} = ultraschall.GetRender_ResampleMode()$0"
    },
    "ULTRASCHALL.SETRENDER_RESAMPLEMODE_WR lua": {
        "prefix": "ultraschallwr.SetRender_ResampleMode",
        "scope": "lua",
        "description": "sets the current mode of the \"Resample mode (if needed)\"-dropdownlist from the Render to File-dialog\nReturns false in case of an error\nPARAMETERS:\nmode:the mode, that is set\nRETURNS:\nretval:true, setting it was successful; false, setting it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRender_ResampleMode(${3:integer mode})$0"
    },
    "ULTRASCHALL.GETSTARTNEWFILERECSIZESTATE_WR lua": {
        "prefix": "ultraschallwr.GetStartNewFileRecSizeState",
        "scope": "lua",
        "description": "Returns, if Reaper shall start a file after a specified amount of MegaBytes as well, if the fileswitches shall be offset when multitrack-recording and the maximum filesize before starting a new file.\nsee SetStartNewFileRecSizeState for setting the current settings.\nRETURNS:\nstart_new_files:true, Reaper starts a new file, when a recorded file reaches max_rec_size; false, files are as long until recording stops\noffset_file_switches:true, When recording multiple tracks, offset file switches for better performance; false, don't offset file-switches\nmax_rec_size:the maximum length of a recorded file in MegaBytes, before Reaper shall start a new file; only applied when When recording multiple tracks, offset file switches for better performance=true\n",
        "body": "${1:local }${2:boolean start_new_files},${3:boolean offset_file_switches},${4:integer max_rec_size} = ultraschall.GetStartNewFileRecSizeState()$0"
    },
    "ULTRASCHALL.SETSTARTNEWFILERECSIZESTATE_WR lua": {
        "prefix": "ultraschallwr.SetStartNewFileRecSizeState",
        "scope": "lua",
        "description": "Sets, if Reaper shall start a file after a specified amount of MegaBytes as well, if the fileswitches shall be offset when multitrack-recording and the maximum filesize before starting a new file.\nsee GetStartNewFileRecSizeState for getting the current settings.\nReturns false in case of an error\nPARAMETERS:\nstart_new_files:true, Reaper starts a new file, when a recorded file reaches max_rec_size; false, files are as long until recording stops\noffset_file_switches:true, When recording multiple tracks, offset file switches for better performance; false, don't offset file-switches\npersist:true, set the setting to reaper.ini so it persists after restarting Reaper; false, set it only for the time, until Reaper is restarted\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetStartNewFileRecSizeState(${3:boolean start_new_files},${4:boolean offset_file_switches},${5:integer maxrecsize},${6:boolean persist})$0"
    },
    "ULTRASCHALL.GETDEFERRUNSTATE_WR lua": {
        "prefix": "ultraschallwr.GetDeferRunState",
        "scope": "lua",
        "description": "returns the run-state of a Ultraschall-defer-loop in a specific scriptinstance\nYou can either request the runstate of a Defer.\nreturns nil in case of an error.\nPARAMETERS:\ndeferinstance:0, to use the parameter identifier\nRETURNS:\nretval:true, defer-instance is running; false, defer-instance isn't running\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GetDeferRunState(${3:integer deferinstance},${4:optional string scriptidentifier})$0"
    },
    "ULTRASCHALL.STOPDEFERCYCLE_WR lua": {
        "prefix": "ultraschallwr.StopDeferCycle",
        "scope": "lua",
        "description": "Stops a running ultraschall.Defer-instance of a script-instance.\nreturns false in case of an error\nPARAMETERS:\ndefer_identifier:the identifier of the defer-cycle of a script-instance\nRETURNS:\nretval:true, stopping this defer-cycle was successful; false, it wasn't successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.StopDeferCycle(${3:string defer_identifier})$0"
    },
    "ULTRASCHALL.DEFER_WR lua": {
        "prefix": "ultraschallwr.Defer",
        "scope": "lua",
        "description": "runs a custom-defer-cycle, which can be individualized.\nYou can set, how often this defer-cycle shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\\_identifier you have given.\nTo stop such a defer-cycle, use StopDeferCycle, as long as parameter protected is not set to true!\n**Important:** make the deferidentifier as unique as possible(using guids or similar stuff) to avoid naming conflicts with other defer-cycles using the same identifier.\nOtherwise, you risk stopping multiple such defer-loops, when using StopDeferCycle!\nFor the old Defer1 to Defer20-behavior, try ultraschall.ScriptIdentifier..\".defer_scriptXX\" as defer-identifier, where XX is a number.\nreturns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)\nPARAMETERS:\nfunc:the function, you would love to defer to\ndeferidentifier:an identifier, under which you can access this defer-cycle; make it unique using guids in the name, to avoid name-conflicts!\nmode:0 or nil, just run as regular defer-cycle\ntimer_counter:the timer for the defer-cycle\nprotected:true, this defer-cycle is protected from being stopped by StopDeferCycle(); false or nil, you can stop this defer-cycle using StopDeferCycle()\nRETURNS:\nretval:true, running this defer-cycle was successful; false, it wasn't successful\ndefer_identifier:if running this defer-cycle was successful, this holds the defer-identifier you've chosen\n",
        "body": "${1:local }${2:boolean retval},${3:optional string defer_identifier} = ultraschall.Defer(${4:function func},${5:string deferidentifier},${6:optional integer mode},${7:optional number timer_counter},${8:optional boolean protected})$0"
    },
    "ULTRASCHALL.SETDEFERCYCLESETTINGS_WR lua": {
        "prefix": "ultraschallwr.SetDeferCycleSettings",
        "scope": "lua",
        "description": "Sets the mode and timing settings of a running ultraschall.Defer-instance. You can set its mode and the timer/counter-values, even from a script, which does not run the defer-instance!\nReturns false in case of failure.\nPARAMETERS:\ndeferidentifier:an identifier, under which you can access this defer-cycle; make it unique using guids in the name, to avoid name-conflicts! \nmode:the timing mode, in which the defer-cycle runs\ntimer_counter:the timer for the defer-cycle\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetDeferCycleSettings(${3:string deferidentifier},${4:optional integer mode},${5:optional number timer_counter})$0"
    },
    "ULTRASCHALL.GETDEFERCYCLESETTINGS_WR lua": {
        "prefix": "ultraschallwr.GetDeferCycleSettings",
        "scope": "lua",
        "description": "Gets a the mode and timing-settings of a currently running ultraschall.Defer()-cycle\nReturns nil in case of failure.\nPARAMETERS:\ndeferidentifier:an identifier, under which you can access this defer-cycle; make it unique using guids in the name, to avoid name-conflicts! \nRETURNS:\nmode:the timing mode, in which the defer-cycle runs\ntimer_counter:the timer for the defer-cycle\n",
        "body": "${1:local }${2:integer mode},${3:integer timer_counter} = ultraschall.GetDeferCycleSettings(${4:string deferidentifier})$0"
    },
    "ULTRASCHALL.ISVALIDENVSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.IsValidEnvStateChunk",
        "scope": "lua",
        "description": "returns, if a EnvelopeStateChunk is a valid statechunk\nreturns false, in case of an error\nPARAMETERS:\nEnvelopeStateChunk:a string to check, if it's a valid EnvelopeStateChunk\nRETURNS:\nvalid:true, if the string is a valid statechunk; false, if not a valid statechunk\n",
        "body": "${1:local }${2:boolean valid} = ultraschall.IsValidEnvStateChunk(${3:string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.MOVETRACKENVELOPEPOINTSBY_WR lua": {
        "prefix": "ultraschallwr.MoveTrackEnvelopePointsBy",
        "scope": "lua",
        "description": "Moves the envelopepoints between startposition and endposition by moveby in MediaTrack.\nIt moves all trackenvelope-points for all track-envelopes available.\nDoes NOT move item-envelopepoints!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\nMediaTrack:the MediaTrack object of the track, where the EnvelopsPoints shall be moved\ncut_at_border:true, cut envelope-points, that would move outside section between startposition and endposition\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "${1:local }${2:integer retval} = ultraschall.MoveTrackEnvelopePointsBy(${3:number startposition},${4:number endposition},${5:number moveby},${6:MediaTrack MediaTrack},${7:boolean cut_at_border})$0"
    },
    "ULTRASCHALL.GETENVELOPEPOINT_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopePoint",
        "scope": "lua",
        "description": "Returns the values for the idxth envelope point in Tracknumber->EnvelopeName.\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track, beginning with 1. Use 0 for Master Track.\nEnvelopeName:the name of the envelope-lane\nidx:the number of the envelope-point, beginning with 0\nRETURNS:\ntime:the time of the envelope point\nvalue:the raw-value of the envelope point\nshape:the shape of this envelope\ntension:the intensity of the tension of the shape\nselected:true, if this point is selected; false if not\ndBVal:the envelopevalue converted to dB\nEnvelopePointObject:an array with all elements of an envelopepoint\n",
        "body": "${1:local }${2:number time},${3:number value},${4:integer shape},${5:number tension},${6:boolean selected},${7:number dBVal},${8:array EnvelopePointObject} = ultraschall.GetEnvelopePoint(${9:integer Tracknumber},${10:string EnvelopeName},${11:integer idx})$0"
    },
    "ULTRASCHALL.GETCLOSESTENVELOPEPOINTIDX_BYTIME_WR lua": {
        "prefix": "ultraschallwr.GetClosestEnvelopePointIDX_ByTime",
        "scope": "lua",
        "description": "Returns the idxs and EnvelopePointObject of the envelope-points closest to timeposition CheckTime\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track, beginning with 1. Use 0 for Master Track.\nEnvelopeName:the name of the envelope-lane\nCheckTime:the time in seconds to check for the closest envelope-points\nRETURNS:\nidxpre:the idx of the closest envelopepoint at or before CheckTime\nEnvelopePointObjectPre:an EnvelopePointObject of idxpre\nidxpost:the idx of the closest envelopepoint after CheckTime\nEnvelopePointObjectPost:an EnvelopePointObject of idxpost\n",
        "body": "${1:local }${2:integer idxpre},${3:array EnvelopePointObjectPre},${4:integer idxpost},${5:array EnvelopePointObjectPost} = ultraschall.GetClosestEnvelopePointIDX_ByTime(${6:integer Tracknumber},${7:string EnvelopeName},${8:number CheckTime})$0"
    },
    "ULTRASCHALL.GETENVELOPEPOINTIDX_BETWEEN_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopePointIDX_Between",
        "scope": "lua",
        "description": "Returns a string and an EnvelopePointArray with all idx/EnvelopePointObjects of all envelopepoints between startposition and endposition in the EnvelopeName-lane.\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track. 1 for track 1, 2 for track 2, etc. 0 for Master-track.\nEnvelopeName:the name of the envelope-lane, where you want to have the envelope-points of.\nstartposition:the startposition of the selection in seconds. Must be bigger than or equal 0.\nendposition:the endposition of the selection in seconds. Must be bigger than startposition.\nRETURNS:\nEnvelopeString:a string with all envelope-point-idx in the selection, separated by commas.\nEnvelopePointArray:an array with all EnvelopePointObjects of all envelope-points in selection.\n",
        "body": "${1:local }${2:string EnvelopeString},${3:array EnvelopePointArray} = ultraschall.GetEnvelopePointIDX_Between(${4:integer Tracknumber},${5:string EnvelopeName},${6:number startposition},${7:number endposition})$0"
    },
    "ULTRASCHALL.CHECKENVELOPEPOINTOBJECT_WR lua": {
        "prefix": "ultraschallwr.CheckEnvelopePointObject",
        "scope": "lua",
        "description": "Checks, if EnvelopePointObject is valid or not.\nreturns false in case of an error\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.CheckEnvelopePointObject(${3:array EnvelopePointObject})$0"
    },
    "ULTRASCHALL.ISVALIDENVELOPEPOINTOBJECT_WR lua": {
        "prefix": "ultraschallwr.IsValidEnvelopePointObject",
        "scope": "lua",
        "description": "Checks, if EnvelopePointObject is valid or not.\nreturns false in case of an error\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidEnvelopePointObject(${3:array EnvelopePointObject})$0"
    },
    "ULTRASCHALL.SETENVELOPEPOINTS_ENVELOPEPOINTOBJECT_WR lua": {
        "prefix": "ultraschallwr.SetEnvelopePoints_EnvelopePointObject",
        "scope": "lua",
        "description": "Sets an envelope-point, as defined in EnvelopePointObject.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetEnvelopePoints_EnvelopePointObject(${3:array EnvelopePointObject},${4:boolean sort_in})$0"
    },
    "ULTRASCHALL.SETENVELOPEPOINTS_ENVELOPEPOINTARRAY_WR lua": {
        "prefix": "ultraschallwr.SetEnvelopePoints_EnvelopePointArray",
        "scope": "lua",
        "description": "Sets envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointArray:an array with all EnvelopePointObjects you want to insert\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetEnvelopePoints_EnvelopePointArray(${3:array EnvelopePointArray},${4:boolean sort_in})$0"
    },
    "ULTRASCHALL.DELETEENVELOPEPOINTS_ENVELOPEPOINTOBJECT_WR lua": {
        "prefix": "ultraschallwr.DeleteEnvelopePoints_EnvelopePointObject",
        "scope": "lua",
        "description": "Deletes an envelope-point, as defined in EnvelopePointObject.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteEnvelopePoints_EnvelopePointObject(${3:array EnvelopePointObject})$0"
    },
    "ULTRASCHALL.DELETEENVELOPEPOINTS_ENVELOPEPOINTARRAY_WR lua": {
        "prefix": "ultraschallwr.DeleteEnvelopePoints_EnvelopePointArray",
        "scope": "lua",
        "description": "Deletes the envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointArray:an array with all EnvelopePointObjects you want to insert\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteEnvelopePoints_EnvelopePointArray(${3:array EnvelopePointArray})$0"
    },
    "ULTRASCHALL.ADDENVELOPEPOINTS_ENVELOPEPOINTOBJECT_WR lua": {
        "prefix": "ultraschallwr.AddEnvelopePoints_EnvelopePointObject",
        "scope": "lua",
        "description": "Adds an envelope-point, as defined in EnvelopePointObject.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointObject:an array with all information of an envelope point\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AddEnvelopePoints_EnvelopePointObject(${3:array EnvelopePointObject},${4:boolean sort_in})$0"
    },
    "ULTRASCHALL.ADDENVELOPEPOINTS_ENVELOPEPOINTARRAY_WR lua": {
        "prefix": "ultraschallwr.AddEnvelopePoints_EnvelopePointArray",
        "scope": "lua",
        "description": "Adds the envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.\nreturns true in case of success, false in case of failure.\nPARAMETERS:\nEnvelopePointArray:an array with all EnvelopePointObjects you want to insert\nsort_in:set true, if setting multiple points at once and call Envelope_SortPoints when done.\nRETURNS:\nretval:true, if it's a valid EnvelopePointObject; false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AddEnvelopePoints_EnvelopePointArray(${3:array EnvelopePointArray},${4:boolean sort_in})$0"
    },
    "ULTRASCHALL.CREATEENVELOPEPOINTOBJECT_WR lua": {
        "prefix": "ultraschallwr.CreateEnvelopePointObject",
        "scope": "lua",
        "description": "Creates a new EnvelopePointObject, that can be used by other ultraschall-api-envelope-functions\nreturns false in case of error\nPARAMETERS:\nTrackEnvelope:the track-envelope, in which this EnvelopePointObject shall be\nidx:the number of the envelope-point, beginning with 0\ntime:the time of the envelope point in seconds\nvalue:the raw-value of the envelope point\nshape:the shape of this envelope\ntension:the intensity of the tension of the shape\nselected:true, if this point is selected; false if not\nRETURNS:\nretval:false in case of error, true in case of success.\nEnvelopePointObject:an array with all elements of the envelopepoint\n",
        "body": "${1:local }${2:boolean retval},${3:array EnvelopePointObject} = ultraschall.CreateEnvelopePointObject(${4:TrackEnvelope TrackEnvelope},${5:integer idx},${6:number time},${7:number value},${8:integer shape},${9:number tension},${10:boolean selected})$0"
    },
    "ULTRASCHALL.COUNTENVELOPEPOINTS_WR lua": {
        "prefix": "ultraschallwr.CountEnvelopePoints",
        "scope": "lua",
        "description": "Counts and returns the number of envelope-points in track Tracknumber, envelopelane EnvelopeName.\nreturns -1 in case of error\nPARAMETERS:\nTracknumber:the number of the track, beginning with 1. Use 0 for Master Track.\nEnvelopeName:the name of the envelope-lane\nRETURNS:\nenvpoint_count:the number of envelope-points in requested track+envelope-lane\n",
        "body": "${1:local }${2:integer envpoint_count} = ultraschall.CountEnvelopePoints(${3:integer Tracknumber},${4:string EnvelopeName})$0"
    },
    "ULTRASCHALL.SETENVELOPEHEIGHT_WR lua": {
        "prefix": "ultraschallwr.SetEnvelopeHeight",
        "scope": "lua",
        "description": "Changes the Envelope-lane-height and compactible state of TrackEnvelope or TrackEnvelopeStateChunk.\nreturns false in case of an error\nPARAMETERS:\nHeight:the height of the envelopelane in pixels when not compacted. Reaper accepts 24-443 currently. Nil keeps old value.\nCompacted:shall the envelopelane be compacted(true) or not(false). Nil keeps old value.\nTrackEnvelope:the TrackEnvelopeStateChunk you want to alter. Will be used only, if TrackEnvelope is set to nil\nTrackEnvelopeStateChunk:the TrackEnvelopeStateChunk you want to alter. Will be used only, if TrackEnvelope is set to nil\nRETURNS:\nretval:true in case of success; false in case of error\nTrackEnvelopeStateChunk:the altered TrackEnvelopeStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackEnvelopeStateChunk} = ultraschall.SetEnvelopeHeight(${4:integer Height},${5:boolean Compacted},${6:TrackEnvelope TrackEnvelope},${7:string TrackEnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETALLTRACKENVELOPES_WR lua": {
        "prefix": "ultraschallwr.GetAllTrackEnvelopes",
        "scope": "lua",
        "description": "Returns all TrackEnvelopes of all tracks from the current project as a handy table\nThe format of the table is as follows:\nTrackEnvelopes[trackenvelope_idx][\"Track\"] - the idx of the track; 0, for mastertrack, 1, for first track, etc\nTrackEnvelopes[trackenvelope_idx][\"EnvelopeObject\"] - the TrackEnvelope-object\nTrackEnvelopes[trackenvelope_idx][\"EnvelopeName\"] - the name of of TrackEnvelopeObject\nRETURNS:\nnumber_of_trackenvelopes:the number of TrackEnvelopes found in the current project\nTrackEnvelopes_Table:all found TrackEnvelopes as a handy table(see description for details)\n",
        "body": "${1:local }${2:integer number_of_trackenvelopes},${3:table TrackEnvelopes_Table} = ultraschall.GetAllTrackEnvelopes()$0"
    },
    "ULTRASCHALL.ISVALIDENVELOPEPOINTARRAY_WR lua": {
        "prefix": "ultraschallwr.IsValidEnvelopePointArray",
        "scope": "lua",
        "description": "Checks, if an EnvelopePointArray is a valid one.\nReturns false in case of an error\nPARAMETERS:\nEnvelopePointArray:the EnvelopePointArray to check for it's validity\nRETURNS:\nretval:true, EnvelopePointArray is a valid one; false, EnvelopePointArray isn't valid\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidEnvelopePointArray(${3:EnvelopePointArray EnvelopePointArray})$0"
    },
    "ULTRASCHALL.GETLASTENVELOPEPOINT_TRACKENVELOPE_WR lua": {
        "prefix": "ultraschallwr.GetLastEnvelopePoint_TrackEnvelope",
        "scope": "lua",
        "description": "Gets the values of the last envelope-point in TrackEnvelope/MediaItemEnvelope.\nNote: there's a \"hidden\" last envelopepoint in every Envelope, which will be ignored by this function. It will return the last visible envelope-point instead!\nReturns false in case of an error\nPARAMETERS:\nEnvelope:the Trackenvelope/MediaItemenvelope, whose last point you want\nRETURNS:\nretval:true, getting the envelopepoint was successful; false, in case of an error\nenvpointidx:the idx of the found envelope-point; with 0 for the first one on the Envelope\ntime:the time of the envelope-point in seconds\nvalue:the value of the envelope-point\nshape:the shape of the envelope-point\ntension:the intensity of the tension of the shape\noptional boolean selected:true, envelope-point is selected; false, it is not selected\n",
        "body": "${1:local }${2:boolean retval},${3:optional integer envpointidx},${4:optional number time},${5:optional number value},${6:optional integer shape},${7:optional number tension},${8:optional boolean selected} = ultraschall.GetLastEnvelopePoint_TrackEnvelope(${9:TrackEnvelope Envelope})$0"
    },
    "ULTRASCHALL.GETARMSTATE_ENVELOPE_WR lua": {
        "prefix": "ultraschallwr.GetArmState_Envelope",
        "scope": "lua",
        "description": "Returns the current armed-state of a TrackEnvelope-object.\nIt is the entry ARM\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose armed-state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nretval:0, unarmed; 1, armed\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetArmState_Envelope(${3:TrackEnvelope TrackEnvelope},${4:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.SETARMSTATE_ENVELOPE_WR lua": {
        "prefix": "ultraschallwr.SetArmState_Envelope",
        "scope": "lua",
        "description": "Sets the new armed-state of a TrackEnvelope-object.\nreturns false in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose armed-state you want to change\nstate:0, unarmed; 1, armed\nEnvelopeStateChunk:if parameter TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameters and change its arm-state\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\nEnvelopeStateChunk:the altered EnvelopeStateChunk, when parameter TrackEnvelope is set to nil\n",
        "body": "${1:local }${2:boolean retval},${3:optional string EnvelopeStateChunk} = ultraschall.SetArmState_Envelope(${4:TrackEnvelope TrackEnvelope},${5:integer state},${6:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKENVELOPE_CLICKSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackEnvelope_ClickState",
        "scope": "lua",
        "description": "Returns the currently clicked Envelopepoint and TrackEnvelope, as well as the current timeposition.\nWorks only, if the mouse is above the EnvelopePoint while having it clicked!\nReturns false, if no envelope is clicked at\nRETURNS:\nclickstate:true, an envelopepoint has been clicked; false, no envelopepoint has been clicked\nposition:the position, at which the mouse has clicked\ntrack:the track, from which the envelope and it's corresponding point is taken from\nenvelope:the TrackEnvelope, in which the clicked envelope-point lies\nEnvelopePointIDX:the id of the clicked EnvelopePoint\n",
        "body": "${1:local }${2:boolean clickstate},${3:number position},${4:MediaTrack track},${5:TrackEnvelope envelope},${6:integer EnvelopePointIDX} = ultraschall.GetTrackEnvelope_ClickState()$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_NUMBERSONLY_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_NumbersOnly",
        "scope": "lua",
        "description": "returns a state from an EnvelopeStateChunk.\nIt only supports single-entry-states with numbers/integers, separated by spaces!\nAll other values will be set to nil and strings with spaces will produce weird results!\nreturns nil in case of an error\nPARAMETERS:\nstate:the state, whose attributes you want to retrieve\nfunctionname:if this function is used within specific gettrackstate-functions, pass here the \"host\"-functionname, so error-messages will reflect that\nnumbertoggle:true or nil; converts all values to numbers; false, keep them as string versions\nRETURNS:\nvalues:all values found as numerical indexed array\n",
        "body": "${1:local }${2:table values} = ultraschall.GetEnvelopeState_NumbersOnly(${3:string state},${4:optional string EnvelopeStateChunk},${5:optional string functionname},${6:optional boolean numbertoggle})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_ACT_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_Act",
        "scope": "lua",
        "description": "Returns the current act-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry ACT\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nact:0, bypass on\nautomation_settings:automation item-options for this envelope\n",
        "body": "${1:local }${2:integer act},${3:integer automation_settings} = ultraschall.GetEnvelopeState_Act(${4:TrackEnvelope TrackEnvelope},${5:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_VIS_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_Vis",
        "scope": "lua",
        "description": "Returns the current visibility-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry VIS\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nvisible:1, envelope is visible\nlane:1, envelope is in it's own lane \nunknown:unknown; default=1\n",
        "body": "${1:local }${2:integer visible},${3:integer lane},${4:integer unknown} = ultraschall.GetEnvelopeState_Vis(${5:TrackEnvelope TrackEnvelope},${6:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_LANEHEIGHT_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_LaneHeight",
        "scope": "lua",
        "description": "Returns the current laneheight-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry LANEHEIGHT\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nheight:the height of this envelope in pixels; 24 - 263 pixels\ncompacted:1, envelope-lane is compacted(\"normal\" height is not shown but still stored in height); \n",
        "body": "${1:local }${2:integer height},${3:integer compacted} = ultraschall.GetEnvelopeState_LaneHeight(${4:TrackEnvelope TrackEnvelope},${5:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_DEFSHAPE_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_DefShape",
        "scope": "lua",
        "description": "Returns the current default-shape-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry DEFSHAPE\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nshape:0, linear\nb:unknown; default value is -1; probably pitch/snap\nc:unknown; default value is -1; probably pitch/snap\n",
        "body": "${1:local }${2:integer shape},${3:integer b},${4:integer c} = ultraschall.GetEnvelopeState_DefShape(${5:TrackEnvelope TrackEnvelope},${6:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_VOLTYPE_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_Voltype",
        "scope": "lua",
        "description": "Returns the current voltype-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry VOLTYPE\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nvoltype:1, default volume-type is fader-scaling; if VOLTYPE-entry is not existing, default volume-type is amplitude-scaling\n",
        "body": "${1:local }${2:integer voltype} = ultraschall.GetEnvelopeState_Voltype(${3:TrackEnvelope TrackEnvelope},${4:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_POOLEDENVINSTANCE_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_PooledEnvInstance",
        "scope": "lua",
        "description": "Returns the current state of a certain automation-item within a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry POOLEDENVINST\nreturns nil in case of error\nPARAMETERS:\nindex:the index-number of the automation-item, whose states you want to have\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nid:counts the automation-item-instances in this project, including deleted ones; 1-based\nposition:position in seconds\nlength:length in seconds\nstart_offset:offset in seconds\nplayrate:playrate; minimum value is 0.001; default is 1.000\nselected:1, automation item is selected; 0, automation item isn't selected\nbaseline:0(-100) to 1(+100); default 0.5(0)\nloopsource:Loop Source; 0 and 1 are allowed settings; 1 is default\ni:1, mute automation-item; 0, unmute automation-item\nj:unknown; 0 is default\npool_id:counts the automation-item-instances in this project, including deleted ones; 1-based\nmute:1, mute automation-item; 0, unmute automation-item\n",
        "body": "${1:local }${2:integer id},${3:number position},${4:number length},${5:number start_offset},${6:number playrate},${7:integer selected},${8:number baseline},${9:integer loopsource},${10:integer i},${11:number j},${12:integer pool_id},${13:integer mute} = ultraschall.GetEnvelopeState_PooledEnvInstance(${14:integer index},${15:TrackEnvelope TrackEnvelope},${16:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_PT_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_PT",
        "scope": "lua",
        "description": "Returns the current state of a certain envelope-point within a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the state entry PT\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nposition:position of the point in seconds\nvolume:volume as fader-value\nselected:1, selected; disappearing, unselected\nbezier_tens2:disappears, if no bezier is set; -1 to 1 \n",
        "body": "${1:local }${2:number position},${3:integer volume},${4:integer point_shape_1},${5:integer point_shape_2},${6:integer selected},${7:number bezier_tens1},${8:number bezier_tens2} = ultraschall.GetEnvelopeState_PT(${9:TrackEnvelope TrackEnvelope},${10:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETENVELOPESTATE_ENVNAME_WR lua": {
        "prefix": "ultraschallwr.GetEnvelopeState_EnvName",
        "scope": "lua",
        "description": "Returns the current envelope-name-state of a TrackEnvelope-object or EnvelopeStateChunk.\nIt is the opening <-tag of the EnvelopeStateChunk\nreturns nil in case of error\nPARAMETERS:\nTrackEnvelope:the TrackEnvelope, whose state you want to know; nil, to use parameter EnvelopeStateChunk instead\nEnvelopeStateChunk:if TrackEnvelope is set to nil, you can pass an EnvelopeStateChunk into this parameter, to get that armed state\nRETURNS:\nenvelopename:the name of the envelope, usually:\nfx_env_id:fx_env is the id of the envelope, as provided by this fx; beginning with 1 for the first\nwet_byp:wet_byp is either \"\" if not existing, wet or bypass\nminimum_range:the minimum value, accepted by this envelope; 6 digits-precision\nmaximum_range:the maximum-value, accepted by this envelope; 6 digits-precision\nunknown:unknown\n",
        "body": "${1:local }${2:string envelopename},${3:optional integer fx_env_id},${4:optional string wet_byp},${5:optional number minimum_range},${6:optional number maximum_range},${7:optional number unknown} = ultraschall.GetEnvelopeState_EnvName(${8:TrackEnvelope TrackEnvelope},${9:optional string EnvelopeStateChunk})$0"
    },
    "ULTRASCHALL.GETALLTAKEENVELOPES_WR lua": {
        "prefix": "ultraschallwr.GetAllTakeEnvelopes",
        "scope": "lua",
        "description": "Returns all TakeEnvelopes of all MediaItems from the current project as a handy table\nThe format of the table is as follows:\nTakeEnvelopes[takeenvelope_idx][\"MediaItem\"] - the idx of the MediaItem\nTakeEnvelopes[takeenvelope_idx][\"MediaItem_Take\"] - the idx of the trake of the MediaItem\nTakeEnvelopes[takeenvelope_idx][\"MediaItem_Take_Name\"] - the name of the MediaItek_Take\nTakeEnvelopes[takeenvelope_idx][\"EnvelopeObject\"] - the TakeEnvelopeObject in question\nTakeEnvelopes[takeenvelope_idx][\"EnvelopeName\"] - the name of of TakeEnvelopeObject\nRETURNS:\nnumber_of_takeenvelopes:the number of TakeEnvelopes found in the current project\nTakeEnvelopes_Table:all found TakeEnvelopes as a handy table(see description for details)\n",
        "body": "${1:local }${2:integer number_of_takeenvelopes},${3:table TakeEnvelopes_Table} = ultraschall.GetAllTakeEnvelopes()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATESTARTUPEVENTS_WR lua": {
        "prefix": "ultraschallwr.EventManager_EnumerateStartupEvents",
        "scope": "lua",
        "description": "Enumerates already existing startupevents, that shall be automatically run at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be started automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nindex:the index of the StartUp-event, whose attributes you want to get; 1 for the first, etc\nRETURNS:\nEventIdentifier:the EventIdentifier of the startup-event\nCallerScriptIdentifier:the ScriptIdentifier of the script, which added this event to the StartUpEvents\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nPaused:true, the event shall be started as paused; false, the event shall be run immediately\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "${1:local }${2:string EventIdentifier},${3:string Eventname},${4:string CallerScriptIdentifier},${5:number CheckAllXSeconds},${6:number CheckForXSeconds},${7:boolean StartActionsOnceDuringTrue},${8:boolean Paused},${9:function CheckFunction},${10:number NumberOfActions},${11:table Actions} = ultraschall.EventManager_EnumerateStartupEvents(${12:integer index})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATESTARTUPEVENTS2_WR lua": {
        "prefix": "ultraschallwr.EventManager_EnumerateStartupEvents2",
        "scope": "lua",
        "description": "Enumerates already existing startupevents by an EventIdentifier.\nStartupEvents are events, that shall be automatically run at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be started automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the identifier of the StartupEvent, that you want to enumerate\nRETURNS:\nindex:the index of the StartupEvent within all StartUpEvents\nEventIdentifier:the EventIdentifier of the startup-event\nCallerScriptIdentifier:the ScriptIdentifier of the script, which added this event to the StartUpEvents\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nPaused:true, the event shall be started as paused; false, the event shall be run immediately\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "${1:local }${2:integer index},${3:string EventIdentifier},${4:string Eventname},${5:string CallerScriptIdentifier},${6:number CheckAllXSeconds},${7:number CheckForXSeconds},${8:boolean StartActionsOnceDuringTrue},${9:boolean Paused},${10:function CheckFunction},${11:number NumberOfActions},${12:table Actions} = ultraschall.EventManager_EnumerateStartupEvents2(${13:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ADDEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_AddEvent",
        "scope": "lua",
        "description": "Adds a new event to the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nPARAMETERS:\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet\nCheckFunction:the function, which shall check if the event occurred\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred\nRETURNS:\nevent_identifier:the unique identifier for this registered event, which can be used later for setting, deleting, etc\n",
        "body": "${1:local }${2:string event_identifier} = ultraschall.EventManager_AddEvent(${3:string EventName},${4:integer CheckAllXSeconds},${5:integer CheckForXSeconds},${6:boolean StartActionsOnceDuringTrue},${7:boolean EventPaused},${8:function CheckFunction},${9:table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ISVALIDEVENTIDENTIFIER_WR lua": {
        "prefix": "ultraschallwr.EventManager_IsValidEventIdentifier",
        "scope": "lua",
        "description": "Checks, if a string is a valid EventIdentifier (valid) and currently registered with an event(valid_inuse) in the Ultraschall-EventManager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, that you want to check\nRETURNS:\nvalid:true, valid EventIdentifier, which is currently registered and in use by the EventManager; false, no currently registered EventIdentifier\nvalid_inuse:true, valid EventIdentifier, which is currently registered and in use by the EventManager; false, no currently registered EventIdentifier\n",
        "body": "${1:local }${2:boolean valid},${3:boolean valid_inuse} = ultraschall.EventManager_IsValidEventIdentifier(${4:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVEEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_RemoveEvent",
        "scope": "lua",
        "description": "Removes a new event to the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, which you want to remove from the EventManager\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_RemoveEvent(${3:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVEALLEVENTS_SCRIPT_WR lua": {
        "prefix": "ultraschallwr.EventManager_RemoveAllEvents_Script",
        "scope": "lua",
        "description": "Removes all registered events from a script with a certain ScriptIdentifier in the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nScriptIdentifier:the unique identifier of the registered event, which you want to remove from the EventManager\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_RemoveAllEvents_Script(${3:string ScriptIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_SETEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_SetEvent",
        "scope": "lua",
        "description": "Sets the attributes of an already added event in the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the registered event, which you want to set\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed; nil, keep the old name\nCheckAllXSeconds:only check all x seconds; 0, for constant checking; nil, keep the old value\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed; nil, keep the old value\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet; nil, keep the old value\nCheckFunction:the function, which shall check if the event occurred; nil, keep the old function\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred; nil, keep the old actionlist\nRETURNS:\nretval:true, setting was successful; false, setting wasn't successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_SetEvent(${3:string EventIdentifier},${4:optional string EventName},${5:optional integer CheckAllXSeconds},${6:optional integer CheckForXSeconds},${7:optional boolean StartActionsOnceDuringTrue},${8:optional boolean EventPaused},${9:optional function CheckFunction},${10:optional table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATEEVENTS_WR lua": {
        "prefix": "ultraschallwr.EventManager_EnumerateEvents",
        "scope": "lua",
        "description": "Gets the attributes of an already added event in the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nPARAMETERS:\nid:the id of the currently registered event, of which you want to have the attributes; starting with 1 for the first\nRETURNS:\nEventIdentifier:the EventIdentifier of the registered event\nEventName:the name of the event\nCallerScriptIdentifier:the ScriptIdentifier of the script, who registered the event\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:true, eventcheck is currently paused; false, eventcheck is currently running\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "${1:local }${2:string EventIdentifier},${3:string EventName},${4:string CallerScriptIdentifier},${5:integer CheckAllXSeconds},${6:integer CheckForXSeconds},${7:boolean StartActionsOnceDuringTrue},${8:boolean EventPaused},${9:function CheckFunction},${10:integer NumberOfActions},${11:table Actions} = ultraschall.EventManager_EnumerateEvents(${12:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ENUMERATEEVENTS2_WR lua": {
        "prefix": "ultraschallwr.EventManager_EnumerateEvents2",
        "scope": "lua",
        "description": "Gets the attributes of an already added event in the Ultraschall Event Manager-checking-queue.\nreturns nil in case of an error\nRETURNS:\nEventIdentifier:the EventIdentifier of the registered event\nEventName:the name of the event\nCallerScriptIdentifier:the ScriptIdentifier of the script, who registered the event\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:true, eventcheck is currently paused; false, eventcheck is currently running\nCheckFunction:the function, which shall check if the event occurred\nNumberOfActions:the number of actions currently registered with this event\nActions:a table which holds all actions and their accompanying sections, who are run when the event occurred\n",
        "body": "${1:local }${2:string EventIdentifier},${3:string EventName},${4:string CallerScriptIdentifier},${5:integer CheckAllXSeconds},${6:integer CheckForXSeconds},${7:boolean StartActionsOnceDuringTrue},${8:boolean EventPaused},${9:function CheckFunction},${10:integer NumberOfActions},${11:table Actions} = ultraschall.EventManager_EnumerateEvents2(${12:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_COUNTREGISTEREDEVENTS_WR lua": {
        "prefix": "ultraschallwr.EventManager_CountRegisteredEvents",
        "scope": "lua",
        "description": "Returns the number of currently registered events in the EventManager-checking-queue\nRETURNS:\ncount_of_registered_events:the number of currently registered events\n",
        "body": "${1:local }${2:integer count_of_registered_events} = ultraschall.EventManager_CountRegisteredEvents()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETLASTUPDATETIME_WR lua": {
        "prefix": "ultraschallwr.EventManager_GetLastUpdateTime",
        "scope": "lua",
        "description": "Returns the last time, the eventlist in the EventManager had been updated in any way.\nRETURNS:\ndatetime:the date and time of the last update, as returned by os.date()\nprecise_time:the last update time as number, as returned by reaper.time_precise()\n",
        "body": "${1:local }${2:string datetime},${3:number precise_time} = ultraschall.EventManager_GetLastUpdateTime()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_PAUSEEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_PauseEvent",
        "scope": "lua",
        "description": "Pauses a registered event in the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, which you want to pause in the EventManager\nRETURNS:\nretval:true, pausing was successful; false, pausing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_PauseEvent(${3:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_RESUMEEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_ResumeEvent",
        "scope": "lua",
        "description": "Resumes a registered and paused event in the Ultraschall Event Manager-checking-queue.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the registered event, which you want to resume in the EventManager\nRETURNS:\nretval:true, resuming was successful; false, resuming was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_ResumeEvent(${3:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_START_WR lua": {
        "prefix": "ultraschallwr.EventManager_Start",
        "scope": "lua",
        "description": "Starts the Ultraschall-EventManager, if it has not been started yet.\nRETURNS:\nretval:true, EventManager has been started successfully; false, EventManager couldn't be started\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_Start()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_ADDSTARTUPEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_AddStartupEvent",
        "scope": "lua",
        "description": "Adds a new event, that shall be automatically registered at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be added automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed\nCheckAllXSeconds:only check all x seconds; 0, for constant checking\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet\nCheckFunction:the function, which shall check if the event occurred\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred\nRETURNS:\nevent_identifier:the unique identifier for this registered event, which can be used later for setting, deleting, etc\n",
        "body": "${1:local }${2:string event_identifier} = ultraschall.EventManager_AddStartupEvent(${3:string EventName},${4:integer CheckAllXSeconds},${5:integer CheckForXSeconds},${6:boolean StartActionsOnceDuringTrue},${7:boolean EventPaused},${8:function CheckFunction},${9:table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVESTARTUPEVENT2_WR lua": {
        "prefix": "ultraschallwr.EventManager_RemoveStartupEvent2",
        "scope": "lua",
        "description": "Removes a startup-event from the config-file of the Ultraschall Event Manager.\nreturns false in case of an error\nPARAMETERS:\nid:the unique identifier of the startup event, which you want to remove from the EventManager-startup-procedure\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_RemoveStartupEvent2(${3:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_REMOVESTARTUPEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_RemoveStartupEvent",
        "scope": "lua",
        "description": "Removes a startup-event from the config-file of the Ultraschall Event Manager.\nreturns false in case of an error\nPARAMETERS:\nevent_identifier:the unique identifier of the startup event, which you want to remove from the EventManager-startup-procedure\nRETURNS:\nretval:true, removing was successful; false, removing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.EventManager_RemoveStartupEvent(${3:string event_identifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_COUNTSTARTUPEVENTS_WR lua": {
        "prefix": "ultraschallwr.EventManager_CountStartupEvents",
        "scope": "lua",
        "description": "Counts the currently available startup-events\nRETURNS:\ncount_startup_events:the number of currently available start-up-events for the EventManager\n",
        "body": "${1:local }${2:integer count_startup_events} = ultraschall.EventManager_CountStartupEvents()$0"
    },
    "ULTRASCHALL.EVENTMANAGER_SETSTARTUPEVENT_WR lua": {
        "prefix": "ultraschallwr.EventManager_SetStartupEvent",
        "scope": "lua",
        "description": "Sets an already existing startupevent, that shall be automatically run at startup of the Ultraschall Event Manager.\nThat means, if you start the EventManager, it will be started automatically to the EventManager-checking-queue, without the need of registering it by hand.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the startup-event, which you want to set\nEventName:a name for the event, which you can choose freely; duplicated eventnames are allowed; nil, to keep current name\nCheckAllXSeconds:only check all x seconds; 0, for constant checking; nil, to keep current value\nCheckForXSeconds:only check for x seconds; 0, check until the event is removed; nil, to keep current value\nStartActionsOnceDuringTrue:if the event occurred: \nEventPaused:false, register the event and check for it immediately; true, register the event but don't check for it yet; nil, to keep current value\nCheckFunction:the function, which shall check if the event occurred; nil, to keep current function\nActions:a table which holds all actions and their accompanying sections, who shall be run when the event occurred; nil, to keep current actionlist\nRETURNS:\nevent_identifier:the unique identifier for this registered event, which can be used later for setting, deleting, etc\n",
        "body": "${1:local }${2:string event_identifier} = ultraschall.EventManager_SetStartupEvent(${3:string EventIdentifier},${4:optional string EventName},${5:optional integer CheckAllXSeconds},${6:optional integer CheckForXSeconds},${7:optional boolean StartActionsOnceDuringTrue},${8:optional boolean EventPaused},${9:optional function CheckFunction},${10:optional table Actions})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETPAUSEDSTATE2_WR lua": {
        "prefix": "ultraschallwr.EventManager_GetPausedState2",
        "scope": "lua",
        "description": "returns, if a certain event, currently registered in the EventManager, is paused(true) or not(false).\nState is requested by EventIdentifier.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the identifier of the registered event, whose pause state you want to retrieve\n",
        "body": "${1:local }${2:boolean paused_state} = ultraschall.EventManager_GetPausedState2(${3:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETPAUSEDSTATE_WR lua": {
        "prefix": "ultraschallwr.EventManager_GetPausedState",
        "scope": "lua",
        "description": "returns, if a certain event, currently registered in the EventManager, is paused(true) or not(false)\nState is requested by number-id, with 1 for the first event, 2 for the second, etc.\nreturns nil in case of an error\nPARAMETERS:\nid:the id of the event, whose paused-state you want to retrieve; 1, the first event; 2, the second event, etc\n",
        "body": "${1:local }${2:boolean paused_state} = ultraschall.EventManager_GetPausedState(${3:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETEVENTIDENTIFIER_WR lua": {
        "prefix": "ultraschallwr.EventManager_GetEventIdentifier",
        "scope": "lua",
        "description": "returns the EventIdentifier of a registered event, by id\nevent is requested by number-id, with 1 for the first event, 2 for the second, etc.\nreturns nil in case of an error\nPARAMETERS:\nid:the id of the event, whose EventIdenrifier you want to retrieve; 1, the first event; 2, the second event, etc\n",
        "body": "${1:local }${2:string event_identifier} = ultraschall.EventManager_GetEventIdentifier(${3:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETLASTCHECKFUNCTIONSTATE_WR lua": {
        "prefix": "ultraschallwr.EventManager_GetLastCheckfunctionState",
        "scope": "lua",
        "description": "returns the last state the eventcheck-function returned the last time it was called; of a certain registered event in the EventManager.\nState is requested by number-id, with 1 for the first event, 2 for the second, etc.\nreturns nil in case of an error; nil and time, if the EventCheck-function didn't return a boolean\nPARAMETERS:\nid:the id of the event, whose eventcheckfunction-retval you want to retrieve; 1, the first event; 2, the second event, etc\n",
        "body": "${1:local }${2:boolean check_state},${3:number last_statechange_precise_time} = ultraschall.EventManager_GetLastCheckfunctionState(${4:integer id})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETREGISTEREDEVENTID_WR lua": {
        "prefix": "ultraschallwr.EventManager_GetRegisteredEventID",
        "scope": "lua",
        "description": "returns the id of a registered event, meaning 1, if it's the first event, 2 if it's the second, etc\nIt is the position within all events currently registered within the EventManager.\nreturns nil in case of an error\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the event, whose id you want to retrieve\n",
        "body": "${1:local }${2:integer id} = ultraschall.EventManager_GetRegisteredEventID(${3:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_GETLASTCHECKFUNCTIONSTATE2_WR lua": {
        "prefix": "ultraschallwr.EventManager_GetLastCheckfunctionState2",
        "scope": "lua",
        "description": "returns the last state the eventcheck-function returned the last time it was called; of a certain registered event in the EventManager.\nState is requested by EventIdentifier\nreturns nil in case of an error; nil and time, if the EventCheck-function didn't return a boolean\nPARAMETERS:\nEventIdentifier:the EventIdentifier of the event, whose last checkfunction-state you want to retrieve\n",
        "body": "${1:local }${2:boolean check_state},${3:number last_statechange_precise_time} = ultraschall.EventManager_GetLastCheckfunctionState2(${4:string EventIdentifier})$0"
    },
    "ULTRASCHALL.EVENTMANAGER_DEBUGMODE_USERSPACE_WR lua": {
        "prefix": "ultraschallwr.EventManager_DebugMode_UserSpace",
        "scope": "lua",
        "description": "Returns the current contents of the UserSpace, as stored by the checkfunction of a registered event in the EventManager.\nThe table is of the format:\nuserspace[index][\"index\"]    - the name of the index\nuserspace[index][\"datatype\"] - the datatype of the value in this userspace-index\nuserspace[index][\"value\"]    - the value in this userspace-index\nNote: Debugmode is not for productive usecases, as it costs resources. Please turn it off again, after you've finished debugging.\nSee EventManager\\_DebugMode for more details on stopping DebugMode.\nreturns nil in case of an error\nPARAMETERS:\nindex:the index of the event, whose UserSpace you want to retrieve\nRETURNS:\nuserspace_count:the number of values within the userspace\nuserspace:the contents of the userspace as a handy table\n",
        "body": "${1:local }${2:integer userspace_count},${3:table userspace} = ultraschall.EventManager_DebugMode_UserSpace(${4:integer index})$0"
    },
    "ULTRASCHALL.READFULLFILE_WR lua": {
        "prefix": "ultraschallwr.ReadFullFile",
        "scope": "lua",
        "description": "Return contents of filename_with_path.\nReturns nil in case of an error.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nbinary:true if the file shall be read as a binary file; false if read as ASCII. Default is ASCII.\nRETURNS:\ncontents:the contents of the whole file.\nlength_of_file:the number of bytes of the file\nnumber_of_lines:number of lines in file (-1 if parameter binary is set to true)\n",
        "body": "${1:local }${2:string contents},${3:integer length_of_file},${4:integer number_of_lines} = ultraschall.ReadFullFile(${5:string filename_with_path},${6:boolean binary})$0"
    },
    "ULTRASCHALL.READVALUEFROMFILE_WR lua": {
        "prefix": "ultraschallwr.ReadValueFromFile",
        "scope": "lua",
        "description": "Return contents of filename_with_path.\nIf \"value\" is given, it will return all lines, containing the value in the file \"filename_with_path\".\nThe second line-numbers return-value is very valuable when giving a \"value\". \"Value\" is not case-sensitive.\nThe value can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nvalue:the value to look in the file for. Not case-sensitive.\nRETURNS:\ncontents:the contents of the file, or the lines that contain parameter value in it, separated by a newline\nlinenumbers:a string, that contains the linenumbers returned as a , separated csv-string\nnumberoflines:the total number of lines in the file\nnumber_of_foundlines:the number of found lines\n",
        "body": "${1:local }${2:string contents},${3:string linenumbers},${4:integer numberoflines},${5:integer number_of_foundlines} = ultraschall.ReadValueFromFile(${6:string filename_with_path},${7:string value})$0"
    },
    "ULTRASCHALL.READLINERANGEFROMFILE_WR lua": {
        "prefix": "ultraschallwr.ReadLinerangeFromFile",
        "scope": "lua",
        "description": "Return contents of filename_with_path, from firstlinenumber to lastlinenumber. Counting of linenumbers starts with 1 for the first line.\nThe returned string contains all requested lines, separated by a newline.\nReturns nil, if the linenumbers are invalid.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nfirstlinenumber:the first linenumber to be returned. First line in the file begins with 1!\nlastlinenumber:the last linenumber to be returned; -1, for the whole file\nRETURNS:\ncontents:the contents the lines of the file, that you requested\ncorrectnumberoflines:true, if the number of lines are returned, as requested; false if fewer lines are returned\nnumber_of_lines:the number of read lines\n",
        "body": "${1:local }${2:string contents},${3:boolean correctnumberoflines},${4:integer number_of_lines} = ultraschall.ReadLinerangeFromFile(${5:string filename_with_path},${6:integer firstlinenumber},${7:integer lastlinenumber})$0"
    },
    "ULTRASCHALL.MAKECOPYOFFILE_WR lua": {
        "prefix": "ultraschallwr.MakeCopyOfFile",
        "scope": "lua",
        "description": "Copies input_filename_with_path to output_filename_with_path.\nOnly textfiles! For binary-files use MakeCopyOfFile_Binary() instead!\nReturns true, if it worked, false if it didn't.\nPARAMETERS:\ninput_filename_with_path:filename of the file to copy\noutput_filename_with_path:filename of the copied file to be created.\nRETURNS:\nretval:true, if copy worked, false if it didn't.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MakeCopyOfFile(${3:string input_filename_with_path},${4:string output_filename_with_path})$0"
    },
    "ULTRASCHALL.MAKECOPYOFFILE_BINARY_WR lua": {
        "prefix": "ultraschallwr.MakeCopyOfFile_Binary",
        "scope": "lua",
        "description": "Copies input_filename_with_path to output_filename_with_path as binary-file.\nreturns false in case of an error\nPARAMETERS:\ninput_filename_with_path:filename of the file to copy\noutput_filename_with_path:filename of the copied file, that shall be created\nRETURNS:\nretval:returns true, if copy worked; false if it didn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MakeCopyOfFile_Binary(${3:string input_filename_with_path},${4:string output_filename_with_path})$0"
    },
    "ULTRASCHALL.READBINARYFILEUNTILPATTERN_WR lua": {
        "prefix": "ultraschallwr.ReadBinaryFileUntilPattern",
        "scope": "lua",
        "description": "Returns a binary file, up until a pattern. The pattern is not case-sensitive.\nPattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nreturns false in case of an error\nPARAMETERS:\npattern:a pattern to search for. Case-sensitive.\nRETURNS:\nlength:the length of the returned data\ncontent:the content of the file, that has been read until pattern\n",
        "body": "${1:local }${2:integer length},${3:string content} = ultraschall.ReadBinaryFileUntilPattern(${4:string input_filename_with_path},${5:string pattern})$0"
    },
    "ULTRASCHALL.READBINARYFILEFROMPATTERN_WR lua": {
        "prefix": "ultraschallwr.ReadBinaryFileFromPattern",
        "scope": "lua",
        "description": "Returns a binary file, from pattern onwards. The pattern is not case-sensitive.\nThe pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.\ni.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc\nreturns false in case of an error\nPARAMETERS:\npattern:a pattern to search for. Case-sensitive.\nRETURNS:\nlength:the length of the returned data\ncontent:the content of the file, that has been read from pattern to the end\n",
        "body": "${1:local }${2:integer length},${3:string content} = ultraschall.ReadBinaryFileFromPattern(${4:string input_filename_with_path},${5:string pattern})$0"
    },
    "ULTRASCHALL.COUNTLINESINFILE_WR lua": {
        "prefix": "ultraschallwr.CountLinesInFile",
        "scope": "lua",
        "description": "Counts lines in a textfile. In binary files, the number of lines may be weird and unexpected!\nReturns -1, if no such file exists.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nRETURNS:\nlinesinfile:number of lines in a textfile; -1 in case of error\n",
        "body": "${1:local }${2:integer linesinfile} = ultraschall.CountLinesInFile(${3:string filename_with_path})$0"
    },
    "ULTRASCHALL.READFILEASLINES_ARRAY_WR lua": {
        "prefix": "ultraschallwr.ReadFileAsLines_Array",
        "scope": "lua",
        "description": "Return contents of filename_with_path, from firstlinenumber to lastlinenumber as an array. Counting of linenumbers starts with 1 for the first line.\nThe returned array contains all requested lines, which each entry holding one returned line.\nReturns nil, if the linenumbers are invalid.\nPARAMETERS:\nfilename_with_path:filename of the file to be read\nfirstlinenumber:the first linenumber to be returned. First line in the file begins with 1!\nlastlinenumber:the last linenumber to be returned; -1, read all lines in the file\nRETURNS:\ncontents:the contents the lines of the file, that you requested as an array, in which each entry hold one line of the file\ncorrectnumberoflines:true, if the number of lines are returned, as you requested; false if fewer lines are returned\nnumber_of_lines:the number of lines returned\n",
        "body": "${1:local }${2:array contents},${3:boolean correctnumberoflines},${4:integer number_of_lines} = ultraschall.ReadFileAsLines_Array(${5:string filename_with_path},${6:integer firstlinenumber},${7:integer lastlinenumber})$0"
    },
    "ULTRASCHALL.READBINARYFILE_OFFSET_WR lua": {
        "prefix": "ultraschallwr.ReadBinaryFile_Offset",
        "scope": "lua",
        "description": "Returns the contents of a binary file from startoffset until startoffset+numberofbytes.\nWhen setting startoffset to a negative value, it will read from the end of the file, means:\n-100 will start -100 characters before the end of the file and numberofbytes will read from that point on\nReturns false, if file can not be opened.\nPARAMETERS:\ninput_filename_with_path:filename of the file to be read\nstartoffset:the offset, at where to begin the fileread. 0 for the beginning of the file; negative values set offset from the end of the file\nnumberofbytes:the number of bytes to read. -1 for until the end of the file. If there are fewer bytes than requested, the returned string will be shorter.\nRETURNS:\nlength:the length of the returned part of the file, might be shorter than requested, if file ends before\ncontent:the content of the file, that has been read\n",
        "body": "${1:local }${2:integer length},${3:string content} = ultraschall.ReadBinaryFile_Offset(${4:string input_filename_with_path},${5:integer startoffset},${6:integer numberofbytes})$0"
    },
    "ULTRASCHALL.GETLENGTHOFFILE_WR lua": {
        "prefix": "ultraschallwr.GetLengthOfFile",
        "scope": "lua",
        "description": "Returns the length of the file filename_with_path in bytes.\nWill return -1, if no such file exists.\nPARAMETERS:\nfilename_with_path:filename to write the value to\nRETURNS:\nlengthoffile:the length of the file in bytes. -1 in case of error\n",
        "body": "${1:local }${2:integer lengthoffile} = ultraschall.GetLengthOfFile(${3:string filename_with_path})$0"
    },
    "ULTRASCHALL.COUNTDIRECTORIESANDFILESINPATH_WR lua": {
        "prefix": "ultraschallwr.CountDirectoriesAndFilesInPath",
        "scope": "lua",
        "description": "returns the number of files and directories in path\nreturns -1, in case of error\nPARAMETERS:\npath:the path to count the files and directories from\nRETURNS:\nfilecount:the number of files found in path\ndircount:the number of directories found in path\n",
        "body": "${1:local }${2:integer filecount},${3:integer dircount} = ultraschall.CountDirectoriesAndFilesInPath(${4:string path})$0"
    },
    "ULTRASCHALL.GETALLFILENAMESINPATH_WR lua": {
        "prefix": "ultraschallwr.GetAllFilenamesInPath",
        "scope": "lua",
        "description": "returns the number of files and the filenames in path\nreturns -1, in case of error\nPARAMETERS:\npath:the path to get the filenames from\nRETURNS:\nfilecount:the number of files found in path\nfiles:the filenames found in path\n",
        "body": "${1:local }${2:integer filecount},${3:array files} = ultraschall.GetAllFilenamesInPath(${4:string path})$0"
    },
    "ULTRASCHALL.GETALLDIRECTORIESINPATH_WR lua": {
        "prefix": "ultraschallwr.GetAllDirectoriesInPath",
        "scope": "lua",
        "description": "returns the number of directories and the directorynames in path\nreturns -1, in case of error\nPARAMETERS:\npath:the path to get the directories from\nRETURNS:\nfilecount:the number of directories found in path\n",
        "body": "${1:local }${2:integer filecount},${3:array directories} = ultraschall.GetAllDirectoriesInPath(${4:string path})$0"
    },
    "ULTRASCHALL.CHECKFORVALIDFILEFORMATS_WR lua": {
        "prefix": "ultraschallwr.CheckForValidFileFormats",
        "scope": "lua",
        "description": "Returns the fileformat of a Reaper-supported-file, images, audios(opus and m4a missing, though!), and video(mp4-video missing, though!).\nNote: Checks the file itself and does not check for correct file-extension. Reaper needs the correct file-extension or it can't read an otherwise valid imagefile.\nFor example: if you want to import a GIF, renamed to filename.JPG, Reaper will not be able to read it. Only when the extension is the same as the file itself(filename.GIF).\nReturns nil in case of an error\nPARAMETERS:\nfilename_with_path:the file to check for it's image-fileformat\nRETURNS:\nfileformat:the format of the file; JPG, PNG, GIF, LCF, ICO, WAV, AIFF, ASF/WMA/WMV, MP3, MP3 -ID3TAG, FLAC, MKV/MKA/MKS/MK3D/WEBM, AVI, RPP_PROJECT, unknown\nsupported_by_reaper:true, if importing of the fileformat is supported by Reaper; false, if not\nmediatype:the type of the media; Image, Audio, Audio/Video, Video, Reaper\n",
        "body": "${1:local }${2:string fileformat},${3:boolean supported_by_reaper},${4:string mediatype} = ultraschall.CheckForValidFileFormats(${5:string filename_with_path})$0"
    },
    "ULTRASCHALL.DIRECTORYEXISTS_WR lua": {
        "prefix": "ultraschallwr.DirectoryExists",
        "scope": "lua",
        "description": "Checks, if a directory exists in path.\nOn Linux: path and directory are case-sensitive!\nReturns false in case of error.\nPARAMETERS:\npath:the path, in which to look for the existence of parameter directory\ndirectory:the name of the directory to check for in path\nRETURNS:\nretval:true, directory exists; false, directory does not exist\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DirectoryExists(${3:string path},${4:string directory})$0"
    },
    "ULTRASCHALL.ONLYFILESOFCERTAINTYPE_WR lua": {
        "prefix": "ultraschallwr.OnlyFilesOfCertainType",
        "scope": "lua",
        "description": "Returns the filenames_with_path from a filearray, that are of a certain filetype\nreturns -1 in case of an error\nPARAMETERS:\nfilearray:an array with files to check for; index is 1-based\nRETURNS:\nfoundfilecount:the number of files that contain the right filetype\nfoundfilearray:an array with all the files that contain the right filetype\n",
        "body": "${1:local }${2:integer foundfilecount},${3:array foundfilearray} = ultraschall.OnlyFilesOfCertainType(${4:array filearray},${5:string filetype})$0"
    },
    "ULTRASCHALL.GETREAPERWORKDIR_WR lua": {
        "prefix": "ultraschallwr.GetReaperWorkDir",
        "scope": "lua",
        "description": "returns the current workdir, which is the directory. If you create a file without giving a path, this file will be created in this work-dir.\nRETURNS:\ncurrent_workdir:the current workdir of Reaper\n",
        "body": "${1:local }${2:string current_workdir} = ultraschall.GetReaperWorkDir()$0"
    },
    "ULTRASCHALL.DIRECTORYEXISTS2_WR lua": {
        "prefix": "ultraschallwr.DirectoryExists2",
        "scope": "lua",
        "description": "returns, if Path is an existing path.\nreturns false in case of an error\nPARAMETERS:\nPath:the path to check for\nRETURNS:\nretval:true, if path exists; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DirectoryExists2(${3:string Path})$0"
    },
    "ULTRASCHALL.SETREAPERWORKDIR_WR lua": {
        "prefix": "ultraschallwr.SetReaperWorkDir",
        "scope": "lua",
        "description": "sets a new current working directory for Reaper. This requires a restart of Reaper to take effect, due API-limitations!\nreturns false in case of an error\nPARAMETERS:\nPath:the path to set as new current working directory\nRETURNS:\nretval:true, if path could be set; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetReaperWorkDir(${3:string Path})$0"
    },
    "ULTRASCHALL.CREATEVALIDTEMPFILE_WR lua": {
        "prefix": "ultraschallwr.CreateValidTempFile",
        "scope": "lua",
        "description": "Tries to determine a valid temporary filename. Will check filename_with_path with an included number between 0 and 16384 to create such a filename.\nYou can also add your own suffix to the filename.\nThe pattern is: filename_with_path$Suffix~$number.ext (when retainextension is set to true!)\nIf you wish, you can also create this temporary-file as an empty file.\nThe path of the tempfile is always the same as the original file.\nReturns nil in case of failure.\nPARAMETERS:\nfilename_with_path:the original filename\ncreate:true, if you want to create that temporary file as an empty file; false, just return the filename\nsuffix:if you want to alter the temporary filename with an additional suffix, use this parameter\nretainextension:true, keep the extension(if existing) at the end of the tempfile; false, just add the suffix~number at the end.\nRETURNS:\ntempfilename:the valid temporary filename found\n",
        "body": "${1:local }${2:string tempfilename} = ultraschall.CreateValidTempFile(${3:string filename_with_path},${4:boolean create},${5:string suffix},${6:boolean retainextension})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_INSERT_WR lua": {
        "prefix": "ultraschallwr.WriteValueToFile_Insert",
        "scope": "lua",
        "description": "Inserts value into a file at linenumber. All lines, up to linenumber-1 come before value, all lines at linenumber to the end of the file will come after value.\nWill return -1, if no such line exists.\nNote: non-binary-files only!\nPARAMETERS:\nfilename_with_path:filename to write the value to\nlinenumber:the linenumber, at where to insert the value into the file\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.WriteValueToFile_Insert(${3:string filename_with_path},${4:integer linenumber},${5:string value})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_REPLACE_WR lua": {
        "prefix": "ultraschallwr.WriteValueToFile_Replace",
        "scope": "lua",
        "description": "Replaces the linenumbers startlinenumber to endlinenumber in a file with value. All lines, up to startlinenumber-1 come before value, all lines at endlinenumber+1 to the end of the file will come after value.\nWill return -1, if no such lines exists.\nNote: non-binary-files only!\nPARAMETERS:\nfilename_with_path:filename to write the value to\nstartlinenumber:the first linenumber, to be replaced with value in the file\nendlinenumber:the last linenumber, to be replaced with value in the file\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.WriteValueToFile_Replace(${3:string filename_with_path},${4:integer startlinenumber},${5:integer endlinenumber},${6:string value})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_INSERTBINARY_WR lua": {
        "prefix": "ultraschallwr.WriteValueToFile_InsertBinary",
        "scope": "lua",
        "description": "Inserts value into a file at byteposition. All bytes, up to byteposition-1 come before value, all bytes at byteposition to the end of the file will come after value.\nWill return -1, if no such line exists.\nNote: good for binary files\nPARAMETERS:\nfilename_with_path:filename to write the value to\nbyteposition:the byteposition, at where to insert the value into the file\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.WriteValueToFile_InsertBinary(${3:string filename_with_path},${4:integer byteposition},${5:string value})$0"
    },
    "ULTRASCHALL.WRITEVALUETOFILE_REPLACEBINARY_WR lua": {
        "prefix": "ultraschallwr.WriteValueToFile_ReplaceBinary",
        "scope": "lua",
        "description": "Replaces content in the file from startbyteposition to endbyteposition-1 with value. All bytes, up to startbyteposition-1 come before value, all bytes from (and including)endbyteposition to the end of the file will come after value.\nWill return -1, if no such line exists.\nNote: good for binary files\nPARAMETERS:\nfilename_with_path:filename to write the value to\nstartbyteposition:the first byte in the file to be replaced, starting with 1, if you want to replace at the beginning of the file. Everything before startposition will be kept.\nendbyteposition:the first byte after the replacement. Everything from endbyteposition to the end of the file will be kept.\nvalue:the value to be inserted into the file\nRETURNS:\nretval:1, in case of success, -1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.WriteValueToFile_ReplaceBinary(${3:string filename_with_path},${4:integer startbyteposition},${5:integer endbyteposition},${6:string value})$0"
    },
    "ULTRASCHALL.GETALLRECURSIVEFILESANDSUBDIRECTORIES_WR lua": {
        "prefix": "ultraschallwr.GetAllRecursiveFilesAndSubdirectories",
        "scope": "lua",
        "description": "Returns all subdirectories and files within a given path.\nMight take some time with many folders/files.\nReturns -1 in case of an error.\nPARAMETERS:\npath:the path from where to retrieve the files and subdirectories\nRETURNS:\nfound_dirs:the number of directories found; -1, in case of an error\ndirs_array:the full path to the found directories as an array\nfound_files:the number of files found\nfiles_array:the full path to the found files as an array\n",
        "body": "${1:local }${2:integer found_dirs},${3:array dirs_array},${4:integer found_files},${5:array files_array} = ultraschall.GetAllRecursiveFilesAndSubdirectories(${6:string path})$0"
    },
    "ULTRASCHALL.SAVESUBTITLES_SRT_WR lua": {
        "prefix": "ultraschallwr.SaveSubtitles_SRT",
        "scope": "lua",
        "description": "saves the subtitles from the subtitle-table.\nThe subtitles-table is expected to be of the following format:\nsubtitle_table[subtitle_index][\"start\"]   = starttime in seconds\nsubtitle_table[subtitle_index][\"end\"]     = endtime in seconds\nsubtitle_table[subtitle_index][\"caption\"] = the caption, which shall be shown from start to end-time\nreturns -1 in case of an error\nPARAMETERS:\nsubtitle_filename_with_path:the filename of the subtitle-file, into which you want to store the subtitles\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SaveSubtitles_SRT(${3:string subtitle_filename_with_path},${4:table subtitle_table})$0"
    },
    "ULTRASCHALL.READSUBTITLES_SRT_WR lua": {
        "prefix": "ultraschallwr.ReadSubtitles_SRT",
        "scope": "lua",
        "description": "parses an srt-subtitle-file and returns its contents as table\nreturns nil in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the subrip srt-file\nRETURNS:\nCaptions_Counter:the number of captions in the file\nCaptions:the Captions as a table of the format:\n",
        "body": "${1:local }${2:integer Captions_Counter},${3:table Captions} = ultraschall.ReadSubtitles_SRT(${4:string filename_with_path})$0"
    },
    "ULTRASCHALL.MOVEFILEORFOLDER_WR lua": {
        "prefix": "ultraschallwr.MoveFileOrFolder",
        "scope": "lua",
        "description": "Moves a file or folder from oldpath to newpath.\nreturns false in case of an error\nPARAMETERS:\nfile_foldername:the folder- or filename, which you want to move\noldpath:the old path, in which the file or folder is located\nnewpath:the new path, into which the file or folder shall be moved\nRETURNS:\nretval:true, moving was successful; false, moving was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MoveFileOrFolder(${3:string file_foldername},${4:string oldpath},${5:string newpath})$0"
    },
    "ULTRASCHALL.ISVALIDFXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.IsValidFXStateChunk",
        "scope": "lua",
        "description": "Returns, if a StateChunk is a valid FXStateChunk.\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nReturns false in case of an error\nPARAMETERS:\nStateChunk:the StateChunk, which you want to check, whether it's a valid FXStateChunk\nRETURNS:\nretval:true, it is a valid FXStateChunk; false, it is not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidFXStateChunk(${3:string StateChunk})$0"
    },
    "ULTRASCHALL.GETFXFROMFXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetFXFromFXStateChunk",
        "scope": "lua",
        "description": "Returns all lines of a specific TrackFX/ItemFX from a StateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the FX-entries\nid:the id of the FX-entries you want to have, starting with 1 for the first\nRETURNS:\nfx:all lines of an fx from a statechunk\n",
        "body": "${1:local }${2:string fx} = ultraschall.GetFXFromFXStateChunk(${3:string FXStateChunk},${4:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-learn-setting from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is the PARMLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmLearn-settings\nfxid:the fx, of which you want to get the parameter-learn-settings\nid:the id of the ParmLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parmname},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message} = ultraschall.GetParmLearn_FXStateChunk(${7:string FXStateChunk},${8:integer fxid},${9:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLEARN_MEDIAITEM_WR lua": {
        "prefix": "ultraschallwr.GetParmLearn_MediaItem",
        "scope": "lua",
        "description": "Returns a parameter-learn-setting from a MediaItem\nIt is the PARMLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose ParmLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-learn-settings\nid:the id of the ParmLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parmname},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message} = ultraschall.GetParmLearn_MediaItem(${7:MediaItem MediaItem},${8:integer fxid},${9:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLEARN_MEDIATRACK_WR lua": {
        "prefix": "ultraschallwr.GetParmLearn_MediaTrack",
        "scope": "lua",
        "description": "Returns a parameter-learn-setting from a MediaTrack\nIt is the PARMLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaTrack:the MediaTrack, whose ParmLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-learn-settings\nid:the id of the ParmLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-messages\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parmname},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message} = ultraschall.GetParmLearn_MediaTrack(${7:MediaTrack MediaTrack},${8:integer fxid},${9:integer id})$0"
    },
    "ULTRASCHALL.GETPARMALIAS_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-alias-setting from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nParameter-aliases are only stored for MediaTracks.\nIt is the PARMALIAS-entry\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmAlias-settings\nfxid:the fx, of which you want to get the parameter-alias-settings\nid:the id of the ParmAlias-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparm_aliasname:the alias-name of the parameter\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parm_aliasname} = ultraschall.GetParmAlias_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer id})$0"
    },
    "ULTRASCHALL.GETPARMALIAS_MEDIATRACK_WR lua": {
        "prefix": "ultraschallwr.GetParmAlias_MediaTrack",
        "scope": "lua",
        "description": "Returns a parameter-aliasname-setting from a MediaTrack\nIt is the PARMALIAS-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaTrack:the MediaTrack, whose ParmAlias-setting you want to get\nfxid:the fx, of which you want to get the parameter-alias-settings\nid:the id of the ParmAlias-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparm_aliasname:the alias-name of the parameter\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parm_aliasname} = ultraschall.GetParmAlias_MediaTrack(${4:MediaTrack MediaTrack},${5:integer fxid},${6:integer id})$0"
    },
    "ULTRASCHALL.GETPARMMODULATIONCHUNK_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetParmModulationChunk_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-modulation-chunk from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt's the\nstring parm_modulation_chunk - a chunk of the parameter-modulation settings\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the Parameter-modulation-settings\ninteger fxid - the fx, of which you want to get the parameter-modulation-chunk-settings\ninteger id - the id of the Parameter-modulation you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, modulation, fxstatechunk\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the Parameter-modulation-settings\nfxid:the fx, of which you want to get the parameter-modulation-chunk-settings\nid:the id of the Parameter-modulation you want to have, starting with 1 for the first\nRETURNS:\nparm_modulation_chunk:a chunk of the parameter-modulation settings\n",
        "body": "${1:local }${2:string parm_modulation_chunk} = ultraschall.GetParmModulationChunk_FXStateChunk(${3:string FXStateChunk},${4:integer fxid},${5:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFOLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Returns a parameter-lfo-learn-setting from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is the LFOLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmLFOLearn-settings\nfxid:the fx, of which you want to get the parameter-lfo-learn-settings\nid:the id of the ParmLFOLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parmname},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message} = ultraschall.GetParmLFOLearn_FXStateChunk(${7:string FXStateChunk},${8:integer fxid},${9:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFOLEARN_MEDIAITEM_WR lua": {
        "prefix": "ultraschallwr.GetParmLFOLearn_MediaItem",
        "scope": "lua",
        "description": "Returns a parameter-lfo-learn-setting from a MediaItem\nIt is the LFOLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose ParmLFOLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-lfo-learn-settings\nid:the id of the ParmLFOLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parmname},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message} = ultraschall.GetParmLFOLearn_MediaItem(${7:MediaItem MediaItem},${8:integer fxid},${9:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFOLEARN_MEDIATRACK_WR lua": {
        "prefix": "ultraschallwr.GetParmLFOLearn_MediaTrack",
        "scope": "lua",
        "description": "Returns a parameter-lfo-learn-setting from a MediaTrack\nIt is the LFOLEARN-entry\nReturns nil in case of an error\nPARAMETERS:\nMediaTrack:the MediaTrack, whose ParmLFOLearn-setting you want to get\nfxid:the fx, of which you want to get the parameter-lfo-learn-settings\nid:the id of the ParmLFOLearn-settings you want to have, starting with 1 for the first\nRETURNS:\nparm_idx:the idx of the parameter; order is exactly like the order in the contextmenu of Parameter List -> Learn\nparmname:the name of the parameter, though usually only wet or bypass\nmidi_note:an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-messages\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn\n",
        "body": "${1:local }${2:integer parm_idx},${3:string parmname},${4:integer midi_note},${5:integer checkboxflags},${6:optional string osc_message} = ultraschall.GetParmLFOLearn_MediaTrack(${7:MediaTrack MediaTrack},${8:integer fxid},${9:integer id})$0"
    },
    "ULTRASCHALL.GETPARMAUDIOCONTROL_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetParmAudioControl_FXStateChunk",
        "scope": "lua",
        "description": "Returns the parameter-modulation-settings of the Audio control signal-settings from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is entries from the\ninteger parmidx - the id of the parameter, that shall be modulated; order like in the dropdownlist\nstring parmname - the name of the parameter, usually bypass or wet\ninteger parameter_modulation - the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nnumber parmbase - parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\ninteger audioctrl - \"Audio control signal (sidechain)\"-checkbox - 0, disabled; 1, enabled\nnumber audioctrlstrength - the strength-slider for AudioControlSignal; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\ninteger audioctrl_direction - the direction-radiobuttons for AudioControlSignal; -1, Negative; 0, Centered; 1, Positive\ninteger channels - the Track audio channel-dropdownlist; linked to entry parameter stereo as well\n- -1, no channel selected(yet) (default)\n- 0 and higher, track 1 and higher is selected\ninteger stereo - linked to channels as well\n- 0, mono(use only the channel set in CHAN); 1, stereo(use the channel set in CHAN and CHAN+1)\ninteger rms_attack - rms attack in milliseconds; 0 to 1000; default is 300\ninteger rms_release - rms release in milliseconds; 0 to 1000; default is 300\nnumber db_lo - db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\n- Min volume-slider in dB; maximum valuerange possible is -60dB to 11.9dB\nnumber db_hi - db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\n- Max volume-slider in dB; maximum valuerange possible is -59.9dB to 12dB\nnumber audioctrlshaping_x - the x-position of the shaping-dragging-point; between 0.000000 and 1.000000\nnumber audioctrlshaping_y - the y-position of the shaping-dragging-point; between 0.000000 and 1.000000\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the ParmModulation-settings\ninteger fxid - the fx, of which you want to get the parameter-modulation-settings\ninteger id - the id of the ParmModulation-settings you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, modulation, fxstatechunk, audio control signal\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmModulation-settings\nfxid:the fx, of which you want to get the parameter-modulation-settings\nid:the id of the ParmModulation-settings you want to have, starting with 1 for the first\nRETURNS:\nparmidx:the id of the parameter, that shall be modulated; order like in the dropdownlist\nparmname:the name of the parameter, usually bypass or wet\nparameter_modulation:the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nparmbase:parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\naudioctrl:the y-position of the shaping-dragging-point; between 0.000000 and 1.000000\naudioctrlstrength:the strength-slider for AudioControlSignal; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\naudioctrl_direction:the direction-radiobuttons for AudioControlSignal; -1, Negative; 0, Centered; 1, Positive\nchannels:the Track audio channel-dropdownlist; linked to entry parameter stereo as well\nstereo:linked to channels as well\nrms_attack:rms attack in milliseconds; 0 to 1000; default is 300\nrms_release:rms release in milliseconds; 0 to 1000; default is 300\ndb_lo:db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\ndb_hi:db_lo decides the lowest value possible for parameter db_hi; db_hi decides the highest volume for db_lo\naudioctrlshaping_x:the x-position of the shaping-dragging-point; between 0.000000 and 1.000000\naudioctrlshaping_y:the y-position of the shaping-dragging-point; between 0.000000 and 1.000000\n",
        "body": "${1:local }${2:integer parmidx},${3:string parmname},${4:integer parameter_modulation},${5:number parmbase},${6:integer audioctrl},${7:number audioctrlstrength},${8:integer audioctrl_direction},${9:integer channels},${10:integer stereo},${11:integer rms_attack},${12:integer rms_release},${13:number db_lo},${14:number db_hi},${15:number audioctrlshaping_x},${16:number audioctrlshaping_y} = ultraschall.GetParmAudioControl_FXStateChunk(${17:string FXStateChunk},${18:integer fxid},${19:integer id})$0"
    },
    "ULTRASCHALL.GETPARMLFO_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetParmLFO_FXStateChunk",
        "scope": "lua",
        "description": "Returns the parameter-modulation-settings of the LFO-settings from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is entries from the\ninteger parmidx - the id of the parameter, that shall be modulated; order like in the dropdownlist\nstring parmname - the name of the parameter, usually bypass or wet\ninteger parameter_modulation - the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nnumber parmbase - parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\ninteger lfo - LFO checkbox; 0, disabled; 1, enabled\nnumber lfo_strength - Strength-slider in the LFO parameter-modulation; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\ninteger lfo_direction - Direction-radiobuttons in the LFO parameter modulation; -1, Negative; 0, Centered; 1, Positive\ninteger lfo_shape - the shape of the LFO\n- 0, sine\n- 1, square\n- 2, saw L\n- 3, saw R\n- 4, triangle\n- 5, random\ninteger temposync - the Tempo sync-checkbox in the LFO parameter-modulation; 0, disabled; 1, enabled\ninteger unknown - unknown\ninteger phase_reset - phase-reset-dropdownlist\n- 0, On seek/loop (deterministic output)\n- 1, Free-running (non-deterministic output)\nnumber lfo_speed - Speed-slider in the LFO parameter-modulation; either Hz(temposync=0) or QN(temposync=1)\n- Hz: 0(0.0039Hz) to 1(8.0000Hz); higher values are possible, lower values go into negative; default is 0.124573(1.0000Hz)\n- QN: 0(8.0000QN) to 1(0.2500QN); lower values are possible; higher values go into negative; default is 0.9(1.0000QN)\nnumber lfo_speedphase - Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the ParmModulation-settings\ninteger fxid - the fx, of which you want to get the parameter-modulation-settings\ninteger id - the id of the ParmModulation-settings you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, modulation, fxstatechunk, lfo\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmModulation-settings\nfxid:the fx, of which you want to get the parameter-modulation-settings\nid:the id of the ParmModulation-settings you want to have, starting with 1 for the first\nRETURNS:\nparmidx:the id of the parameter, that shall be modulated; order like in the dropdownlist\nparmname:the name of the parameter, usually bypass or wet\nparameter_modulation:the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nparmbase:parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\nlfo:Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\nlfo_strength:Strength-slider in the LFO parameter-modulation; 0.0000(0%) to 1.000(100%); 0.493(49.3%); default is 1\nlfo_direction:Direction-radiobuttons in the LFO parameter modulation; -1, Negative; 0, Centered; 1, Positive\nlfo_shape:the shape of the LFO\ntemposync:the Tempo sync-checkbox in the LFO parameter-modulation; 0, disabled; 1, enabled\nunknown:unknown\nphase_reset:phase-reset-dropdownlist\nlfo_speed:Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\nlfo_speedphase:Phase-slider in the LFO parameter-modulation; 0.000 to to 1.000; default is 0.5\n",
        "body": "${1:local }${2:integer parmidx},${3:string parmname},${4:integer parameter_modulation},${5:number parmbase},${6:integer lfo},${7:number lfo_strength},${8:integer lfo_direction},${9:integer lfo_shape},${10:integer temposync},${11:integer unknown},${12:integer phase_reset},${13:number lfo_speed},${14:number lfo_speedphase} = ultraschall.GetParmLFO_FXStateChunk(${15:string FXStateChunk},${16:integer fxid},${17:integer id})$0"
    },
    "ULTRASCHALL.GETPARMMIDIPLINK_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetParmMIDIPLink_FXStateChunk",
        "scope": "lua",
        "description": "Returns the parameter-modulation-settings of the Parameter-Link-Modulation-settings from an FXStateChunk\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nIt is entries from the\ninteger parmidx - the id of the parameter, that shall be modulated; order like in the dropdownlist\nstring parmname - the name of the parameter, usually bypass or wet\ninteger parameter_modulation - the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nnumber parmbase - parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\nboolean plink_enabled - true, parameter-linking is enabled; false, parameter linking is disabled\nnumber scale - the scale-slider; -1.00(-100%) to 1.00(100%); default is 0(0%)\ninteger midi_fx_idx - the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area\n-  -1, nothing selected\n-  -100, MIDI-parameter-settings\n-  0 - the first fx\n-  1 - the second fx\n-  2 - the third fx, etc\ninteger midi_fx_idx2 - the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area; Reaper stores the idx for idx using two values, where this is the second one\n- it is unknown why, so I include it in here anyway\n-  -1, nothing selected\n-  -100, MIDI-parameter-settings\n-  0 - the first fx\n-  1 - the second fx\n-  2 - the third fx, etc\ninteger linked_parmidx - the parameter idx, that you want to link;\n- When MIDI:\n-     16\n- When FX-parameter:\n-     0 to n; 0 for the first; 1, for the second, etc\nnumber offset - Offset-slider; -1.00(-100%) to 1.00(100%); default is 0(0%)\noptional integer bus - the MIDI-bus; 0 to 15 for bus 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\noptional integer channel - the MIDI-channel; 0, omni; 1 to 16 for channel 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\noptional integer category - the MIDI-category, which affects the meaning of parameter midi_note; only available, when midi_fx_idx=-100, otherwise nil\n- 144, MIDI note\n- 160, Aftertouch\n- 176, CC 14Bit and CC\n- 192, Program Change\n- 208, Channel Pressure\n- 224, Pitch\noptional integer midi_note - the midi_note/command, whose meaning depends on parameter category; only available, when midi_fx_idx=-100, otherwise nil\n-   When MIDI note:\n-        0(C-2) to 127(G8)\n-   When Aftertouch:\n-        0(C-2) to 127(G8)\n-   When CC14 Bit:\n-        128 to 159; see dropdownlist for the commands(the order of the list is the same as this numbering)\n-   When CC:\n-        0 to 119; see dropdownlist for the commands(the order of the list is the same as this numbering)\n-   When Program Change:\n-        0\n-   When Channel Pressure:\n-        0\n-   When Pitch:\n-        0\nstring FXStateChunk - the FXStateChunk, from which you want to retrieve the ParmLinkModulation-settings\ninteger fxid - the fx, of which you want to get the parameter-linking-modulation-settings\ninteger id - the id of the ParmLinkModulation-settings you want to have, starting with 1 for the first\nFX-Management\nParameter Mapping\nUS_Api_Functions\nModules/ultraschall_functions_FXManagement_Module.lua\nfxmanagement, get, parameter, linking, linked, midi, fx, modulation, fxstatechunk, lfo\nPARAMETERS:\nFXStateChunk:the FXStateChunk, from which you want to retrieve the ParmLinkModulation-settings\nfxid:the fx, of which you want to get the parameter-linking-modulation-settings\nid:the id of the ParmLinkModulation-settings you want to have, starting with 1 for the first\nRETURNS:\nparmidx:the parameter idx, that you want to link; \nparmname:the name of the parameter, usually bypass or wet\nparameter_modulation:the \"Enable parameter modulation, baseline value(envelope overrides)\"-checkbox; 0, enabled; 1, disabled\nparmbase:parameter-modulation-baseline-slider; between 0.0000 and 1.0000; default is 0.2500\nplink_enabled:true, parameter-linking is enabled; false, parameter linking is disabled\nscale:the scale-slider; -1.00(-100%) to 1.00(100%); default is 0(0%)\nmidi_fx_idx:the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area; Reaper stores the idx for idx using two values, where this is the second one\nmidi_fx_idx2:the big MIDI/FX-button in the \"Link from MIDI or FX parameter\"-area; Reaper stores the idx for idx using two values, where this is the second one\nlinked_parmidx:the parameter idx, that you want to link; \noffset:Offset-slider; -1.00(-100%) to 1.00(100%); default is 0(0%) \nbus:the MIDI-bus; 0 to 15 for bus 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\nchannel:the MIDI-channel; 0, omni; 1 to 16 for channel 1 to 16; only available, when midi_fx_idx=-100, otherwise nil\ncategory:the MIDI-category, which affects the meaning of parameter midi_note; only available, when midi_fx_idx=-100, otherwise nil\nmidi_note:the midi_note/command, whose meaning depends on parameter category; only available, when midi_fx_idx=-100, otherwise nil\n",
        "body": "${1:local }${2:integer parmidx},${3:string parmname},${4:integer parameter_modulation},${5:number parmbase},${6:boolean plink_enabled},${7:number scale},${8:integer midi_fx_idx},${9:integer midi_fx_idx2},${10:integer linked_parmidx},${11:number offset},${12:optional integer bus},${13:optional integer channel},${14:optional integer category},${15:optional integer midi_note} = ultraschall.GetParmMIDIPLink_FXStateChunk(${16:string FXStateChunk},${17:integer fxid},${18:integer id})$0"
    },
    "ULTRASCHALL.DELETEPARMLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.DeleteParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Deletes a ParmLearn-entry from an FXStateChunk.\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, which you want to delete a ParmLearn from\nfxid:the id of the fx, which holds the to-delete-ParmLearn-entry; beginning with 1\nid:the id of the ParmLearn-entry to delete; beginning with 1\nRETURNS:\nretval:true, if deletion was successful; false, if the function couldn't delete anything\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string alteredFXStateChunk} = ultraschall.DeleteParmLearn_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer id})$0"
    },
    "ULTRASCHALL.DELETEPARMALIAS_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.DeleteParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Deletes a ParmAlias-entry from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, which you want to delete a ParmAlias from\nfxid:the id of the fx, which holds the to-delete-ParmAlias-entry; beginning with 1\nid:the id of the ParmAlias-entry to delete; beginning with 1\nRETURNS:\nretval:true, if deletion was successful; false, if the function couldn't delete anything\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string alteredFXStateChunk} = ultraschall.DeleteParmAlias_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer id})$0"
    },
    "ULTRASCHALL.DELETEPARMLFOLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.DeleteParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Deletes a ParmLFO-Learn-entry from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, which you want to delete a ParmLFO-Learn-entry from\nfxid:the id of the fx, which holds the to-delete-ParmLFO-Learn-entry; beginning with 1\nid:the id of the ParmLFO-Learn-entry to delete; beginning with 1\nRETURNS:\nretval:true, if deletion was successful; false, if the function couldn't delete anything\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string alteredFXStateChunk} = ultraschall.DeleteParmLFOLearn_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer id})$0"
    },
    "ULTRASCHALL.SETPARMLFOLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.SetParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Sets an already existing ParmLFO-Learn-entry of an FX-plugin from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a ParmLFO-Learn-entry\nfxid:the id of the fx, which holds the to-set-ParmLFO-Learn-entry; beginning with 1\nid:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLFO)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:optional string alteredFXStateChunk} = ultraschall.SetParmLFOLearn_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer id},${7:integer midi_note},${8:integer checkboxflags},${9:optional string osc_message})$0"
    },
    "ULTRASCHALL.SETPARMLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.SetParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Sets an already existing Parm-Learn-entry of an FX-plugin from an FXStateChunk.\nIt's the PARMLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nid:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:optional string alteredFXStateChunk} = ultraschall.SetParmLearn_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer id},${7:integer midi_note},${8:integer checkboxflags},${9:optional string osc_message})$0"
    },
    "ULTRASCHALL.SETPARMALIAS_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.SetParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Sets an already existing Parm-Learn-entry of an FX-plugin from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nid:the id of the Parm-Learn-entry to set; beginning with 1\nparmalias:the new aliasname of the parameter\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:optional string alteredFXStateChunk} = ultraschall.SetParmAlias_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer id},${7:string parmalias})$0"
    },
    "ULTRASCHALL.SETFXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.SetFXStateChunk",
        "scope": "lua",
        "description": "Adds/replaces FXStateChunk to/in a TrackStateChunk or a MediaItemStateChunk.\nreturns false in case of an error\nPARAMETERS:\nStateChunk:the FXStateChunk, which you want to set into the TrackStateChunk\nFXStateChunk:the FXStateChunk, which you want to set into the TrackStateChunk\nTakeFXChain_id:when using MediaItemStateChunks, this allows you to choose the take of which you want the FXChain; default is 1\nRETURNS:\nretval:true, if setting fxstatechunk was successful; false, if setting was unsuccessful\nalteredStateChunk:the altered StateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:optional string alteredStateChunk} = ultraschall.SetFXStateChunk(${4:string StateChunk},${5:string FXStateChunk},${6:optional integer TakeFXChain_id})$0"
    },
    "ULTRASCHALL.GETFXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetFXStateChunk",
        "scope": "lua",
        "description": "Returns an FXStateChunk from a TrackStateChunk or a MediaItemStateChunk.\nAn FXStateChunk holds all FX-plugin-settings for a specific MediaTrack or MediaItem.\nReturns nil in case of an error or if no FXStateChunk has been found.\nPARAMETERS:\nStateChunk:the StateChunk, from which you want to retrieve the FXStateChunk\nTakeFXChain_id:when using MediaItemStateChunks, this allows you to choose the take of which you want the FXChain; default is 1\nRETURNS:\nFXStateChunk:the FXStateChunk, stored in the StateChunk\n",
        "body": "${1:local }${2:string FXStateChunk} = ultraschall.GetFXStateChunk(${3:string StateChunk},${4:optional integer TakeFXChain_id})$0"
    },
    "ULTRASCHALL.ADDPARMLFOLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.AddParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Adds a new Parm-LFOLearn-entry to an FX-plugin from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nparmidx:the parameter, whose alias you want to add\nparmname:the name of the parameter, usually \\\"\\\" or \\\"byp\\\" for bypass or \\\"wet\\\" for wet; when using wet or bypass, these are essential to give!\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLFOLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:optional string alteredFXStateChunk} = ultraschall.AddParmLFOLearn_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer parmidx},${7:string parmname},${8:integer midi_note},${9:integer checkboxflags},${10:optional string osc_message})$0"
    },
    "ULTRASCHALL.ADDPARMLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.AddParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Adds a new Parm-Learn-entry to an FX-plugin from an FXStateChunk.\nIt's the PARMLEARN-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nparmidx:the parameter, whose alias you want to add\nparmname:the name of the parameter, usually \\\"\\\" or \\\"byp\\\" for bypass or \\\"wet\\\" for wet; when using wet or bypass, these are essential to give!\nmidi_note:  an integer representation of the MIDI-note, which is set as command; 0, in case of an OSC-message\ncheckboxflags:the checkboxes checked in the MIDI/OSC-learn dialog\nosc_message:the osc-message, that triggers the ParmLearn, only when midi_note is set to 0!\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:optional string alteredFXStateChunk} = ultraschall.AddParmLearn_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:integer parmidx},${7:string parmname},${8:integer midi_note},${9:integer checkboxflags},${10:optional string osc_message})$0"
    },
    "ULTRASCHALL.ADDPARMALIAS_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.AddParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Adds a new Parm-Alias-entry to an FX-plugin from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns false in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to set a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-set-Parm-Learn-entry; beginning with 1\nparmalias:the new aliasname of the parameter\nRETURNS:\nretval:true, if setting new values was successful; false, if setting was unsuccessful(e.g. no such ParmLearn)\nalteredFXStateChunk:the altered FXStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:optional string alteredFXStateChunk} = ultraschall.AddParmAlias_FXStateChunk(${4:string FXStateChunk},${5:integer fxid},${6:string parmalias})$0"
    },
    "ULTRASCHALL.COUNTPARMALIAS_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.CountParmAlias_FXStateChunk",
        "scope": "lua",
        "description": "Counts already existing Parm-Alias-entries of an FX-plugin from an FXStateChunk.\nIt's the PARMALIAS-entry\nreturns -1 in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to count a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-count-Parm-Learn-entry; beginning with 1\nRETURNS:\ncount:the number of ParmAliases found\n",
        "body": "${1:local }${2:integer count} = ultraschall.CountParmAlias_FXStateChunk(${3:string FXStateChunk},${4:integer fxid})$0"
    },
    "ULTRASCHALL.COUNTPARMLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.CountParmLearn_FXStateChunk",
        "scope": "lua",
        "description": "Counts already existing Parm-Learn-entries of an FX-plugin from an FXStateChunk.\nIt's the PARMLEARN-entry\nreturns -1 in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to count a Parm-Learn-entry\nfxid:the id of the fx, which holds the to-count-Parm-Learn-entry; beginning with 1\nRETURNS:\ncount:the number of ParmLearn-entried found\n",
        "body": "${1:local }${2:integer count} = ultraschall.CountParmLearn_FXStateChunk(${3:string FXStateChunk},${4:integer fxid})$0"
    },
    "ULTRASCHALL.COUNTPARMLFOLEARN_FXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.CountParmLFOLearn_FXStateChunk",
        "scope": "lua",
        "description": "Counts already existing Parm-LFOLearn-entries of an FX-plugin from an FXStateChunk.\nIt's the LFOLEARN-entry\nreturns -1 in case of an error\nPARAMETERS:\nFXStateChunk:the FXStateChunk, in which you want to count a Parm-LFOLearn-entry\nfxid:the id of the fx, which holds the to-count-Parm-LFOLearn-entry; beginning with 1\nRETURNS:\ncount:the number of LFOLearn-entried found\n",
        "body": "${1:local }${2:integer count} = ultraschall.CountParmLFOLearn_FXStateChunk(${3:string FXStateChunk},${4:integer fxid})$0"
    },
    "ULTRASCHALL.COUNTFXSTATECHUNKSINSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.CountFXStateChunksInStateChunk",
        "scope": "lua",
        "description": "Counts all FXStateChunks within a StateChunk.\nYou can pass ItemStateChunks, TrackStateChunks and ProjectStateChunks.\nreturns -1 in case of an error.\nPARAMETERS:\nStateChunk:the StateChunk, whose count of FXStateChunks you want to retrieve\nRETURNS:\ncount_of_takefx_statechunks:the number of take-fx-StateChunks within the StateChunk. When passing Track/ProjectStateChunks, it returns number of all FXStateChunks from all Takes within the StateChunk\ncount_of_trackfx_statechunks:the number of TrackFX-StateChunks; each track alawys has a single one, so it should match the number of tracks within the StateChunk; 0, if you pass a ItemStateChunk\n",
        "body": "${1:local }${2:integer count_of_takefx_statechunks},${3:integer count_of_trackfx_statechunks} = ultraschall.CountFXStateChunksInStateChunk(${4:string StateChunk})$0"
    },
    "ULTRASCHALL.REMOVEFXSTATECHUNKFROMTRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.RemoveFXStateChunkFromTrackStateChunk",
        "scope": "lua",
        "description": "Clears the FXChain from a TrackStateChunk\nreturns nil in case of an error.\nPARAMETERS:\nTrackStateChunk:the TrackStateChunk, whose FXStateChunk you want to remove\nRETURNS:\naltered_TrackStateChunk:the TrackStateChunk, cleared of the Track-FXStateChunk\n",
        "body": "${1:local }${2:string altered_TrackStateChunk} = ultraschall.RemoveFXStateChunkFromTrackStateChunk(${3:string TrackStateChunk})$0"
    },
    "ULTRASCHALL.REMOVEFXSTATECHUNKFROMITEMSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.RemoveFXStateChunkFromItemStateChunk",
        "scope": "lua",
        "description": "Removes a certain Take-FXStateChunk from an ItemStateChunk.\nReturns nil in case of failure.\nPARAMETERS:\nItemStateChunk:the ItemStateChunk, from which you want to remove an FXStateChunk\ntake_id:the take, whose FXStateChunk you want to remove\nRETURNS:\nalteredItemStateChunk:the StateChunk, from which the FXStateChunk was removed\n",
        "body": "${1:local }${2:string alteredItemStateChunk} = ultraschall.RemoveFXStateChunkFromItemStateChunk(${3:string ItemStateChunk},${4:integer take_id})$0"
    },
    "ULTRASCHALL.LOADFXSTATECHUNKFROMRFXCHAINFILE_WR lua": {
        "prefix": "ultraschallwr.LoadFXStateChunkFromRFXChainFile",
        "scope": "lua",
        "description": "Loads an FXStateChunk from an RFXChain-file.\nIf you don't give a path, it will try to load the file from the folder ResourcePath()/FXChains.\nreturns nil in case of an error\nPARAMETERS:\nfilename:the filename of the RFXChain-file(must include \".RfxChain\"); omit the path to load it from the folder ResourcePath()/FXChains\ntrackfx_or_takefx:0, return the FXStateChunk as Track-FXStateChunk; 1, return the FXStateChunk as Take-FXStateChunk\nRETURNS:\nFXStateChunk:the loaded FXStateChunk; nil, in case of an error\n",
        "body": "${1:local }${2:string FXStateChunk} = ultraschall.LoadFXStateChunkFromRFXChainFile(${3:string filename},${4:integer trackfx_or_takefx})$0"
    },
    "ULTRASCHALL.SAVEFXSTATECHUNKASRFXCHAINFILE_WR lua": {
        "prefix": "ultraschallwr.SaveFXStateChunkAsRFXChainfile",
        "scope": "lua",
        "description": "Loads an FXStateChunk from an RFXChain-file.\nIf you don't give a path, it will try to load the file from the folder ResourcePath/FXChains.\nreturns -1 in case of an error\nPARAMETERS:\nfilename:the filename of the output-RFXChain-file(must include \".RfxChain\"); omit the path to save it into the folder ResourcePath/FXChains\nFXStateChunk:the FXStateChunk, which you want to set into the TrackStateChunk\nRETURNS:\nretval:-1 in case of failure, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SaveFXStateChunkAsRFXChainfile(${3:string filename},${4:string FXStateChunk})$0"
    },
    "ULTRASCHALL.GETALLRFXCHAINFILENAMES_WR lua": {
        "prefix": "ultraschallwr.GetAllRFXChainfilenames",
        "scope": "lua",
        "description": "Returns all available RFXChainfiles in the folder ResourcePath/FXChains\nRETURNS:\ncount_of_RFXChainfiles:the number of available RFXChainFiles\nRFXChainfiles:the filenames of the RFXChainfiles\n",
        "body": "${1:local }${2:integer count_of_RFXChainfiles},${3:array RFXChainfiles} = ultraschall.GetAllRFXChainfilenames()$0"
    },
    "ULTRASCHALL.GETRECENTFX_WR lua": {
        "prefix": "ultraschallwr.GetRecentFX",
        "scope": "lua",
        "description": "Returns the recent fx-list\nRETURNS:\ncount_of_RecentFX:the number of available recent fx\nRecentFX:the names of the recent fx\n",
        "body": "${1:local }${2:integer count_of_RecentFX},${3:array RecentFX} = ultraschall.GetRecentFX()$0"
    },
    "ULTRASCHALL.SPLITSTRINGATLINEFEEDTOARRAY_WR lua": {
        "prefix": "ultraschallwr.SplitStringAtLineFeedToArray",
        "scope": "lua",
        "description": "Splits the string unsplitstring at linefeed/tabs/control characters and puts each of these splitpieces into an array, each splitpiece one array-entry.\nThe linefeeds will not(!) be returned in the array's entries.\nReturns the number of entries in the array, as well as the array itself\nIf there are no control characters or linefeeds in the string, the array will have only one entry with unsplitstring in it.\nreturns -1 in case of failure\nPARAMETERS:\nunsplitstring:the string, that shall be split at LineFeed/Tabs/Control Characters. Nil is not allowed.\nRETURNS:\ncount:number of entries in the split_string-array\nsplit_string:an array with all the individual \"postsplit\"-pieces of the string\n",
        "body": "${1:local }${2:integer count},${3:array split_string} = ultraschall.SplitStringAtLineFeedToArray(${4:string unsplitstring})$0"
    },
    "ULTRASCHALL.COUNTCHARACTERINSTRING_WR lua": {
        "prefix": "ultraschallwr.CountCharacterInString",
        "scope": "lua",
        "description": "Counts, how often character appears in checkstring and returns the count, as well as a array an with the position-numbers.\nreturns -1 in case of error\nPARAMETERS:\ncheckstring:the string to check search through\ncharacter:the character to search for. Only single characters are allowed. Controlcodes like \\n \\t count as single character. Case sensitive.\nRETURNS:\ncount:the number of occurences of character in checkstring\npositions:the positionnumbers of the character in checkstring\n",
        "body": "${1:local }${2:integer count},${3:array positions} = ultraschall.CountCharacterInString(${4:string checkstring},${5:string character})$0"
    },
    "ULTRASCHALL.ISVALIDMATCHINGPATTERN_WR lua": {
        "prefix": "ultraschallwr.IsValidMatchingPattern",
        "scope": "lua",
        "description": "Returns, if patstring is a valid pattern-matching-string\nPARAMETERS:\npatstring:the string to check for, if it's a valid pattern-matching-string\nRETURNS:\nretval:true, patstring is a valid pattern-matching-string; false, patstring isn't a valid pattern-matching-string\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidMatchingPattern(${3:string patstring})$0"
    },
    "ULTRASCHALL.CSV2INDIVIDUALLINESASARRAY_WR lua": {
        "prefix": "ultraschallwr.CSV2IndividualLinesAsArray",
        "scope": "lua",
        "description": "convert a csv-string to an array of the individual values. If separator cannot be found, it'll return the original string\nreturns nil in case or error\nPARAMETERS:\ncsv_line:a string as a csv, with all values included and separated by parameter separator\nseparator:the separator, that separates the individual entries; use nil for commas; separators will be removed from the final strings!\nRETURNS:\ncount:the number of entries\nindividual_values:all values, each in an individual array-position\n",
        "body": "${1:local }${2:integer count},${3:array individual_values} = ultraschall.CSV2IndividualLinesAsArray(${4:string csv_line},${5:optional string separator})$0"
    },
    "ULTRASCHALL.ROUNDNUMBER_WR lua": {
        "prefix": "ultraschallwr.RoundNumber",
        "scope": "lua",
        "description": "returns a rounded value of the parameter number. %.5 and higher rounds up, lower than %.5 round down.\nreturns nil in case of an error\nPARAMETERS:\nnum:the floatingpoint number, you'd like to have rounded.\nRETURNS:\nretval:the rounded number\n",
        "body": "${1:local }${2:integer retval} = ultraschall.RoundNumber(${3:number num})$0"
    },
    "ULTRASCHALL.GETPARTIALSTRING_WR lua": {
        "prefix": "ultraschallwr.GetPartialString",
        "scope": "lua",
        "description": "returns the part of a filename-string between sep1 and sep2\nreturns nil if it doesn't work, no sep1 or sep2 exist\nPARAMETERS:\nstr:separator on the \"right\" side of the partial string\nsep1:separator on the \"left\" side of the partial string\nsep2:separator on the \"right\" side of the partial string\nRETURNS:\npartial_string:the partial string between sep1 and sep2\n",
        "body": "${1:local }${2:string partial_string} = ultraschall.GetPartialString(${3:string str},${4:string sep1},${5:string sep2})$0"
    },
    "ULTRASCHALL.NOTES2CSV_WR lua": {
        "prefix": "ultraschallwr.Notes2CSV",
        "scope": "lua",
        "description": "Gets the project's notes and returns it as a CSV.\nRETURNS:\ncsv_retval:the project notes, returned as a csv-string; entries separated by a comma\n",
        "body": "${1:local }${2:string csv_retval} = ultraschall.Notes2CSV()$0"
    },
    "ULTRASCHALL.CSV2LINE_WR lua": {
        "prefix": "ultraschallwr.CSV2Line",
        "scope": "lua",
        "description": "converts a string of csv-values into a string with all values and without the ,-separators\nreturns nil in case of error\nRETURNS:\nvalues:all values in one string\n",
        "body": "${1:local }${2:string values} = ultraschall.CSV2Line(${3:string csv_line})$0"
    },
    "ULTRASCHALL.ISITEMINTRACK_WR lua": {
        "prefix": "ultraschallwr.IsItemInTrack",
        "scope": "lua",
        "description": "checks, whether a given item is part of the track tracknumber\nreturns true, if the itemIDX is part of track tracknumber, false if not, nil if no such itemIDX or Tracknumber available\nPARAMETERS:\ntracknumber:the number of the track to check in, with 1 for track 1, 2 for track 2, etc.\nitemIDX:the number of the item to check of\nRETURNS:\nretval:true, if item is in track, false if item isn't in track\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsItemInTrack(${3:integer tracknumber},${4:integer itemIDX})$0"
    },
    "ULTRASCHALL.CHECKACTIONCOMMANDIDFORMAT2_WR lua": {
        "prefix": "ultraschallwr.CheckActionCommandIDFormat2",
        "scope": "lua",
        "description": "Checks, whether an action command id is a valid commandid(which is a number) or a valid _action_command_id (which is a string with an _underscore in the beginning).\nUnlike CheckActionCommandIDFormat, this checks whether an action-command-id-string is an actual registered one(case sensitive!).\nreturns false in case of an error\nPARAMETERS:\n:the ActionCommandID you want to check; either a number or an action_command_id with an underscore at the beginning\nRETURNS:\nretval:true, valid action_command_id; false, not a valid action_command_id\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.CheckActionCommandIDFormat2(${3:action_command_id})$0"
    },
    "ULTRASCHALL.TOGGLESTATEACTION_WR lua": {
        "prefix": "ultraschallwr.ToggleStateAction",
        "scope": "lua",
        "description": "Toggles state of an action using the actioncommand_id(instead of the CommandID-number)\nreturns current state of the action after toggling or -1 in case of error.\nPARAMETERS:\nsection:the section of the action(see ShowActionlist-dialog)\nactioncommand_id:the ActionCommandID of the action to toggle\nstate:1 or 0\nRETURNS:\nretval:state if the action, after it has been toggled\n",
        "body": "${1:local }${2:integer retval} = ultraschall.ToggleStateAction(${3:integer section},${4:string actioncommand_id},${5:integer state})$0"
    },
    "ULTRASCHALL.TOGGLESTATEBUTTON_WR lua": {
        "prefix": "ultraschallwr.ToggleStateButton",
        "scope": "lua",
        "description": "Toggles state and refreshes the button of an actioncommand_id\nreturns false in case of error\nPARAMETERS:\nsection:the section of the action(see ShowActionlist-dialog)\nactioncommand_id:the ActionCommandID of the action to toggle\nstate:1 or 0\nRETURNS:\nretval:true, toggling worked; false, toggling didn't work\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ToggleStateButton(${3:integer section},${4:string actioncommand_id},${5:integer state})$0"
    },
    "ULTRASCHALL.SECONDSTOTIME_WR lua": {
        "prefix": "ultraschallwr.SecondsToTime",
        "scope": "lua",
        "description": "converts timeposition in seconds(pos) to a timestring (h)hh:mm:ss.mss\nreturns nil in case of error\nPARAMETERS:\npos:timeposition in seconds\nRETURNS:\ntime_string:timestring in (h)hh:mm:ss.mss\n",
        "body": "${1:local }${2:string time_string} = ultraschall.SecondsToTime(${3:number pos})$0"
    },
    "ULTRASCHALL.TIMETOSECONDS_WR lua": {
        "prefix": "ultraschallwr.TimeToSeconds",
        "scope": "lua",
        "description": "converts a timestring days:hours:minutes:seconds.milliseconds to timeposition in seconds\nit is ok, to have only some of the last ones given, so i.e. excluding days and hours is ok. Though excluding values inbetween does not work!\nA single integer in timestring will be seen as seconds.\nTo only specifiy milliseconds in particular, start the number with a .\nall other values are separated by :\nreturns -1 in case of error, timestring is a nil or if you try to add an additional value, added before days\ndoes not check for valid timeranges, so 61 minutes is possible to give, even if hours are present in the string\nPARAMETERS:\ntimestring:a string like: days:hours:minutes:seconds.milliseconds , i.e. 1:16:27:50.098\nRETURNS:\nposition:the converted position\n",
        "body": "${1:local }${2:number position} = ultraschall.TimeToSeconds(${3:string timestring})$0"
    },
    "ULTRASCHALL.SECONDSTOTIMESTRING_HH_MM_SS_MSS_WR lua": {
        "prefix": "ultraschallwr.SecondsToTimeString_hh_mm_ss_mss",
        "scope": "lua",
        "description": "Converts the parameter time into a timestring of the format hh:mm:ss.mss\nValid timeranges are from 0 to 359999.99 seconds(about 99 hours).\nreturns -1 in case of error\nPARAMETERS:\ntime:the time in seconds to be converted into the timestring\nRETURNS:\ntimestring:the converted timestring. It will always follow the format hh:mm:ss.mss and fill up digits with zeros, if necessary.\n",
        "body": "${1:local }${2:string timestring} = ultraschall.SecondsToTimeString_hh_mm_ss_mss(${3:number time})$0"
    },
    "ULTRASCHALL.TIMESTRINGTOSECONDS_HH_MM_SS_MSS_WR lua": {
        "prefix": "ultraschallwr.TimeStringToSeconds_hh_mm_ss_mss",
        "scope": "lua",
        "description": "Converts the parameter timestring of the format hh:mm:ss.mss into seconds\nThe timestring must follow strictly this format, or the function returns -1 as result.\nreturns -1 in case of error\nPARAMETERS:\ntimestring:the converted timestring. It must always follow the format hh:mm:ss.mss. Fill up digits with zeros, if necessary.\nRETURNS:\ntime:the time in seconds to be converted into the timestring, -1 in case of an error\n",
        "body": "${1:local }${2:number time} = ultraschall.TimeStringToSeconds_hh_mm_ss_mss(${3:string timestring})$0"
    },
    "ULTRASCHALL.COUNTPATTERNINSTRING_WR lua": {
        "prefix": "ultraschallwr.CountPatternInString",
        "scope": "lua",
        "description": "returns the count and an array with all positions of searchstring in sourcestring.\nPARAMETERS:\nsourcestring:the string, you want to search through\nsearchstring:the string, you want to search for in sourcestring\nnon_case_sensitive:true, the search does not care about case-sensitivity; false, case of searchstring will be kept\nRETURNS:\ncount:the number of appearances of searchstring in sourcestring\npositions:an array with count-entries, where every entry contains the position of searchstring in sourcestring\n",
        "body": "${1:local }${2:integer count},${3:array positions} = ultraschall.CountPatternInString(${4:string sourcestring},${5:string searchstring},${6:boolean non_case_sensitive})$0"
    },
    "ULTRASCHALL.OPENURL_WR lua": {
        "prefix": "ultraschallwr.OpenURL",
        "scope": "lua",
        "description": "Opens the URI with the standard-browser installed in your system.\nreturns -1 in case of an error\nPARAMETERS:\nurl:the url to be opened in the browser; will check for :// in it for validity!\n",
        "body": "${1:local }${2:integer retval} = ultraschall.OpenURL(${3:string url})$0"
    },
    "ULTRASCHALL.COMPAREARRAYS_WR lua": {
        "prefix": "ultraschallwr.CompareArrays",
        "scope": "lua",
        "description": "Compares Array using parameter CompareArray2 and returns an array with all entries in CompareArray2, that are not in Array.\nThe comparable arrays must be indexed by integer-numbers.\nReturns nil in case of an error\nPARAMETERS:\nArray:the array you want to check against Array; all entries in CompareArray2 that are not in Array will be returned\nCompareArray2:the array you want to check against Array; all entries in CompareArray2 that are not in Array will be returned\nRETURNS:\ndiff_array:an array with all entries from CompareArray2, that are not in Array\n",
        "body": "${1:local }${2:table diff_array} = ultraschall.CompareArrays(${3:table Array},${4:table CompareArray2})$0"
    },
    "ULTRASCHALL.GETOS_WR lua": {
        "prefix": "ultraschallwr.GetOS",
        "scope": "lua",
        "description": "Returns operating system and if it's a 64bit/32bit-operating system.\nRETURNS:\noperating_system:the operating system used; usually \"Win\", \"Mac\" or \"Other\"(e.g. when Linux is used)\nbits:the number of bits of the operating-system. Either 32 or 64 bit.\n",
        "body": "${1:local }${2:string operating_system},${3:integer bits} = ultraschall.GetOS()$0"
    },
    "ULTRASCHALL.ISOS_WINDOWS_WR lua": {
        "prefix": "ultraschallwr.IsOS_Windows",
        "scope": "lua",
        "description": "returns, if the current operating system is windows\nRETURNS:\nis_windows:true, if the operating-system is windows; false if not\n",
        "body": "${1:local }${2:boolean is_windows},${3:integer number_of_bits} = ultraschall.IsOS_Windows()$0"
    },
    "ULTRASCHALL.ISOS_MAC_WR lua": {
        "prefix": "ultraschallwr.IsOS_Mac",
        "scope": "lua",
        "description": "returns, if the current operating system is mac-osx\nRETURNS:\nis_mac:true, if the operating-system is mac-osx; false if not\n",
        "body": "${1:local }${2:boolean is_mac},${3:integer number_of_bits} = ultraschall.IsOS_Mac()$0"
    },
    "ULTRASCHALL.ISOS_OTHER_WR lua": {
        "prefix": "ultraschallwr.IsOS_Other",
        "scope": "lua",
        "description": "returns, if the current operating system is neither mac or win\nRETURNS:\nis_other:true, if the operating-system is neither mac or win; false if not\n",
        "body": "${1:local }${2:boolean is_other},${3:integer number_of_bits} = ultraschall.IsOS_Other()$0"
    },
    "ULTRASCHALL.GETREAPERAPPVERSION_WR lua": {
        "prefix": "ultraschallwr.GetReaperAppVersion",
        "scope": "lua",
        "description": "Returns operating system and if it's a 64bit/32bit-operating system.\nRETURNS:\nmajorversion:the majorversion of Reaper. Can be used for comparisions like \"if version<5 then ... end\".\nsubversion:the subversion of Reaper. Can be used for comparisions like \"if subversion<96 then ... end\".\nbits:the number of bits of the reaper-app\noperating_system:the operating system, either \"Win\", \"OSX\" or \"Other\"\nportable:true, if it's a portable installation; false, if it isn't a portable installation\nbetaversion:if you use a pre-release of Reaper, this contains the beta-version, like \"rc9\" or \"+dev0423\" or \"pre6\"\n",
        "body": "${1:local }${2:integer majorversion},${3:integer subversion},${4:string bits},${5:string operating_system},${6:boolean portable},${7:optional string betaversion} = ultraschall.GetReaperAppVersion()$0"
    },
    "ULTRASCHALL.LIMITFRACTIONOFFLOAT_WR lua": {
        "prefix": "ultraschallwr.LimitFractionOfFloat",
        "scope": "lua",
        "description": "limits the fraction of a float-number to a specific length of fraction(digits). You can also choose to round the value or not.\nreturns nil in case of error\nPARAMETERS:\nnumber:the number, whose fraction shall be limited\nlength_of_fraction:the number of digits in the fraction\nroundit:false, no rounding; true, rounds the fraction. Rounding-precision is only length_of_fraction+1, all the other digits will be ignored. If length_of_fraction+1>=5, it will be rounded up, otherwise down.\nRETURNS:\naltered_number:the altered number with the new fraction-length. Will be equal to parameter number, if number was integer or fraction less digits than length_of_fraction\n",
        "body": "${1:local }${2:number altered_number} = ultraschall.LimitFractionOfFloat(${3:number number},${4:integer length_of_fraction},${5:boolean roundit})$0"
    },
    "ULTRASCHALL.GETALLENTRIESFROMTABLE_WR lua": {
        "prefix": "ultraschallwr.GetAllEntriesFromTable",
        "scope": "lua",
        "description": "Gets an iterable version of table. Good for analysing unknown tables.\nReturns the number of entries, a table(array) with the datatypes of each entry and the table with all it's entries in the same order as in the foundtypes-table.\nThis doesn't treat table recursivley, means: each \"Subtable\" within the table is treated as one entry of the type \"table\". That means, that these tables must be analysed themselves in an extra step!\nA[1]=1\nA[2][1]=2\nA[2][2]=3.4\nwill return two(!) entries, the first being of type \"integer\", the second being of type \"table\". Next step would be to run use this function to analyse A[2] as well, which would result in two entries: the first being of type \"integer\" and the second of type \"float\", etc.\nreturns -1 in case of error\nPARAMETERS:\ntable:the table to get the individual entries from\nRETURNS:\ncount:the number of table-entries found\nfoundtypes:a table, with count-entries, each entry having the type of each entry in the returned_table as string.\nreturned_table:an iterable version of table. The type of each entry can be found in the accompanying entry of foundtypes\n",
        "body": "${1:local }${2:integer count},${3:table foundtypes},${4:table returned_table} = ultraschall.GetAllEntriesFromTable(${5:table table})$0"
    },
    "ULTRASCHALL.APIEXISTS_WR lua": {
        "prefix": "ultraschallwr.APIExists",
        "scope": "lua",
        "description": "returns true, if a certain function/variable exists in ultraschall.\nreturns false if nothing has been found\nPARAMETERS:\nfunctionname:the name of the function to check for; only the functionname without ultraschall. !\nRETURNS:\nretval:true, if element exists; false if it doesn't exist\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.APIExists(${3:string functionname})$0"
    },
    "ULTRASCHALL.ISVALIDGUID_WR lua": {
        "prefix": "ultraschallwr.IsValidGuid",
        "scope": "lua",
        "description": "Checks, if guid is a valid guid. Can also be used for strings, that contain a guid somewhere in them(strict=false)\nA valid guid is a string that follows the following pattern:\n{........-....-....-....-............}\nwhere . is a hexadecimal value(0-F)\nReturns false in case of error\nPARAMETERS:\nguid:the guid to check for validity\nstrict:true, guid must only be the valid guid; false, guid must contain a valid guid somewhere in it(means, can contain trailing or preceding characters)\nRETURNS:\nretval:true, guid is/contains a valid guid; false, guid isn't/does not contain a valid guid\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidGuid(${3:string guid},${4:boolean strict})$0"
    },
    "ULTRASCHALL.SETGUIDEXTSTATE_WR lua": {
        "prefix": "ultraschallwr.SetGuidExtState",
        "scope": "lua",
        "description": "Sets an extension-state using a given guid. Good for storing additional metadata of objects like MediaTracks, MediaItems, MediaItem_Takes, etc(everything, that has a guid).\nThe state can be saved as either global extension state or \"local\" extension-project-state(in the currently opened project)\nThe guid can have additional text, but must contain a valid guid somewhere in it!\nA valid guid is a string that follows the following pattern:\n{........-....-....-....-............}\nwhere . is a hexadecimal value(0-F)\nReturns -1 in case of error\nPARAMETERS:\nguid:the guid of the object, for whom you want to store a key/value-pair; can have additional characters before and after the guid, but must contain a valid guid!\nkey:the key for this guid\nvalue:the value to store into the key/value-store\nsavelocation:0, store as project extension state(into the currently opened project); 1, store as global extension state(when persist=true, into reaper-extstate.ini in the resourcesfolder)\noverwrite:true, overwrite a previous given value; false, don't overwrite, if a value exists already\npersists:true, make extension state persistent(available after Reaper-restart); false, don't make it persistent; Only with global extension states\nRETURNS:\nretval:the idx of the extstate(if a project extension state); 1, successful(with extension states), -1, unsuccessful\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetGuidExtState(${3:string guid},${4:string key},${5:string value},${6:integer savelocation},${7:boolean overwrite},${8:boolean persists})$0"
    },
    "ULTRASCHALL.SETBITFIELD_WR lua": {
        "prefix": "ultraschallwr.SetBitfield",
        "scope": "lua",
        "description": "Alters an integer-bitfield.\nReturns nil in case of error, like invalid bit-values\nPARAMETERS:\ninteger_bitfield:the old integer-bitfield that you want to alter\nset_to:true, set the bits to 1; false, set the bits to 0; nil, toggle the bits\nRETURNS:\nnew_integer_bitfield:the newly altered bitfield\n",
        "body": "${1:local }${2:integer new_integer_bitfield} = ultraschall.SetBitfield(${3:integer integer_bitfield},${4:boolean set_to},${5:integer bit_1},${6:integer bit_2},${7:... integer bit_n})$0"
    },
    "ULTRASCHALL.SETINTCONFIGVAR_BITFIELD_WR lua": {
        "prefix": "ultraschallwr.SetIntConfigVar_Bitfield",
        "scope": "lua",
        "description": "Alters an integer-bitfield stored by a ConfigVariable.\nReturns false in case of error, like invalid bit-values, etc\nPARAMETERS:\nconfigvar:the config-variable, that is stored as an integer-bitfield, that you want to alter.\nset_to:true, set the bits to 1; false, set the bits to 0; nil, toggle the bits\nRETURNS:\nretval:true, if altering was successful; false, if not successful\nnew_integer_bitfield:the newly altered bitfield\n",
        "body": "${1:local }${2:boolean retval},${3:integer new_integer_bitfield} = ultraschall.SetIntConfigVar_Bitfield(${4:string configvar},${5:boolean set_to},${6:integer bit_1},${7:integer bit_2},${8:... integer bit_n})$0"
    },
    "ULTRASCHALL.CONVERTSTRINGTOASCII_ARRAY_WR lua": {
        "prefix": "ultraschallwr.ConvertStringToAscii_Array",
        "scope": "lua",
        "description": "Converts a string into it's individual characters and numerical-representation as a table and after that returns its number of table-entries and the table.\nReturns -1 if string isn't a valid string\nPARAMETERS:\nstring:the string to be converted\nRETURNS:\nlength:the number of characters in the string/entries in the returned table byte_array\nbyte_array:the ByteArray as a table, with the format\n",
        "body": "${1:local }${2:integer length},${3:table byte_array} = ultraschall.ConvertStringToAscii_Array(${4:string string})$0"
    },
    "ULTRASCHALL.COMPARESTRINGWITHASCIIVALUES_WR lua": {
        "prefix": "ultraschallwr.CompareStringWithAsciiValues",
        "scope": "lua",
        "description": "Compares a string with a number of byte-values(like ASCII-values).\nBytevalues can be either decimal and hexadecimal.\n-1, if you want to skip checking of a specific position in string.\nReturns false in case of error\nPARAMETERS:\nstring:the string to check against the bytevalues\nbytevalue_1:one or more parameters, that include the bytevalues to check against the accompanying byte in string; -1, if you want to skip check for that position\nRETURNS:\nretval:true, if check was successful; false, if not successful\nerrorposition:if retval is false, this will contain the position in string, where the checking failed; nil, if retval is true\n",
        "body": "${1:local }${2:boolean retval},${3:integer errorposition} = ultraschall.CompareStringWithAsciiValues(${4:string string},${5:integer bytevalue_1},${6:integer bytevalue_2},${7:... integer bytevalue_n})$0"
    },
    "ULTRASCHALL.RETURNSMINUSONEINCASEOFERROR_ARZALA_WR lua": {
        "prefix": "ultraschallwr.ReturnsMinusOneInCaseOfError_Arzala",
        "scope": "lua",
        "description": "Returns -1 in case of an error\nRETURNS:\nretval:returns -1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.ReturnsMinusOneInCaseOfError_Arzala()$0"
    },
    "ULTRASCHALL.COUNTLINESINSTRING_WR lua": {
        "prefix": "ultraschallwr.CountLinesInString",
        "scope": "lua",
        "description": "Counts the lines in a string. It counts them by counting \\n-newlines(not carriage returns!)\nReturns -1 in case of an error\nPARAMETERS:\nString:the string to count the lines of\nRETURNS:\nnumber_of_lines:number of lines of the string\n",
        "body": "${1:local }${2:integer number_of_lines} = ultraschall.CountLinesInString(${3:string String})$0"
    },
    "ULTRASCHALL.RETURNTYPEOFREAPEROBJECT_WR lua": {
        "prefix": "ultraschallwr.ReturnTypeOfReaperObject",
        "scope": "lua",
        "description": "returns the type of a Reaper-object.\nPARAMETERS:\nobject:a Reaper-object of the following types:\nRETURNS:\nobjecttype:the type of the parameter of object\n",
        "body": "${1:local }${2:string objecttype} = ultraschall.ReturnTypeOfReaperObject(${3:Reaperobject object})$0"
    },
    "ULTRASCHALL.ISOBJECTVALIDREAPEROBJECT_WR lua": {
        "prefix": "ultraschallwr.IsObjectValidReaperObject",
        "scope": "lua",
        "description": "checks, if object is a valid Reaper-object. It also returns the type of that Reaper-object.\nPARAMETERS:\nobject:a Reaper-object of the following types:\nRETURNS:\nretval:true, if it's a valid Reaper-object; false, if not\nobjecttype:the type of the parameter of object\n",
        "body": "${1:local }${2:boolean retval},${3:string objecttype} = ultraschall.IsObjectValidReaperObject(${4:Reaperobject object})$0"
    },
    "ULTRASCHALL.REMOVETABLEENTRIESOFTYPE_WR lua": {
        "prefix": "ultraschallwr.RemoveTableEntriesOfType",
        "scope": "lua",
        "description": "Removes all entries from worktable, that are of the datatype as given by removetype.\nreturns nil in case of error\nPARAMETERS:\nworktable:the unaltered source-table for processing\nremovetype:the type that shall be removed from table\nRETURNS:\nalteredtable:the table, that contains only the entries that are nt of the type as given by parameter removetype\n",
        "body": "${1:local }${2:table alteredtable} = ultraschall.RemoveTableEntriesOfType(${3:table worktable},${4:string removetype})$0"
    },
    "ULTRASCHALL.ISITEMINTRACK3_WR lua": {
        "prefix": "ultraschallwr.IsItemInTrack3",
        "scope": "lua",
        "description": "Checks, whether a MediaItem is in any of the tracks, given by trackstring.\nsee IsItemInTrack to use itemidx instead of the MediaItem-object.\nsee IsItemInTrack2 to check against only one track.\nreturns nil in case of error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to know the track is is placed in\ntrackstring:a string with all tracknumbers, separated by commas; 1 for track 1, 2 for track 2, etc\nRETURNS:\nretval:true, if item is in track; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsItemInTrack3(${3:MediaItem MediaItem},${4:string trackstring})$0"
    },
    "ULTRASCHALL.ADDINTTOCHAR_WR lua": {
        "prefix": "ultraschallwr.AddIntToChar",
        "scope": "lua",
        "description": "Adds/subtracts int to/from the numeric representation of character. It will return the new character.\nIt will not(!) include \"overflows\" into the adding/subtraction. That said, if you want to add a value resulting in a character above ASCII-code 255, it will fail!\nReturns nil in case of an error\nPARAMETERS:\ncharacter:the character, onto which you want to add/subtract parameter int; only single character allowed\nint:the value, that you want to add to the numerical representation of parameter character\nRETURNS:\nnew_character:the new character, after parameter int has been added/subtracted from/to character\n",
        "body": "${1:local }${2:string new_character} = ultraschall.AddIntToChar(${3:string character},${4:integer int})$0"
    },
    "ULTRASCHALL.MAKEFUNCTIONUNDOABLE_WR lua": {
        "prefix": "ultraschallwr.MakeFunctionUndoable",
        "scope": "lua",
        "description": "Run the function Func and create an undopoint for this function. You can also give an UndoMessage and a flag for Reaper to use.\nAll parameters needed by Func follow after parameter Flag, as if it would be the normal parameters.\nThis should make creating undo-points much much easier...\nNote: Reaper will use the undo-point only for functions, who do \"undo\"-able things. If you don't have something of that kind(no creating a track or something), Reaper will not create an undo-point.\nReturns false in case of an error\nPARAMETERS:\nFunc:the parameters, as needed by the function Func; will be given to Func as provided by you\nUndoMessage:the undo-message to be displayed by Reaper in the Undo-history\nFlag:you can set a flag, if you want, for this undo-point\n:the parameters, as needed by the function Func; will be given to Func as provided by you\nFunc_parameters_n:the parameters, as needed by the function Func; will be given to Func as provided by you\nRETURNS:\nretval:the returnvalues, as returned by function Func\ncurrent_UndoMessage:the current UndoMessage for the last action done by Reaper. Use this so see, if getting an undo-point was successful\nretvals_1:the returnvalues, as returned by function Func\n...:the returnvalues, as returned by function Func\nretvals_2:the returnvalues, as returned by function Func\n",
        "body": "${1:local }${2:boolean retval},${3:string current_UndoMessage},${4:retvals_1},${5:...},${6:retvals_2} = ultraschall.MakeFunctionUndoable(${7:function Func},${8:string UndoMessage},${9:integer Flag},${10:Func_parameters_1},${11: ... Func_parameters_n})$0"
    },
    "ULTRASCHALL.RETURNTABLEASINDIVIDUALVALUES_WR lua": {
        "prefix": "ultraschallwr.ReturnTableAsIndividualValues",
        "scope": "lua",
        "description": "Returns the first 64 entries of an numerical-indexed table as returnvalues\nPARAMETERS:\nTable:the table, whose values you want to return. It will only return values with index 1...64!\nRETURNS:\nretval1:the values from Table returned\nretval2:the values from Table returned\nretval3:the values from Table returned\n...:the values from Table returned\nretval64:the values from Table returned\n",
        "body": "${1:local }${2:retval1},${3:retval2},${4:retval3},${5:...},${6:retval64} = ultraschall.ReturnTableAsIndividualValues(${7:table Table})$0"
    },
    "ULTRASCHALL.TYPE_WR lua": {
        "prefix": "ultraschallwr.type",
        "scope": "lua",
        "description": "Returns the type of the object.\nSupported types are Lua's own datatypes as well as Reaper's own datatypes.\nDue API-limitations, SWS-specific datatypes are not supported in this function!\nPARAMETERS:\nobject:the object, whose type you want to know\nRETURNS:\ntype_of_object:the type of the object; the following are valid:\nisnumber:true, if object is a number(either integer or number)\n",
        "body": "${1:local }${2:string type_of_object},${3:optional boolean isnumber} = ultraschall.type(${4:identifier object})$0"
    },
    "ULTRASCHALL.CONCATINTEGERINDEXEDTABLES_WR lua": {
        "prefix": "ultraschallwr.ConcatIntegerIndexedTables",
        "scope": "lua",
        "description": "Concatenates the entries of two tables into one table. The entries of each table must be indexed by integers\nThe new table still has the same references as the old table, means: if you remove the old tables/entries in the old tables, the concatenated table/accompanying entries will loose elements.\nTo get a \"true\"-concatenated copy, you should first create new copies of the tables, using MakeCopyOfTable.\nPARAMETERS:\ntable1:the first table to be concatenated; the entries must be indexed by integer-numbers!\ntable2:the second table to be concatenated; the entries must be indexed by integer-numbers!\nRETURNS:\nnumentries:the number of entries in the new table\nconcatenated_table:the new concatenated table\n",
        "body": "${1:local }${2:integer numentries},${3:array concatenated_table} = ultraschall.ConcatIntegerIndexedTables(${4:array table1},${5:array table2})$0"
    },
    "ULTRASCHALL.REVERSETABLE_WR lua": {
        "prefix": "ultraschallwr.ReverseTable",
        "scope": "lua",
        "description": "reversed the order of the entries of a table, means, the last entry will become the first, the first become the last, etc.\nThe table must be indexed by integers.\nReturns nil if table isn't a valid table\nRETURNS:\nreversed_table:the resulting table with the reversed order of all entries\nentry_count:the number of entries in the reversed_table\n",
        "body": "${1:local }${2:table reversed_table},${3:integer entry_count} = ultraschall.ReverseTable(${4:table the_table})$0"
    },
    "ULTRASCHALL.GETDUPLICATESFROMARRAYS_WR lua": {
        "prefix": "ultraschallwr.GetDuplicatesFromArrays",
        "scope": "lua",
        "description": "Returns the duplicates and the originals(entries only in one of the arrays) of two arrays. It will also return the number of entries.\nThis works only on arrays with integer-indexed entries; index must start with index 1!\nreturns -1 in case of an error\nPARAMETERS:\narray1:the first array to check for duplicates and \"original\"-entries\narray2:the second array to check for duplicates and \"original\"-entries\nRETURNS:\nduplicate_count:the number of entries in both arrays\nduplicate_array:the entries in both arrays\noriginalscount_array1:the number of entries only in array1\noriginals_array1:the entries that are only existing in array1\noriginalscount_array2:the number of entries only in array2\narray originals_array2:the entries that are only existing in array2\n",
        "body": "${1:local }${2:integer duplicate_count},${3:array duplicate_array},${4:integer originalscount_array1},${5:array originals_array1},${6:integer originalscount_array2},${7:array originals_array2} = ultraschall.GetDuplicatesFromArrays(${8:array array1},${9:array array2})$0"
    },
    "ULTRASCHALL.GETSCRIPTFILENAMEFROMACTIONCOMMANDID_WR lua": {
        "prefix": "ultraschallwr.GetScriptFilenameFromActionCommandID",
        "scope": "lua",
        "description": "returns the filename with path of a script, associated to a ReaScript.\nCommand-ID-numbers do not work!\nreturns false in case of an error\nRETURNS:\nscriptfilename_with_path:the scriptfilename with path associated with this ActionCommandID\n",
        "body": "${1:local }${2:string scriptfilename_with_path} = ultraschall.GetScriptFilenameFromActionCommandID(${3:string action_command_id})$0"
    },
    "ULTRASCHALL.COMBINEBYTESTOINTEGER_WR lua": {
        "prefix": "ultraschallwr.CombineBytesToInteger",
        "scope": "lua",
        "description": "Combines the Byte-values Byte_1 to Byte_n into one integer.\nThat means, if you give 4 values, it will return a 32bit-integer(4*8Bits).\nNegative values will use the maximum possible value of that byte minus the bits.\nIn Byte_1, -2 will be 255-1=254, in Byte 2, -2 will be 65280-256=65024.\nUse bitoffset to define, from which bit on you want to combine the values.\nReturns -1 in case of an error\nPARAMETERS:\nbitoffset:if you want to start combining the values from a certain bitoffset-onwards, set the offset here; use 0 to start with the first bit.\nByte_1:a bytevalue that you want to combine into one\nByte_2:a bytevalue that you want to combine into one\n:a bytevalue that you want to combine into one\nByte_n:a bytevalue that you want to combine into one\nRETURNS:\nretval:the combined integer\n",
        "body": "${1:local }${2:integer retval} = ultraschall.CombineBytesToInteger(${3:integer bitoffset},${4:integer Byte_1},${5:optional Byte_2},${6:...},${7:optional Byte_n})$0"
    },
    "ULTRASCHALL.SPLITINTEGERINTOBYTES_WR lua": {
        "prefix": "ultraschallwr.SplitIntegerIntoBytes",
        "scope": "lua",
        "description": "Splits a 32-bit-integer-value into four bytes.\nReturns -1 in case of an error\nRETURNS:\nByte1:the first eight bits of the integer-value as a Byte\nByte2:the second eight bits of the integer-value as a Byte\nByte3:the third eight bits of the integer-value as a Byte\nByte4:the fourth eight bits of the integer-value as a Byte\n",
        "body": "${1:local }${2:integer Byte1},${3:integer Byte2},${4:integer Byte3},${5:integer Byte4} = ultraschall.SplitIntegerIntoBytes(${6:integer integervalue})$0"
    },
    "ULTRASCHALL.GETREAPERSCRIPTPATH_WR lua": {
        "prefix": "ultraschallwr.GetReaperScriptPath",
        "scope": "lua",
        "description": "Returns path to Reaper's script-folder\nRETURNS:\nreaper_script_path:the path of the scripts-folder of Reaper\n",
        "body": "${1:local }${2:string reaper_script_path} = ultraschall.GetReaperScriptPath()$0"
    },
    "ULTRASCHALL.GETREAPERCOLORTHEMESPATH_WR lua": {
        "prefix": "ultraschallwr.GetReaperColorThemesPath",
        "scope": "lua",
        "description": "Returns path to Reaper's color-theme-folder\nRETURNS:\nreaper_colorthemes_path:the path of the color-theme-folder of Reaper\n",
        "body": "${1:local }${2:string reaper_colorthemes_path} = ultraschall.GetReaperColorThemesPath()$0"
    },
    "ULTRASCHALL.GETREAPERJSFXPATH_WR lua": {
        "prefix": "ultraschallwr.GetReaperJSFXPath",
        "scope": "lua",
        "description": "Returns path to Reaper's JSFX-plugin-folder\nRETURNS:\nreaper_jsfx_path:the path of the JSFX-plugin-folder of Reaper\n",
        "body": "${1:local }${2:string reaper_jsfx_path} = ultraschall.GetReaperJSFXPath()$0"
    },
    "ULTRASCHALL.GETREAPERWEBRCPATH_WR lua": {
        "prefix": "ultraschallwr.GetReaperWebRCPath",
        "scope": "lua",
        "description": "Returns path to the Web-RC-folder for Reaper as well as for the user-webrc-pages.\n",
        "body": "${1:local }${2:string reaper_webrc_path},${3:string user_webrc_path} = ultraschall.GetReaperWebRCPath()$0"
    },
    "ULTRASCHALL.CYCLETABLE_WR lua": {
        "prefix": "ultraschallwr.CycleTable",
        "scope": "lua",
        "description": "Cycles the entries by offset. Offset can be positive(cycle forward) or negative(cycle negative). The number also tells the function, by how many entries the table shall be cycled, with 1 for one entry, 2 for 2 entries, etc.\nEntries \"falling out\" of one side(top or bottom) of the table will be readded on the other side.\nreturns nil in case of error\nPARAMETERS:\nthe_table:the table to cycle through\noffset:the offset, by which to cycle the entries through; positive, cycle entries forward; negative, cycle entries backward\nRETURNS:\nnew_table:the altered table\n",
        "body": "${1:local }${2:table new_table} = ultraschall.CycleTable(${3:table the_table},${4:integer offset})$0"
    },
    "ULTRASCHALL.SPLITSTRINGATNULLBYTES_WR lua": {
        "prefix": "ultraschallwr.SplitStringAtNULLBytes",
        "scope": "lua",
        "description": "Splits splitstring into individual string at NULL-Bytes.\nreturns -1 in case of an error\nPARAMETERS:\nsplitstring:the string with NULL-Bytes(\\0) into it, that you want to split\nRETURNS:\ncount:the number of found strings\nsplit_strings:the found strings put into an array\n",
        "body": "${1:local }${2:integer count},${3:array split_strings} = ultraschall.SplitStringAtNULLBytes(${4:string splitstring})$0"
    },
    "ULTRASCHALL.MAIN_ONCOMMANDBYFILENAME_WR lua": {
        "prefix": "ultraschallwr.Main_OnCommandByFilename",
        "scope": "lua",
        "description": "Runs a command by a filename. It internally registers the file temporarily as command, runs it and unregisters it again.\nThis is especially helpful, when you want to run a command for sure without possible command-id-number-problems.\nIt returns a unique script-identifier for this script, which can be used to communicate with this script-instance.\nThe started script gets its script-identifier using GetScriptIdentifier.\nYou can use this script-identifier e.g. as extstate.\nReturns false in case of an error\nPARAMETERS:\nfilename:the name and path of the scriptfile to run\n...:parameters that shall be passed over to the script\nRETURNS:\nretval:true, if running it was successful; false, if not\nscript_identifier:a unique script-identifier, which can be used as extstate to communicate with the started scriptinstance\n",
        "body": "${1:local }${2:boolean retval},${3:string script_identifier} = ultraschall.Main_OnCommandByFilename(${4:string filename},${5:string ...})$0"
    },
    "ULTRASCHALL.MIDI_ONCOMMANDBYFILENAME_WR lua": {
        "prefix": "ultraschallwr.MIDI_OnCommandByFilename",
        "scope": "lua",
        "description": "Runs a command by a filename in the MIDI-editor-context. It internally registers the file temporarily as command, runs it and unregisters it again.\nThis is especially helpful, when you want to run a command for sure without possible command-id-number-problems.\nIt returns a unique script-identifier for this script, which can be used to communicate with this script-instance.\nThe started script gets its script-identifier using GetScriptIdentifier.\nYou can use this script-identifier e.g. as extstate.\nReturns false in case of an error\nPARAMETERS:\nfilename:the name plus path of the scriptfile to run\nMidi_EditorHWND:the window-handler of the MIDI-editor, in which to run the script; nil, for the last active MIDI-editor\n...:parameters, that shall be passed over to the script\nRETURNS:\nretval:true, if running it was successful; false, if not\nscript_identifier:a unique script-identifier, which can be used as extstate to communicate with the started scriptinstance\n",
        "body": "${1:local }${2:boolean retval},${3:string script_identifier} = ultraschall.MIDI_OnCommandByFilename(${4:string filename},${5:optional HWND Midi_EditorHWND},${6:string ...})$0"
    },
    "ULTRASCHALL.GETSCRIPTPARAMETERS_WR lua": {
        "prefix": "ultraschallwr.GetScriptParameters",
        "scope": "lua",
        "description": "Gets the parameters stored for a specific script_identifier.\nreturns -1 in case of an error\nPARAMETERS:\nscript_identifier:the script-identifier, whose parameters you want to retrieve; \nremove:true or nil, remove the stored parameter-extstates; false, keep them for later retrieval\nRETURNS:\nnum_params:the number of parameters available\nparams:the values of the parameters as an array\ncaller_script_identifier:the scriptidentifier of the script, that set the parameters\n",
        "body": "${1:local }${2:integer num_params},${3:array params},${4:string caller_script_identifier} = ultraschall.GetScriptParameters(${5:optional string script_identifier},${6:optional boolean remove})$0"
    },
    "ULTRASCHALL.SETSCRIPTPARAMETERS_WR lua": {
        "prefix": "ultraschallwr.SetScriptParameters",
        "scope": "lua",
        "description": "Sets the parameters stored for a specific script_identifier.\nPARAMETERS:\nscript_identifier:the script-identifier, whose parameters you want to retrieve; \n...:the parameters you want to set; there can be more than one, but they must be strings\nRETURNS:\nretval:true, storing was successful\nscript_identifier:the script_identifier, whose parameters have been set\n",
        "body": "${1:local }${2:boolean retval},${3:string script_identifier} = ultraschall.SetScriptParameters(${4:string script_identifier},${5:string ...})$0"
    },
    "ULTRASCHALL.GETSCRIPTRETURNVALUES_WR lua": {
        "prefix": "ultraschallwr.GetScriptReturnvalues",
        "scope": "lua",
        "description": "Gets the return-values which a specific sender\\_script\\_identifier sent to the current script.\nIf you have started numerous child-scripts and want to know, which child-script sent you return-values, see GetScriptReturnvalues_Sender\nreturns -1 in case of an error\nPARAMETERS:\nsender_script_identifier:the script-identifier, that sent the return-values to your script\nremove:true or nil, remove the stored retval-extstates; false, keep them for later retrieval\nRETURNS:\nretvals:the number of return-values available\n",
        "body": "${1:local }${2:integer num_params},${3:array retvals} = ultraschall.GetScriptReturnvalues(${4:string sender_script_identifier},${5:optional boolean remove})$0"
    },
    "ULTRASCHALL.SETSCRIPTRETURNVALUES_WR lua": {
        "prefix": "ultraschallwr.SetScriptReturnvalues",
        "scope": "lua",
        "description": "Send return-values back to the script, that has a specific script_identifier.\nreturns false in case of an error\nPARAMETERS:\nscript_identifier:the script-identifier of the script-instance, to where you want to send the returnvalues \n...:the returnvalues you want to set; there can be more than one, but they must be strings\nRETURNS:\nretval:true, storing was successful; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetScriptReturnvalues(${3:string script_identifier},${4:string ...})$0"
    },
    "ULTRASCHALL.GETSCRIPTRETURNVALUES_SENDER_WR lua": {
        "prefix": "ultraschallwr.GetScriptReturnvalues_Sender",
        "scope": "lua",
        "description": "Retrieves, which scripts sent returnvalues to the current script.\nRETURNS:\ncount:the number of scripts, who have left returnvalues for the current script\nretval_sender:the ScriptIdentifier of the scripts, who returned values\n",
        "body": "${1:local }${2:integer count},${3:array retval_sender} = ultraschall.GetScriptReturnvalues_Sender()$0"
    },
    "ULTRASCHALL.BASE64_ENCODER_WR lua": {
        "prefix": "ultraschallwr.Base64_Encoder",
        "scope": "lua",
        "description": "Converts a string into a Base64-Encoded string.\nCurrently, only standard Base64-encoding is supported.\nReturns nil in case of an error\nPARAMETERS:\nsource_string:the string that you want to convert into Base64\nbase64_type:the Base64-decoding-style\nremove_newlines:1, removes \\n-newlines(including \\r-carriage return) from the string\nremove_tabs:1, removes \\t-tabs from the string\nRETURNS:\nencoded_string:the encoded string\n",
        "body": "${1:local }${2:string encoded_string} = ultraschall.Base64_Encoder(${3:string source_string},${4:optional integer base64_type},${5:optional integer remove_newlines},${6:optional integer remove_tabs})$0"
    },
    "ULTRASCHALL.BASE64_DECODER_WR lua": {
        "prefix": "ultraschallwr.Base64_Decoder",
        "scope": "lua",
        "description": "Converts a Base64-encoded string into a normal string.\nCurrently, only standard Base64-encoding is supported.\nReturns nil in case of an error\nPARAMETERS:\nsource_string:the Base64-encoded string\nbase64_type:the Base64-decoding-style\nRETURNS:\ndecoded_string:the decoded string\n",
        "body": "${1:local }${2:string decoded_string} = ultraschall.Base64_Decoder(${3:string source_string},${4:optional integer base64_type})$0"
    },
    "ULTRASCHALL.STATECHUNKLAYOUTER_WR lua": {
        "prefix": "ultraschallwr.StateChunkLayouter",
        "scope": "lua",
        "description": "Layouts StateChunks as returned by GetTrackStateChunk or GetItemStateChunk into a format that resembles the formatting-rules of an rpp-file.\nThis is very helpful, when parsing such a statechunk, as you can now use the number of spaces used for intendation as help parsing.\nUsually, every new element, that starts with < will be followed by none or more lines, that have two spaces added in the beginning.\nExample of a MediaItemStateChunk(I use . to display the needed spaces in the beginning of each line):\n<ITEM\n..POSITION 6.96537864205337\n..SNAPOFFS 0\n..LENGTH 1745.2745\n..LOOP 0\n..ALLTAKES 0\n..FADEIN 1 0.01 0 1 0 0\n..FADEOUT 1 0.01 0 1 0 0\n..MUTE 0\n..SEL 1\n..IGUID {020E6372-97E6-4066-9010-B044F67F2772}\n..IID 1\n..NAME myaudio.flac\n..VOLPAN 1 0 1 -1\n..SOFFS 0\n..PLAYRATE 1 1 0 -1 0 0.0025\n..CHANMODE 0\n..GUID {79F087CE-49E8-4212-91F5-8487FBCF10B1}\n..<SOURCE FLAC\n....FILE \"C:\\Users\\meo\\Desktop\\X_Karo_Lynn-Interview.flac\"\n..>\n>\nThis function will not check, if you've passed a valid statechunk!\nreturns nil in case of an error\nPARAMETERS:\nstatechunk:a statechunk, that you want to layout properly\nRETURNS:\nlayouted_statechunk:the statechunk, that is now layouted to the rules of rpp-projectfiles\n",
        "body": "${1:local }${2:string layouted_statechunk} = ultraschall.StateChunkLayouter(${3:string statechunk})$0"
    },
    "ULTRASCHALL.REVERSEENDIANESS_BYTE_WR lua": {
        "prefix": "ultraschallwr.ReverseEndianess_Byte",
        "scope": "lua",
        "description": "reverses the endianess of a byte and returns this as value.\nThe parameter byte must be between 0 and 255!\nreturns nil in case of an error\nPARAMETERS:\nbyte:the integer whose endianess you want to reverse\nRETURNS:\nnewbyte:the endianess-reversed byte\n",
        "body": "${1:local }${2:integer newbyte} = ultraschall.ReverseEndianess_Byte(${3:integer byte})$0"
    },
    "ULTRASCHALL.CONVERTINTEGERTOBITS_WR lua": {
        "prefix": "ultraschallwr.ConvertIntegerToBits",
        "scope": "lua",
        "description": "converts an integer-value(up to 64 bits) into it's individual bits and returns it as comma-separated csv-string as well as a table with 64 entries.\nreturns nil in case of an error\nPARAMETERS:\ninteger:the integer-number to separated into it's individual bits\nRETURNS:\nbitvals_csv:a comma-separated csv-string of all bitvalues, with bit 1 coming first and bit 32 coming last\nbitvalues:a 64-entry table, where each entry contains the bit-value of integer; first entry for bit 1, 64th entry for bit 64\n",
        "body": "${1:local }${2:string bitvals_csv},${3:table bitvalues} = ultraschall.ConvertIntegerToBits(${4:integer integer})$0"
    },
    "ULTRASCHALL.CONVERTBITSTOINTEGER_WR lua": {
        "prefix": "ultraschallwr.ConvertBitsToInteger",
        "scope": "lua",
        "description": "converts a table with all bitvalues into it's integer-representation.\neach table-entry holds either a 1 or a 0;\nwith index 1 being the first (for 1),\nindex 2 for the second (for 2),\nindex 3 for the third (for 4),\nindex 4 for the fourth(for 8), etc\nreturns nil in case of an error\nPARAMETERS:\nbitvalues:a table, where each entry contains the bit-value of integer; first entry for bit 1, 64th entry for bit 64, etc\n",
        "body": "${1:local }${2:integer integervalue} = ultraschall.ConvertBitsToInteger(${3:table bitvalues})$0"
    },
    "ULTRASCHALL.GETSETINTCONFIGVAR_WR lua": {
        "prefix": "ultraschallwr.GetSetIntConfigVar",
        "scope": "lua",
        "description": "Gets/Sets an integer-bitfield of an integer-configvariable.\nPass to it a varname, if it shall be set or gotten from and up to 32 parameters who specify, if that bit shall be set(true) or not(false) or the currently set value shall be used(nil)\nSee Reaper_Config_Variables.html for more details on config-variables in Reaper.\nreturns false in case of an error\nPARAMETERS:\nvarname:the name of the config-variable\nset:true, set this config-var; false, don't set it\nbit1:true, set this bit; false, don't set this bit; nil, use the currently set value\n:true, set this bit; false, don't set this bit; nil, use the currently set value\nbit32:true, set this bit; false, don't set this bit; nil, use the currently set value\nRETURNS:\nretval:true, getting/setting the config-var was successful; false, it wasn't successful\nconfig_var_value:the new/current value of the configuration-variable\n",
        "body": "${1:local }${2:boolean retval},${3:integer config_var_value} = ultraschall.GetSetIntConfigVar(${4:string varname},${5:boolean set},${6:optional boolean bit1},${7:...},${8:optional boolean bit32})$0"
    },
    "ULTRASCHALL.GETSCRIPTIDENTIFIER_WR lua": {
        "prefix": "ultraschallwr.GetScriptIdentifier",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nThe identifier is of the format \"ScriptIdentifier:scriptfilename-{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}.ext\", where the {}-part is a guid and ext either .lua .py or .eel\nDefer1](#Defer1) to [Defer20 make use of this to stop a running defer-loop from the outside of a deferred-script.\nRETURNS:\nscript_identifier:a unique script-identifier for this script-instance, of the format:\n",
        "body": "${1:local }${2:string script_identifier} = ultraschall.GetScriptIdentifier()$0"
    },
    "ULTRASCHALL.REPLACEPARTOFSTRING_WR lua": {
        "prefix": "ultraschallwr.ReplacePartOfString",
        "scope": "lua",
        "description": "replaces a part of a string with a second string\nReturns nil in case of an error\nPARAMETERS:\noriginalstring:the originalstring, in which you want to insert the string\ninsertstring:the string that shall be inserted\noffset:the position, at which to insert the string; it is the position BEFORE the position at which to insert, so if you want to replace the 25th character, offset is 24!\nlength:the length of the part of the originalstring that shall be replaced, counted from offset. 0 or nil for simple insertion.\nRETURNS:\nreplaced_string:the altered string\n",
        "body": "${1:local }${2:string replaced_string} = ultraschall.ReplacePartOfString(${3:string originalstring},${4:string insertstring},${5:integer offset},${6:optional integer length})$0"
    },
    "ULTRASCHALL.SEARCHSTRINGINSTRING_WR lua": {
        "prefix": "ultraschallwr.SearchStringInString",
        "scope": "lua",
        "description": "Searches for the string searchstring in fullstring.\nKeep in mind: Umlauts may produce multibyte-values. Therefore, the returned offsets might be confusing.\nreturns -1 in case of error, 0 if string wasn't found\nPARAMETERS:\nfullstring:the string to be searched through\nsearchstring:the string to search for within fullstring\nRETURNS:\ncount:the number of found occurences of searchstring in fullstring\nposarray:an array that contains the positions, where searchstring was found within fullstring\n",
        "body": "${1:local }${2:integer count},${3:array posarray} = ultraschall.SearchStringInString(${4:string fullstring},${5:string searchstring})$0"
    },
    "ULTRASCHALL.MKVOL2DB_WR lua": {
        "prefix": "ultraschallwr.MKVOL2DB",
        "scope": "lua",
        "description": "Converts an MKVOL-value into a dB-value.\nMKVOL-values are used by the routing-functions for HWOut/AUXSendReceive, specifically for their volume-value as these can't be converted using Reaper's own DB2SLIDER or SLIDER2DB, so this function should help you.\nThis function is an adapted one from the function provided in Plugins/reaper\\_www\\_root/main.js\nSee DB2MKVOL to convert a dB-value into it's MKVOL-representation\nreturns nil in case of an error\nPARAMETERS:\nmkvol_value:the mkvol_value, that you want to convert into dB\nRETURNS:\ndb_value:the dB-value, converted from the MKVOL-value; minimum -144dB\n",
        "body": "${1:local }${2:number db_value} = ultraschall.MKVOL2DB(${3:number mkvol_value})$0"
    },
    "ULTRASCHALL.DB2MKVOL_WR lua": {
        "prefix": "ultraschallwr.DB2MKVOL",
        "scope": "lua",
        "description": "Converts an dB-value into a MKVOL-value.\nMKVOL-values are used by the routing-functions for HWOut/AUXSendReceive, specifically for their volume-value as these can't be converted using Reaper's own DB2SLIDER or SLIDER2DB, so this function should help you.\nSee MKVOL2DB to convert a MKVOL-value into it's dB-representation\nreturns nil in case of an error\nPARAMETERS:\ndb_value:the dB-value, that you want to convert into the MKVOL-value; minimum is -144dB\nRETURNS:\nmkvol_value:the mkvol-value, converted from the dB-value\n",
        "body": "${1:local }${2:number mkvol_value} = ultraschall.DB2MKVOL(${3:number db_value})$0"
    },
    "ULTRASCHALL.CONVERTINTEGERINTOSTRING2_WR lua": {
        "prefix": "ultraschallwr.ConvertIntegerIntoString2",
        "scope": "lua",
        "description": "Splits numerous integers into its individual bytes and converts them into a string-representation.\nMaximum 32bit-integers are supported.\nReturns nil in case of an error.\nPARAMETERS:\nSize:the maximum size of the integer to convert, 1(8 bit) to 4(32 bit)\nintegervalue_1:the first integer value to convert from\n:the last integer value to convert from\nintegervalue_n:the last integer value to convert from\nRETURNS:\nconverted_value:the string-representation of the integer\n",
        "body": "${1:local }${2:string converted_value} = ultraschall.ConvertIntegerIntoString2(${3:integer Size},${4:integer integervalue_1},${5:...},${6:integer integervalue_n})$0"
    },
    "ULTRASCHALL.CONVERTSTRINGTOINTEGERS_WR lua": {
        "prefix": "ultraschallwr.ConvertStringToIntegers",
        "scope": "lua",
        "description": "Converts a string into its integer-representation. Allows you to set the size of the integers between 1 Byte and 8 Bytes(64 bits).\nReturns -1 in case of an error.\nPARAMETERS:\nString:the string to convert into its integer representation\nSize:the size of the integers. 1 for 8 bits, 2 for 16 bits, ..., 8 for 64 bits\nRETURNS:\nnum_integers:the number of integers converted from this string\nindividual_integers:the individual integers, as converted from the original string\n",
        "body": "${1:local }${2:integer num_integers},${3:array individual_integers} = ultraschall.ConvertStringToIntegers(${4:string String},${5:integer Size})$0"
    },
    "ULTRASCHALL.SETSCRIPTIDENTIFIER_DESCRIPTION_WR lua": {
        "prefix": "ultraschallwr.SetScriptIdentifier_Description",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can set its description, that is less cryptic than the ScriptIdentifier itself.\nYou can get it using GetScriptIdentifier_Description.\nreturns -1 in case of an error\nPARAMETERS:\ndescription:the new description of your script\nRETURNS:\nretval:-1 in case of an error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetScriptIdentifier_Description(${3:string description})$0"
    },
    "ULTRASCHALL.GETSCRIPTIDENTIFIER_DESCRIPTION_WR lua": {
        "prefix": "ultraschallwr.GetScriptIdentifier_Description",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can get its description, that is less cryptic than the ScriptIdentifier itself.\nYou can set it using SetScriptIdentifier_Description.\nRETURNS:\nscript_identifier_description:the description of your script\n",
        "body": "${1:local }${2:string script_identifier_description} = ultraschall.GetScriptIdentifier_Description()$0"
    },
    "ULTRASCHALL.SETSCRIPTIDENTIFIER_TITLE_WR lua": {
        "prefix": "ultraschallwr.SetScriptIdentifier_Title",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can set its title, that is less cryptic than the ScriptIdentifier itself.\nNo \\n-newlines, \\r-carriag returns or \\0-nullbytes are allowed and will be removed\nYou can get it using GetScriptIdentifier_Title.\nreturns -1 in case of an error\nPARAMETERS:\ntitle:the new title of your script\nRETURNS:\nretval:-1 in case of an error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetScriptIdentifier_Title(${3:string title})$0"
    },
    "ULTRASCHALL.GETSCRIPTIDENTIFIER_TITLE_WR lua": {
        "prefix": "ultraschallwr.GetScriptIdentifier_Title",
        "scope": "lua",
        "description": "The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.\nThis identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance\nits own script-identifier, so you can be sure, that you communicate with the right instance.\nWith this function, you can get its description, that is less cryptic than the ScriptIdentifier itself.\nDefault is the script's filename.\nYou can set it using SetScriptIdentifier_Title.\nRETURNS:\nscript_identifier_title:the title of your script; default is the filename of the script\n",
        "body": "${1:local }${2:string script_identifier_title} = ultraschall.GetScriptIdentifier_Title()$0"
    },
    "ULTRASCHALL.PRINTPROGRESSBAR_WR lua": {
        "prefix": "ultraschallwr.PrintProgressBar",
        "scope": "lua",
        "description": "Calculate a simple progressbar, which can be optionally displayed in the ReaScript console; Will clear the console before displaying the next updated progressbar.\nWill update it only, if the current-value of last time this function got called is different from the current one or toptext or bottomtext changed.\nYou can also use the returnvalues to draw your own progressbar, e.g. in a gfx.init-window\nIf you need to calculate a new progressbar, after the former got to 100%, it is wise to call ResetProgressBar, or it might not update the first time you call this function.\nReturns false in case of an error\nPARAMETERS:\nshow:true, show progressbar in the ReaScript-console; false, don't show it there\nlength:the length of the progressbar in characters. Minimum is 10.\nmaximumvalue:the maximum integer-value, to which to count; minimum 1\ncurrentvalue:the current integer-value, at which we are with counting, minimum 0\npercentage:true, show percentage in progressbar; false, show only progressbar\noffset:an offset to be added before the progressbar, so you can indent it\ntoptext:an optional string, that shall be displayed above the progressbar\nbottomtext:an optional string, that shall be displayed below the progressbar\nRETURNS:\nretval:true, displaying was successful; false, displaying wasn't successful\nProgressString:the progressbar including its full statuses and layout\npercentage:the progression of the progressbar in percent\nprogress_position:the current progress-position, relative to length and maximumvalue\n",
        "body": "${1:local }${2:boolean retval},${3:string ProgressString},${4:integer percentage},${5:integer progress_position} = ultraschall.PrintProgressBar(${6:boolean show},${7:integer length},${8:integer maximumvalue},${9:integer currentvalue},${10:boolean percentage},${11:integer offset},${12:optional string toptext},${13:optional string bottomtext})$0"
    },
    "ULTRASCHALL.STOREFUNCTIONINEXTSTATE_WR lua": {
        "prefix": "ultraschallwr.StoreFunctionInExtState",
        "scope": "lua",
        "description": "Stores a function into an extstate. You can store it's debug-information as well.\nTo load the function again, use LoadFunctionFromExtState\nReturns false in case of an error\nPARAMETERS:\nsection:the sectionname of the extstate\nkey:the keyname of the extstate\nfunc:the function, that you want to store\ndebug:true, store debug-values as well; false, don't store the debug-values as well\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.StoreFunctionInExtState(${3:string section},${4:string key},${5:function func},${6:boolean debug})$0"
    },
    "ULTRASCHALL.LOADFUNCTIONFROMEXTSTATE_WR lua": {
        "prefix": "ultraschallwr.LoadFunctionFromExtState",
        "scope": "lua",
        "description": "Loads a function from an extstate, if it has been stored in there before.\nThe extstate must contain a valid function. If something else is stored, the loaded \"function\" might crash Lua!\nTo store the function, use StoreFunctionInExtState\nReturns false in case of an error\nPARAMETERS:\nsection:the sectionname of the extstate\nkey:the keyname of the extstate\nRETURNS:\nfunction:the stored function, that you want to (re-)load\n",
        "body": "${1:local }${2:function function} = ultraschall.LoadFunctionFromExtState(${3:string section},${4:string key})$0"
    },
    "ULTRASCHALL.CONVERTHEX2ASCII_WR lua": {
        "prefix": "ultraschallwr.ConvertHex2Ascii",
        "scope": "lua",
        "description": "converts a hexstring into an ascii-string.\nWill combine two hexvalues into one byte, until the whole string is converted.\nSee ConvertAscii2Hex to convert a string into its HEX-representation.\nReturns nil in case of an error\nPARAMETERS:\nhexstring:the original string with only hexadecimal numbers \nRETURNS:\nascii_string:the converted string\n",
        "body": "${1:local }${2:string ascii_string} = ultraschall.ConvertHex2Ascii(${3:string hexstring})$0"
    },
    "ULTRASCHALL.CONVERTASCII2HEX_WR lua": {
        "prefix": "ultraschallwr.ConvertAscii2Hex",
        "scope": "lua",
        "description": "converts an ascii-string into a hexstring.\nSee ConvertHex2Ascii to convert a HEX-string into its normal string-representation.\nReturns nil in case of an error\nPARAMETERS:\nascii_string:the converted string\nRETURNS:\nhexstring:the original string with only hexadecimal numbers \n",
        "body": "${1:local }${2:string hexstring} = ultraschall.ConvertAscii2Hex(${3:string ascii_string})$0"
    },
    "ULTRASCHALL.GETALLACTIONS_WR lua": {
        "prefix": "ultraschallwr.GetAllActions",
        "scope": "lua",
        "description": "Returns all actions and accompanying attributes from a specific section as a handy table\nThe table is of the following format:\nactiontable[index][\"commandid\"]       - the command-id-number of the action\nactiontable[index][\"actioncommandid\"] - the action-command-id-string of the action, if it's a named command(usually scripts or extensions), otherwise empty string\nactiontable[index][\"name\"]            - the name of command\nactiontable[index][\"scriptfilename\"]  - the filename+path of a command, that is a ReaScript, otherwise empty string\nactiontable[index][\"termination\"]     - the termination-state of the action\n-1  - not available\n4   - Dialogwindow appears(Terminate, New Instance, Abort), if another instance of a given script is started, that's already running\n260 - always Terminate All(!) Instances, if you try to run another instance of a script, that's already running. When no instance is running, it simply starts the script.\n516 - always start a New Instance of the script, that's already running\nactiontable[index][\"consolidate\"]     - the consolidate-state of custom actions; 1 consolidate undo points, 2 show in Actions-Menu, 3 consolidate undo points AND show in Actions Menu; -1, if not available\nactiontable[index][\"actiontype\"]      - the type of the action; \"native action\", \"extension action\", \"custom action\", \"script\"\nreturns -1 in case of an error.\nPARAMETERS:\nsection:the section, whose actions you want to retrieve\nRETURNS:\nnumber_of_actions:the number of actions found; -1 in case of an error\nactiontable:a table, which holds all attributes of an action(see description for more details)\n",
        "body": "${1:local }${2:integer number_of_actions},${3:table actiontable} = ultraschall.GetAllActions(${4:integer section})$0"
    },
    "ULTRASCHALL.ISWITHINTIMERANGE_WR lua": {
        "prefix": "ultraschallwr.IsWithinTimeRange",
        "scope": "lua",
        "description": "returns if time is between(including) start and stop.\nreturns false in case of an error\nPARAMETERS:\ntime:the time in seconds, to check for\nstart:the starttime in seconds, within to check for\nstop:the endtime in seconds, within to check for\nRETURNS:\nretval:true, time is between start and stop; false, it isn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsWithinTimeRange(${3:number time},${4:number start},${5:number stop})$0"
    },
    "ULTRASCHALL.MEDIAEXPLORER_ONCOMMAND_WR lua": {
        "prefix": "ultraschallwr.MediaExplorer_OnCommand",
        "scope": "lua",
        "description": "runs a Media Explorer-associated action.\nNote: Can only run Reaper's native actions currently(all actions having a number as actioncommandid), not scripts!\nreturns false if Media Explorer is closed\nRETURNS:\nretval:true, could update run the action in the Media Explorer; false, couldn't run it\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MediaExplorer_OnCommand(${3:integer actioncommandid})$0"
    },
    "ULTRASCHALL.UPDATEMEDIAEXPLORER_WR lua": {
        "prefix": "ultraschallwr.UpdateMediaExplorer",
        "scope": "lua",
        "description": "updates the listview of the Media Explorer.\nreturns false if Media Explorer is closed\nRETURNS:\nretval:true, could update the listview of the Media Explorer; false, couldn't update the listview\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.UpdateMediaExplorer()$0"
    },
    "ULTRASCHALL.FINDPATTERNSINSTRING_WR lua": {
        "prefix": "ultraschallwr.FindPatternsInString",
        "scope": "lua",
        "description": "Finds all occurrences of matching-patterns in a string. You can sort them optionally.\nreturns -1 in case of an error\nPARAMETERS:\nSourceString:the source-string to search for all occurences\npattern:the matching-pattern, with which to search for in the string\nsort_after_finding:true, sorts the entries; false, doesn't sort the entries\nRETURNS:\ncount_found_items:the number of found items in the string; -1, in case of an error\nfound_items:all occurrences found in the string as an array\n",
        "body": "${1:local }${2:integer count_found_items},${3:array found_items} = ultraschall.FindPatternsInString(${4:string SourceString},${5:string pattern},${6:boolean sort_after_finding})$0"
    },
    "ULTRASCHALL.RUNLUASOURCECODE_WR lua": {
        "prefix": "ultraschallwr.RunLuaSourceCode",
        "scope": "lua",
        "description": "runs the Lua-code stored in the parameter code\nDoes not check for validity and syntaxerrors in the code!\nYou can also add new callable functions that way. Just put function-declarations in the parameter code.\nFor instance from the following code:\ncode=function main()\nreaper.MB(\"I'm only run, when my parent function main is called\", \"\", 0)\nend\nreaper.MB(\"I'm run immediately\", \"\", 0)\"\nwhen called by\nultraschall.RunLuaSourceCode(code)\nonly the line reaper.MB(\"I'm run immediately\", \"\", 0) will be run immediately.\nIf you want to run the function main as well, you need to explicitly call it with main()\nreturns false in case of an error; nil, in case of an syntax/lua-error in the code itself\nPARAMETERS:\ncode:the code, that you want to execute; you can also add new functions that way\nRETURNS:\nretval:true, code was run successfully; false, code wasn't successfully; nil, code had an error in it, probably syntax error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.RunLuaSourceCode(${3:string code})$0"
    },
    "ULTRASCHALL.MAIN_ONCOMMAND_LUACODE_WR lua": {
        "prefix": "ultraschallwr.Main_OnCommand_LuaCode",
        "scope": "lua",
        "description": "Runs LuaCode as new temporary script-instance. It internally registers the code as a file temporarily as command, runs it and unregisters it again.\nThis is especially helpful, when you want to run a command for sure without possible command-id-number-problems.\nIt returns a unique script-identifier for this script, which can be used to communicate with this script-instance.\nThe started script gets its script-identifier using GetScriptIdentifier.\nYou can use this script-identifier e.g. as extstate.\nReturns false in case of an error\nPARAMETERS:\nCode:the Lua-code, which shall be run; will not be checked vor validity!\n...:parameters that shall be passed over to the script\nRETURNS:\nretval:true, if running it was successful; false, if not\nscript_identifier:a unique script-identifier, which can be used as extstate to communicate with the started code\n",
        "body": "${1:local }${2:boolean retval},${3:string script_identifier} = ultraschall.Main_OnCommand_LuaCode(${4:string Code},${5:string ...})$0"
    },
    "ULTRASCHALL.REPLACEPATTERNINSTRING_WR lua": {
        "prefix": "ultraschallwr.ReplacePatternInString",
        "scope": "lua",
        "description": "Replaces the index'th occurrence of pattern in OriginalString with replacepattern.\nUnlike string.gsub, this replaces only the selected pattern!\nreturns nil, false in case of an error\nPARAMETERS:\nOriginalString:the string, from which you want to replace a specific occurence of a matching pattern\npattern:the pattern to look for\nreplacestring:the string, which shall replace the found pattern\nindex:the number of found occurence of the pattern in the string, which shall be replaced\nRETURNS:\naltered_string:the altered string, where the n'th occurence of the pattern has been replaced\nreplaced:true, there has been a replacement; false, no replacement has happened\n",
        "body": "${1:local }${2:string altered_string},${3:boolean replaced} = ultraschall.ReplacePatternInString(${4:string OriginalString},${5:string pattern},${6:string replacestring},${7:integer index})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_TOBASE64STRING_WR lua": {
        "prefix": "ultraschallwr.ConvertFunction_ToBase64String",
        "scope": "lua",
        "description": "Converts a function into a BASE64-string.\nTo load a function from a BASE64-string, use ConvertFunction_FromBase64String\nReturns nil in case of an error\nPARAMETERS:\nto_convert_function:the function, that you want to convert\ndebug:true, store debug-information as well; false, only store function\nRETURNS:\nBASE64_functionstring:the function, stored as BASE64-string\n",
        "body": "${1:local }${2:string BASE64_functionstring} = ultraschall.ConvertFunction_ToBase64String(${3:function to_convert_function},${4:boolean debug})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_FROMBASE64STRING_WR lua": {
        "prefix": "ultraschallwr.ConvertFunction_FromBase64String",
        "scope": "lua",
        "description": "Loads a function from a BASE64-string.\nTo convert a function into a BASE64-string, use ConvertFunction_ToBase64String\nReturns nil in case of an error\nPARAMETERS:\nBASE64_functionstring:the function, stored as BASE64-string\nRETURNS:\nfunction:the loaded function\n",
        "body": "${1:local }${2:function function} = ultraschall.ConvertFunction_FromBase64String(${3:string BASE64_functionstring})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_TOHEXSTRING_WR lua": {
        "prefix": "ultraschallwr.ConvertFunction_ToHexString",
        "scope": "lua",
        "description": "Converts a function into a HEX-string.\nTo load a function from a HEX-string, use ConvertFunction_FromHexString\nReturns nil in case of an error\nPARAMETERS:\nto_convert_function:the function, that you want to convert\ndebug:true, store debug-information as well; false, only store function\nRETURNS:\nHEX_functionstring:the function, stored as HEX-string\n",
        "body": "${1:local }${2:string HEX_functionstring} = ultraschall.ConvertFunction_ToHexString(${3:function to_convert_function},${4:boolean debug})$0"
    },
    "ULTRASCHALL.CONVERTFUNCTION_FROMHEXSTRING_WR lua": {
        "prefix": "ultraschallwr.ConvertFunction_FromHexString",
        "scope": "lua",
        "description": "Loads a function from a HEX-string.\nTo convert a function into a HEX-string, use ConvertFunction_ToHexString\nReturns nil in case of an error\nPARAMETERS:\nHEX_functionstring:the function, stored as HEX-string\nRETURNS:\nfunction:the loaded function\n",
        "body": "${1:local }${2:function function} = ultraschall.ConvertFunction_FromHexString(${3:string HEX_functionstring})$0"
    },
    "ULTRASCHALL.BENCHMARK_GETSTARTTIME_WR lua": {
        "prefix": "ultraschallwr.Benchmark_GetStartTime",
        "scope": "lua",
        "description": "This function is for benchmarking parts of your code.\nIt returns the starttime of the last benchmark-start.\nreturns nil, if no benchmark has been made yet.\nUse Benchmark_MeasureTime to start/reset a new benchmark-measureing.\nRETURNS:\nstarttime:the starttime of the currently running benchmark\n",
        "body": "${1:local }${2:number starttime} = ultraschall.Benchmark_GetStartTime()$0"
    },
    "ULTRASCHALL.BENCHMARK_MEASURETIME_WR lua": {
        "prefix": "ultraschallwr.Benchmark_MeasureTime",
        "scope": "lua",
        "description": "This function is for benchmarking parts of your code.\nIt returns the passed time, since last time calling this function.\nUse Benchmark_GetStartTime to start the benchmark.\nPARAMETERS:\ntime_mode:the formatting of elapsed_time_string\nreset:true, resets the starttime(for new measuring); false, keeps current measure-starttime(for continuing measuring)\nRETURNS:\nelapsed_time:the elapsed time, formatted by parameter time_mode\nelapsed_time_string:the elapsed time, formatted by parameter time_mode\nmeasure_evaluation:an evaluation of time, mostly starting with < or > an a number of +\n",
        "body": "${1:local }${2:number elapsed_time},${3:string elapsed_time_string},${4:string measure_evaluation} = ultraschall.Benchmark_MeasureTime(${5:optional integer time_mode},${6:optional boolean reset})$0"
    },
    "ULTRASCHALL.RESIZEPNG_WR lua": {
        "prefix": "ultraschallwr.ResizePNG",
        "scope": "lua",
        "description": "resizes a png-file. It will stretch/shrink the picture by that. That means you can't crop or enhance pngs with this function.\nIf you set aspectratio=true, then the image will be resized with correct aspect-ratio. However, it will use the value from parameter width as maximum size for each side of the picture.\nSo if the height of the png is bigger than the width, the height will get the size and width will be shrinked accordingly.\nWhen making pngs bigger, pixelation will occur. No pixel-filtering within this function!\nreturns false in case of an error\nPARAMETERS:\nfilename_with_path:the output-file, where to store the resized png\noutputfilename_with_path:the output-file, where to store the resized png\naspectratio:true, keep aspect-ratio(use size of param width as base); false, don't keep aspect-ratio\nwidth:the width of the newly created png in pixels\nheight:the height of the newly created png in pixels\n",
        "body": "${1:local }${2:integer count} = ultraschall.ResizePNG(${3:string filename_with_path},${4:string outputfilename_with_path},${5:boolean aspectratio},${6:integer width},${7:integer height})$0"
    },
    "ULTRASCHALL.CAPTURESCREENAREAASPNG_WR lua": {
        "prefix": "ultraschallwr.CaptureScreenAreaAsPNG",
        "scope": "lua",
        "description": "captures an area of the screen and writes it as png-file.\nNote for Mac-users: it doesn't seem to work under certain circumstances, which are still under investigation.\nreturns false in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the png-file to write\nx:the x-position of the area to capture\ny:the y-position of the area to capture\nw:the width of the area to capture\nh:the height of the area to capture\nRETURNS:\nretval:true, capturing was successful; false, capturing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.CaptureScreenAreaAsPNG(${3:string filename_with_path},${4:integer x},${5:integer y},${6:integer w},${7:integer h})$0"
    },
    "ULTRASCHALL.CAPTUREWINDOWASPNG_WR lua": {
        "prefix": "ultraschallwr.CaptureWindowAsPNG",
        "scope": "lua",
        "description": "captures a window and stores it as png-file.\nNote for Windows-users with no Windows 10:\nKeep in mind, that even if you choose a dedicated window, if it's located behind other windows, these might be captured as well.\nNote for Mac-users: it doesn't seem to work under certain circumstances, which are still under investigation.\nreturns false in case of an error\nPARAMETERS:\nwindow_or_windowtitle:either a hwnd or the exact windowtitle of the window, which you want to capture\nfilename_with_path:the filename with path of the output-file\nx:the x-position within the window to capture; nil, to use the left side of the window\ny:the y-position within the window to capture; nil, to use the top side of the window\nw:true, use the workaround for invisible window-borders on windows 10; false, just capture the window\nh:the height of the capture-area; nil, to use the height of the window\nwin10:true, use the workaround for invisible window-borders on windows 10; false, just capture the window\nRETURNS:\nretval:true, capturing was successful; false, capturing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.CaptureWindowAsPNG(${3:identifier window_or_windowtitle},${4:string filename_with_path},${5:integer x},${6:integer y},${7:integer w},${8:integer h},${9:boolean win10})$0"
    },
    "ULTRASCHALL.LOCALIZE_WR lua": {
        "prefix": "ultraschallwr.Localize",
        "scope": "lua",
        "description": "Translates the string original_string into its translated version, as stored in a translation-file.\nTo set a translationfile, see Localize_UseFile.\nIf the string contains %s, the optional parameters \"...\" will replace them. The order of the parameters is the order of the replacement of the %s in the string.\nIf no translation is available, it returns the original string. In that case, %s in the string could be replaced by optional parameters ...\nThis function can be used with or without ultraschall. at the beginning, for your convenience.\nsee [specs for more information](../misc/ultraschall_translation_file_format.USLangPack).\nreturns nil in case of an error\nPARAMETERS:\noriginal_string:the original string, that you want to translate\n:optional parameters, who will be used to substitute %s in the returned string; order of the optional parameters reflects order of %s in the string\nRETURNS:\ntranslated_string:the translated string; will be the original_string(with optional substitution), if translation is not possible\nretval:true, translation-was successful; false, translation wasn't successful\n",
        "body": "${1:local }${2:string translated_string},${3:boolean retval} = ultraschall.Localize(${4:string original_string},${5:...})$0"
    },
    "ULTRASCHALL.LOCALIZE_REFRESHFILE_WR lua": {
        "prefix": "ultraschallwr.Localize_RefreshFile",
        "scope": "lua",
        "description": "Reloads the translation-file, that has been set using Localize_UseFile.\nsee [specs for more information](../misc/ultraschall_translation_file_format.USLangPack).\nRETURNS:\nretval:true, translation-file has been found and set successfully; false, translation-file hasn't been found\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.Localize_RefreshFile()$0"
    },
    "ULTRASCHALL.ADDNORMALMARKER_WR lua": {
        "prefix": "ultraschallwr.AddNormalMarker",
        "scope": "lua",
        "description": "Adds a normal marker. Returns the index of the marker as marker_number.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nposition:position in seconds.\nshown_number:the number, that will be shown within Reaper. Can be multiple times. Use -1 to let Reaper decide the number.\nmarkertitle:the title of the marker.\nRETURNS:\nmarker_number:the overall-marker-index, can be used for reaper's own marker-management functions\nguid:the guid, associated with this marker\n",
        "body": "${1:local }${2:integer marker_number},${3:string guid} = ultraschall.AddNormalMarker(${4:number position},${5:integer shown_number},${6:string markertitle})$0"
    },
    "ULTRASCHALL.ADDPODRANGEREGION_WR lua": {
        "prefix": "ultraschallwr.AddPodRangeRegion",
        "scope": "lua",
        "description": "Adds a region, which shows the time-range from the beginning to the end of the podcast.\nreturns -1 in case of an error\nPARAMETERS:\nstartposition:begin of the podcast in seconds\nendposition:end of the podcast in seconds\nRETURNS:\nmarker_number:the overall-marker-index, can be used for reaper's own marker-management functions\nguid:the guid of the PodRangeRegion\n",
        "body": "${1:local }${2:integer marker_number},${3:string guid} = ultraschall.AddPodRangeRegion(${4:number startposition},${5:number endposition})$0"
    },
    "ULTRASCHALL.GETMARKERBYNAME_WR lua": {
        "prefix": "ultraschallwr.GetMarkerByName",
        "scope": "lua",
        "description": "Get all markers/regions that have a certain name. This function is not case-sensitive.\nreturns -1 in case of an error\nPARAMETERS:\nsearchname:the name to look for; must be exact; not case-sensitive\nsearchisrgn:true, search only within regions; false, search only within markers\nRETURNS:\ncount_markers:the number of found markers/regions\nfoundmarkers:an array with all marker/region-numbers of the found markers; counts only regions or markers(depending on parameter searchisrgn); markernumbers are 0-based\nfound_guids:the guids of all markers/regions found\n",
        "body": "${1:local }${2:integer count_markers},${3:array foundmarkers},${4:array found_guids} = ultraschall.GetMarkerByName(${5:string searchname},${6:boolean searchisrgn})$0"
    },
    "ULTRASCHALL.GETMARKERBYNAME_PATTERN_WR lua": {
        "prefix": "ultraschallwr.GetMarkerByName_Pattern",
        "scope": "lua",
        "description": "Get all markers/regions that have a certain character-sequence in their name. This function is not case-sensitive.\nreturns -1 in case of an error\nPARAMETERS:\nsearchname:the name to look for; a character-sequence that shall be part of the name; not case-sensitive\nsearchisrgn:true, search only within regions; false, search only within markers\nRETURNS:\ncount_markers:the number of found markers/regions\nfoundmarkers:an array with all marker/region-numbers of the found markers; counts only regions or markers(depending on parameter searchisrgn)\nfoundguids:the guids of all found markers/regions\n",
        "body": "${1:local }${2:integer count_markers},${3:array foundmarkers},${4:array foundguids} = ultraschall.GetMarkerByName_Pattern(${5:string searchname},${6:boolean searchisrgn})$0"
    },
    "ULTRASCHALL.GETMARKERANDREGIONSBYINDEX_WR lua": {
        "prefix": "ultraschallwr.GetMarkerAndRegionsByIndex",
        "scope": "lua",
        "description": "Returns the values of a certain marker/region. The numbering of idx is either only for the markers or for regions, depending on what you set with parameter searchisrgn.\nreturns nil in case of an error\nPARAMETERS:\nidx:the number of the requested marker/region; counts only within either markers or regions, depending on what you've set searchisrgn to; 1-based!\nsearchisrgn:true, search only within regions; false, search only within markers\nRETURNS:\nname:the name of the marker/region\ncolor:the color-value of the marker/region\npos:the position of the marker/region\nrgnend:the end of the region\nguid:the guid of the marker/region; if it's a marker, the retval rgnend will be nil!\n",
        "body": "${1:local }${2:string name},${3:integer shown_number},${4:integer color},${5:number pos},${6:optional number rgnend},${7:string guid} = ultraschall.GetMarkerAndRegionsByIndex(${8:integer idx},${9:boolean searchisrgn})$0"
    },
    "ULTRASCHALL.SETMARKERBYINDEX_WR lua": {
        "prefix": "ultraschallwr.SetMarkerByIndex",
        "scope": "lua",
        "description": "Sets the values of a certain marker/region. The numbering of idx is either only for the markers or for regions, depending on what you set with parameter searchisrgn.\nreturns false in case of an error\nPARAMETERS:\nidx:the number of the requested marker/region; counts only within either markers or regions, depending on what you've set searchisrgn to\nsearchisrgn:true, search only within regions; false, search only within markers\nshown_number:the shown-number of the region/marker; no duplicate numbers for regions allowed; nil to keep previous shown_number\nposition:the end of the region in seconds; nil to keep previous region-end\nrgnend:the end of the region in seconds; nil to keep previous region-end\nname:the name of the marker/region; nil to keep the previous name\ncolor:color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000; nil to keep the previous color\nflags:flags&1 to clear name; 0, keep it; nil to use the previous setting\nRETURNS:\nretval:true, setting the marker/region was successful; false, setting of the marker/region was unsuccessful.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetMarkerByIndex(${3:integer idx},${4:boolean searchisrgn},${5:integer shown_number},${6:number position},${7:position rgnend},${8:string name},${9:integer color},${10:integer flags})$0"
    },
    "ULTRASCHALL.ADDEDITMARKER_WR lua": {
        "prefix": "ultraschallwr.AddEditMarker",
        "scope": "lua",
        "description": "Adds an Edit marker. Returns the index of the marker as marker_number.\nreturns -1 in case of an error\nPARAMETERS:\nposition:position in seconds.\nshown_number:the number, that will be shown within Reaper. Can be multiple times. Use -1 to let Reaper decide the number.\nedittitle:the title of the edit-marker; will be shown as _Edit:edittitle\nRETURNS:\nmarker_number:the overall-marker-index, can be used for reaper's own marker-management functions\nguid:the guid, associated with this marker\n",
        "body": "${1:local }${2: integer marker_number},${3:string guid} = ultraschall.AddEditMarker(${4:number position},${5:integer shown_number},${6:string edittitle})$0"
    },
    "ULTRASCHALL.COUNTNORMALMARKERS_WR lua": {
        "prefix": "ultraschallwr.CountNormalMarkers",
        "scope": "lua",
        "description": "Counts all normal markers.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nRETURNS:\nnumber_of_markers:number of normal markers\n",
        "body": "${1:local }${2: integer number_of_markers} = ultraschall.CountNormalMarkers()$0"
    },
    "ULTRASCHALL.COUNTEDITMARKERS_WR lua": {
        "prefix": "ultraschallwr.CountEditMarkers",
        "scope": "lua",
        "description": "Counts all edit-markers.\nRETURNS:\nnumber_of_edit_markers:number of edit markers\n",
        "body": "${1:local }${2: integer number_of_edit_markers} = ultraschall.CountEditMarkers()$0"
    },
    "ULTRASCHALL.GETPODRANGEREGION_WR lua": {
        "prefix": "ultraschallwr.GetPodRangeRegion",
        "scope": "lua",
        "description": "Gets the start_position and the end_position of the PodRangeRegion.\nreturns -1 if no PodRangeRegion exists\nRETURNS:\nstart_position:beginning of the podrangeregion, that marks the beginning of the podcast\nend_position:end of the podrangeregion, that marks the end of the podcast\nguid:the guid associated with this marker\n",
        "body": "${1:local }${2: number start_position},${3:number end_position},${4:string guid} = ultraschall.GetPodRangeRegion()$0"
    },
    "ULTRASCHALL.ENUMERATENORMALMARKERS_WR lua": {
        "prefix": "ultraschallwr.EnumerateNormalMarkers",
        "scope": "lua",
        "description": "Get the data of a normal marker.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nReturns -1 in case of error\nPARAMETERS:\nnumber:number of the marker(normal markers only). Refer ultraschall.CountNormalMarkers for getting the number of normal markers.\nRETURNS:\nretnumber:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nretidxnum:indexnumber of the marker\nposition:the position of the marker\nmarkertitle:the name of the marker\nguid:the guid of the enumerated marker\n",
        "body": "${1:local }${2:integer retnumber},${3:integer retidxnum},${4:number position},${5:string markertitle},${6:string guid} = ultraschall.EnumerateNormalMarkers(${7:integer number})$0"
    },
    "ULTRASCHALL.ENUMERATEEDITMARKERS_WR lua": {
        "prefix": "ultraschallwr.EnumerateEditMarkers",
        "scope": "lua",
        "description": "Gets the data of an edit marker.\nreturns -1 in case of an error\nPARAMETERS:\nedit_index:number of the edit-marker. Refer ultraschall.CountEditMarkers for getting the number of edit-markers.\nRETURNS:\nretnumber:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nshown_number:indexnumber of the marker\nposition:the position of the marker\nedittitle:the name of the marker\nguid:the guid of the editmarker\n",
        "body": "${1:local }${2:integer retnumber},${3:integer shown_number},${4:number position},${5:string edittitle},${6:string guid} = ultraschall.EnumerateEditMarkers(${7:integer edit_index})$0"
    },
    "ULTRASCHALL.GETALLEDITMARKERS_WR lua": {
        "prefix": "ultraschallwr.GetAllEditMarkers",
        "scope": "lua",
        "description": "returns the number of editmarkers and an array with each editmarker in the format:\neditmarkersarray[index][0] - position\neditmarkersarray[index][1] - name\neditmarkersarray[index][2] - idx\neditmarkersarray[index][3] - guid\nRETURNS:\nnumber_of_editmarkers:the number of editmarkers returned\neditmarkersarray:an array with all the edit-markers of the project\n",
        "body": "${1:local }${2:integer number_of_editmarkers},${3:array editmarkersarray} = ultraschall.GetAllEditMarkers()$0"
    },
    "ULTRASCHALL.GETALLNORMALMARKERS_WR lua": {
        "prefix": "ultraschallwr.GetAllNormalMarkers",
        "scope": "lua",
        "description": "returns the number of normalmarkers and an array with each normalmarker in the format:\nnormalmarkersarray[index][0] - position\nnormalmarkersarray[index][1] - name\nnormalmarkersarray[index][2] - idx of the marker within all markers in project\nnormalmarkersarray[index][3] - the shown index number of the marker\nnormalmarkersarray[index][4] - the guid of the marker\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nRETURNS:\nnumber_of_normalmarkers:the number of normalmarkers returned\nnormalmarkersarray:an array, that holds all normal markers of the project\n",
        "body": "${1:local }${2:index number_of_normalmarkers},${3:array normalmarkersarray} = ultraschall.GetAllNormalMarkers()$0"
    },
    "ULTRASCHALL.GETALLMARKERS_WR lua": {
        "prefix": "ultraschallwr.GetAllMarkers",
        "scope": "lua",
        "description": "To get all Markers in the project(normal, edit, chapter), regardless of their category.\nDoesn't return regions!\nreturns the number of markers and an array with each marker in the format:\nmarkersarray[index][0] - position\nmarkersarray[index][1] - name\nmarkersarray[index][2] - indexnumber of the marker within all markers in the project\nmarkersarray[index][3] - the shown index-number\nmarkersarray[index][4] - the color of the marker\nmarkersarray[index][5] - the guid of the marker\nRETURNS:\nallmarkersarray:an array, that holds all markers(not regions!) of the project\n",
        "body": "${1:local }${2: integer number_of_all_markers},${3:array allmarkersarray} = ultraschall.GetAllMarkers()$0"
    },
    "ULTRASCHALL.SETNORMALMARKER_WR lua": {
        "prefix": "ultraschallwr.SetNormalMarker",
        "scope": "lua",
        "description": "Sets values of a normal Marker(no _Chapter:, _Shownote:, etc). Returns true if successful and false if not(i.e. marker doesn't exist)\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns false in case of an error\nPARAMETERS:\nnumber:the number of the marker\nposition:position of the marker in seconds\nshown_number:the number of the marker\nmarkertitle:title of the marker\nRETURNS:\nretval:true if successful and false if not(i.e. marker doesn't exist)\n",
        "body": "${1:local }${2: boolean retval} = ultraschall.SetNormalMarker(${3:integer number},${4:number position},${5:integer shown_number},${6:string markertitle})$0"
    },
    "ULTRASCHALL.SETEDITMARKER_WR lua": {
        "prefix": "ultraschallwr.SetEditMarker",
        "scope": "lua",
        "description": "Sets values of an Edit Marker. Returns true if successful and false if not(i.e. marker doesn't exist)\nreturns false in case of an error\nPARAMETERS:\nedit_index:the number of the edit marker\nposition:position of the marker in seconds\nshown_number:the number of the marker\nRETURNS:\nretval:true if successful and false if not(i.e. marker doesn't exist)\n",
        "body": "${1:local }${2: boolean retval} = ultraschall.SetEditMarker(${3:integer edit_index},${4:number position},${5:integer shown_number},${6:string edittitle})$0"
    },
    "ULTRASCHALL.DELETEPODRANGEREGION_WR lua": {
        "prefix": "ultraschallwr.DeletePodRangeRegion",
        "scope": "lua",
        "description": "deletes the PodRange-Region.\nReturns false if unsuccessful\nRETURNS:\nretval:true, if deleting was successful; false, if not\n",
        "body": "${1:local }${2: integer retval} = ultraschall.DeletePodRangeRegion()$0"
    },
    "ULTRASCHALL.DELETENORMALMARKER_WR lua": {
        "prefix": "ultraschallwr.DeleteNormalMarker",
        "scope": "lua",
        "description": "Deletes a Normal-Marker. Returns true if successful and false if not(i.e. marker doesn't exist) Use ultraschall.EnumerateNormalMarkers to get the correct number.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nnumber:number of a normal marker\nRETURNS:\nretval:true, if successful, false if not\n",
        "body": "${1:local }${2: boolean retval} = ultraschall.DeleteNormalMarker(${3:integer number})$0"
    },
    "ULTRASCHALL.DELETEEDITMARKER_WR lua": {
        "prefix": "ultraschallwr.DeleteEditMarker",
        "scope": "lua",
        "description": "Deletes an _Edit:-Marker. Returns true if successful and false if not(i.e. marker doesn't exist) Use ultraschall.EnumerateEditMarkers to get the correct number.\nPARAMETERS:\nedit_index:number of an edit marker\nRETURNS:\nretval:true, if successful, false if not\n",
        "body": "${1:local }${2: boolean retval} = ultraschall.DeleteEditMarker(${3:integer edit_index})$0"
    },
    "ULTRASCHALL.EXPORTEDITMARKERSTOFILE_WR lua": {
        "prefix": "ultraschallwr.ExportEditMarkersToFile",
        "scope": "lua",
        "description": "Export Edit-Markers (not regions!) to filename_with_path.\nEach line in the exportfile contains an entry for such an edit-marker in the format:\nhh:mm:ss.mss Title\nReturns -1 in case of error.\nPARAMETERS:\nfilename_with_path:the name of the export-file\nPodRangeStart:beginning of the podcast in seconds\nPodRangeEnd:end of the podcast in seconds\nRETURNS:\nretval:1 in case of success, -1 if it failed\n",
        "body": "${1:local }${2: integer retval} = ultraschall.ExportEditMarkersToFile(${3:string filename_with_path},${4:number PodRangeStart},${5:number PodRangeEnd})$0"
    },
    "ULTRASCHALL.EXPORTNORMALMARKERSTOFILE_WR lua": {
        "prefix": "ultraschallwr.ExportNormalMarkersToFile",
        "scope": "lua",
        "description": "Export Normal-Markers to filename_with_path. Returns -1 in case of error.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nfilename_with_path:the name of the export-file\nPodRangeStart:beginning of the podcast in seconds\nPodRangeEnd:end of the podcast in seconds\nRETURNS:\nretval:1 in case of success, -1 if it failed\n",
        "body": "${1:local }${2: integer retval} = ultraschall.ExportNormalMarkersToFile(${3:string filename_with_path},${4:number PodRangeStart},${5:number PodRangeEnd})$0"
    },
    "ULTRASCHALL.IMPORTEDITFROMFILE_WR lua": {
        "prefix": "ultraschallwr.ImportEditFromFile",
        "scope": "lua",
        "description": "Imports editentries from a file and returns an array of the imported values.\nreturns -1 in case of error\nPARAMETERS:\nfilename_with_path:markerfile to be imported\n:podcast-start-offset\n",
        "body": "${1:local }${2: array editmarkers} = ultraschall.ImportEditFromFile(${3:string filename_with_path},${4:PodRangestart})$0"
    },
    "ULTRASCHALL.IMPORTMARKERSFROMFILE_WR lua": {
        "prefix": "ultraschallwr.ImportMarkersFromFile",
        "scope": "lua",
        "description": "Imports markerentries from a file and returns an array of the imported values.\nreturns -1 in case of error\nPARAMETERS:\nfilename_with_path:markerfile to be imported\n:podcast-start-offset\n",
        "body": "${1:local }${2: array markers} = ultraschall.ImportMarkersFromFile(${3:string filename_with_path},${4:PodrangeStart})$0"
    },
    "ULTRASCHALL.MARKERTOEDITMARKER_WR lua": {
        "prefix": "ultraschallwr.MarkerToEditMarker",
        "scope": "lua",
        "description": "Converts a normal-marker to an edit-marker.\nNormal markers are all markers, that don't include \"_Shownote:\" or \"_Edit\" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).\nreturns -1 in case of an error\nPARAMETERS:\nmarkerindex:number of the normal-marker. Refer ultraschall.CountNormalMarkers for getting the number of normal-markers.\nRETURNS:\nidx:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nshown_number:the shown number of the marker\nposition:the position of the marker in seconds\nmarkertitle:the markertitle\n",
        "body": "${1:local }${2: integer idx},${3:integer shown_number},${4:number position},${5:string markertitle} = ultraschall.MarkerToEditMarker(${6:integer markerindex})$0"
    },
    "ULTRASCHALL.EDITTOMARKER_WR lua": {
        "prefix": "ultraschallwr.EditToMarker",
        "scope": "lua",
        "description": "Converts an edit-marker to a normal marker.\nreturns -1 in case of an error\nPARAMETERS:\nedit_index:number of the edit-marker. Refer ultraschall.CountEditMarkers for getting the number of edit-markers.\nRETURNS:\nidx:overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of\nshown_number:the shown number of the marker\nposition:the position of the marker in seconds\nmarkertitle:the markertitle\n",
        "body": "${1:local }${2: integer idx},${3:integer shown_number},${4:number position},${5:string markertitle} = ultraschall.EditToMarker(${6:integer edit_index})$0"
    },
    "ULTRASCHALL.GETMARKERBYSCREENCOORDINATES_WR lua": {
        "prefix": "ultraschallwr.GetMarkerByScreenCoordinates",
        "scope": "lua",
        "description": "returns the markers at a given absolute-x-pixel-position. It sees markers according their graphical representation in the arrange-view, not just their position! Returned string will be \"Markeridx\\npos\\nName\\nMarkeridx2\\npos2\\nName2\\n...\".\nWill return \"\", if no marker has been found.\nReturns only markers, no time markers or regions!\nreturns nil in case of an error\nPARAMETERS:\nxmouseposition:the absolute x-screen-position, like current mouse-position\nRETURNS:\nmarker:a string with all markernumbers, markerpositions and markertitles, separated by a newline. \n",
        "body": "${1:local }${2:string marker} = ultraschall.GetMarkerByScreenCoordinates(${3:integer xmouseposition})$0"
    },
    "ULTRASCHALL.GETMARKERBYTIME_WR lua": {
        "prefix": "ultraschallwr.GetMarkerByTime",
        "scope": "lua",
        "description": "returns the markers at a given project-position in seconds.\nIt sees markers according their actual graphical representation in the arrange-view, not just their position.\nIf, for example, you pass to it the current playposition, the function will return the marker as long as the playcursor is behind the marker-graphics.\nReturned string will be \"Markeridx\\npos\\nName\\nMarkeridx2\\npos2\\nName2\\n...\".\nWill return \"\", if no marker has been found.\nReturns only markers, no time markers or regions!\nreturns nil in case of an error\nPARAMETERS:\nposition:the time-position in seconds\n",
        "body": "${1:local }${2:string markers} = ultraschall.GetMarkerByTime(${3:number position})$0"
    },
    "ULTRASCHALL.GETREGIONBYSCREENCOORDINATES_WR lua": {
        "prefix": "ultraschallwr.GetRegionByScreenCoordinates",
        "scope": "lua",
        "description": "returns the regions at a given absolute-x-pixel-position. It sees regions according their graphical representation in the arrange-view, not just their position! Returned string will be \"Regionidx\\npos\\nName\\nRegionidx2\\npos2\\nName2\\n...\".\nReturns only regions, no time markers or other markers!\nWill return \"\", if no region has been found.\nreturns nil in case of an error\nPARAMETERS:\nxmouseposition:the absolute x-screen-position, like current mouse-position\n",
        "body": "${1:local }${2:string markers} = ultraschall.GetRegionByScreenCoordinates(${3:integer xmouseposition})$0"
    },
    "ULTRASCHALL.GETREGIONBYTIME_WR lua": {
        "prefix": "ultraschallwr.GetRegionByTime",
        "scope": "lua",
        "description": "returns the regions at a given absolute-x-pixel-position. It sees regions according their graphical representation in the arrange-view, not just their position! Returned string will be \"Regionidx\\npos\\nName\\nRegionidx2\\npos2\\nName2\\n...\".\nReturns only regions, no timesignature-markers or other markers!\nWill return \"\", if no region has been found.\nreturns nil in case of an error\nPARAMETERS:\nposition:position in seconds\n",
        "body": "${1:local }${2:string markers} = ultraschall.GetRegionByTime(${3:number position})$0"
    },
    "ULTRASCHALL.GETTIMESIGNATURESBYSCREENCOORDINATES_WR lua": {
        "prefix": "ultraschallwr.GetTimeSignaturesByScreenCoordinates",
        "scope": "lua",
        "description": "returns the time-signature/tempo-marker at a given absolute-x-pixel-position. It sees time-signature/tempo-markers according their graphical representation in the arrange-view, not just their position! Returned string will be \"tempomarkeridx\\npos\\ntempomarkeridx2\\npos2\\n...\".\nReturns only time-signature-markers, no regions or other markers!\nWill return \"\", if no timesig-marker has been found.\nreturns nil in case of an error\nPARAMETERS:\nxmouseposition:the absolute x-screen-position, like current mouse-position\n",
        "body": "${1:local }${2:string markers} = ultraschall.GetTimeSignaturesByScreenCoordinates(${3:integer xmouseposition})$0"
    },
    "ULTRASCHALL.GETTIMESIGNATURESBYTIME_WR lua": {
        "prefix": "ultraschallwr.GetTimeSignaturesByTime",
        "scope": "lua",
        "description": "returns the time-signature/tempo-marker at a given absolute-x-pixel-position. It sees time-signature/tempo-markers according their graphical representation in the arrange-view, not just their position! Returned string will be \"tempomarkeridx\\npos\\ntempomarkeridx2\\npos2\\n...\".\nReturns only time-signature-markers, no other markers or regions!\nWill return \"\", if no timesig-marker has been found.\nreturns nil in case of an error\nPARAMETERS:\nposition:position in seconds\n",
        "body": "${1:local }${2:string markers} = ultraschall.GetTimeSignaturesByTime(${3:number position})$0"
    },
    "ULTRASCHALL.ISMARKEREDIT_WR lua": {
        "prefix": "ultraschallwr.IsMarkerEdit",
        "scope": "lua",
        "description": "returns true, if the marker is an edit-marker, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's an edit-marker, false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsMarkerEdit(${3:integer markerid})$0"
    },
    "ULTRASCHALL.ISMARKERNORMAL_WR lua": {
        "prefix": "ultraschallwr.IsMarkerNormal",
        "scope": "lua",
        "description": "returns true, if the marker is a normal-marker, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's an normal-marker, false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsMarkerNormal(${3:integer markerid})$0"
    },
    "ULTRASCHALL.ISREGIONPODRANGE_WR lua": {
        "prefix": "ultraschallwr.IsRegionPodrange",
        "scope": "lua",
        "description": "returns true, if the marker is a Podrange-region, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's a PodRange-Region, false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsRegionPodrange(${3:integer markerid})$0"
    },
    "ULTRASCHALL.ISREGIONEDITREGION_WR lua": {
        "prefix": "ultraschallwr.IsRegionEditRegion",
        "scope": "lua",
        "description": "returns true, if the marker is an Edit-region, false if not. Returns nil, if markerid is invalid.\nMarkerid is the marker-number for all markers, as used by marker-functions from Reaper.\nreturns nil in case of an error\nPARAMETERS:\nmarkerid:the markerid of all markers in the project, beginning with 0 for the first marker\nRETURNS:\nretval:true, if it's an Edit-Region, false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsRegionEditRegion(${3:integer markerid})$0"
    },
    "ULTRASCHALL.ADDEDITREGION_WR lua": {
        "prefix": "ultraschallwr.AddEditRegion",
        "scope": "lua",
        "description": "Adds a new edit-region and returns index of the newly created edit-marker-region.\nreturns -1 in case of an error\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntext:the title of the marker\nRETURNS:\nmarkernr:the number of the newly created region\nguid:the guid, associated with this edit-region\n",
        "body": "${1:local }${2:integer markernr},${3:string guid} = ultraschall.AddEditRegion(${4:number startposition},${5:number endposition},${6:string text})$0"
    },
    "ULTRASCHALL.SETEDITREGION_WR lua": {
        "prefix": "ultraschallwr.SetEditRegion",
        "scope": "lua",
        "description": "Sets the values of an already existing edit-region. To retain an already set position, endposition and/or edittitle, use nil.\nReturns true in case of success, false if not.\nNote: if you set the new beginning of the region before another region, the indexnumber of the edit-region changes. So if you want to set an edit-region repeatedly, you should get the indexnumber using ultraschall.EnumerateEditRegion, or you might accidently change another region!\nreturns -1 in case of an error\nPARAMETERS:\nnumber:endposition in seconds, nil to retain the old value\nposition:endposition in seconds, nil to retain the old value\nendposition:endposition in seconds, nil to retain the old value\nRETURNS:\nretval:true, in case of success, false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetEditRegion(${3:integer number},${4:number position},${5:number endposition},${6:string edittitle})$0"
    },
    "ULTRASCHALL.DELETEEDITREGION_WR lua": {
        "prefix": "ultraschallwr.DeleteEditRegion",
        "scope": "lua",
        "description": "Deletes an already existing edit-region.\nReturns true in case of success, false if not.\nPARAMETERS:\nnumber:the number of the edit-region, beginning with 1 for the first edit-region\nRETURNS:\nretval:true, in case of success, false if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteEditRegion(${3:integer number})$0"
    },
    "ULTRASCHALL.ENUMERATEEDITREGION_WR lua": {
        "prefix": "ultraschallwr.EnumerateEditRegion",
        "scope": "lua",
        "description": "Returns the values of an edit-region.\nreturns -1 in case of an error\nPARAMETERS:\nnumber:the number of the edit-region, beginning with 1 for the first edit-region\nRETURNS:\nretval:the overall marker-index-number of all markers in the project, -1 in case of error\nposition:endposition in seconds\nendposition:endposition in seconds\ntitle:the title of the region\nrgnindexnumber:the overall region index number, as used by other of Reaper's own marker-functions\nguid:the guid of the edit-region\n",
        "body": "${1:local }${2:integer retval},${3:number position},${4:number endposition},${5:string title},${6:integer rgnindexnumber},${7:string guid} = ultraschall.EnumerateEditRegion(${8:integer number})$0"
    },
    "ULTRASCHALL.COUNTEDITREGIONS_WR lua": {
        "prefix": "ultraschallwr.CountEditRegions",
        "scope": "lua",
        "description": "returns the number of edit-regions in the project.\nRETURNS:\nretval:the number of edit-regions in the project\n",
        "body": "${1:local }${2:integer retval} = ultraschall.CountEditRegions()$0"
    },
    "ULTRASCHALL.GETALLMARKERSBETWEEN_WR lua": {
        "prefix": "ultraschallwr.GetAllMarkersBetween",
        "scope": "lua",
        "description": "To get all Markers in the project(normal, edit, chapter), regardless of their category, between startposition and endposition.\nDoesn't return regions!\nreturns the number of markers and an array with each marker in the format:\nmarkersarray[index][0] - position\nmarkersarray[index][1] - name\nmarkersarray[index][2] - indexnumber of the marker within all markers in the project\nmarkersarray[index][3] - the shown index-number\nmarkersarray[index][4] - the color of the marker\nmarkersarray[index][5] - the guid of the marker\nreturns -1 in case of error\nPARAMETERS:\nstartposition:the earliest position a returned marker may have\nendposition:the latest position a returned marker may have\nRETURNS:\nallmarkersarray:an array, that holds all markers(not regions!) of the project\n",
        "body": "${1:local }${2:integer number_of_all_markers},${3:array allmarkersarray} = ultraschall.GetAllMarkersBetween(${4:number startposition},${5:number endposition})$0"
    },
    "ULTRASCHALL.GETALLREGIONS_WR lua": {
        "prefix": "ultraschallwr.GetAllRegions",
        "scope": "lua",
        "description": "To get all Regions in the project(normal, edit, chapter), regardless of their category.\nDoesn't return markers!\nreturns the number of markers and an array with each marker in the format:\nregionarray[index][0] - position\nregionarray[index][1] - endposition\nregionarray[index][2] - name\nregionarray[index][3] - indexnumber of the region within all markers in the project. This is 1-based, unlike in Reaper's own API!\nregionarray[index][4] - the shown index-number\nregionarray[index][5] - the color of the region\nregionarray[index][6] - the guid of the region\nreturns -1 in case of error\n",
        "body": "${1:local }${2:integer number_of_all_regions},${3:array allregionsarray} = ultraschall.GetAllRegions()$0"
    },
    "ULTRASCHALL.GETALLREGIONSBETWEEN_WR lua": {
        "prefix": "ultraschallwr.GetAllRegionsBetween",
        "scope": "lua",
        "description": "To get all Regions in the project(normal, edit, chapter), regardless of their category between start- and endposition.\nSet partial to true, if you want to get regions as well, that are only partially between start- and endposition\nDoesn't return markers!\nreturns the number of markers and an array with each marker in the format:\nregionarray[index][0] - position\nregionarray[index][1] - endposition\nregionarray[index][2] - name\nregionarray[index][3] - indexnumber of the region within all markers in the project\nregionarray[index][4] - the shown index-number\nregionarray[index][5] - the color of the region\nregionarray[index][6] - the guid of the region\nreturns -1 in case of error\nPARAMETERS:\nstartposition:the earliest position a returned region may have\nendposition:the latest position a returned region may have\n",
        "body": "${1:local }${2:integer number_of_all_regions},${3:array allregionsarray} = ultraschall.GetAllRegionsBetween(${4:number startposition},${5:number endposition},${6:boolean partial})$0"
    },
    "ULTRASCHALL.PARSEMARKERSTRING_WR lua": {
        "prefix": "ultraschallwr.ParseMarkerString",
        "scope": "lua",
        "description": "Parses the entries in markerstring for timestrings and markertitles.\nIt returns the number of entries as well as a table with all marker-information.\nThe table works as such:\nmarkertable[1][markernumber] - the timestring of the marker, -1 if no time is available\nmarkertable[2][markernumber] - the time, converted into position in seconds, -1 if no time is available\nmarkertable[3][markernumber] - the name of the marker\nreturns -1 in case of an error\nPARAMETERS:\nmarkerstring:a string with all markers. An entry is \"timestring markertitle\\n\". Each marker-entry must be separated by a newline from each other.\nstrict:interpret the time in timestring more strict or more loosely?\nRETURNS:\nnumber_of_entries:the number of markers in markerstring\nmarkerarray:a table with all the information of a marker\n",
        "body": "${1:local }${2:integer number_of_entries},${3:array markerarray} = ultraschall.ParseMarkerString(${4:string markerstring},${5:boolean strict})$0"
    },
    "ULTRASCHALL.RENUMERATEMARKERS_WR lua": {
        "prefix": "ultraschallwr.RenumerateMarkers",
        "scope": "lua",
        "description": "Renumbers the shown numbers of markers(not regions!) in the current project, that have the color colorvalue.\nThe numbering starts with the number startingnumber.\nThe markers will be renumbered from the earliest marker in the project to the latest one.\nreturns -1 in case of an error\nPARAMETERS:\ncolorvalue:the (systemdependent)colorvalue a marker must have. -1 if you want all markers to be numbered.\nstartingnumber:the first number that shall be given.\nRETURNS:\nretval:-1 in case of error, nil in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.RenumerateMarkers(${3:integer colorvalue},${4:integer startingnumber})$0"
    },
    "ULTRASCHALL.ISMARKERATPOSITION_WR lua": {
        "prefix": "ultraschallwr.IsMarkerAtPosition",
        "scope": "lua",
        "description": "returns, if markers are at position and returns the marker-numbers.\nThe marker-numbers are numerated by order, not the shown marker-numbers!\nreturns false in case of error\nPARAMETERS:\nposition:the position to check for markers in seconds; only positive numbers\nRETURNS:\nretval:true, if the function found marker(s); false, if no markers are available at position\ncount:the count of markers at position\nmarkersstring:a string with all the markernumbers, separated by a ,\nmarkersarray:an array with each entry consisting a markernumber\n",
        "body": "${1:local }${2:boolean retval},${3:integer count},${4:string markersstring},${5:array markersarray} = ultraschall.IsMarkerAtPosition(${6:number position})$0"
    },
    "ULTRASCHALL.ISREGIONATPOSITION_WR lua": {
        "prefix": "ultraschallwr.IsRegionAtPosition",
        "scope": "lua",
        "description": "returns, if regions are at position and returns the region-numbers.\nThe region-numbers are numerated by order, not the shown region-numbers!\nreturns false in case of error\nPARAMETERS:\nposition:the position to check for regions in seconds; only positive numbers\nRETURNS:\nretval:true, if the function found region(s); false, if no regions are available at position\ncount:the count of regions at position\nregionsstring:a string with all the regionnumbers, separated by a ,\nregionsarray:an array with each entry consisting a regionnumber\n",
        "body": "${1:local }${2:boolean retval},${3:integer count},${4:string regionsstring},${5:array regionsarray} = ultraschall.IsRegionAtPosition(${6:number position})$0"
    },
    "ULTRASCHALL.COUNTMARKERSANDREGIONS_WR lua": {
        "prefix": "ultraschallwr.CountMarkersAndRegions",
        "scope": "lua",
        "description": "Returns the position of the last projectmarker in the project(no regions or time-sig-markers!).\nUse GetMarkerAndRegionsByIndex to enumerate markers or regions in particular.\nReturns -1 in case of no markers available\nRETURNS:\ncount_markers:the number of markers available in the project\ncount_regions:the number of regions available in the project\n",
        "body": "${1:local }${2:integer count_markers},${3:integer count_regions} = ultraschall.CountMarkersAndRegions()$0"
    },
    "ULTRASCHALL.GETLASTMARKERPOSITION_WR lua": {
        "prefix": "ultraschallwr.GetLastMarkerPosition",
        "scope": "lua",
        "description": "Returns the position of the last projectmarker in the project(no regions or time-sig-markers!).\nReturns -1 in case of no markers available\nRETURNS:\nposition:the position of the last marker in the project\nmarker_idx:the idx of the last marker in the project. Not the shown number!\n",
        "body": "${1:local }${2:number position},${3:integer marker_idx} = ultraschall.GetLastMarkerPosition()$0"
    },
    "ULTRASCHALL.GETLASTREGION_WR lua": {
        "prefix": "ultraschallwr.GetLastRegion",
        "scope": "lua",
        "description": "Returns the position of the last region in the project(no markers or time-sig-markers!).\nNote: Last region means the last ending region in the project, even if it's the first starting.\nReturns -1 in case of no regions available\nRETURNS:\nposition:the endposition of the last region in the project\nendposition:the endposition of the last region in the project\nregion_idx:the idx of the last region in the project. Not the shown number!\n",
        "body": "${1:local }${2:number position},${3:number endposition},${4:integer region_idx} = ultraschall.GetLastRegion()$0"
    },
    "ULTRASCHALL.GETLASTTIMESIGMARKERPOSITION_WR lua": {
        "prefix": "ultraschallwr.GetLastTimeSigMarkerPosition",
        "scope": "lua",
        "description": "Returns the position of the last time-signature-marker in the project(no markers or regions!).\nReturns -1 in case of no time-signature-markers available\nRETURNS:\nposition:the beatposition of the last timesig-marker in the project\nmeasureposition:the measureposition of the last timesig-marker in the project\nbeatposition:the beatposition of the last timesig-marker in the project\ntimesig_idx:the idx of the last timesig-marker in the project.\n",
        "body": "${1:local }${2:number position},${3:number measureposition},${4:number beatposition},${5:integer timesig_idx} = ultraschall.GetLastTimeSigMarkerPosition()$0"
    },
    "ULTRASCHALL.GETMARKERUPDATECOUNTER_WR lua": {
        "prefix": "ultraschallwr.GetMarkerUpdateCounter",
        "scope": "lua",
        "description": "returns the number of times, a marker in any project has been updated since Reaper started.\nCounts up, if a marker is added, set, moved, deleted from any project opened in Reaper.\nThis counter includes already closed projects as well\nRETURNS:\nmarker_update_counter:the number of times a marker in any project in Reaper has been updated\n",
        "body": "${1:local }${2:integer marker_update_counter} = ultraschall.GetMarkerUpdateCounter()$0"
    },
    "ULTRASCHALL.MOVETIMESIGMARKERSBY_WR lua": {
        "prefix": "ultraschallwr.MoveTimeSigMarkersBy",
        "scope": "lua",
        "description": "Moves time-signature-markers between startposition and endposition by moveby.\nDoes NOT move normal projectmarkers or regions!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\ncut_at_borders:shortens or cuts markers, that leave the section between startposition and endposition\nupdate_timeline:true, updates the timeline after moving time-signature markers; false, don't update timeline(must be done manually then)\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "${1:local }${2:integer retval} = ultraschall.MoveTimeSigMarkersBy(${3:number startposition},${4:number endposition},${5:number moveby},${6:boolean cut_at_borders},${7:boolean update_timeline})$0"
    },
    "ULTRASCHALL.GETALLTIMESIGMARKERS_WR lua": {
        "prefix": "ultraschallwr.GetAllTimeSigMarkers",
        "scope": "lua",
        "description": "Returns the number of Tempo/Time-Signature-Markers in the project, as well as an array with all attributes of all these markers.\nThe array is of the format: TimeSigArray[markernumber(1-based)][attribute-idx]\nwhere attribute-idx is\n1, number timepos\n2, number measurepos\n3, number beatpos\n4, number bpm\n5, number timesig_num\n6, number timesig_denom\n7, boolean lineartempo\nreturns -1 in case of error\nRETURNS:\nnum_timesig_markers:the number of time-signature-markers in the project\nTimeSigArray:an array with all time-signature-markers and all their attributes; see Description for more details\n",
        "body": "${1:local }${2:integer num_timesig_markers},${3:array TimeSigArray} = ultraschall.GetAllTimeSigMarkers()$0"
    },
    "ULTRASCHALL.MOVEMARKERSBY_WR lua": {
        "prefix": "ultraschallwr.MoveMarkersBy",
        "scope": "lua",
        "description": "Moves the markers between startposition and endposition by moveby.\nDoes NOT move regions and time-signature-markers!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\ncut_at_borders:shortens or cuts markers, that leave the section between startposition and endposition when applying moveby\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "${1:local }${2:integer retval} = ultraschall.MoveMarkersBy(${3:number startposition},${4:number endposition},${5:number moveby},${6:boolean cut_at_borders})$0"
    },
    "ULTRASCHALL.MOVEREGIONSBY_WR lua": {
        "prefix": "ultraschallwr.MoveRegionsBy",
        "scope": "lua",
        "description": "Moves the regions between startposition and endposition by moveby.\nWill affect only regions, who start within start and endposition. It will not affect those, who end within start and endposition but start before startposition.\nDoes NOT move markers and time-signature-markers!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\nmoveby:in seconds, negative values: move toward beginning of project, positive values: move toward the end of project\ncut_at_borders:shortens or cuts markers, that leave the section between startposition and endposition\nRETURNS:\nretval:-1 in case of failure\n",
        "body": "${1:local }${2:integer retval} = ultraschall.MoveRegionsBy(${3:number startposition},${4:number endposition},${5:number moveby},${6:boolean cut_at_borders})$0"
    },
    "ULTRASCHALL.RIPPLECUT_REGIONS_WR lua": {
        "prefix": "ultraschallwr.RippleCut_Regions",
        "scope": "lua",
        "description": "Ripplecuts regions, where applicable.\nIt cuts all (parts of) regions between startposition and endposition and moves remaining parts plus all regions after endposition by endposition-startposition toward projectstart.\nReturns false in case of an error.\nPARAMETERS:\nstartposition:the startposition from where regions shall be cut from\nendposition:the endposition to which regions shall be cut from; all regions/parts of regions after that will be moved toward projectstart\nRETURNS:\nwere_regions_altered:true, if regions were cut/altered; false, if not\nnumber_of_altered_regions:the number of regions that were altered/cut/moved\narray altered_regions:  altered_regions_array[index_of_region][8] - the new endposition\n",
        "body": "${1:local }${2:boolean were_regions_altered},${3:integer number_of_altered_regions},${4:array altered_regions} = ultraschall.RippleCut_Regions(${5:number startposition},${6:number endposition})$0"
    },
    "ULTRASCHALL.GETALLCUSTOMMARKERS_WR lua": {
        "prefix": "ultraschallwr.GetAllCustomMarkers",
        "scope": "lua",
        "description": "Will return all custom-markers with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not check custom-regions, use GetAllCustomRegions instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nRETURNS:\ncount:the number of found markers; -1, in case of an error\nmarker_array:an array with all found custom-markers. It follows the scheme:\n",
        "body": "${1:local }${2:integer count},${3:table marker_array} = ultraschall.GetAllCustomMarkers(${4:string custom_marker_name})$0"
    },
    "ULTRASCHALL.GETALLCUSTOMREGIONS_WR lua": {
        "prefix": "ultraschallwr.GetAllCustomRegions",
        "scope": "lua",
        "description": "Will return all custom-regions with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not check custom-markers, use GetAllCustomMarkers instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_region_name:the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called \"__CustomRegion::\"\nRETURNS:\ncount:the number of found regions; -1, in case of an error\n",
        "body": "${1:local }${2:integer count},${3:table marker_array} = ultraschall.GetAllCustomRegions(${4:string custom_region_name})$0"
    },
    "ULTRASCHALL.COUNTALLCUSTOMMARKERS_WR lua": {
        "prefix": "ultraschallwr.CountAllCustomMarkers",
        "scope": "lua",
        "description": "Will count all custom-markers with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not count custom-regions, use CountAllCustomRegions instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nRETURNS:\ncount:the number of found markers; -1, in case of an error\n",
        "body": "${1:local }${2:integer count} = ultraschall.CountAllCustomMarkers(${3:string custom_marker_name})$0"
    },
    "ULTRASCHALL.COUNTALLCUSTOMREGIONS_WR lua": {
        "prefix": "ultraschallwr.CountAllCustomRegions",
        "scope": "lua",
        "description": "Will count all custom-regions with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not count custom-markers, use CountAllCustomMarkers instead.\nreturns -1 in case of an error\nPARAMETERS:\ncustom_region_name:the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called \"__CustomRegion::\"\nRETURNS:\ncount:the number of found regions; -1, in case of an error\n",
        "body": "${1:local }${2:integer count} = ultraschall.CountAllCustomRegions(${3:string custom_region_name})$0"
    },
    "ULTRASCHALL.ENUMERATECUSTOMMARKERS_WR lua": {
        "prefix": "ultraschallwr.EnumerateCustomMarkers",
        "scope": "lua",
        "description": "Will return a specific custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not enumerate custom-regions, use EnumerateCustomRegions instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nidx:the index of the marker within all same-named custom-markers; 0, for the first custom-marker\nRETURNS:\nretval:true, if the custom-marker exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\n",
        "body": "${1:local }${2:boolean retval},${3:integer marker_index},${4:number pos},${5:string name},${6:integer shown_number},${7:integer color} = ultraschall.EnumerateCustomMarkers(${8:string custom_marker_name},${9:integer idx})$0"
    },
    "ULTRASCHALL.ENUMERATECUSTOMREGIONS_WR lua": {
        "prefix": "ultraschallwr.EnumerateCustomRegions",
        "scope": "lua",
        "description": "Will return a specific custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not enumerate custom-markers, use EnumerateCustomMarkers instead.\nreturns false in case of an error\nPARAMETERS:\nidx:the index of the region within all same-named custom-regions; 0, for the first custom-region\nRETURNS:\nretval:true, if the custom-region exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the region\nguid:the guid of the custom-region\n",
        "body": "${1:local }${2:boolean retval},${3:integer marker_index},${4:number pos},${5:number regionend},${6:string name},${7:integer shown_number},${8:integer color},${9:string guid} = ultraschall.EnumerateCustomRegions(${10:string custom_marker_name},${11:integer idx})$0"
    },
    "ULTRASCHALL.DELETECUSTOMMARKERS_WR lua": {
        "prefix": "ultraschallwr.DeleteCustomMarkers",
        "scope": "lua",
        "description": "Will delete a specific custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not delete custom-regions, use DeleteCustomRegions instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"\nidx:the index of the marker within all same-named custom-markers; 0, for the first custom-marker\nRETURNS:\nretval:true, if the custom-marker exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\n",
        "body": "${1:local }${2:boolean retval},${3:integer marker_index},${4:number pos},${5:string name},${6:integer shown_number},${7:integer color} = ultraschall.DeleteCustomMarkers(${8:string custom_marker_name},${9:integer idx})$0"
    },
    "ULTRASCHALL.DELETECUSTOMREGIONS_WR lua": {
        "prefix": "ultraschallwr.DeleteCustomRegions",
        "scope": "lua",
        "description": "Deletes a specific custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not delete custom-markers, use DeleteCustomMarkers instead.\nreturns false in case of an error\nPARAMETERS:\nidx:the index of the region within all same-named custom-regions; 0, for the first custom-region\nRETURNS:\nretval:true, if the custom-region exists; false, if not or an error occurred\nmarker_index:the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc\npos:the position of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the region\n",
        "body": "${1:local }${2:boolean retval},${3:integer marker_index},${4:number pos},${5:number regionend},${6:string name},${7:integer shown_number},${8:integer color} = ultraschall.DeleteCustomRegions(${9:string custom_marker_name},${10:integer idx})$0"
    },
    "ULTRASCHALL.ADDCUSTOMMARKER_WR lua": {
        "prefix": "ultraschallwr.AddCustomMarker",
        "scope": "lua",
        "description": "Will add new custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not add custom-regions, use AddCustomRegion instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"; nil, adds a normal marker\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if adding the custom-marker was successful; false, if not or an error occurred\nmarkernumber:the indexnumber of the newly added custommarker\nguid:the guid of the custommarker\n",
        "body": "${1:local }${2:boolean retval},${3:integer markernumber},${4:string guid} = ultraschall.AddCustomMarker(${5:string custom_marker_name},${6:number pos},${7:string name},${8:integer shown_number},${9:integer color})$0"
    },
    "ULTRASCHALL.ADDCUSTOMREGION_WR lua": {
        "prefix": "ultraschallwr.AddCustomRegion",
        "scope": "lua",
        "description": "Will add new custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not add custom-markers, use AddCustomMarker instead.\nreturns false in case of an error\nPARAMETERS:\npos:the position of the region in seconds\nregionend:the endposition of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if adding the custom-region was successful; false, if not or an error occurred\nshown_number:if the desired shown_number is already used by another region, this will hold the alternative number for the new custom-region\nguid:the guid of the customregion\n",
        "body": "${1:local }${2:boolean retval},${3:integer shown_number},${4:integer markerindex},${5:string guid} = ultraschall.AddCustomRegion(${6:string custom_region_name},${7:number pos},${8:number regionend},${9:string name},${10:integer shown_number},${11:integer color})$0"
    },
    "ULTRASCHALL.SETCUSTOMMARKER_WR lua": {
        "prefix": "ultraschallwr.SetCustomMarker",
        "scope": "lua",
        "description": "Will set attributes of an already existing custom-marker with a certain name.\nA custom-marker has the naming-scheme\n\\_customname: text for this marker\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-marker has the name\n\\_\\_customname:: test for this marker\nExample:\nThe custom-marker *VanillaChief* has the custom\\_marker\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-markers.\nWill not set custom-regions, use SetCustomRegion instead.\nreturns false in case of an error\nPARAMETERS:\ncustom_marker_name:the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called \"__CustomMarker::\"; nil, make it a normal marker\nidx:the index-number of the custom-marker within all custom-markers\npos:the position of the marker in seconds\nname:the name of the marker, exluding the custom-marker-name\nshown_number:the markernumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if setting the new attributes of the custom-marker was successful; false, if not or an error occurred\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetCustomMarker(${3:string custom_marker_name},${4:integer idx},${5:number pos},${6:string name},${7:integer shown_number},${8:integer color})$0"
    },
    "ULTRASCHALL.SETCUSTOMREGION_WR lua": {
        "prefix": "ultraschallwr.SetCustomRegion",
        "scope": "lua",
        "description": "Will set an already existing custom-region with a certain name.\nA custom-region has the naming-scheme\n\\_customname: text for this region\nYou just need to pass customname to this function, leaving out the preceding \\_ and the trailing :\nException: if the custom-region has the name\n\\_\\_customname:: test for this region\nExample:\nThe custom-region *VanillaChief* has the custom\\_region\\_name *VanillaChief* and will be shown as *\\_VanillaChief: text* in the project.\nSo you pass VanillaChief to this function to get all \\_VanillaChief:-regions.\nWill not add custom-markers, use AddCustomMarker instead.\nreturns false in case of an error, like the desired shown_number is already taken by another region\nPARAMETERS:\nidx:the index of the custom region to change\npos:the position of the region in seconds\nname:the name of the region, exluding the custom-region-name\nshown_number:the regionnumber, that is displayed in the timeline of the arrangeview\ncolor:the color of the marker\nRETURNS:\nretval:true, if adding the region was successful; false, if not or an error occurred\nshown_number:if the desired shown_number is already used by another region, this will hold the alternative number for the new custom-region\n",
        "body": "${1:local }${2:boolean retval},${3:integer shown_number} = ultraschall.SetCustomRegion(${4:string custom_region_name},${5:integer idx},${6:number pos},${7:number regionend},${8:string name},${9:integer shown_number},${10:integer color})$0"
    },
    "ULTRASCHALL.GETNEXTFREEREGIONINDEX_WR lua": {
        "prefix": "ultraschallwr.GetNextFreeRegionIndex",
        "scope": "lua",
        "description": "returns the next unused region-index-number, beginning with 0.\nRETURNS:\nfree_shown_number:the next free/unused region-index-number\n",
        "body": "${1:local }${2:integer free_shown_number} = ultraschall.GetNextFreeRegionIndex()$0"
    },
    "ULTRASCHALL.ISMARKERVALIDCUSTOMMARKER_WR lua": {
        "prefix": "ultraschallwr.IsMarkerValidCustomMarker",
        "scope": "lua",
        "description": "returns true, if the marker with id markeridx is a valid custom-marker of the type custom_marker_name\nmarkeridx is the index of all markers and regions!\nreturns false in case of an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsMarkerValidCustomMarker(${3:string custom_marker_name},${4:integer markeridx})$0"
    },
    "ULTRASCHALL.ISREGIONVALIDCUSTOMREGION_WR lua": {
        "prefix": "ultraschallwr.IsRegionValidCustomRegion",
        "scope": "lua",
        "description": "returns true, if the marker with id markeridx is a valid custom-region of the type custom_region_name\nmarkeridx is the index of all markers and regions!\nreturns false in case of an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsRegionValidCustomRegion(${3:string custom_region_name},${4:integer markeridx})$0"
    },
    "ULTRASCHALL.GETMARKERIDFROMGUID_WR lua": {
        "prefix": "ultraschallwr.GetMarkerIDFromGuid",
        "scope": "lua",
        "description": "Gets the corresponding indexnumber of a marker-guid\nThe index is for all markers and regions, inclusive and 1-based\nreturns -1 in case of an error\nPARAMETERS:\nguid:the guid of the marker/region, whose index-number you want to retrieve\nRETURNS:\nindex:the index of the marker/region, whose guid you have passed to this function\n",
        "body": "${1:local }${2:integer index} = ultraschall.GetMarkerIDFromGuid(${3:string guid})$0"
    },
    "ULTRASCHALL.GETGUIDFROMMARKERID_WR lua": {
        "prefix": "ultraschallwr.GetGuidFromMarkerID",
        "scope": "lua",
        "description": "Gets the corresponding marker-guid of a marker with a specific index\nThe index is for all markers and regions, inclusive and 1-based\nreturns -1 in case of an error\nPARAMETERS:\nindex:the index of the marker/region, whose guid you want to retrieve\nRETURNS:\nguid:the guid of the marker/region of the marker with a specific index\n",
        "body": "${1:local }${2:string guid} = ultraschall.GetGuidFromMarkerID(${3:integer index})$0"
    },
    "ULTRASCHALL.ISTIMESIGMARKERATPOSITION_WR lua": {
        "prefix": "ultraschallwr.IsTimeSigmarkerAtPosition",
        "scope": "lua",
        "description": "returns, if at position is a time-signature marker\nreturns false in case of an error\nPARAMETERS:\nposition:nil or 0, use position in seconds; 1, use position in measures\nposition_mode:nil or 0, use position in seconds; 1, use position in measures\nRETURNS:\nretval:true, marker found; false, marker not found\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsTimeSigmarkerAtPosition(${3:number position},${4:optional integer position_mode})$0"
    },
    "ULTRASCHALL.GETITEMPOSITION_WR lua": {
        "prefix": "ultraschallwr.GetItemPosition",
        "scope": "lua",
        "description": "Returns position-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nposition:the position in seconds, as set in the statechunk\n",
        "body": "${1:local }${2:number position} = ultraschall.GetItemPosition(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMLENGTH_WR lua": {
        "prefix": "ultraschallwr.GetItemLength",
        "scope": "lua",
        "description": "Returns length-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nlength:the length in seconds, as set in the statechunk\n",
        "body": "${1:local }${2:number length} = ultraschall.GetItemLength(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSNAPOFFSET_WR lua": {
        "prefix": "ultraschallwr.GetItemSnapOffset",
        "scope": "lua",
        "description": "Returns snapoffs-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nsnapoffset:the snapoffset in seconds, as set in the statechunk\n",
        "body": "${1:local }${2:number snapoffset} = ultraschall.GetItemSnapOffset(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMLOOP_WR lua": {
        "prefix": "ultraschallwr.GetItemLoop",
        "scope": "lua",
        "description": "Returns loopstate-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nloopstate:the loopstate, as set in the statechunk; 1, loop source; 0, don't loop source\n",
        "body": "${1:local }${2:integer loopstate} = ultraschall.GetItemLoop(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMALLTAKES_WR lua": {
        "prefix": "ultraschallwr.GetItemAllTakes",
        "scope": "lua",
        "description": "Returns alltakes-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nalltakes:Play all takes(1) or don't play all takes(0)\n",
        "body": "${1:local }${2:integer alltakes} = ultraschall.GetItemAllTakes(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMFADEIN_WR lua": {
        "prefix": "ultraschallwr.GetItemFadeIn",
        "scope": "lua",
        "description": "Returns fadein-entries of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nfadestate3:fadeinstate entry as set in the rppxml-mediaitem-statechunk\nfadestate5:fadeinstate entry as set in the rppxml-mediaitem-statechunk\n",
        "body": "${1:local }${2:number fadestate1},${3:number fadestate2},${4:number fadestate3},${5:number fadestate4},${6:integer fadestate5},${7:number fadestate6} = ultraschall.GetItemFadeIn(${8:MediaItem MediaItem},${9:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMFADEOUT_WR lua": {
        "prefix": "ultraschallwr.GetItemFadeOut",
        "scope": "lua",
        "description": "Returns fadeout-entries of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\ncurvetype1:the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype2\nfadeout_length:the fadeout-length in seconds; overrides fadeout_length and will be moved to fadeout_length when fadeout-length changes(e.g. mouse-drag); might be autocrossfade-length\nfadeout_length2:the fadeout-length in seconds; overrides fadeout_length and will be moved to fadeout_length when fadeout-length changes(e.g. mouse-drag); might be autocrossfade-length\ncurvetype2:the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype1\nfadestate5:unknown\ncurve:curvation of the fadeout, -1 to 1\n",
        "body": "${1:local }${2:number curvetype1},${3:number fadeout_length},${4:number fadeout_length2},${5:number curvetype2},${6:integer fadestate5},${7:number curve} = ultraschall.GetItemFadeOut(${8:MediaItem MediaItem},${9:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMFADEFLAG_WR lua": {
        "prefix": "ultraschallwr.GetItemFadeFlag",
        "scope": "lua",
        "description": "Returns autofade-entry of a MediaItem or MediaItemStateChunk.\nIt's the FADEFLAG-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nautofade_state:the autofade-state; 1, autofade is off; nil, autofade is on\n",
        "body": "${1:local }${2:integer autofade_state} = ultraschall.GetItemFadeFlag(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMIGUID_WR lua": {
        "prefix": "ultraschallwr.GetItemIGUID",
        "scope": "lua",
        "description": "Returns the IGUID-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nIGUID:the IGUID of the item\n",
        "body": "${1:local }${2:string IGUID} = ultraschall.GetItemIGUID(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMIID_WR lua": {
        "prefix": "ultraschallwr.GetItemIID",
        "scope": "lua",
        "description": "Returns the IID-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nIID:the IID of the item; the item-id, which is basically a counter of all items created within this project. May change, so use it only as a counter. If you want to identify a specific item, use GUID and IGUID instead.\n",
        "body": "${1:local }${2:integer IID} = ultraschall.GetItemIID(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMNAME_WR lua": {
        "prefix": "ultraschallwr.GetItemName",
        "scope": "lua",
        "description": "Returns the name-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nname:the name of the item\n",
        "body": "${1:local }${2:string name} = ultraschall.GetItemName(${3:MediaItem MediaItem},${4:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMVOLPAN_WR lua": {
        "prefix": "ultraschallwr.GetItemVolPan",
        "scope": "lua",
        "description": "Returns the vol/pan-entries of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nvolpan1:unknown\npan:unknown\nvolume:from 0(-inf) to 3.981072(+12db), 1 is 0db; higher numbers are allowed; negative means phase inverted\nvolpan4:unknown\n",
        "body": "${1:local }${2:number volpan1},${3:number pan},${4:number volume},${5:number volpan4} = ultraschall.GetItemVolPan(${6:MediaItem MediaItem},${7:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSAMPLEOFFSET_WR lua": {
        "prefix": "ultraschallwr.GetItemSampleOffset",
        "scope": "lua",
        "description": "Returns the sampleoffset-entry of a MediaItem or MediaItemStateChunk.\nIt's the SOFFS-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nsampleoffset:sampleoffset in seconds\n",
        "body": "${1:local }${2:number sampleoffset} = ultraschall.GetItemSampleOffset(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMPLAYRATE_WR lua": {
        "prefix": "ultraschallwr.GetItemPlayRate",
        "scope": "lua",
        "description": "Returns the playback-rate-entries of a MediaItem or MediaItemStateChunk.\nIt's the PLAYRATE-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nplaybackrate:1 is 1x, 2 is 2x, 1.8 is 1.8x,etc\npreserve_pitch:preserve pitch, 1 - preserve, 0 - don't preserve\npitch_adjust:pitch_adjust(semitones); negative values allowed; 1.1=1.1 semitones higher, -0.3=0.3 semitones lower,etc\ntakepitch_timestretch_mode:- the item's pitchmode - 65536 for project-default\noptimize_tonal_content:2, checkbox for optimize-tonal-content is set on; 0, checkbox for optimize-tonal-content is set off\nstretch_marker_fadesize:in milliseconds; negative values are allowed\n",
        "body": "${1:local }${2:number playbackrate},${3:integer preserve_pitch},${4:number pitch_adjust},${5:integer takepitch_timestretch_mode},${6:integer optimize_tonal_content},${7:number stretch_marker_fadesize} = ultraschall.GetItemPlayRate(${8:MediaItem MediaItem},${9:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMCHANMODE_WR lua": {
        "prefix": "ultraschallwr.GetItemChanMode",
        "scope": "lua",
        "description": "Returns the channelmode-entry of a MediaItem or MediaItemStateChunk.\nIt's the CHANMODE-entry\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nchannelmode:channelmode of the MediaItem\n",
        "body": "${1:local }${2:integer channelmode} = ultraschall.GetItemChanMode(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMGUID_WR lua": {
        "prefix": "ultraschallwr.GetItemGUID",
        "scope": "lua",
        "description": "Returns the GUID-entry of a MediaItem or MediaItemStateChunk.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nGUID:the GUID of the item\n",
        "body": "${1:local }${2:string GUID} = ultraschall.GetItemGUID(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMRECPASS_WR lua": {
        "prefix": "ultraschallwr.GetItemRecPass",
        "scope": "lua",
        "description": "Returns the recpass-entry of a MediaItem or MediaItemStateChunk.\nIt's the counter of the recorded item-takes within a project, ordered by the order of recording. Only displayed with recorded item-takes, not imported ones.\nIt's the RECPASS-entry.\nReturns nil in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nrecpass_state:the number of recorded mediaitem; every recorded item gets it's counting-number.\n",
        "body": "${1:local }${2:integer recpass_state} = ultraschall.GetItemRecPass(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMBEAT_WR lua": {
        "prefix": "ultraschallwr.GetItemBeat",
        "scope": "lua",
        "description": "Returns the beatstate/timebase-entry of a MediaItem or MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nbeatstate:the item-timebase state\n",
        "body": "${1:local }${2:integer beatstate} = ultraschall.GetItemBeat(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMMIXFLAG_WR lua": {
        "prefix": "ultraschallwr.GetItemMixFlag",
        "scope": "lua",
        "description": "Returns the item-mix-behavior-entry of a MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nitemmix_state:the item-mix-behavior\n",
        "body": "${1:local }${2:integer itemmix_state} = ultraschall.GetItemMixFlag(${3:MediaItem MediaItem},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMUSTRACKNUMBER_STATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetItemUSTrackNumber_StateChunk",
        "scope": "lua",
        "description": "Returns the tracknumber as well as the mediatrack-object from where the mediaitem was from, as given by a MediaItemStateChunk.\nThis works only, if the StateChunk contains the entry \"ULTRASCHALL_TRACKNUMBER\", which holds the original tracknumber of the MediaItem.\nThis entry will only be added by functions from the Ultraschall-API, like GetAllMediaItemsBetween\nReturns -1 in case of error.\nPARAMETERS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\ntracknumber:the tracknumber, where this item came from; starts with 1 for the first track!\ntrack:the accompanying track as MediaTrack-object\n",
        "body": "${1:local }${2:integer tracknumber},${3:MediaTrack track} = ultraschall.GetItemUSTrackNumber_StateChunk(${4:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMUSTRACKNUMBER_STATECHUNK_WR lua": {
        "prefix": "ultraschallwr.SetItemUSTrackNumber_StateChunk",
        "scope": "lua",
        "description": "Adds/Replaces the entry \"ULTRASCHALL_TRACKNUMBER\" in a MediaItemStateChunk, that tells other Ultraschall-Apifunctions, from which track this item originated from.\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\ntracknumber:the tracknumber you want to set, with 1 for track 1, 2 for track 2\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "${1:local }${2:string MediaItemStateChunk} = ultraschall.SetItemUSTrackNumber_StateChunk(${3:string MediaItemStateChunk},${4:integer tracknumber})$0"
    },
    "ULTRASCHALL.SETITEMPOSITION_WR lua": {
        "prefix": "ultraschallwr.SetItemPosition",
        "scope": "lua",
        "description": "Sets position in a MediaItem or MediaItemStateChunk in seconds.\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nposition:position in seconds\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "${1:local }${2:string MediaItemStateChunk} = ultraschall.SetItemPosition(${3:MediaItem MediaItem},${4:integer position},${5:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMLENGTH_WR lua": {
        "prefix": "ultraschallwr.SetItemLength",
        "scope": "lua",
        "description": "Sets length in a MediaItem and MediaItemStateChunk in seconds.\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nMediaItem:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nlength:length in seconds\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "${1:local }${2:string MediaItemStateChunk} = ultraschall.SetItemLength(${3:MediaItem MediaItem},${4:integer length},${5:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetItemStateChunk",
        "scope": "lua",
        "description": "Returns the statechunk of MediaItem. Parameter AddTracknumber allows you to set, whether the tracknumber of the MediaItem shall be inserted to the statechunk as well, by the new entry \"ULTRASCHALL_TRACKNUMBER\".\nreturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose statechunk you want to have\nAddTracknumber:nil or true; add the tracknumber, where the MediaItem lies, as additional entry entry \"ULTRASCHALL_TRACKNUMBER\" to the statechunk; false, just return the original statechunk.\nRETURNS:\nretval:true, if getting the statechunk was successful; false, if not\nMediaItemStateChunk:the statechunk of the MediaItem\n",
        "body": "${1:local }${2:boolean retval},${3:string MediaItemStateChunk} = ultraschall.GetItemStateChunk(${4:MediaItem MediaItem},${5:boolean AddTracknumber})$0"
    },
    "ULTRASCHALL.ISVALIDMEDIAITEMSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.IsValidMediaItemStateChunk",
        "scope": "lua",
        "description": "Checks, whether MediaItemStateChunk is a valide MediaItemStateChunk.\nReturns false in case of an error\nPARAMETERS:\nMediaItemStateChunk:the string to check, if it's a valid MediaItemStateChunk\nRETURNS:\nretval:true, MediaItemStateChunk is valid; false, MediaItemStateChunk isn't a valid statechunk\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidMediaItemStateChunk(${3:string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.CHECKMEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.CheckMediaItemArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemArray is valid.\nIt throws out all entries, that are not MediaItems and returns the altered array as result.\nreturns false in case of error or if it is not a valid MediaItemArray\nPARAMETERS:\nMediaItemArray:a MediaItemArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemArray is valid, false if not\ncount:the number of entries in the returned retMediaItemArray\nretMediaItemArray:the, possibly, altered MediaItemArray\n",
        "body": "${1:local }${2:boolean retval},${3:integer count},${4:array retMediaItemArray} = ultraschall.CheckMediaItemArray(${5:array MediaItemArray})$0"
    },
    "ULTRASCHALL.ISVALIDMEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.IsValidMediaItemArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemArray is valid.\nIt throws out all entries, that are not MediaItems and returns the altered array as result.\nreturns false in case of an error or if it is not a valid MediaItemArray\nPARAMETERS:\nMediaItemArray:a MediaItemArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemArray is valid, false if not\ncount:the number of entries in the returned retMediaItemArray\nretMediaItemArray:the, possibly, altered MediaItemArray\n",
        "body": "${1:local }${2:boolean retval},${3:integer count},${4:array retMediaItemArray} = ultraschall.IsValidMediaItemArray(${5:array MediaItemArray})$0"
    },
    "ULTRASCHALL.CHECKMEDIAITEMSTATECHUNKARRAY_WR lua": {
        "prefix": "ultraschallwr.CheckMediaItemStateChunkArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemStateChunkArray is valid.\nIt throws out all entries, that are not MediaItemStateChunks and returns the altered array as result.\nreturns false in case of an error or if it is not a valid MediaItemStateChunkArray\nPARAMETERS:\nMediaItemStateChunkArray:a MediaItemStateChunkArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemStateChunkArray is valid, false if not\ncount:the number of entries in the returned retMediaItemStateChunkArray\nretMediaItemStateChunkArray:the, possibly, altered MediaItemStateChunkArray\n",
        "body": "${1:local }${2:boolean retval},${3:integer count},${4:array retMediaItemStateChunkArray} = ultraschall.CheckMediaItemStateChunkArray(${5:array MediaItemStateChunkArray})$0"
    },
    "ULTRASCHALL.ISVALIDMEDIAITEMSTATECHUNKARRAY_WR lua": {
        "prefix": "ultraschallwr.IsValidMediaItemStateChunkArray",
        "scope": "lua",
        "description": "Checks, whether MediaItemStateChunkArray is valid.\nIt throws out all entries, that are not MediaItemStateChunks and returns the altered array as result.\nreturns false in case of an error or if it is not a valid MediaItemStateChunkArray\nPARAMETERS:\nMediaItemStateChunkArray:a MediaItemStateChunkArray that shall be checked for validity\nRETURNS:\nretval:returns true if MediaItemStateChunkArray is valid, false if not\ncount:the number of entries in the returned retMediaItemStateChunkArray\nretMediaItemStateChunkArray:the, possibly, altered MediaItemStateChunkArray\n",
        "body": "${1:local }${2:boolean retval},${3:integer count},${4:array retMediaItemStateChunkArray} = ultraschall.IsValidMediaItemStateChunkArray(${5:array MediaItemStateChunkArray})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSATPOSITION_WR lua": {
        "prefix": "ultraschallwr.GetMediaItemsAtPosition",
        "scope": "lua",
        "description": "Gets all Mediaitems at position, from the tracks given by trackstring.\nReturns a MediaItemArray with the found MediaItems\nreturns -1 in case of error\nPARAMETERS:\nposition:position in seconds\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nnumber_of_items:the number of items at position\nMediaItemArray:an array, that contains all MediaItems at position from the tracks given by trackstring.\nMediaItemStateChunkArray:an array, that contains all Mediaitem's MediaItemStatechunks at position from the tracks given by trackstring.\n",
        "body": "${1:local }${2:integer number_of_items},${3:array MediaItemArray},${4:array MediaItemStateChunkArray} = ultraschall.GetMediaItemsAtPosition(${5:number position},${6:string trackstring})$0"
    },
    "ULTRASCHALL.ONLYMEDIAITEMSOFTRACKSINTRACKSTRING_WR lua": {
        "prefix": "ultraschallwr.OnlyMediaItemsOfTracksInTrackstring",
        "scope": "lua",
        "description": "Throws all MediaItems out of the MediaItemArray, that are not within the tracks, as given with trackstring.\nReturns the \"cleared\" MediaItemArray\nreturns -1 in case of error\nPARAMETERS:\nMediaItemArray:an array with MediaItems; no nil-entries allowed, will be seen as the end of the array\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nMediaItemArray:the \"cleared\" array, that contains only Items in tracks, as given by trackstring, -1 in case of error\n",
        "body": "${1:local }${2:integer retval},${3:array MediaItemArray} = ultraschall.OnlyMediaItemsOfTracksInTrackstring(${4:array MediaItemArray},${5:string trackstring})$0"
    },
    "ULTRASCHALL.SPLITMEDIAITEMS_POSITION_WR lua": {
        "prefix": "ultraschallwr.SplitMediaItems_Position",
        "scope": "lua",
        "description": "Splits items at position, in the tracks given by trackstring.\nIf auto-crossfade is set in the Reaper-preferences, crossfade turns it on(true) or off(false).\nReturns false, in case of error.\nPARAMETERS:\nposition:the position in seconds\ntrackstring:the numbers for the tracks, where split shall be applied to; numbers separated by a comma\ncrossfade:true or nil, automatic crossfade(if enabled) will be applied; false, automatic crossfade is off\nRETURNS:\nretval:true - success, false - error\nMediaItemArray:an array with the items on the right side of the split\n",
        "body": "${1:local }${2:boolean retval},${3:array MediaItemArray} = ultraschall.SplitMediaItems_Position(${4:number position},${5:string trackstring},${6:boolean crossfade})$0"
    },
    "ULTRASCHALL.SPLITITEMSATPOSITIONFROMARRAY_WR lua": {
        "prefix": "ultraschallwr.SplitItemsAtPositionFromArray",
        "scope": "lua",
        "description": "Splits items in MediaItemArray at position, in the tracks given by trackstring.\nIf auto-crossfade is set in the Reaper-preferences, crossfade turns it on(true) or off(false).\nReturns false, in case of error.\nPARAMETERS:\nposition:the position in seconds\nMediaItemArray:an array with the items, where split shall be applied to. No nil-entries allowed!\ncrossfade:true - automatic crossfade(if enabled) will be applied; false - automatic crossfade is off\nRETURNS:\nretval:true - success, false - error\nMediaItemArray:an array with the items on the right side of the split\n",
        "body": "${1:local }${2:boolean retval},${3:array MediaItemArray} = ultraschall.SplitItemsAtPositionFromArray(${4:number position},${5:array MediaItemArray},${6:boolean crossfade})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEM_WR lua": {
        "prefix": "ultraschallwr.DeleteMediaItem",
        "scope": "lua",
        "description": "deletes a MediaItem. Returns true, in case of success, false in case of error.\nreturns the MediaItemStateChunk of the deleted MediaItem as well, so you can do additional processing with a deleted item.\nreturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem to be deleted\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\nMediaItemStateChunk:the StateChunk of the deleted MediaItem\n",
        "body": "${1:local }${2:boolean retval},${3:string MediaItemStateChunk} = ultraschall.DeleteMediaItem(${4:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEMSFROMARRAY_WR lua": {
        "prefix": "ultraschallwr.DeleteMediaItemsFromArray",
        "scope": "lua",
        "description": "deletes the MediaItems from MediaItemArray. Returns true, in case of success, false in case of error.\nIn addition, it returns a MediaItemStateChunkArray, that contains the statechunks of all deleted MediaItems\nreturns false in case of an error\nPARAMETERS:\nMediaItemArray:a array with MediaItem-objects to delete; no nil entries allowed\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\n",
        "body": "${1:local }${2:boolean retval},${3:array MediaItemArray} = ultraschall.DeleteMediaItemsFromArray(${4:array MediaItemArray})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEMS_POSITION_WR lua": {
        "prefix": "ultraschallwr.DeleteMediaItems_Position",
        "scope": "lua",
        "description": "Delete the MediaItems at given position, from the tracks as given by trackstring.\nreturns, if deleting was successful and an array with all statechunks of all deleted MediaItems\nreturns false in case of an error\nPARAMETERS:\nposition:the position in seconds\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\nMediaItemStateChunkArray:and array with all statechunks of all deleted MediaItems; \n",
        "body": "${1:local }${2:boolean retval},${3:array MediaItemStateChunkArray} = ultraschall.DeleteMediaItems_Position(${4:number position},${5:string trackstring})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSBETWEEN_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItemsBetween",
        "scope": "lua",
        "description": "Gets all MediaItems between startposition and endposition from the tracks as given by trackstring.\nSet inside to true to get only items, that are fully within the start and endposition, set it to false, if you also want items, that are just partially inside(end or just the beginning of the item).\nReturns the number of items, an array with all the MediaItems and an array with all the MediaItemStateChunks of the items, as used by functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nThe statechunks include a new element \"ULTRASCHALL_TRACKNUMBER\", which contains the tracknumber of where the item originally was in; important, if you delete the items as you'll otherwise loose this information!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntrackstring:the tracknumbers, separated by a comma\ninside:true, only items that are completely within selection; false, include items that are partially within selection\nRETURNS:\ncount:the number of found items\nMediaItemArray:an array with all the found MediaItems\nMediaItemStateChunkArray:an array with the MediaItemStateChunks, that can be used to create new items with InsertMediaItem_MediaItemStateChunk\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemArray},${4:array MediaItemStateChunkArray} = ultraschall.GetAllMediaItemsBetween(${5:number startposition},${6:number endposition},${7:string trackstring},${8:boolean inside})$0"
    },
    "ULTRASCHALL.MOVEMEDIAITEMSAFTER_BY_WR lua": {
        "prefix": "ultraschallwr.MoveMediaItemsAfter_By",
        "scope": "lua",
        "description": "Moves all items after old_position by change_position_by-seconds. Affects only items, that begin after oldposition, so items that start before and end after old_position do not move.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nchange_position_by:the change of the position in seconds; positive - toward the end of the project, negative - toward the beginning.\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MoveMediaItemsAfter_By(${3:number old_position},${4:number change_position_by},${5:string trackstring})$0"
    },
    "ULTRASCHALL.MOVEMEDIAITEMSBEFORE_BY_WR lua": {
        "prefix": "ultraschallwr.MoveMediaItemsBefore_By",
        "scope": "lua",
        "description": "Moves all items before old_position by change_position_by-seconds. Affects only items, that end before oldposition, so items that start before and end after old_position do not move.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nchange_position_by:the change of the position in seconds; positive - toward the end of the project, negative - toward the beginning.\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MoveMediaItemsBefore_By(${3:number old_position},${4:number change_position_by},${5:string trackstring})$0"
    },
    "ULTRASCHALL.MOVEMEDIAITEMSBETWEEN_TO_WR lua": {
        "prefix": "ultraschallwr.MoveMediaItemsBetween_To",
        "scope": "lua",
        "description": "Moves the items between sectionstart and sectionend to newposition, within the tracks given by trackstring.\nIf inside is set to true, only items completely within the section are moved; if set to false, also items are affected, that are just partially within the section.\nItems, that start after sectionstart, and therefore have an offset, will be moved to newposition+their offset. Keep that in mind.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nstartposition:begin of the item-selection in seconds\nendposition:end of the item-selection in seconds\nnewposition:new position in seconds\ntrackstring:the tracknumbers, separated by a ,\ninside:true, only items completely within the section; false, also items partially within the section\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MoveMediaItemsBetween_To(${3:number startposition},${4:number endposition},${5:number newposition},${6:string trackstring},${7:boolean inside})$0"
    },
    "ULTRASCHALL.CHANGELENGTHOFMEDIAITEMS_FROMARRAY_WR lua": {
        "prefix": "ultraschallwr.ChangeLengthOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the length of the MediaItems in MediaItemArray to newlength.\nThey will all be set to the new length, regardless of their old length. If you want to change the length of the items not >to< newlength, but >by< newlength, use ChangeDeltaLengthOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\nnewlength:the new length of the items in seconds\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ChangeLengthOfMediaItems_FromArray(${3:array MediaItemArray},${4:number newlength})$0"
    },
    "ULTRASCHALL.CHANGEDELTALENGTHOFMEDIAITEMS_FROMARRAY_WR lua": {
        "prefix": "ultraschallwr.ChangeDeltaLengthOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the length of the MediaItems in MediaItemArray by deltalength.\nIf you want to change the length of the items not >by< deltalength, but >to< deltalength, use ChangeLengthOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\ndeltalength:the change of the length of the items in seconds, positive value - longer, negative value - shorter\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ChangeDeltaLengthOfMediaItems_FromArray(${3:array MediaItemArray},${4:number deltalength})$0"
    },
    "ULTRASCHALL.CHANGEOFFSETOFMEDIAITEMS_FROMARRAY_WR lua": {
        "prefix": "ultraschallwr.ChangeOffsetOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the audio-offset of the MediaItems in MediaItemArray to newoffset.\nIt affects all(!) takes that the MediaItems has.\nIf you want to change the offset of the items not >to< newoffset, but >by< newoffset, use ChangeDeltaOffsetOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\nnewoffset:the new offset of the items in seconds\nRETURNS:\nretval:true, in case of success; false, in case of failure\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ChangeOffsetOfMediaItems_FromArray(${3:array MediaItemArray},${4:number newoffset})$0"
    },
    "ULTRASCHALL.CHANGEDELTAOFFSETOFMEDIAITEMS_FROMARRAY_WR lua": {
        "prefix": "ultraschallwr.ChangeDeltaOffsetOfMediaItems_FromArray",
        "scope": "lua",
        "description": "Changes the audio-offset of the MediaItems in MediaItemArray by deltaoffset.\nIt affects all(!) takes of the MediaItems have.\nIf you want to change the offset of the items not >by< deltaoffset, but >to< deltaoffset, use ChangeOffsetOfMediaItems_FromArray instead.\nReturns false in case of failure, true in case of success.\nPARAMETERS:\nMediaItemArray:an array with items to be changed. No nil entries allowed!\nRETURNS:\nretval:true in case of success; false in case of failure\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray(${3:array MediaItemArray},${4:number deltaoffset})$0"
    },
    "ULTRASCHALL.SECTIONCUT_WR lua": {
        "prefix": "ultraschallwr.SectionCut",
        "scope": "lua",
        "description": "Cuts out all items between startposition and endposition in the tracks given by trackstring.\nReturns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition of the section in seconds\nendposition:the endposition of the section in seconds\ntrackstring:the tracknumbers, separated by ,\nadd_to_clipboard:true, puts the cut items into the clipboard; false, don't put into the clipboard\nRETURNS:\nnumber_items:the number of cut items\nMediaItemArray_StateChunk:an array with the mediaitem-states of the cut items.\n",
        "body": "${1:local }${2:integer number_items},${3:array MediaItemArray_StateChunk} = ultraschall.SectionCut(${4:number startposition},${5:number endposition},${6:string trackstring},${7:boolean add_to_clipboard})$0"
    },
    "ULTRASCHALL.SECTIONCUT_INVERSE_WR lua": {
        "prefix": "ultraschallwr.SectionCut_Inverse",
        "scope": "lua",
        "description": "Cuts out all items before(!) startposition and after(!) endposition in the tracks given by trackstring; it keeps all items inbetween startposition and endposition.\nReturns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition of the section in seconds\nendposition:the endposition of the section in seconds\ntrackstring:the tracknumbers, separated by ,\nadd_to_clipboard:true, puts the cut items into the clipboard; false, don't put into the clipboard\nRETURNS:\nnumber_items_beforestart:the number of cut items before startposition\nMediaItemArray_StateChunk_beforestart:an array with the mediaitem-states of the cut items before startposition\nnumber_items_afterend:the number of cut items after endposition\nMediaItemArray_StateChunk_afterend:an array with the mediaitem-states of the cut items after endposition\n",
        "body": "${1:local }${2:integer number_items_beforestart},${3:array MediaItemArray_StateChunk_beforestart},${4:integer number_items_afterend},${5:array MediaItemArray_StateChunk_afterend} = ultraschall.SectionCut_Inverse(${6:number startposition},${7:number endposition},${8:string trackstring},${9:boolean add_to_clipboard})$0"
    },
    "ULTRASCHALL.RIPPLECUT_WR lua": {
        "prefix": "ultraschallwr.RippleCut",
        "scope": "lua",
        "description": "Cuts out all items between startposition and endposition in the tracks given by trackstring. After cut, it moves the remaining items after(!) endposition toward projectstart, by the difference between start and endposition.\nReturns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:the startposition of the section in seconds\nendposition:the endposition of the section in seconds\ntrackstring:the tracknumbers, separated by ,\nmoveenvelopepoints:moves envelopepoints, if existing, as well\nadd_to_clipboard:true, puts the cut items into the clipboard; false, don't put into the clipboard\nRETURNS:\nnumber_items:the number of cut items\nMediaItemArray_StateChunk:an array with the mediaitem-states of the cut items\n",
        "body": "${1:local }${2:integer number_items},${3:array MediaItemArray_StateChunk} = ultraschall.RippleCut(${4:number startposition},${5:number endposition},${6:string trackstring},${7:boolean moveenvelopepoints},${8:boolean add_to_clipboard})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEM_MEDIAITEM_WR lua": {
        "prefix": "ultraschallwr.InsertMediaItem_MediaItem",
        "scope": "lua",
        "description": "Inserts MediaItem in MediaTrack at position. Returns the newly created(or better: inserted) MediaItem as well as startposition, endposition and length of the inserted item.\nReturns -1 in case of failure.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItem:the MediaItem that shall be inserted into a track\nMediaTrack:the track, where the item shall be inserted to\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nMediaItem:the newly created MediaItem\nstartposition:the startposition of the inserted MediaItem in seconds\nendposition:the endposition of the inserted MediaItem in seconds\nlength:the length of the inserted MediaItem in seconds\n",
        "body": "${1:local }${2:integer retval},${3:MediaItem MediaItem},${4:number startposition},${5:number endposition},${6:number length} = ultraschall.InsertMediaItem_MediaItem(${7:number position},${8:MediaItem MediaItem},${9:MediaTrack MediaTrack})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEM_MEDIAITEMSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.InsertMediaItem_MediaItemStateChunk",
        "scope": "lua",
        "description": "Inserts a new MediaItem in MediaTrack at position. Uses a mediaitem-state-chunk as created by functions like GetAllMediaItemsBetween, reaper.GetItemStateChunk and reaper.SetItemStateChunk.. Returns the newly created MediaItem.\nReturns -1 in case of failure.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaTrack:the track, where the item shall be inserted to; nil, use the statechunk-entry ULTRASCHALL_TRACKNUMBER for the track instead.\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nMediaItem:the newly created MediaItem\nstartposition:the startposition of the inserted MediaItem in seconds\nendposition:the endposition of the inserted MediaItem in seconds\nlength:the length of the inserted MediaItem in seconds\n",
        "body": "${1:local }${2:integer retval},${3:MediaItem MediaItem},${4:number startposition},${5:number endposition},${6:number length} = ultraschall.InsertMediaItem_MediaItemStateChunk(${7:number position},${8:string MediaItemStateChunk},${9:MediaTrack MediaTrack})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.InsertMediaItemArray",
        "scope": "lua",
        "description": "Inserts the MediaItems from MediaItemArray at position into the tracks, as given by trackstring.\nReturns the number of newly created items, as well as an array with the newly create MediaItems.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemArray:an array with the MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nRETURNS:\nnumber_of_items:the number of MediaItems created\nMediaItemArray:an array with the newly created MediaItems\n",
        "body": "${1:local }${2:integer number_of_items},${3:array MediaItemArray} = ultraschall.InsertMediaItemArray(${4:number position},${5:array MediaItemArray},${6:string trackstring})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSTATECHUNKSFROMITEMS_WR lua": {
        "prefix": "ultraschallwr.GetMediaItemStateChunksFromItems",
        "scope": "lua",
        "description": "Returns the MediaItem-StateChunks for all MediaItems in MediaItemArray. It returns the number of items as well as an array, with each entry one MediaItemStateChunk.\nStateChunks are used by the reaper-functions reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nReturns -1 in case of failure.\nPARAMETERS:\nMediaItemArray:an array with the MediaItems you want the statechunks of\nRETURNS:\nnumber_of_items:the number of trackstatechunks, usually the same as MediaItems in MediaItemArray\nMediaItemArray_StateChunks:an array with the StateChunks of the MediaItems in MediaItemArray\n",
        "body": "${1:local }${2:integer number_of_items},${3:array MediaItemArray_StateChunks} = ultraschall.GetMediaItemStateChunksFromItems(${4:array MediaItemArray})$0"
    },
    "ULTRASCHALL.RIPPLEINSERT_WR lua": {
        "prefix": "ultraschallwr.RippleInsert",
        "scope": "lua",
        "description": "It inserts the MediaItems from MediaItemArray at position into the tracks, as given by trackstring. It moves the items, that were there before, accordingly toward the end of the project.\nReturns the number of newly created items, as well as an array with the newly created MediaItems and the endposition of the last(projectposition) inserted item into the project.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemArray:an array with the MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nmoveenvelopepoints:true, move the envelopepoints as well; false, keep the envelopepoints where they are\nmovemarkers:true, move markers as well; false, keep markers where they are\nRETURNS:\nnumber_of_items:the number of newly created items\nMediaItemArray:an array with the newly created MediaItems\nendpos_inserted_items:the endposition of the last newly inserted MediaItem\n",
        "body": "${1:local }${2:integer number_of_items},${3:array MediaItemArray},${4:number endpos_inserted_items} = ultraschall.RippleInsert(${5:number position},${6:array MediaItemArray},${7:string trackstring},${8:boolean moveenvelopepoints},${9:boolean movemarkers})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEMSTATECHUNKARRAY_WR lua": {
        "prefix": "ultraschallwr.InsertMediaItemStateChunkArray",
        "scope": "lua",
        "description": "Inserts the MediaItems from MediaItemStateChunkArray at position into the tracks, as given by trackstring.\nNote:Needs ULTRASCHALL_TRACKNUMBER within the statechunks, which includes the tracknumber for each mediaitem to be included. Else it will return -1. That entry will be included automatically into the MediaItemStateChunkArray as provided by GetAllMediaItemsBetween. If you need to manually insert that entry into a statechunk, use SetItemUSTRackNumber_StateChunk.\nReturns the number of newly created items, as well as an array with the newly create MediaItems.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from(or the tracks set with the entry ULTRASCHALL_TRACKNUMBER). Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemStateChunkArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemStateChunkArray:an array with the statechunks of the MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nRETURNS:\nnumber_of_items:the number of MediaItems created\nMediaItemArray:an array with the newly created MediaItems\n",
        "body": "${1:local }${2:integer number_of_items},${3:array MediaItemArray} = ultraschall.InsertMediaItemStateChunkArray(${4:number position},${5:array MediaItemStateChunkArray},${6:string trackstring})$0"
    },
    "ULTRASCHALL.RIPPLEINSERT_MEDIAITEMSTATECHUNKS_WR lua": {
        "prefix": "ultraschallwr.RippleInsert_MediaItemStateChunks",
        "scope": "lua",
        "description": "It inserts the MediaItems from MediaItemStateChunkArray at position into the tracks, as given by trackstring. It moves the items, that were there before, accordingly toward the end of the project.\nReturns the number of newly created items, as well as an array with the newly created MediaItems as statechunks and the endposition of the last(projectposition) inserted item into the project.\nReturns -1 in case of failure.\nNote: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.\nIf you have a MediaItemStateChunkArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.\nPARAMETERS:\nposition:the position of the newly created mediaitem\nMediaItemStateChunkArray:an array with the statechunks of MediaItems to be inserted\ntrackstring:the numbers of the tracks, separated by a ,\nmoveenvelopepoints:true, move the envelopepoints as well; false, keep the envelopepoints where they are\nmovemarkers:true, move markers as well; false, keep markers where they are\nRETURNS:\nnumber_of_items:the number of newly created items\nMediaItemStateChunkArray:an array with the newly created MediaItems as StateChunkArray\nendpos_inserted_items:the endposition of the last newly inserted MediaItem\n",
        "body": "${1:local }${2:integer number_of_items},${3:array MediaItemStateChunkArray},${4:number endpos_inserted_items} = ultraschall.RippleInsert_MediaItemStateChunks(${5:number position},${6:array MediaItemStateChunkArray},${7:string trackstring},${8:boolean moveenvelopepoints},${9:boolean movemarkers})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSFROMTRACK_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItemsFromTrack",
        "scope": "lua",
        "description": "returns the number of items of tracknumber, as well as an array with all MediaItems and an array with all MediaItemStateChunks\nreturns -1 in case of error\nPARAMETERS:\ntracknumber:the tracknumber, from where you want to get the item\nRETURNS:\nitemcount:the number of items in that track\nMediaItemArray:an array with all MediaItems from this track\nMediaItemStateChunkArray:an array with all MediaItemStateCunks from this track\n",
        "body": "${1:local }${2:integer itemcount},${3:array MediaItemArray},${4:array MediaItemStateChunkArray} = ultraschall.GetAllMediaItemsFromTrack(${5:integer tracknumber})$0"
    },
    "ULTRASCHALL.SETITEMSLOCKSTATE_WR lua": {
        "prefix": "ultraschallwr.SetItemsLockState",
        "scope": "lua",
        "description": "Sets the lockstate of the items in MediaItemArray. Set lockstate=true to set the items locked; false to set them unlocked.\nreturns true in case of success, false in case of error\nPARAMETERS:\nMediaItemArray:an array with the MediaItems to be processed\nlockstate:true, to set the MediaItems to locked, false to set them to unlocked\nRETURNS:\nretval:true in case of success, false in case of error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetItemsLockState(${3:array MediaItemArray},${4:boolean lockstate})$0"
    },
    "ULTRASCHALL.ADDLOCKSTATETOMEDIAITEMSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.AddLockStateToMediaItemStateChunk",
        "scope": "lua",
        "description": "Sets the lockstate in a MediaItemStateChunk. Set lockstate=true to set the chunk locked; false to set it unlocked.\nDoes not apply the changes to the MediaItem itself. To do that, use reaper.GetItemStateChunk or ApplyStateChunkToItems!\nreturns the changed MediaItemStateChunk\nreturns -1 in case of failure\nPARAMETERS:\nMediaItemStateChunk:the statechunk of the item to be processed, as returned by functions like reaper.GetItemStateChunk\nlockstate:true, to set the MediaItemStateChunk to locked, false to set it to unlocked\nRETURNS:\nchangedMediaItemStateChunk:the lockstate-modified MediaItemStateChunk\n",
        "body": "${1:local }${2:string changedMediaItemStateChunk} = ultraschall.AddLockStateToMediaItemStateChunk(${3:string MediaItemStateChunk},${4:boolean lockstate})$0"
    },
    "ULTRASCHALL.ADDLOCKSTATETO_MEDIAITEMSTATECHUNKARRAY_WR lua": {
        "prefix": "ultraschallwr.AddLockStateTo_MediaItemStateChunkArray",
        "scope": "lua",
        "description": "Sets the lockstates in a MediaItemStateChunkArray. Set lockstate=true to set the chunks locked; false to set them unlocked.\nDoes not apply the changes to the MediaItem itself. To do that, use reaper.GetItemStateChunk or ApplyStateChunkToItems!\nreturns the number of entries and the altered MediaItemStateChunkArray; -1 in case of failure\nPARAMETERS:\nMediaItemStateChunkArray:the statechunkarray of the items to be processed, as returned by functions like reaper.GetItemStateChunk\nlockstate:true, to set the MediaItemStateChunk to locked, false to set it to unlocked\nRETURNS:\ncount:the number of entries in the changed MediaItemStateChunkArray\nchangedMediaItemStateChunkArray:the lockstate-modified MediaItemStateChunkArray\n",
        "body": "${1:local }${2:integer count},${3:array changedMediaItemStateChunkArray} = ultraschall.AddLockStateTo_MediaItemStateChunkArray(${4:array MediaItemStateChunkArray},${5:boolean lockstate})$0"
    },
    "ULTRASCHALL.APPLYSTATECHUNKTOITEMS_WR lua": {
        "prefix": "ultraschallwr.ApplyStateChunkToItems",
        "scope": "lua",
        "description": "Applies changed StateChunks to the respective items. Skips deleted items, as they can't be set.\nIt will look into the IGUID-entry of the statechunks, to find the right corresponding MediaItem to apply the statechunk to.\nreturns the number of entries and the altered MediaItemStateChunkArray; -1 in case of failure\nPARAMETERS:\nMediaItemStateChunkArray:the statechunkarray of the items to be applied, as returned by functions like reaper.GetItemStateChunk\nundostate:true, sets the changed undo-possible, false undo-impossible\nRETURNS:\nretval:true it worked, false it didn't\nskippeditemscount:the number of entries that couldn't be applied\nskipped_MediaItemStateChunkArray:the StateChunks, that couldn't be aplied\n",
        "body": "${1:local }${2:boolean retval},${3:integer skippeditemscount},${4:array skipped_MediaItemStateChunkArray} = ultraschall.ApplyStateChunkToItems(${5:array MediaItemStateChunkArray},${6:boolean undostate})$0"
    },
    "ULTRASCHALL.GETALLLOCKEDITEMSFROMMEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.GetAllLockedItemsFromMediaItemArray",
        "scope": "lua",
        "description": "Returns the number and the items that are locked, as well as the number and the items that are NOT locked.\nThe items are returned as MediaItemArrays\nreturns -1 in case of failure\nPARAMETERS:\nMediaItemArray:the statechunkarray of the items to be checked.\nRETURNS:\ncountlock:the number of locked items. -1 in case of failure\nlocked_MediaItemArray:the un(!)locked items in a mediaitemarray\ncountunlock:the number of un(!)locked items\nunlocked_MediaItemArray:the un(!)locked items in a mediaitemarray\n",
        "body": "${1:local }${2:integer countlock},${3:array locked_MediaItemArray},${4:integer countunlock},${5:array unlocked_MediaItemArray} = ultraschall.GetAllLockedItemsFromMediaItemArray(${6:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSTATECHUNKSFROMMEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.GetMediaItemStateChunksFromMediaItemArray",
        "scope": "lua",
        "description": "Returns the number of items and statechunks of the Items in MediaItemArray. It skips items in MediaItemArray, that are deleted.\nreturns -1 in case of failure\nPARAMETERS:\nMediaItemArray:the statechunkarray of the items to be checked.\nRETURNS:\ncount:the number of statechunks returned. -1 in case of failure\nMediaItemStateChunkArray:the statechunks of the items in mediaitemarray\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemStateChunkArray} = ultraschall.GetMediaItemStateChunksFromMediaItemArray(${4:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETSELECTEDMEDIAITEMSATPOSITION_WR lua": {
        "prefix": "ultraschallwr.GetSelectedMediaItemsAtPosition",
        "scope": "lua",
        "description": "Returns all selected items at position in the tracks as given by trackstring, as MediaItemArray. Empty MediaItemAray if none is found.\nreturns -1 in case of error\nPARAMETERS:\nposition:position in seconds\ntrackstring:the tracknumbers, separated by commas\nRETURNS:\ncount:the number of entries in the returned MediaItemArray\nMediaItemArray:the found MediaItems returned as an array\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemArray},${4:array MediaItemStateChunkArray} = ultraschall.GetSelectedMediaItemsAtPosition(${5:number position},${6:string trackstring})$0"
    },
    "ULTRASCHALL.GETSELECTEDMEDIAITEMSBETWEEN_WR lua": {
        "prefix": "ultraschallwr.GetSelectedMediaItemsBetween",
        "scope": "lua",
        "description": "Returns all selected items between startposition and endposition in the tracks as given by trackstring, as MediaItemArray. Empty MediaItemAray if none is found.\nreturns -1 in case of error\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntrackstring:the tracknumbers, separated by commas\ninside:true, only items completely within start/endposition; false, also items, that are partially within start/endposition\nRETURNS:\ncount:the number of entries in the returned MediaItemArray\nMediaItemArray:the found MediaItems returned as an array\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemArray} = ultraschall.GetSelectedMediaItemsBetween(${4:number startposition},${5:number endposition},${6:string trackstring},${7:boolean inside})$0"
    },
    "ULTRASCHALL.DESELECTMEDIAITEMS_MEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.DeselectMediaItems_MediaItemArray",
        "scope": "lua",
        "description": "Deselects all MediaItems, that are in MediaItemArray.\nreturns -1 in case of error\nPARAMETERS:\nMediaItemArray:an array with all the MediaItemObjects, that shall be deselected\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.DeselectMediaItems_MediaItemArray(${3:array MediaItemArray})$0"
    },
    "ULTRASCHALL.SELECTMEDIAITEMS_MEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.SelectMediaItems_MediaItemArray",
        "scope": "lua",
        "description": "Selects all MediaItems, that are in MediaItemArray.\nreturns -1 in case of error\nPARAMETERS:\nMediaItemArray:an array with all the MediaItemObjects, that shall be selected\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SelectMediaItems_MediaItemArray(${3:array MediaItemArray})$0"
    },
    "ULTRASCHALL.ENUMERATEMEDIAITEMSINTRACK_WR lua": {
        "prefix": "ultraschallwr.EnumerateMediaItemsInTrack",
        "scope": "lua",
        "description": "returns the itemnumberth MediaItemobject in track, the number of items in tracknumber and an array with all MediaItems from this track.\nreturns -1 in case of error\nPARAMETERS:\ntracknumber:the tracknumber, from where you want to get the item\nitemnumber:the itemnumber within that track. 1 for the first, 2 for the second, etc\nRETURNS:\nitem:the number of items in that track\nitemcount:the number of items in that track\nMediaItemArray:an array with all MediaItems from this track\n",
        "body": "${1:local }${2:MediaItem item},${3:integer itemcount},${4:array MediaItemArray} = ultraschall.EnumerateMediaItemsInTrack(${5:integer tracknumber},${6:integer itemnumber})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMARRAYLENGTH_WR lua": {
        "prefix": "ultraschallwr.GetMediaItemArrayLength",
        "scope": "lua",
        "description": "Returns the beginning of the first item, the end of the last item as well as the length between start and end of all items within the MediaItemArray.\nWill return -1, in case of error\nPARAMETERS:\nMediaItemArray:an array with MediaItems, as returned by functions like GetAllMediaItemsBetween or GetMediaItemsAtPosition or similar.\nRETURNS:\nstart:the beginning of the earliest item in the MediaItemArray in seconds\nend:the end of the latest item in the MediaItemArray, timewise, in seconds\nlength:the length of the MediaItemArray in seconds\n",
        "body": "${1:local }${2:integer start},${3:integer end},${4:integer length} = ultraschall.GetMediaItemArrayLength(${5:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMSTATECHUNKARRAYLENGTH_WR lua": {
        "prefix": "ultraschallwr.GetMediaItemStateChunkArrayLength",
        "scope": "lua",
        "description": "Returns the beginning of the first item, the end of the last item as well as the length between start and end of all items within the MediaItemStateChunkArray.\nWill return -1, in case of error\nPARAMETERS:\nMediaItemStateChunkArray:an array with MediaItemStateChunks, as returned by functions like GetAllMediaItemsBetween or GetMediaItemsAtPosition or similar.\nRETURNS:\nstart:the beginning of the earliest item in the MediaItemArray in seconds\nend:the end of the latest item in the MediaItemArray, timewise, in seconds\nlength:the length of the MediaItemArray in seconds\n",
        "body": "${1:local }${2:integer start},${3:integer end},${4:integer length} = ultraschall.GetMediaItemStateChunkArrayLength(${5:array MediaItemStateChunkArray})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMGUIDS_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItemGUIDs",
        "scope": "lua",
        "description": "Returns an array with all MediaItem-GUIDs in order of the MediaItems-count(1 for first MediaItem, etc).\nReturns nil in case of an error\n",
        "body": "${1:local }${2:table GUID_Array},${3:integer count_of_GUID} = ultraschall.GetAllMediaItemGUIDs()$0"
    },
    "ULTRASCHALL.GETITEMSPECTRALCONFIG_WR lua": {
        "prefix": "ultraschallwr.GetItemSpectralConfig",
        "scope": "lua",
        "description": "returns the item-spectral-config, which is the fft-size of the spectral view for this item.\nset itemidx to -1 to use the optional parameter MediaItemStateChunk to alter a MediaItemStateChunk instead of an item directly.\nreturns -1 in case of error or nil if no spectral-config exists(e.g. when no spectral-edit is applied to this item)\nPARAMETERS:\nitemidx:the number of the item, with 1 for the first item, 2 for the second, etc.; -1, to use the parameter MediaItemStateChunk\nMediaItemStateChunk:you can give a MediaItemStateChunk to process, if itemidx is set to -1\nRETURNS:\nitem_spectral_config:the fft-size in points for the spectral-view; 16, 32, 64, 128, 256, 512, 1024(default), 2048, 4096, 8192; -1, if not existing\n",
        "body": "${1:local }${2:integer item_spectral_config} = ultraschall.GetItemSpectralConfig(${3:integer itemidx},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMSPECTRALCONFIG_WR lua": {
        "prefix": "ultraschallwr.SetItemSpectralConfig",
        "scope": "lua",
        "description": "sets the item-spectral-config, which is the fft-size of the spectral view for this item.\nreturns false in case of error or if no spectral-config exists(e.g. when no spectral-edit is applied to this item)\nPARAMETERS:\nitemidx:the number of the item, with 1 for the first item, 2 for the second, etc.; -1, if you want to use the optional parameter MediaItemStateChunk\nitem_spectral_config:the fft-size in points for the spectral-view; 16, 32, 64, 128, 256, 512, 1024(default), 2048, 4096, 8192; nil, to remove it\nMediaItemStateChunk:a MediaItemStateChunk you want to have altered; works only, if itemdidx is set to -1, otherwise it will be ignored\nRETURNS:\nretval:true, if setting spectral-config worked; false, if not\nMediaItemStateChunk:the altered MediaItemStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string MediaItemStateChunk} = ultraschall.SetItemSpectralConfig(${4:integer itemidx},${5:integer item_spectral_config},${6:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.COUNTITEMSPECTRALEDITS_WR lua": {
        "prefix": "ultraschallwr.CountItemSpectralEdits",
        "scope": "lua",
        "description": "counts the number of SPECTRAL_EDITs in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns -1 in case of error\nPARAMETERS:\nitemidx:the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\ncount:the number of spectral-edits available in a given MediaItem/MediaItemStateChunk\n",
        "body": "${1:local }${2:integer count} = ultraschall.CountItemSpectralEdits(${3:integer itemidx},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSPECTRALEDIT_WR lua": {
        "prefix": "ultraschallwr.GetItemSpectralEdit",
        "scope": "lua",
        "description": "returns the settings of a specific SPECTRAL_EDIT in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns -1 in case of error\nPARAMETERS:\nitemidx:the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead\nspectralidx:the number of the spectral-edit to return; 1 for the first, 2 for the second, etc\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\nstart_pos:the startposition of the spectral-edit-region in seconds\nlength:the length of the spectral-edit-region in seconds\ngain:the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB\nfade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_range_bottom:the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nfreq_range_top:the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\nbyp_solo:sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo\ngate_thres:sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)\ngate_floor:sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)\ncomp_thresh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\ncomp_exp_ratio:sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default\nn:negative with low frequency-fade, positive with high-frequency-fade\no:unknown\nfade2:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade2:negative with low frequency-fade, positive with high-frequency-fade\n",
        "body": "${1:local }${2:number start_pos},${3:number length},${4:number gain},${5:number fade},${6:number freq_fade},${7:number freq_range_bottom},${8:number freq_range_top},${9:integer h},${10:integer byp_solo},${11:number gate_thres},${12:number gate_floor},${13:number comp_thresh},${14:number comp_exp_ratio},${15:number n},${16:number o},${17:number fade2},${18:number freq_fade2} = ultraschall.GetItemSpectralEdit(${19:integer itemidx},${20:integer spectralidx},${21:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.DELETEITEMSPECTRALEDIT_WR lua": {
        "prefix": "ultraschallwr.DeleteItemSpectralEdit",
        "scope": "lua",
        "description": "deletes a specific SPECTRAL_EDIT in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns false in case of error\nPARAMETERS:\nitemidx:the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead\nspectralidx:the number of the spectral-edit to delete; 1 for the first, 2 for the second, etc\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\nretval:true, if deleting an spectral-edit-entry was successful; false, if it was unsuccessful\nMediaItemStateChunk:the altered MediaItemStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string MediaItemStateChunk} = ultraschall.DeleteItemSpectralEdit(${4:integer itemidx},${5:integer spectralidx},${6:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMSPECTRALVISIBILITYSTATE_WR lua": {
        "prefix": "ultraschallwr.SetItemSpectralVisibilityState",
        "scope": "lua",
        "description": "Sets SPECTROGRAM-state in a MediaItem or MediaItemStateChunk.\nSetting it shows the spectrogram, in which you can do spectral-editing, as selected in the MediaItem-menu \"Spectral-editing -> Toggle show spectrogram for selected items\"\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nitemidx:the number of the item in the project; use -1 to use MediaItemStateChunk instead\nstate:the state of the SPECTROGRAM; 0, to hide SpectralEdit; 1, to set SpectralEdit visible\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk; only read, when itemidx=-1\nRETURNS:\nMediaItemStateChunk:the altered rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "${1:local }${2:string MediaItemStateChunk} = ultraschall.SetItemSpectralVisibilityState(${3:integer itemidx},${4:integer state},${5:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.SETITEMSPECTRALEDIT_WR lua": {
        "prefix": "ultraschallwr.SetItemSpectralEdit",
        "scope": "lua",
        "description": "Sets a spectral-edit-instance in a MediaItem or MediaItemStateChunk.\nAfter committing the changed MediaItemStateChunk to a MediaItem, Reaper may change the order of the spectral-edits! Keep that in mind, when changing numerous Spectral-Edits or use MediaItemStateChunks for the setting before committing them to a MediaItem using Reaper's function reaper.SetItemStateChunk().\nIt returns the modified MediaItemStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nitemidx:the number of the item in the project; use -1 to use MediaItemStateChunk instead\nspectralidx:the number of the spectral-edit-instance, that you want to set\nstart_pos:the startposition of the spectral-edit-region in seconds\nlength:the length of the spectral-edit-region in seconds\ngain:the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB\nfade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_range_bottom:the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nfreq_range_top:the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nh:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nbyp_solo:sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo\ngate_thres:sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)\ngate_floor:sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)\ncomp_thresh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\ncomp_exp_ratio:sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default\nn:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\no:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nfade2:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade2:negative with low frequency-fade, positive with high-frequency-fade\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\nRETURNS:\nMediaItemStateChunk:an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk\n",
        "body": "${1:local }${2:string MediaItemStateChunk} = ultraschall.SetItemSpectralEdit(${3:integer itemidx},${4:integer spectralidx},${5:number start_pos},${6:number length},${7:number gain},${8:number fade},${9:number freq_fade},${10:number freq_range_bottom},${11:number freq_range_top},${12:integer h},${13:integer byp_solo},${14:number gate_thres},${15:number gate_floor},${16:number comp_thresh},${17:number comp_exp_ratio},${18:number n},${19:number o},${20:number fade2},${21:number freq_fade2},${22:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSOURCEFILE_TAKE_WR lua": {
        "prefix": "ultraschallwr.GetItemSourceFile_Take",
        "scope": "lua",
        "description": "returns filename, the PCM_Source-object and the MediaItem_Take-object of a specific take. Use take_nr=0 for active take.\nreturns nil in case of error\nPARAMETERS:\nMediaItem:the MediaItem-object, in which the requested take lies\ntake_nr:the number of the requested take; use 0 for the active take\nRETURNS:\nsource_filename:the filename of the requested take\nsource:the PCM_source-object of the requested take\ntake:the Media-Item_Take-object of the requested take\n",
        "body": "${1:local }${2:string source_filename},${3:PCM_source source},${4:MediaItem_Take take} = ultraschall.GetItemSourceFile_Take(${5:MediaItem MediaItem},${6:integer take_nr})$0"
    },
    "ULTRASCHALL.ADDITEMSPECTRALEDIT_WR lua": {
        "prefix": "ultraschallwr.AddItemSpectralEdit",
        "scope": "lua",
        "description": "Adds a new SPECTRAL_EDIT-entry in a given MediaItem/MediaItemStateChunk.\nThe SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.\nIf itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.\nreturns false in case of error\nPARAMETERS:\nitemidx:the MediaItem to add to another spectral-edit-entry; -1, to use the parameter MediaItemStateChunk instead\nstart_pos:the startposition of the spectral-edit-region in seconds\nlength:the length of the spectral-edit-region in seconds\ngain:the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB\nfade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade:negative with low frequency-fade, positive with high-frequency-fade\nfreq_range_bottom:the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nfreq_range_top:the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)\nh:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nbyp_solo:sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo\ngate_thres:sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)\ngate_floor:sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)\ncomp_thresh:sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default\ncomp_exp_ratio:sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default\nn:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\no:unknown\nfade2:negative with low frequency-fade, positive with high-frequency-fade\nfreq_fade2:negative with low frequency-fade, positive with high-frequency-fade\nMediaItemStateChunk:if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored\nRETURNS:\nretval:true, if adding was successful; false, if adding wasn't successful\nstatechunk:the altered MediaItemStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:MediaItemStateChunk statechunk} = ultraschall.AddItemSpectralEdit(${4:integer itemidx},${5:number start_pos},${6:number length},${7:number gain},${8:number fade},${9:number freq_fade},${10:number freq_range_bottom},${11:number freq_range_top},${12:integer h},${13:integer byp_solo},${14:number gate_thres},${15:number gate_floor},${16:number comp_thresh},${17:number comp_exp_ratio},${18:number n},${19:number o},${20:number fade2},${21:number freq_fade2},${22:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.GETITEMSPECTRALVISIBILITYSTATE_WR lua": {
        "prefix": "ultraschallwr.GetItemSpectralVisibilityState",
        "scope": "lua",
        "description": "returns, if spectral-editing is shown in the arrange-view of item itemidx\nset itemidx to -1 to use the optional parameter MediaItemStateChunk to alter a MediaItemStateChunk instead of an item directly.\nreturns -1 in case of error\nPARAMETERS:\nitemidx:the number of the item, with 1 for the first item, 2 for the second, etc.; -1, to use the parameter MediaItemStateChunk\nMediaItemStateChunk:you can give a MediaItemStateChunk to process, if itemidx is set to -1\n",
        "body": "${1:local }${2:integer spectrogram_state} = ultraschall.GetItemSpectralVisibilityState(${3:integer itemidx},${4:optional string MediaItemStateChunk})$0"
    },
    "ULTRASCHALL.INSERTIMAGEFILE_WR lua": {
        "prefix": "ultraschallwr.InsertImageFile",
        "scope": "lua",
        "description": "Inserts a supported image-file into your project.\nDue API-limitations, it creates two undo-points(one for inserting the MediaItem and one for changing the length).\nReturns false in case of an error\nPARAMETERS:\nfilename_with_path:the file to check for it's image-fileformat\ntrack:the track, in which the image shall be inserted\nposition:the position of the inserted image in seconds\nlength:the length of the image-item in seconds; 1, for the default length of 1 second\nlooped:true, loop the inserted image-file; false, don't loop the inserted image-file\nRETURNS:\nretval:true, if inserting was successful; false, if inserting was unsuccessful\nitem:the MediaItem of the newly inserted image\n",
        "body": "${1:local }${2:boolean retval},${3:MediaItem item} = ultraschall.InsertImageFile(${4:string filename_with_path},${5:integer track},${6:number position},${7:number length},${8:boolean looped})$0"
    },
    "ULTRASCHALL.GETALLSELECTEDMEDIAITEMS_WR lua": {
        "prefix": "ultraschallwr.GetAllSelectedMediaItems",
        "scope": "lua",
        "description": "Returns all selected items in the project as MediaItemArray. Empty MediaItemAray if none is found.\nRETURNS:\ncount:the number of entries in the returned MediaItemArray\nMediaItemArray:all selected MediaItems returned as an array\nMediaItemStateChunkArray:the statechunks of all found MediaItems as an array\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemArray},${4:array MediaItemStateChunkArray} = ultraschall.GetAllSelectedMediaItems()$0"
    },
    "ULTRASCHALL.GETPARENTTRACK_MEDIAITEM_WR lua": {
        "prefix": "ultraschallwr.GetParentTrack_MediaItem",
        "scope": "lua",
        "description": "Returns the tracknumber and the MediaTrack-object of the track in which the MediaItem is placed.\nreturns -1 in case of error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to know the track is is placed in\nRETURNS:\ntracknumber:the tracknumber of the track, in which the MediaItem is placed; 1 for track 1, 2 for track 2, etc\nmediatrack:the MediaTrack-object of the track, in which the MediaItem is placed\n",
        "body": "${1:local }${2:integer tracknumber},${3:MediaTrack mediatrack} = ultraschall.GetParentTrack_MediaItem(${4:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.ISITEMINTRACK2_WR lua": {
        "prefix": "ultraschallwr.IsItemInTrack2",
        "scope": "lua",
        "description": "Checks, whether a MediaItem is in track with tracknumber.\nsee IsItemInTrack to use itemidx instead of the MediaItem-object.\nsee IsItemInTrack3 to check against multiple tracks at once using a trackstring.\nreturns nil in case of error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to know the track is is placed in\ntracknumber:the tracknumber to check the parent track of the MediaItem against, with 1 for track 1, etc\nRETURNS:\nretval:true, if item is in track; false, if not\ntracknumber:the tracknumber of the track, in which the item lies\n",
        "body": "${1:local }${2:boolean retval},${3:integer tracknumber} = ultraschall.IsItemInTrack2(${4:MediaItem MediaItem},${5:integer tracknumber})$0"
    },
    "ULTRASCHALL.ISITEMINTIMERANGE_WR lua": {
        "prefix": "ultraschallwr.IsItemInTimerange",
        "scope": "lua",
        "description": "checks, whether a given MediaItem is within startposition and endposition and returns the result.\nreturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem to check for, if it's within the timerange\nendposition:the endtime of the timerange, in which the MediaItem must be, in seconds\ninside:true, MediaItem must be fully within timerange; false, MediaItem can be partially inside timerange\nRETURNS:\nretval:true, item is in timerange; false, item isn't in timerange\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsItemInTimerange(${3:MediaItem MediaItem},${4:number startposiiton},${5:number endposition},${6:boolean inside})$0"
    },
    "ULTRASCHALL.ONLYITEMSINTRACKSANDTIMERANGE_WR lua": {
        "prefix": "ultraschallwr.OnlyItemsInTracksAndTimerange",
        "scope": "lua",
        "description": "Removes all items from MediaItemArray, that aren't in tracks, as given by trackstring and are outside the timerange(starttime to endtime).\nreturns -1 in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, that shall be checked for trackexistence and timerange\ntrackstring:a string with all requested tracknumbers in which the MediaItem must be, separated by commas; 1 for track 1, 2 for track 2, etc\nstarttime:the starttime of the timerange, in which the MediaItem must be, in seconds\nendtime:the endtime of the timerange, in which the MediaItem must be, in seconds\ninside:true, only MediaItems are returned, that are fully within starttime and endtime; false, return also MediaItems partially in timerange\nRETURNS:\ncount:the number of items that fit the requested tracks and timerange\nMediaItemArray:the altered MediaItemArray, that has only the MediaItems from tracks as requested by trackstring and from within timerange\n",
        "body": "${1:local }${2:integer count},${3:MediaItemArray MediaItemArray} = ultraschall.OnlyItemsInTracksAndTimerange(${4:MediaItemArray MediaItemArray},${5:string trackstring},${6:number starttime},${7:number endtime},${8:boolean inside})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOMEDIAITEM_WR lua": {
        "prefix": "ultraschallwr.ApplyActionToMediaItem",
        "scope": "lua",
        "description": "Applies an action to a MediaItem, in either main or MIDI-Editor section-context.\nThe action given must support applying itself to selected items.\nReturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, to whom the action shall be applied to\nactioncommandid:the commandid-number or ActionCommandID, that shall be run.\nrepeat_action:the number of times this action shall be applied to each item; minimum value is 1\nmidi:true, run an action from MIDI-Editor-section-context; false, run an action from the main section\nMIDI_hwnd:the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one\nRETURNS:\nretval:true, if running the action was successful; false, if not or an error occured\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyActionToMediaItem(${3:MediaItem MediaItem},${4:string actioncommandid},${5:integer repeat_action},${6:boolean midi},${7:optional HWND MIDI_hwnd})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOMEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.ApplyActionToMediaItemArray",
        "scope": "lua",
        "description": "Applies an action to the MediaItems in MediaItemArray, in either main or MIDI-Editor section-context\nThe action given must support applying itself to selected items.\nThis function applies the action to each MediaItem individually. To apply the action to all MediaItems in MediaItemArray at once, see ApplyActionToMediaItemArray2.\nReturns false in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, to whom the action shall be applied to\nactioncommandid:the commandid-number or ActionCommandID, that shall be run.\nrepeat_action:the number of times this action shall be applied to each item; minimum value is 1\nmidi:true, run an action from MIDI-Editor-section-context; false, run an action from the main section\nMIDI_hwnd:the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one\nRETURNS:\nretval:true, if running the action was successful; false, if not or an error occured\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyActionToMediaItemArray(${3:MediaItemArray MediaItemArray},${4:string actioncommandid},${5:integer repeat_action},${6:boolean midi},${7:optional HWND MIDI_hwnd})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSINTIMESELECTION_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItemsInTimeSelection",
        "scope": "lua",
        "description": "Gets all MediaItems from within a time-selection\nReturns -1 in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers, separated by a comma; 1 for the first track, 2 for the second\nRETURNS:\ncount:the number of items found in time-selection\nMediaItemArray:an array with all MediaItems found within time-selection\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemArray} = ultraschall.GetAllMediaItemsInTimeSelection(${4:string trackstring},${5:boolean inside})$0"
    },
    "ULTRASCHALL.NORMALIZEITEMS_WR lua": {
        "prefix": "ultraschallwr.NormalizeItems",
        "scope": "lua",
        "description": "Normalizes all items in MediaItemArray.\nReturns -1 in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, that shall be normalized\nRETURNS:\nretval:-1, in case of an error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.NormalizeItems(${3:array MediaItemArray})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMS_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItems",
        "scope": "lua",
        "description": "Returns a MediaItemArray with all MediaItems in the current project\nRETURNS:\nitemcount:the number of items in the MediaItemArray\nMediaItemArray:an array with all MediaItems from the current project\n",
        "body": "${1:local }${2:integer itemcount},${3:MediaItemArray MediaItemArray} = ultraschall.GetAllMediaItems()$0"
    },
    "ULTRASCHALL.PREVIEWMEDIAITEM_WR lua": {
        "prefix": "ultraschallwr.PreviewMediaItem",
        "scope": "lua",
        "description": "Will play a preview a given MediaItem.\nYou can just play one preview at a time, except when previewing additionally through the MediaExplorer.\nReturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, of which you want to play a preview\nPreviewtype:the type of the preview\nRETURNS:\nretval:false, in case of error; true, in case of success\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.PreviewMediaItem(${3:MediaItem MediaItem},${4:integer Previewtype})$0"
    },
    "ULTRASCHALL.PREVIEWMEDIAFILE_WR lua": {
        "prefix": "ultraschallwr.PreviewMediaFile",
        "scope": "lua",
        "description": "Plays a preview of a media-file. You can only play one file at a time.\nReturns false in case of an error\nPARAMETERS:\nfilename_with_path:the filename with path of the media-file to play\ngain:the gain of the volume; nil, defaults to 1\nloop:true, loop the previewed file; false or nil, don't loop the file\nRETURNS:\nretval:true, starting preview was successful; false, starting preview wasn't successful\n",
        "body": "${1:local }${2:integer retval} = ultraschall.PreviewMediaFile(${3:string filename_with_path},${4:optional number gain},${5:optional boolean loop})$0"
    },
    "ULTRASCHALL.GETMEDIAITEMTAKE_WR lua": {
        "prefix": "ultraschallwr.GetMediaItemTake",
        "scope": "lua",
        "description": "Returns the requested MediaItem-Take of MediaItem. Use TakeNr=0 for the active take(!)\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, of whom you want to request a certain take.\nTakeNr:the take that you want to request; 1 for the first; 2 for the second, etc; 0, for the current active take\nRETURNS:\nTake:the number of takes available within this Mediaitem\nTakeCount:the number of takes available within this Mediaitem\n",
        "body": "${1:local }${2:MediaItem_Take Take},${3:integer TakeCount} = ultraschall.GetMediaItemTake(${4:MediaItem MediaItem},${5:integer TakeNr})$0"
    },
    "ULTRASCHALL.APPLYFUNCTIONTOMEDIAITEMARRAY_WR lua": {
        "prefix": "ultraschallwr.ApplyFunctionToMediaItemArray",
        "scope": "lua",
        "description": "Applies function \"functionname\" on all items in MediaItemArray. Parameter ... is all parameters used for function \"functionname\", where you should use nil in place of the parameter that shall hold a MediaItem.\nReturns a table with a boolean(did the function run without an error) and all returnvalues returned by function \"functionname\".\nReturns nil in case of an error. Will NOT(!) stop execution, if function \"functionname\" produces an error(see table returnvalues for more details)\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, who you want to apply functionname to.\nfunctionname:the name of the function to apply to every MediaItem in MediaItemArray\n:This nil-parameter will be filled with the appropriate MediaItem by ApplyFunctionToMediaItemArray automatically\n:This nil-parameter will be filled with the appropriate MediaItem by ApplyFunctionToMediaItemArray automatically\n:This nil-parameter will be filled with the appropriate MediaItem by ApplyFunctionToMediaItemArray automatically\nRETURNS:\ntable returnvalues:all other tableentries contain the returnvalues, as returned by function \"functionname\"\n",
        "body": "${1:local }${2:table returnvalues} = ultraschall.ApplyFunctionToMediaItemArray(${3:MediaItemArray MediaItemArray},${4:function functionname},${5:functionparameters1},${6:...},${7:functionparametersn})$0"
    },
    "ULTRASCHALL.GETGAPSBETWEENITEMS_WR lua": {
        "prefix": "ultraschallwr.GetGapsBetweenItems",
        "scope": "lua",
        "description": "Returns a table with all gaps between items in MediaTrack.\nReturns -1 in case of an error\nPARAMETERS:\nMediaTrack:the track, of which you want to have the gaps between items\nRETURNS:\nnumber_of_gaps:the number of gaps found between items; -1, in case of error\ngaptable:an array with all gappositions found\n",
        "body": "${1:local }${2:integer number_of_gaps},${3:array gaptable} = ultraschall.GetGapsBetweenItems(${4:MediaTrack MediaTrack})$0"
    },
    "ULTRASCHALL.DELETEMEDIAITEMS_BETWEEN_WR lua": {
        "prefix": "ultraschallwr.DeleteMediaItems_Between",
        "scope": "lua",
        "description": "Delete the MediaItems between start- and endposition, from the tracks as given by trackstring.\nReturns also a MediaItemStateChunkArray, that contains the statechunks of all deleted MediaItem\nreturns false in case of an error\nPARAMETERS:\nstartposition:the startposition in seconds\nendposition:the endposition in seconds\ntrackstring:the tracknumbers, separated by a comma\ninside:true, delete only MediaItems that are completely within start and endposition; false, also include MediaItems partially within start and endposition\nRETURNS:\nretval:true, delete was successful; false was unsuccessful\nMediaItemStateChunkArray:and array with all statechunks of all deleted MediaItems; \n",
        "body": "${1:local }${2:boolean retval},${3:array MediaItemStateChunkArray} = ultraschall.DeleteMediaItems_Between(${4:number startposition},${5:number endposition},${6:string trackstring},${7:boolean inside})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOMEDIAITEMARRAY2_WR lua": {
        "prefix": "ultraschallwr.ApplyActionToMediaItemArray2",
        "scope": "lua",
        "description": "Applies an action to the MediaItems in MediaItemArray, in either main or MIDI-Editor section-context\nThe action given must support applying itself to selected items.\nThis function applies the action to all MediaItems at once. To apply the action to each MediaItem in MediaItemArray individually, see ApplyActionToMediaItemArray\nReturns false in case of an error\nPARAMETERS:\nMediaItemArray:an array with all MediaItems, to whom the action shall be applied to\nactioncommandid:the commandid-number or ActionCommandID, that shall be run.\nrepeat_action:the number of times this action shall be applied to each item; minimum value is 1\nmidi:true, run an action from MIDI-Editor-section-context; false, run an action from the main section\nMIDI_hwnd:the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one\nRETURNS:\nretval:true, if running the action was successful; false, if not or an error occured\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyActionToMediaItemArray2(${3:MediaItemArray MediaItemArray},${4:string actioncommandid},${5:integer repeat_action},${6:boolean midi},${7:optional HWND MIDI_hwnd})$0"
    },
    "ULTRASCHALL.GETMEDIAFILEATTRIBUTES_WR lua": {
        "prefix": "ultraschallwr.GetMediafileAttributes",
        "scope": "lua",
        "description": "returns the attributes of a mediafile\nif the mediafile is an rpp-project, this function creates a proxy-file called filename.RPP-PROX, which is a wave-file of the length of the project.\nThis file can be deleted safely after that, but would be created again the next time this function is called.\nreturns -1 in case of an error\nPARAMETERS:\nfilename:the file whose attributes you want to have\nRETURNS:\nlength:the length of the mediafile in seconds\nnumchannels:the number of channels of the mediafile\nSamplerate:the samplerate of the mediafile in hertz\nFiletype:the type of the mediafile, like MP3, WAV, MIDI, FLAC, RPP_PROJECT etc\n",
        "body": "${1:local }${2:number length},${3:integer numchannels},${4:integer Samplerate},${5:string Filetype} = ultraschall.GetMediafileAttributes(${6:string filename})$0"
    },
    "ULTRASCHALL.INSERTMEDIAITEMFROMFILE_WR lua": {
        "prefix": "ultraschallwr.InsertMediaItemFromFile",
        "scope": "lua",
        "description": "Inserts the mediafile filename into the project at position in track\nWhen giving an rpp-projectfile, it will be rendered by Reaper and inserted as subproject!\nDue API-limitations, it creates two undo-points: one for inserting the MediaItem and one for changing the length(when endposition isn't -1).\nReturns -1 in case of failure\nPARAMETERS:\nfilename:the path+filename of the mediafile to be inserted into the project\ntrack:the track, in which the file shall be inserted\nposition:the length of the newly created mediaitem; -1, use the length of the sourcefile\nendposition:the length of the newly created mediaitem; -1, use the length of the sourcefile\neditcursorpos:the position of the editcursor after insertion of the mediafile\noffset:an offset, to delay the insertion of the item, to overcome possible \"too late\"-starting of playback of item during recording\nRETURNS:\nretval:0, if insertion worked; -1, if it failed\nitem:the newly created MediaItem\nendposition:the endposition of the newly created MediaItem in seconds\nnumchannels:the number of channels of the mediafile\nSamplerate:the samplerate of the mediafile in hertz\nFiletype:the type of the mediafile, like MP3, WAV, MIDI, FLAC, etc\neditcursorposition:the (new) editcursorposition\ntrack:returns the MediaTrack, in which the item is included\n",
        "body": "${1:local }${2:integer retval},${3:MediaItem item},${4:number endposition},${5:integer numchannels},${6:integer Samplerate},${7:string Filetype},${8:number editcursorposition},${9:MediaTrack track} = ultraschall.InsertMediaItemFromFile(${10:string filename},${11:integer track},${12:number position},${13:number endposition},${14:integer editcursorpos},${15:optional number offset})$0"
    },
    "ULTRASCHALL.COPYMEDIAITEMTODESTINATIONTRACK_WR lua": {
        "prefix": "ultraschallwr.CopyMediaItemToDestinationTrack",
        "scope": "lua",
        "description": "Copies MediaItem to MediaTrack_destination at position.\nReturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, that you want to create a copy from\nMediaTrack_destination:the track, into which you want to copy the MediaItem\nposition:the position of the copy of the MediaItem; negative, to keep the position of the source-MediaItem\nRETURNS:\nnewMediaItem:the newly created MediaItem; nil, if no item could be created\nstatechunk:the statechunk of the newly created MediaItem\n",
        "body": "${1:local }${2:MediaItem newMediaItem},${3:MediaItemStateChunk statechunk} = ultraschall.CopyMediaItemToDestinationTrack(${4:MediaItem MediaItem},${5:MediaTrack MediaTrack_destination},${6:number position})$0"
    },
    "ULTRASCHALL.ISSPLITATPOSITION_WR lua": {
        "prefix": "ultraschallwr.IsSplitAtPosition",
        "scope": "lua",
        "description": "returns, if theres at least one split, MediaItemend or MediaItemstart at position within the tracks given in trackstring.\nreturns false in case of an error\nPARAMETERS:\ntrackstring:the tracknumbers, within to search for, as comma separated string. Starting 1 for the first track.\nposition:the position, at which to check for.\nRETURNS:\nretval:true, there's a split/mediaitemend/mediaitemstart at position; false, it isn't\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsSplitAtPosition(${3:string trackstring},${4:number position})$0"
    },
    "ULTRASCHALL.GETITEM_NUMBER_WR lua": {
        "prefix": "ultraschallwr.GetItem_Number",
        "scope": "lua",
        "description": "returns the indexnumber of a MediaItem-object\nCan be helpful with Reaper's own API-functions, like reaper.GetMediaItem(ReaProject proj, integer itemidx)\nreturns -1 in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose itemidx you want to have\nRETURNS:\nitemidx:the indexnumber of the MediaItem, zero based. \n",
        "body": "${1:local }${2:integer itemidx} = ultraschall.GetItem_Number(${3:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.GETITEM_HIGHESTRECCOUNTER_WR lua": {
        "prefix": "ultraschallwr.GetItem_HighestRecCounter",
        "scope": "lua",
        "description": "Takes the RECPASS-counters of all items and takes and returns the highest one, which usually means, the number of items, who have been recorded since the project has been created.\nNote: a RECPASS-entry can also be part of a copy of a recorded item, so multiple items/takes can share the same RECPASS-entries with the same counter.\nMeans: the highest number can be of multiple items\nreturns -1 if no recorded item/take has been found.\nRETURNS:\nhighest_item_reccount:the highest reccount of all MediaItems, which usually means, that so many Items have been recorded in this project\nfound:the number of MediaItems, who have a recpass-entry in their StateChunk, means, who have been recorded.    \n",
        "body": "${1:local }${2:integer highest_item_reccount},${3:integer found} = ultraschall.GetItem_HighestRecCounter()$0"
    },
    "ULTRASCHALL.GETITEM_CLICKSTATE_WR lua": {
        "prefix": "ultraschallwr.GetItem_ClickState",
        "scope": "lua",
        "description": "Returns the currently clicked item and take, as well as the current timeposition.\nMostly useful in defer-scripts.\nReturns false, if no item is clicked at\nRETURNS:\nclickstate:true, item is clicked on; false, item isn't clicked on\nposition:the position, at which the item is currently clicked at\nitem:the Item, which is currently clicked at\ntake:the take found at clickposition\n",
        "body": "${1:local }${2:boolean clickstate},${3:number position},${4:MediaItem item},${5:MediaItem_Take take} = ultraschall.GetItem_ClickState()$0"
    },
    "ULTRASCHALL.GETENDOFITEM_WR lua": {
        "prefix": "ultraschallwr.GetEndOfItem",
        "scope": "lua",
        "description": "Returns the endposition of MediaItem\nreturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose ending-position you want to know\nRETURNS:\nend_of_item_position:the position of the ending edge of the MediaItem\n",
        "body": "${1:local }${2:number end_of_item_position} = ultraschall.GetEndOfItem(${3:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMATTRIBUTES_TABLE_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItemAttributes_Table",
        "scope": "lua",
        "description": "Returns all attributes of MediaItem as a handy table.\nThe returned table is of the following scheme:\nAttributeTable[\"B_MUTE\"] - bool * : muted\nAttributeTable[\"B_LOOPSRC\"] - bool * : loop source\nAttributeTable[\"B_ALLTAKESPLAY\"] - bool * : all takes play\nAttributeTable[\"B_UISEL\"] - bool * : selected in arrange view\nAttributeTable[\"C_BEATATTACHMODE\"] - char * : item timebase, -1=track or project default, 1=beats (position, length, rate), 2=beats (position only). for auto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nAttributeTable[\"C_AUTOSTRETCH:\"] - char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nAttributeTable[\"C_LOCK\"] - char * : locked, &1=locked\nAttributeTable[\"D_VOL\"] - double * : item volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nAttributeTable[\"D_POSITION\"] - double * : item position in seconds\nAttributeTable[\"D_LENGTH\"] - double * : item length in seconds\nAttributeTable[\"D_SNAPOFFSET\"] - double * : item snap offset in seconds\nAttributeTable[\"D_FADEINLEN\"] - double * : item manual fadein length in seconds\nAttributeTable[\"D_FADEOUTLEN\"] - double * : item manual fadeout length in seconds\nAttributeTable[\"D_FADEINDIR\"] - double * : item fadein curvature, -1..1\nAttributeTable[\"D_FADEOUTDIR\"] - double * : item fadeout curvature, -1..1\nAttributeTable[\"D_FADEINLEN_AUTO\"] - double * : item auto-fadein length in seconds, -1=no auto-fadein\nAttributeTable[\"D_FADEOUTLEN_AUTO\"] - double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nAttributeTable[\"C_FADEINSHAPE\"] - int * : fadein shape, 0..6, 0=linear\nAttributeTable[\"C_FADEOUTSHAPE\"] - int * : fadeout shape, 0..6, 0=linear\nAttributeTable[\"I_GROUPID\"] - int * : group ID, 0=no group\nAttributeTable[\"I_LASTY\"] - int * : Y-position of track in pixels (read-only)\nAttributeTable[\"I_LASTH\"] - int * : height in track in pixels (read-only)\nAttributeTable[\"I_CUSTOMCOLOR\"] - int * : custom color, OS dependent color|0x100000 (i.e. ColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will not be used, but will store the color anyway)\nAttributeTable[\"I_CURTAKE\"] - int * : active take number\nAttributeTable[\"IP_ITEMNUMBER\"] - int, item number on this track (read-only, returns the item number directly)\nAttributeTable[\"F_FREEMODE_Y\"] - float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nAttributeTable[\"F_FREEMODE_H\"] - float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nAttributeTable[\"P_TRACK\"] - MediaTrack * (read-only)\nreturns nil in case of an error\nPARAMETERS:\nMediaItem:the MediaItem, whose attributes you want to retrieve\nRETURNS:\nAttributeTable:a table with all attributes of a MediaItem\n",
        "body": "${1:local }${2:table AttributeTable} = ultraschall.GetAllMediaItemAttributes_Table(${3:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.SETALLMEDIAITEMATTRIBUTES_TABLE_WR lua": {
        "prefix": "ultraschallwr.SetAllMediaItemAttributes_Table",
        "scope": "lua",
        "description": "Sets all attributes of MediaItem using a AttributeTable, which holds all the new settings for the MediaItem.\nThe expected table is of the following scheme:\nAttributeTable[\"B_MUTE\"] - bool * : muted\nAttributeTable[\"B_LOOPSRC\"] - bool * : loop source\nAttributeTable[\"B_ALLTAKESPLAY\"] - bool * : all takes play\nAttributeTable[\"B_UISEL\"] - bool * : selected in arrange view\nAttributeTable[\"C_BEATATTACHMODE\"] - char * : item timebase, -1=track or project default, 1=beats (position, length, rate), 2=beats (position only). for auto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nAttributeTable[\"C_AUTOSTRETCH:\"] - char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nAttributeTable[\"C_LOCK\"] - char * : locked, &1=locked\nAttributeTable[\"D_VOL\"] - double * : item volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nAttributeTable[\"D_POSITION\"] - double * : item position in seconds\nAttributeTable[\"D_LENGTH\"] - double * : item length in seconds\nAttributeTable[\"D_SNAPOFFSET\"] - double * : item snap offset in seconds\nAttributeTable[\"D_FADEINLEN\"] - double * : item manual fadein length in seconds\nAttributeTable[\"D_FADEOUTLEN\"] - double * : item manual fadeout length in seconds\nAttributeTable[\"D_FADEINDIR\"] - double * : item fadein curvature, -1..1\nAttributeTable[\"D_FADEOUTDIR\"] - double * : item fadeout curvature, -1..1\nAttributeTable[\"D_FADEINLEN_AUTO\"] - double * : item auto-fadein length in seconds, -1=no auto-fadein\nAttributeTable[\"D_FADEOUTLEN_AUTO\"] - double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nAttributeTable[\"C_FADEINSHAPE\"] - int * : fadein shape, 0..6, 0=linear\nAttributeTable[\"C_FADEOUTSHAPE\"] - int * : fadeout shape, 0..6, 0=linear\nAttributeTable[\"I_GROUPID\"] - int * : group ID, 0=no group\nAttributeTable[\"I_LASTY\"] - int * : Y-position of track in pixels (read-only)\nAttributeTable[\"I_LASTH\"] - int * : height in track in pixels (read-only)\nAttributeTable[\"I_CUSTOMCOLOR\"] - int * : custom color, OS dependent color|0x100000 (i.e. ColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will not be used, but will store the color anyway)\nAttributeTable[\"I_CURTAKE\"] - int * : active take number\nAttributeTable[\"IP_ITEMNUMBER\"] - int, item number on this track (read-only, returns the item number directly)\nAttributeTable[\"F_FREEMODE_Y\"] - float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nAttributeTable[\"F_FREEMODE_H\"] - float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nAttributeTable[\"P_TRACK\"] - MediaTrack * (read-only)\nreturns false in case of an error or if some of the attributes could not be set.\nPARAMETERS:\nMediaItem:the MediaItem, whose attributes you want to set\nAttributeTable:a table which holds all settings, that you want to set\nRETURNS:\nretval:true, setting was successful; false, setting attributes failed\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetAllMediaItemAttributes_Table(${3:MediaItem MediaItem},${4:table AttributeTable})$0"
    },
    "ULTRASCHALL.GETALLSELECTEDMEDIAITEMSBETWEEN_WR lua": {
        "prefix": "ultraschallwr.GetAllSelectedMediaItemsBetween",
        "scope": "lua",
        "description": "Gets all selected MediaItems between startposition and endposition from the tracks as given by trackstring.\nSet inside to true to get only items, that are fully within the start and endposition, set it to false, if you also want items, that are just partially inside(end or just the beginning of the item).\nReturns the number of selected items, an array with all the selected MediaItems and an array with all the MediaItemStateChunks of the selected items, as used by functions as InsertMediaItem_MediaItemStateChunk, reaper.GetItemStateChunk and reaper.SetItemStateChunk.\nThe statechunks include a new element \"ULTRASCHALL_TRACKNUMBER\", which contains the tracknumber of where the item originally was in; important, if you delete the items as you'll otherwise loose this information!\nReturns -1 in case of failure.\nPARAMETERS:\nstartposition:startposition in seconds\nendposition:endposition in seconds\ntrackstring:the tracknumbers, separated by a comma\ninside:true, only items that are completely within selection; false, include items that are partially within selection\nRETURNS:\ncount:the number of selected items\nMediaItemArray:an array with all the found and selected MediaItems\nMediaItemStateChunkArray:an array with the MediaItemStateChunks, that can be used to create new items with InsertMediaItem_MediaItemStateChunk\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemArray},${4:array MediaItemStateChunkArray} = ultraschall.GetAllSelectedMediaItemsBetween(${5:number startposition},${6:number endposition},${7:string trackstring},${8:boolean inside})$0"
    },
    "ULTRASCHALL.MEDIAITEMS_OUTTAKES_ADDSELECTEDITEMS_WR lua": {
        "prefix": "ultraschallwr.MediaItems_Outtakes_AddSelectedItems",
        "scope": "lua",
        "description": "Adds selected MediaItems to the outtakes-vault of a given project.\nreturns -1 in case of an error\nPARAMETERS:\nTargetProject:the project, into whose outtakes-vault the selected items shall be added to; 0 or nil, for the current project\nRETURNS:\nnumber_of_items:the number of items, added to the outtakes-vault\n",
        "body": "${1:local }${2:integer number_of_items} = ultraschall.MediaItems_Outtakes_AddSelectedItems(${3:ReaProject TargetProject})$0"
    },
    "ULTRASCHALL.MEDIAITEMS_OUTTAKES_GETALLITEMS_WR lua": {
        "prefix": "ultraschallwr.MediaItems_Outtakes_GetAllItems",
        "scope": "lua",
        "description": "Returns all MediaItems stored in the outtakes-vault of a given project.\nreturns -1 in case of an error\nPARAMETERS:\nTargetProject:the project, into whose outtakes-vault the selected items shall be added to; 0 or nil, for the current project\nEachItemsAfterAnother:position the MediaItems one after the next, so if you import them, they would be stored one after another\nRETURNS:\nnumber_of_items:the number of items, added to the outtakes-vault\nMediaItemStateChunkArray:all the MediaItemStateChunks of the stored MediaItems in the outtakes vault\n",
        "body": "${1:local }${2:integer number_of_items},${3:array MediaItemStateChunkArray} = ultraschall.MediaItems_Outtakes_GetAllItems(${4:ReaProject TargetProject},${5:optional boolean EachItemsAfterAnother})$0"
    },
    "ULTRASCHALL.MEDIAITEMS_OUTTAKES_INSERTALLITEMS_WR lua": {
        "prefix": "ultraschallwr.MediaItems_Outtakes_InsertAllItems",
        "scope": "lua",
        "description": "Inserts all MediaItems from the outtakes-vault into a certain track, with one item after the other, back to back.\nreturns false in case of an error\nPARAMETERS:\nTargetProject:the project, into whose outtakes-vault the selected items shall be added to; 0 or nil, for the current project\ntracknumber:the tracknumber, into which to insert all items from the outtakes-vault\nStartposition:the position, at which to insert the first MediaItem; nil, startposition=0\nRETURNS:\nretval:true, adding was successful; false, adding was unsuccessful\nnumber_of_items:the number of added items\nMediaItemArray:all the inserted MediaItems\n",
        "body": "${1:local }${2:boolean retval},${3:integer number_of_items},${4:array MediaItemArray} = ultraschall.MediaItems_Outtakes_InsertAllItems(${5:ReaProject TargetProject},${6:integer tracknumber},${7:number Startposition})$0"
    },
    "ULTRASCHALL.DELETEPROJEXTSTATE_SECTION_WR lua": {
        "prefix": "ultraschallwr.DeleteProjExtState_Section",
        "scope": "lua",
        "description": "Deletes all key/values from a specific section.\nReturns -1 in case of an error.\nPARAMETERS:\nsection:the section/extname, whose key/values shall be deleted\nRETURNS:\nretval:0, in case of success; -1, in case of an error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.DeleteProjExtState_Section(${3:string section})$0"
    },
    "ULTRASCHALL.DELETEPROJEXTSTATE_KEY_WR lua": {
        "prefix": "ultraschallwr.DeleteProjExtState_Key",
        "scope": "lua",
        "description": "Deletes the value from a specific section -> key.\nReturns -1 in case of an error.\nPARAMETERS:\nsection:the section/extname, from whom a key/value shall be deleted\nkey:the key, whose value shall be deleted\nRETURNS:\nretval:0, in case of success; -1, in case of an error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.DeleteProjExtState_Key(${3:string section},${4:section key})$0"
    },
    "ULTRASCHALL.GETPROJEXTSTATE_ALLKEYVALUES_WR lua": {
        "prefix": "ultraschallwr.GetProjExtState_AllKeyValues",
        "scope": "lua",
        "description": "Returns the count of all key/values in a specific section, as well as an array with all keynames and their accompanying stored values.\nThe array has the format:\nAllValues[idx][1]=Key\nAllValues[idx][2]=Value\nReturns -1 in case of an error or if no key exists in the given section\nPARAMETERS:\nsection:the section/extname, from whom a key/value shall be deleted\nRETURNS:\nretval:0, in case of success; -1, in case of an error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetProjExtState_AllKeyValues(${3:string section})$0"
    },
    "ULTRASCHALL.GETGUIDEXTSTATE_WR lua": {
        "prefix": "ultraschallwr.GetGuidExtState",
        "scope": "lua",
        "description": "Gets an extension-state using a given guid. Good for storing additional metadata of objects like MediaTracks, MediaItems, MediaItem_Takes, etc(everything, that has a guid).\nThe guid can have additional text, but must contain a valid guid somewhere in it!\nA valid guid is a string that follows the following pattern:\n{........-....-....-....-............}\nwhere . is a hexadecimal value(0-F)\nReturns -1 in case of error\nPARAMETERS:\nguid:the guid of the object, for whom you want to get the key/value-pair; can have additional characters before and after the guid, but must contain a valid guid!\nkey:the key for this guid\nsavelocation:0, get as project extension state(from the currently opened project); 1, get as global extension state(when persist=true, from reaper-extstate.ini in the resourcesfolder)\nRETURNS:\nretval:the idx of the extstate(if a project extension state); 1, successful(with extension states), -1, unsuccessful\nvalue:the returned value from the extstate\n",
        "body": "${1:local }${2:integer retval},${3:string value} = ultraschall.GetGuidExtState(${4:string guid},${5:string key},${6:integer savelocation})$0"
    },
    "ULTRASCHALL.SETMARKEREXTSTATE_WR lua": {
        "prefix": "ultraschallwr.SetMarkerExtState",
        "scope": "lua",
        "description": "Stores an Extstate for a specific marker/region.\nThe index is for all markers and regions, inclusive and 1-based\nreturns -1 in case of an error\nPARAMETERS:\nindex:the marker/region-index, for which to store an extstate; starting with 1 for first marker/region, 2 for second marker/region\nkey:the key, into which the marker-extstate shall be stored\nvalue:the value, which you want to store into the marker-extstate\nRETURNS:\nretval:-1, in case of an error; 1, in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetMarkerExtState(${3:integer index},${4:string key},${5:string value})$0"
    },
    "ULTRASCHALL.GETMARKEREXTSTATE_WR lua": {
        "prefix": "ultraschallwr.GetMarkerExtState",
        "scope": "lua",
        "description": "Retrieves an Extstate for a specific marker/region.\nThe index is for all markers and regions, inclusive and 1-based\nreturns nil in case of an error\nPARAMETERS:\nindex:the marker/region-index, for which an extstate has been stored; starting with 1 for first marker/region, 2 for second marker/region\nkey:the key, in which the marker-extstate is stored\nRETURNS:\nvalue:the value, that has been stored into the marker-extstate; nil, in case of an error\n",
        "body": "${1:local }${2:string value} = ultraschall.GetMarkerExtState(${3:integer index},${4:string key})$0"
    },
    "ULTRASCHALL.PROJEXTSTATE_COUNTALLKEYS_WR lua": {
        "prefix": "ultraschallwr.ProjExtState_CountAllKeys",
        "scope": "lua",
        "description": "Counts all keys stored within a certain ProjExtState-section.\nBe aware: if you want to enumerate them using reaper.EnumProjExtState, the first key is indexed 0, the second 1, etc!\nreturns -1 in case of an error\nPARAMETERS:\nsection:the section, of which you want to count all keys\n",
        "body": "${1:local }${2:integer count} = ultraschall.ProjExtState_CountAllKeys(${3:string section})$0"
    },
    "ULTRASCHALL.ZOOMVERTICAL_MIDIEDITOR_WR lua": {
        "prefix": "ultraschallwr.ZoomVertical_MidiEditor",
        "scope": "lua",
        "description": "Zooms within the Midi-Editor vertically.\nreturns false in case of an error\nPARAMETERS:\nzoomamt:the zoom-factor; positive values, zoom in; negative values, zoom out\nmidieditor_hwnd:the HWND of the MIDI-Editor, in which you want to zoom; nil, uses active MIDI-Editor\nRETURNS:\nretval:true, if zooming was successful; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ZoomVertical_MidiEditor(${3:integer zoomamt},${4:optional HWND midieditor_hwnd})$0"
    },
    "ULTRASCHALL.ZOOMHORIZONTAL_MIDIEDITOR_WR lua": {
        "prefix": "ultraschallwr.ZoomHorizontal_MidiEditor",
        "scope": "lua",
        "description": "Zooms within the Midi-Editor horizontally.\nreturns false in case of an error\nPARAMETERS:\nzoomamt:the zoom-factor; positive values, zoom in; negative values, zoom out\nmidieditor_hwnd:the HWND of the MIDI-Editor, in which you want to zoom; nil, uses active MIDI-Editor\nRETURNS:\nretval:true, if zooming was successful; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ZoomHorizontal_MidiEditor(${3:integer zoomamt},${4:optional HWND midieditor_hwnd})$0"
    },
    "ULTRASCHALL.OPENITEMINMIDIEDITOR_WR lua": {
        "prefix": "ultraschallwr.OpenItemInMidiEditor",
        "scope": "lua",
        "description": "opens a given MediaItem in the MIDI-Editor\nreturns false in case of an error\nPARAMETERS:\nMediaItem:the MediaItem to be opened in the MIDI-Editor\nRETURNS:\nretval:true, if opening was successful; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.OpenItemInMidiEditor(${3:MediaItem MediaItem})$0"
    },
    "ULTRASCHALL.QUERYMIDIMESSAGENAMEBYID_WR lua": {
        "prefix": "ultraschallwr.QueryMIDIMessageNameByID",
        "scope": "lua",
        "description": "Returns the name of the MIDI-message, as used by Reaper's function StuffMIDIMessage.\nJust pass over the first and second value. The last one is always velocity, which is ~=0 for it to be accepted.\nHowever, some codes don't have a name associated. In that case, this function returns \"-1\"\nOnly returns the names for mode 1 and english on Windows!\nreturns nil in case of an error\nPARAMETERS:\nmodifier:the modifier value, which is the second parameter of StuffMIDIMessage\nkey:the key value, which is the third parameter of StuffMIDIMessage\nRETURNS:\nmidimessage_name:the actual name of the midi-message, like \"A\" or \"F1\" or \"Ctrl+Alt+Shift+Win+PgUp\".\n",
        "body": "${1:local }${2:string midimessage_name} = ultraschall.QueryMIDIMessageNameByID(${3:integer modifier},${4:integer key})$0"
    },
    "ULTRASCHALL.TOGGLEMUTE_WR lua": {
        "prefix": "ultraschallwr.ToggleMute",
        "scope": "lua",
        "description": "Sets mute within the mute-envelope-lane, by inserting the fitting envelope-points. Can be used to program coughbuttons.\nReturns -1, in case of an error\nPARAMETERS:\ntrack:the track-number, for where you want to set the mute-envelope-lane.\nposition:position in seconds\nstate:0, for mute the track on this position; 1, for unmuting the track on this position\nRETURNS:\nretval:toggling was 0, success; -1, fail\n",
        "body": "${1:local }${2:integer retval} = ultraschall.ToggleMute(${3:integer track},${4:number position},${5:integer state})$0"
    },
    "ULTRASCHALL.TOGGLEMUTE_TRACKOBJECT_WR lua": {
        "prefix": "ultraschallwr.ToggleMute_TrackObject",
        "scope": "lua",
        "description": "Sets mute within the mute-envelope-lane, by inserting the fitting envelope-points. Can be used to program coughbuttons.\nReturns -1, if it fails.\nWorks like ultraschall.ToggleMute but uses a trackobject instead of the tracknumber as parameter.\nPARAMETERS:\ntrackobject:the track-object for the track, where you want to set the mute-envelope-lane. Refer GetTrack() for more details.\nposition:position in seconds\nstate:0, for mute the track on this position, 1, for unmuting the track on this position\nRETURNS:\nretval:toggling was 0, success; -1, fail\n",
        "body": "${1:local }${2:integer retval} = ultraschall.ToggleMute_TrackObject(${3:MediaTrack trackobject},${4:number position},${5:integer state})$0"
    },
    "ULTRASCHALL.GETNEXTMUTESTATE_WR lua": {
        "prefix": "ultraschallwr.GetNextMuteState",
        "scope": "lua",
        "description": "Returns the next mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the track-number, for where you want to set the mute-envelope-lane, beginning with 1.\nposition:position in seconds, from where to look for the next mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "${1:local }${2:integer envIDX},${3:number envVal},${4:number envPosition} = ultraschall.GetNextMuteState(${5:integer track},${6:number position})$0"
    },
    "ULTRASCHALL.GETPREVIOUSMUTESTATE_WR lua": {
        "prefix": "ultraschallwr.GetPreviousMuteState",
        "scope": "lua",
        "description": "Returns the previous mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the track-number, for where you want to set the mute-envelope-lane, beginning with 1.\nposition:position in seconds, from where to look for the previous mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "${1:local }${2:integer envIDX},${3:number envVal},${4:number envPosition} = ultraschall.GetPreviousMuteState(${5:integer track},${6:number position})$0"
    },
    "ULTRASCHALL.GETNEXTMUTESTATE_TRACKOBJECT_WR lua": {
        "prefix": "ultraschallwr.GetNextMuteState_TrackObject",
        "scope": "lua",
        "description": "Returns the next mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the MediaTrack-object, for the track, where you want to set the mute-envelope-lane.\nposition:position in seconds, from where to look for the next mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "${1:local }${2:integer envIDX},${3:number envVal},${4:number envPosition} = ultraschall.GetNextMuteState_TrackObject(${5:MediaTrack track},${6:number position})$0"
    },
    "ULTRASCHALL.GETPREVIOUSMUTESTATE_TRACKOBJECT_WR lua": {
        "prefix": "ultraschallwr.GetPreviousMuteState_TrackObject",
        "scope": "lua",
        "description": "Returns the previous mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0!\nReturns -1 if not existing.\nPARAMETERS:\ntrack:the MediaTrack-object, for the track, where you want to set the mute-envelope-lane.\nposition:position in seconds, from where to look for the previous mute-envelope-point\nRETURNS:\nenvIDX:number of the muteenvelope-point\nenvVal:value of the muteenvelope-point (0 or 1)\nenvPosition:position of the muteenvelope-point in seconds\n",
        "body": "${1:local }${2:integer envIDX},${3:number envVal},${4:number envPosition} = ultraschall.GetPreviousMuteState_TrackObject(${5:MediaTrack track},${6:number position})$0"
    },
    "ULTRASCHALL.COUNTMUTEENVELOPEPOINTS_WR lua": {
        "prefix": "ultraschallwr.CountMuteEnvelopePoints",
        "scope": "lua",
        "description": "Returns the number of the envelope-points in the Mute-lane of track \"track\".\nReturns -1, if it fails.\nPARAMETERS:\ntrack:the track-number, for which you want to count the mute-envelope-points, beginning with 1.\nRETURNS:\nretval:number of mute-envelope-points\n",
        "body": "${1:local }${2:integer retval} = ultraschall.CountMuteEnvelopePoints(${3:integer track})$0"
    },
    "ULTRASCHALL.DELETEMUTESTATE_WR lua": {
        "prefix": "ultraschallwr.DeleteMuteState",
        "scope": "lua",
        "description": "Deletes a mute-point in track tracknumber at position.\nReturns false in case of an error\nPARAMETERS:\ntracknumber:the track in which to delete the mute-point; is 1-based, means 1 for track 1\nposition:the position of the mute-point to delete\nRETURNS:\nretval:true, deleting was successful; false, deleting wasn't successful.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteMuteState(${3:integer tracknumber},${4:number position})$0"
    },
    "ULTRASCHALL.DELETEMUTESTATE_TRACKOBJECT_WR lua": {
        "prefix": "ultraschallwr.DeleteMuteState_TrackObject",
        "scope": "lua",
        "description": "Deletes a mute-point in a MediaTrack-object at position.\nReturns false in case of an error\nPARAMETERS:\nMediaTrack:the track in which to delete the mute-point\nposition:the position of the mute-point to delete\nRETURNS:\nretval:true, deleting was successful; false, deleting wasn't successful.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteMuteState_TrackObject(${3:MediaTrack MediaTrack},${4:number position})$0"
    },
    "ULTRASCHALL.ISMUTEATPOSITION_WR lua": {
        "prefix": "ultraschallwr.IsMuteAtPosition",
        "scope": "lua",
        "description": "Returns true, if a mute-point exists in track tracknumber at position position.\nReturns false in case of an error\nPARAMETERS:\ntracknumber:the track in which to check for a mute-point; is 1-based, means 1 for track 1\nposition:the position to check for a mute-point\nRETURNS:\nretval:true, if there is a mute-point; false, if there isn't one\nenvIDX:if a mute-point is at position, this holds the index of the envelope-point\nenvVal:the current set value of the mute-point\n",
        "body": "${1:local }${2:boolean retval},${3:optional integer envIDX},${4:optional number envVal} = ultraschall.IsMuteAtPosition(${5:integer tracknumber},${6:number position})$0"
    },
    "ULTRASCHALL.ISMUTEATPOSITION_TRACKOBJECT_WR lua": {
        "prefix": "ultraschallwr.IsMuteAtPosition_TrackObject",
        "scope": "lua",
        "description": "Returns true, if a mute-point exists in MediaTrack-object at position position.\nReturns false in case of an error\nPARAMETERS:\nMediaTrack:the track in which to check for a mute-point\nposition:the position to check for a mute-point\nRETURNS:\nretval:true, if there is a mute-point; false, if there isn't one\nenvIDX:if a mute-point is at position, this holds the index of the envelope-point\nenvVal:the current set value of the mute-point\n",
        "body": "${1:local }${2:boolean retval},${3:optional integer envIDX},${4:optional number envVal} = ultraschall.IsMuteAtPosition_TrackObject(${5:MediaTrack MediaTrack},${6:number position})$0"
    },
    "ULTRASCHALL.GETNEXTCLOSESTITEMEDGE_WR lua": {
        "prefix": "ultraschallwr.GetNextClosestItemEdge",
        "scope": "lua",
        "description": "returns the position of the next closest item in seconds. It will return the position of the beginning or the end of that item, depending on what is closer.\nreturns -1 in case of an error\nPARAMETERS:\ntrackstring:a string with the numbers of tracks to check for closest items, separated by a comma (e.g. \"0,1,6\")\ncursor_type:next closest item related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the next closest item. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nposition:the position of the next closest item-edge in tracks in trackstring\nitem_number:the itemnumber in the project\nedgetype:\"beg\" for beginning of the item, \"end\" for the end of the item\nMediaItem found_item:the next closest found MediaItem \n",
        "body": "${1:local }${2:number position},${3:integer item_number},${4:string edgetype},${5:MediaItem found_item} = ultraschall.GetNextClosestItemEdge(${6:string trackstring},${7:integer cursor_type},${8:optional number time_position})$0"
    },
    "ULTRASCHALL.GETPREVIOUSCLOSESTITEMEDGE_WR lua": {
        "prefix": "ultraschallwr.GetPreviousClosestItemEdge",
        "scope": "lua",
        "description": "returns the position of the previous closest item-edge in seconds. It will return the position of the beginning or the end of that item, depending on what is closer.\nreturns -1 in case of an error\nPARAMETERS:\ntracks:a string with the numbers of tracks to check for closest items, separated by a comma (e.g. \"0,1,6\")\ncursor_type:previous closest item related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the previous closest item. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nposition:the position of the previous closest item edge in tracks in trackstring\nposition:the position of the previous closest item edge in tracks in trackstring\nitem_number:the itemnumber in the project\nedgetype:\"beg\" for beginning of the item, \"end\" for the end of the item\nfound_item:the next closest found MediaItem \n",
        "body": "${1:local }${2:number position},${3:number position},${4:integer item_number},${5:string edgetype},${6:MediaItem found_item} = ultraschall.GetPreviousClosestItemEdge(${7:string tracks},${8:integer cursor_type},${9:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTNEXTMARKER_WR lua": {
        "prefix": "ultraschallwr.GetClosestNextMarker",
        "scope": "lua",
        "description": "returns the markerindex(counted from all markers), the position and the name of the next closest marker in seconds.\nreturns -1 in case of an error\nPARAMETERS:\ncursor_type:previous closest marker related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the next closest marker. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the next closest markerindex (of all(!) markers)\nposition:the position of the next closest marker\nmarkertitle:the name of the next closest marker\n",
        "body": "${1:local }${2:number markerindex},${3:number position},${4:string markertitle} = ultraschall.GetClosestNextMarker(${5:integer cursor_type},${6:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTPREVIOUSMARKER_WR lua": {
        "prefix": "ultraschallwr.GetClosestPreviousMarker",
        "scope": "lua",
        "description": "returns the markerindex(counted from all markers), the position and the name of the previous closest marker in seconds.\nPARAMETERS:\ncursor_type:previous closest marker related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the previous closest marker. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the previous closest markerindex (of all(!) markers)\nposition:the position of the previous closest marker\nmarkertitle:the name of the previous closest marker\n",
        "body": "${1:local }${2:number markerindex},${3:number position},${4:string markertitle} = ultraschall.GetClosestPreviousMarker(${5:integer cursor_type},${6:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTNEXTREGIONEDGE_WR lua": {
        "prefix": "ultraschallwr.GetClosestNextRegionEdge",
        "scope": "lua",
        "description": "returns the regionindex(counted from all markers and regions), the position and the name of the next closest regionstart/end(depending on which is closer to time_position) in seconds.\nreturns -1 in case of an error\nPARAMETERS:\ncursor_type:previous closest regionstart/end related to the current position of \ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the next closest regionstart/end. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the next closest markerindex (of all(!) markers)\nposition:the position of the next closest region\nmarkertitle:the name of the next closest region\nedge_type:the type of the edge of the region, either \"beg\" or \"end\"\n",
        "body": "${1:local }${2:number markerindex},${3:number position},${4:string markertitle},${5:string edge_type} = ultraschall.GetClosestNextRegionEdge(${6:integer cursor_type},${7:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTPREVIOUSREGIONEDGE_WR lua": {
        "prefix": "ultraschallwr.GetClosestPreviousRegionEdge",
        "scope": "lua",
        "description": "returns the regionindex(counted from all markers and regions), the position and the name of the previous closest regionstart/end(depending on which is closer to time_position) in seconds.\nreturns -1 in case of an error\nPARAMETERS:\ncursor_type:previous closest regionstart/end related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition\ntime_position:only, when cursor_type=3, a time position in seconds, from where to check for the previous closest regionstart/end. When omitted, it will take the current play(during play and rec) or edit-cursor-position.\nRETURNS:\nmarkerindex:the previous closest markerindex (of all(!) markers)\nposition:the position of the previous closest marker\nmarkertitle:the name of the previous closest marker\nedge_type:the type of the edge of the region, either \"beg\" or \"end\"\n",
        "body": "${1:local }${2:number markerindex},${3:number position},${4:string markertitle},${5:string edge_type} = ultraschall.GetClosestPreviousRegionEdge(${6:integer cursor_type},${7:optional number time_position})$0"
    },
    "ULTRASCHALL.GETCLOSESTGOTOPOINTS_WR lua": {
        "prefix": "ultraschallwr.GetClosestGoToPoints",
        "scope": "lua",
        "description": "returns, what are the closest markers/regions/item starts/itemends to position and within the chosen tracks.\nreturns -1 in case of error\nPARAMETERS:\ntrackstring:tracknumbers, separated by a comma.\ntime_position:a time position in seconds, from where to check for the next/previous closest items/markers/regions.\ncheck_itemedge:true, look for itemedges as possible goto-points; false, do not\ncheck_marker:true, look for markers as possible goto-points; false, do not\ncheck_region:true, look for regions as possible goto-point; false, do not\nRETURNS:\nelementposition_prev:previous closest markers/regions/item starts/itemends\nelementtype_prev:type of the previous closest markers/regions/item starts/itemends\nnumber_prev:number of previous closest markers/regions/item starts/itemends\nelementposition_next:previous closest markers/regions/item starts/itemends\nelementtype_next:type of the previous closest markers/regions/item starts/itemends\nnumber_next:number of previous closest markers/regions/item starts/itemends\n",
        "body": "${1:local }${2:number elementposition_prev},${3:string elementtype_prev},${4:integer number_prev},${5:number elementposition_next},${6:string elementtype_next},${7:integer number_next} = ultraschall.GetClosestGoToPoints(${8:string trackstring},${9:number time_position},${10:optional boolean check_itemedge},${11:optional boolean check_marker},${12:optional boolean check_region})$0"
    },
    "ULTRASCHALL.GETLASTCURSORPOSITION_WR lua": {
        "prefix": "ultraschallwr.GetLastCursorPosition",
        "scope": "lua",
        "description": "Returns the last and current editcursor-position. Needs Ultraschall-API-background-scripts started first, see RunBackgroundHelperFeatures().\nHas an issue, when editcursor-position was changed using a modifier, like alt+click or shift+click! Because of that, you should use this only in defer-scripts.\nreturns -1, if Ultraschall-API-backgroundscripts weren't started yet.\nRETURNS:\nlast_editcursor_position:the last cursorposition before the current one; -1, in case of an error\nnew_editcursor_position:the new cursorposition; -1, in case of an error\nstatechangetime:the time, when the state has changed the last time\n",
        "body": "${1:local }${2:number last_editcursor_position},${3:number new_editcursor_position},${4:number statechangetime} = ultraschall.GetLastCursorPosition()$0"
    },
    "ULTRASCHALL.GETLASTPLAYSTATE_WR lua": {
        "prefix": "ultraschallwr.GetLastPlayState",
        "scope": "lua",
        "description": "Returns the last and current playstate. Needs Ultraschall-API-background-scripts started first, see RunBackgroundHelperFeatures().\npossible states are STOP, PLAY, PLAYPAUSE, REC, RECPAUSE\nreturns -1, if Ultraschall-API-backgroundscripts weren't started yet.\nRETURNS:\nlast_play_state:the last playstate before the current one; -1, in case of an error\nnew_play_state:the new playstate; -1, in case of an error\nstatechangetime:the time, when the state has changed the last time\n",
        "body": "${1:local }${2:string last_play_state},${3:string new_play_state},${4:number statechangetime} = ultraschall.GetLastPlayState()$0"
    },
    "ULTRASCHALL.GETLASTLOOPSTATE_WR lua": {
        "prefix": "ultraschallwr.GetLastLoopState",
        "scope": "lua",
        "description": "Returns the last and current loopstate. Needs Ultraschall-API-background-scripts started first, see RunBackgroundHelperFeatures().\nPossible states are LOOPED, UNLOOPED\nreturns -1, if Ultraschall-API-backgroundscripts weren't started yet.\nRETURNS:\nlast_loop_state:the last loopstate before the current one; -1, in case of an error\nnew_loop_state:the current loopstate; -1, in case of an error\nstatechangetime:the time, when the state has changed the last time\n",
        "body": "${1:local }${2:string last_loop_state},${3:string new_loop_state},${4:number statechangetime} = ultraschall.GetLastLoopState()$0"
    },
    "ULTRASCHALL.GETLOOPSTATE_WR lua": {
        "prefix": "ultraschallwr.GetLoopState",
        "scope": "lua",
        "description": "Returns the current loop-state\nRETURNS:\nretval:0, loop is on; 1, loop is off\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetLoopState()$0"
    },
    "ULTRASCHALL.SETLOOPSTATE_WR lua": {
        "prefix": "ultraschallwr.SetLoopState",
        "scope": "lua",
        "description": "Sets the current loop-state\nreturns false in case of an error\nPARAMETERS:\nstate:0, loop is on; 1, loop is off\nRETURNS:\nretval:true, if setting was successful; false, if setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetLoopState(${3:integer state})$0"
    },
    "ULTRASCHALL.SCRUBBING_MOVECURSOR_GETTOGGLESTATE_WR lua": {
        "prefix": "ultraschallwr.Scrubbing_MoveCursor_GetToggleState",
        "scope": "lua",
        "description": "Returns, if scrub is toggled on/off, for when moving editcursor via action or control surface, as set in Preferences -> Playback.\n",
        "body": "${1:local }${2:boolean state} = ultraschall.Scrubbing_MoveCursor_GetToggleState()$0"
    },
    "ULTRASCHALL.SCRUBBING_MOVECURSOR_TOGGLE_WR lua": {
        "prefix": "ultraschallwr.Scrubbing_MoveCursor_Toggle",
        "scope": "lua",
        "description": "Toggles scrub on/off, for when moving editcursor via action or control surface, as set in Preferences -> Playback.\nreturns false in case of an error\nPARAMETERS:\ntoggle:true, toggles scrubbing on; false, toggles scrubbing off\nRETURNS:\nnew_scrubmode:this is the new value of the configvariable scrubmode, which is altered by this function\n",
        "body": "${1:local }${2:boolean state},${3:optional integer new_scrubmode} = ultraschall.Scrubbing_MoveCursor_Toggle(${4:boolean toggle})$0"
    },
    "ULTRASCHALL.GETPROJECTFILENAME_WR lua": {
        "prefix": "ultraschallwr.GetProjectFilename",
        "scope": "lua",
        "description": "Returns the filename of a currently opened project(-tab)\nreturns nil in case of an error\nPARAMETERS:\nproj:a currently opened project, whose filename you want to know\nRETURNS:\nprojectfilename_with_path:the filename of the project; \"\", project hasn't been saved yet; nil, in case of an error\n",
        "body": "${1:local }${2:string projectfilename_with_path} = ultraschall.GetProjectFilename(${3:ReaProject proj})$0"
    },
    "ULTRASCHALL.CHECKFORCHANGEDPROJECTTABS_WR lua": {
        "prefix": "ultraschallwr.CheckForChangedProjectTabs",
        "scope": "lua",
        "description": "Returns if projecttabs have been changed due reordering, new projects or closed projects, since last calling this function.\nSet update=true to update Ultraschall's internal project-monitoring-list or it will only return the changes since starting the API in this script or since the last time you used this function with parameter update set to true!\nReturns false, -1 in case of error.\nPARAMETERS:\nupdate:true, update Ultraschall's internal projecttab-monitoring-list to the current state of all tabs\nRETURNS:\nretval:false, no changes in the projecttabs at all; true, either order, newprojects or closed project-changes\ncountReorderedProj:the number of reordered projects\nreorderedProj:ReaProjects, who got reordered within the tabs\ncountNewProj:the number of new projects\nnewProj:the new projects as ReaProjects\ncountClosedProj:the number of closed projects\nclosedProj:the closed projects as ReaProjects\ncountRenamedProjects:the number of projects, who got renamed by either saving under a new filename or loading of another project\nRenamesProjects:the renamed projects, by loading a new project or saving the project under another filename\n",
        "body": "${1:local }${2:boolean retval},${3:integer countReorderedProj},${4:array reorderedProj},${5:integer countNewProj},${6:array newProj},${7:integer countClosedProj},${8:array closedProj},${9:integer countRenamedProjects},${10:array RenamesProjects} = ultraschall.CheckForChangedProjectTabs(${11:boolean update})$0"
    },
    "ULTRASCHALL.ISVALIDPROJECTSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.IsValidProjectStateChunk",
        "scope": "lua",
        "description": "Checks, whether ProjectStateChunk is a valid ProjectStateChunk\nPARAMETERS:\nProjectStateChunk:the string to check, if it's a valid ProjectStateChunk\nRETURNS:\nretval:true, if it's a valid ProjectStateChunk; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidProjectStateChunk(${3:string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECTSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProjectStateChunk",
        "scope": "lua",
        "description": "Gets the ProjectStateChunk of the current active project or a projectfile.\nImportant: when calling it too often in a row, this might fail and result in a timeout-error.\nI tried to circumvent this, but best practice is to wait 2-3 seconds inbetween calling this function.\nThis function also eats up a lot of resources, so be sparse with it in general!\nreturns nil if getting the ProjectStateChunk took too long\nPARAMETERS:\nprojectfilename_with_path:the filename of an rpp-projectfile, that you want to load as ProjectStateChunk; nil, to get the ProjectStateChunk from the currently active project\nkeepqrender:true, keeps the QUEUED_RENDER_OUTFILE and QUEUED_RENDER_ORIGINAL_FILENAME entries in the ProjectStateChunk, if existing; false or nil, remove them\nRETURNS:\nProjectStateChunk:the ProjectStateChunk of the current project; nil, if getting the ProjectStateChunk took too long\n",
        "body": "${1:local }${2:string ProjectStateChunk} = ultraschall.GetProjectStateChunk(${3:optional string projectfilename_with_path},${4:optional boolean keepqrender})$0"
    },
    "ULTRASCHALL.ENUMPROJECTS_WR lua": {
        "prefix": "ultraschallwr.EnumProjects",
        "scope": "lua",
        "description": "returns, ReaProject-object and projectname of a requested, opened project.\nReturns nil in case of an error.\nPARAMETERS:\nidx:the project to request; 1(first project-tab) to n(last project-tab), 0 for current project; -1 for currently-rendering project\nRETURNS:\nretval:a ReaProject-object of the project you requested; nil, if not existing\nprojfn:the path+filename.rpp of the project. returns \"\" if no filename exists\n",
        "body": "${1:local }${2:ReaProject retval},${3:string projfn} = ultraschall.EnumProjects(${4:integer idx})$0"
    },
    "ULTRASCHALL.GETPROJECTLENGTH_WR lua": {
        "prefix": "ultraschallwr.GetProjectLength",
        "scope": "lua",
        "description": "Returns the position of the last itemedge, regionend, marker, time-signature-marker in the project.\nIt will return -1, if no such elements are found, means: last\\_markerpos=-1 if no marker has been found\nException when no items are found, it will return nil for last\\_itemedge\nYou can optimise the speed of the function, by setting the appropriate parameters to false.\nSo if you don't need the last itemedge, setting return\\_last\\_itemedge=false speeds up execution massively.\nTo do the same for projectfiles, use: GetProject\\_Length\nPARAMETERS:\nreturn_last_itemedge:true or nil, return the last itemedge; false, don't return it\nreturn_last_markerpos:true or nil, return the last marker/regionend-position; false, don't return it \nreturn_lat_timesigmarkerpos:true or nil, return the last timesignature-marker-position; false, don't return it\nRETURNS:\nlast_itemedge:the position of the last itemedge in the project; nil, if not found\nlast_regionedgepos:the position of the last regionend in the project; -1, if not found\nlast_markerpos:the position of the last marker in the project; -1, if not found \nlast_timesigmarker:the position of the last timesignature-marker in the project; -1, if not found\n",
        "body": "${1:local }${2:number project_length},${3:number last_itemedge},${4:number last_regionedgepos},${5:number last_markerpos},${6:number last_timesigmarker} = ultraschall.GetProjectLength(${7:optional boolean return_last_itemedge},${8:optional boolean return_last_markerpos},${9:optional boolean return_lat_timesigmarkerpos})$0"
    },
    "ULTRASCHALL.GETRECENTPROJECTS_WR lua": {
        "prefix": "ultraschallwr.GetRecentProjects",
        "scope": "lua",
        "description": "returns all available recent projects, as listed in the File -> Recent projects-menu\nRETURNS:\ncount_of_RecentProjects:the number of available recent projects\nRecentProjectsFilenamesWithPath:the filenames of the recent projects\n",
        "body": "${1:local }${2:integer count_of_RecentProjects},${3:array RecentProjectsFilenamesWithPath} = ultraschall.GetRecentProjects()$0"
    },
    "ULTRASCHALL.ISVALIDPROJECTBAYSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.IsValidProjectBayStateChunk",
        "scope": "lua",
        "description": "checks, if ProjectBayStateChunk is a valid ProjectBayStateChunk\nreturns false in case of an error\nPARAMETERS:\nProjectBayStateChunk:a string, that you want to check for being a valid ProjectBayStateChunk\nRETURNS:\nretval:true, valid ProjectBayStateChunk; false, not a valid ProjectBayStateChunk\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidProjectBayStateChunk(${3:string ProjectBayStateChunk})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMS_FROMPROJECTBAYSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItems_FromProjectBayStateChunk",
        "scope": "lua",
        "description": "returns all items from a ProjectBayStateChunk as MediaItemStateChunkArray\nreturns -1 in case of an error\nPARAMETERS:\nProjectBayStateChunk:a string, that you want to check for being a valid ProjectBayStateChunk\nRETURNS:\ncount:the number of items found in the ProjectBayStateChunk\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemStateChunkArray} = ultraschall.GetAllMediaItems_FromProjectBayStateChunk(${4:string ProjectBayStateChunk})$0"
    },
    "ULTRASCHALL.ISTIMESELECTIONACTIVE_WR lua": {
        "prefix": "ultraschallwr.IsTimeSelectionActive",
        "scope": "lua",
        "description": "Returns, if there's a time-selection and its start and endposition in a project.\nreturns false in case of an error\nPARAMETERS:\nProject:the project, whose time-selection-state you want to know; 0 or nil, the current project\nRETURNS:\nretval:true, there is a time-selection; false, there isn't a time-selection\nstart_of_timeselection:start of the time-selection\nend_of_timeselection:end of the time-selection\n",
        "body": "${1:local }${2:boolean retval},${3:optional number start_of_timeselection},${4:optional number end_of_timeselection} = ultraschall.IsTimeSelectionActive(${5:optional ReaProject Project})$0"
    },
    "ULTRASCHALL.GETPROJECTSTATE_NUMBERSONLY_WR lua": {
        "prefix": "ultraschallwr.GetProjectState_NumbersOnly",
        "scope": "lua",
        "description": "returns a state of the project or a ProjectStateChunk.\nIt only supports single-entry-states with numbers/integers, separated by spaces!\nAll other values will be set to nil and strings with spaces will produce weird results!\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the states; nil to use ProjectStateChunk\nstate:the state, whose attributes you want to retrieve\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nnumbertoggle:true or nil; converts all values to numbers; false, keep them as string versions\nRETURNS:\nvalues:all values found as numerical indexed array\n",
        "body": "${1:local }${2:table values} = ultraschall.GetProjectState_NumbersOnly(${3:string projectfilename_with_path},${4:string state},${5:optional string ProjectStateChunk},${6:optional boolean numbertoggle})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERCFG_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderCFG",
        "scope": "lua",
        "description": "Returns the render-cfg-string2, that contains all render-settings for primary and secondary render-settings of a project from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry <RENDER_CFG\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_cfg:the renderstring, which contains all secondary-render-settings for a project/projectstatechunk\nrender_cfg2:the renderstring, which contains all secondary-render-settings for a project/projectstatechunk\n",
        "body": "${1:local }${2:string render_cfg},${3:string render_cfg2} = ultraschall.GetProject_RenderCFG(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GROUPOVERRIDE_WR lua": {
        "prefix": "ultraschallwr.GetProject_GroupOverride",
        "scope": "lua",
        "description": "Returns the group-override-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry GROUPOVERRIDE\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ngroup_override1:the group-override state\ngroup_override3:the group-override state\n",
        "body": "${1:local }${2:integer group_override1},${3:integer group_override2},${4:integer group_override3} = ultraschall.GetProject_GroupOverride(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_AUTOCROSSFADE_WR lua": {
        "prefix": "ultraschallwr.GetProject_AutoCrossFade",
        "scope": "lua",
        "description": "Returns the autocrossfade-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry AUTOXFADE\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename\nRETURNS:\nautocrossfade_state:the autocrossfade-state\n",
        "body": "${1:local }${2:integer autocrossfade_state} = ultraschall.GetProject_AutoCrossFade(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_ENVATTACH_WR lua": {
        "prefix": "ultraschallwr.GetProject_EnvAttach",
        "scope": "lua",
        "description": "Returns the EnvAttach-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry ENVATTACH\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file; nil, use parameter ProjectStateChunk instead\nProjectStateChunk:a projectstatechunk to read the value from; only used, projectfilename_with_path is nil\nRETURNS:\nenv_attach:the env-attach state\n",
        "body": "${1:local }${2:integer env_attach} = ultraschall.GetProject_EnvAttach(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_POOLEDENVATTACH_WR lua": {
        "prefix": "ultraschallwr.GetProject_PooledEnvAttach",
        "scope": "lua",
        "description": "Returns the PooledEnvAttach-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry POOLEDENVATTACH\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file; nil, use parameter ProjectStateChunk instead\nProjectStateChunk:a projectstatechunk to read the value from; only used, projectfilename_with_path is nil\nRETURNS:\npooled_env_attach:the pooled-env-attach state\n",
        "body": "${1:local }${2:integer pooled_env_attach} = ultraschall.GetProject_PooledEnvAttach(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MIXERUIFLAGS_WR lua": {
        "prefix": "ultraschallwr.GetProject_MixerUIFlags",
        "scope": "lua",
        "description": "Returns the MixerUI-state-flags from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry MIXERUIFLAGS\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nstate1:folders, receives, etc \nstate2:master-track, FX, Mixer\n",
        "body": "${1:local }${2:integer state1},${3:integer state2} = ultraschall.GetProject_MixerUIFlags(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PEAKGAIN_WR lua": {
        "prefix": "ultraschallwr.GetProject_PeakGain",
        "scope": "lua",
        "description": "Returns the GetProject_PeakGain-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry PEAKGAIN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npeakgain_state:peakgain-state\n",
        "body": "${1:local }${2:number peakgain_state} = ultraschall.GetProject_PeakGain(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_FEEDBACK_WR lua": {
        "prefix": "ultraschallwr.GetProject_Feedback",
        "scope": "lua",
        "description": "Returns the GetProject_Feedback-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry FEEDBACK\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nfeedback_state:feedback-state\n",
        "body": "${1:local }${2:integer feedback_state} = ultraschall.GetProject_Feedback(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PANLAW_WR lua": {
        "prefix": "ultraschallwr.GetProject_PanLaw",
        "scope": "lua",
        "description": "Returns the GetProject_PanLaw-state from an RPP-Projectfile or a ProjectStateChunk, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db).\nIt's the entry PANLAW\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npanlaw_state:state of the panlaw, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db). 0.5(-6.02 db) to 1(default +0.0 db)\n",
        "body": "${1:local }${2:number panlaw_state} = ultraschall.GetProject_PanLaw(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PROJOFFSETS_WR lua": {
        "prefix": "ultraschallwr.GetProject_ProjOffsets",
        "scope": "lua",
        "description": "Returns the Project Offset-state from an RPP-Projectfile or a ProjectStateChunk, start time as well as start measure.\nas set in ProjectSettings->ProjectSettings->Project Start Time/Measure and the checkbox Base Ruler Marking Off This Measure-checkbox\nIt's the entry PROJOFFS\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nstart_time:the project-start-time in seconds\nstart_measure:starting with 0, unlike the Settingswindow, where the 0 becomes 1 as measure\nbase_ruler_marking_off_this_measure:0, checkbox unchecked; 1, checkbox checked\n",
        "body": "${1:local }${2:number start_time},${3:integer start_measure},${4:integer base_ruler_marking_off_this_measure} = ultraschall.GetProject_ProjOffsets(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MAXPROJECTLENGTH_WR lua": {
        "prefix": "ultraschallwr.GetProject_MaxProjectLength",
        "scope": "lua",
        "description": "Returns the maximum-project-length from an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Advanced->\nas set in ProjectSettings->ProjectSettings->Project Start Time/Measure.\nIt's the entry MAXPROJLEN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nlimit_project_length:checkbox \"Limit project length, stop playback/recording at:\" - 0 off, 1 on\nprojectlength_limit:projectlength-limit in seconds\n",
        "body": "${1:local }${2:integer limit_project_length},${3:number projectlength_limit} = ultraschall.GetProject_MaxProjectLength(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GRID_WR lua": {
        "prefix": "ultraschallwr.GetProject_Grid",
        "scope": "lua",
        "description": "Returns the grid-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry GRID\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file\nRETURNS:\ngridstate1:gridstate1\ngridstate2:gridstate2\ngridstate3:gridstate3\ngridstate4:gridstate4\ngridstate5:gridstate5\ngridstate6:gridstate6\ngridstate7:gridstate7\ngridstate8:gridstate8\n",
        "body": "${1:local }${2:integer gridstate1},${3:integer gridstate2},${4:number gridstate3},${5:integer gridstate4},${6:number gridstate5},${7:integer gridstate6},${8:integer gridstate7},${9:number gridstate8} = ultraschall.GetProject_Grid(${10:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.GETPROJECT_TIMEMODE_WR lua": {
        "prefix": "ultraschallwr.GetProject_Timemode",
        "scope": "lua",
        "description": "Returns the timemode-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry TIMEMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nruler_timemode:ruler-timemode-state\ntimemode2:timemode-state\nshowntime:Transport shown time\ntimemode4:timemode-state\ntimemode5:timemode-state\ntimemode6:timemode-state\ntimemode7:timemode-state\n",
        "body": "${1:local }${2:integer ruler_timemode},${3:integer timemode2},${4:integer showntime},${5:integer timemode4},${6:integer timemode5},${7:integer timemode6},${8:integer timemode7} = ultraschall.GetProject_Timemode(${9:string projectfilename_with_path},${10:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_VIDEOCONFIG_WR lua": {
        "prefix": "ultraschallwr.GetProject_VideoConfig",
        "scope": "lua",
        "description": "Returns the videoconfig-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry VIDEO_CONFIG\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npreferredVidSizeX:preferred video size, x pixels\npreferredVidSizeY:preferred video size, y pixels\nsettingsflags:settings\n",
        "body": "${1:local }${2:integer preferredVidSizeX},${3:integer preferredVidSizeY},${4:integer settingsflags} = ultraschall.GetProject_VideoConfig(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PANMODE_WR lua": {
        "prefix": "ultraschallwr.GetProject_PanMode",
        "scope": "lua",
        "description": "Returns the panmode-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry PANMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\npanmode_state:panmode-state\n",
        "body": "${1:local }${2:integer panmode_state} = ultraschall.GetProject_PanMode(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_CURSORPOS_WR lua": {
        "prefix": "ultraschallwr.GetProject_CursorPos",
        "scope": "lua",
        "description": "Returns the cursorposition-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry CURSOR\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ncursorpos:editcursorposition in seconds\n",
        "body": "${1:local }${2:number cursorpos} = ultraschall.GetProject_CursorPos(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_HORIZONTALZOOM_WR lua": {
        "prefix": "ultraschallwr.GetProject_HorizontalZoom",
        "scope": "lua",
        "description": "Returns the horizontal-zoom-state from an RPP-Projectfile or a ProjectStateChunk.\nKeep in mind, that hzoomscrollpos and scrollbarfactor depend on each other. hzoomscrollpos is a smaller positioning-unit, while scrollbarfactor is the bigger positioning-unit.\nExperiment with it to get an idea.\nIt's the entry ZOOM\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nhzoom:horizontalscrollbarposition - 0 - 4294967296\nhzoomscrollpos:horizontalscrollbarposition - 0 - 4294967296\nscrollbarfactor:0 to 500837, counts up, when maximum hzoomscrollpos overflows\n",
        "body": "${1:local }${2:number hzoom},${3:integer hzoomscrollpos},${4:integer scrollbarfactor} = ultraschall.GetProject_HorizontalZoom(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_VERTICALZOOM_WR lua": {
        "prefix": "ultraschallwr.GetProject_VerticalZoom",
        "scope": "lua",
        "description": "Returns the verticalzoom from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry VZOOMEX\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nvzoom:vertical zoomfactor(0-40)\n",
        "body": "${1:local }${2:integer vzoom} = ultraschall.GetProject_VerticalZoom(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_USERECCONFIG_WR lua": {
        "prefix": "ultraschallwr.GetProject_UseRecConfig",
        "scope": "lua",
        "description": "Returns the rec-cfg-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry USE_REC_CFG\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrec_cfg:recording-cfg-state\n",
        "body": "${1:local }${2:integer rec_cfg} = ultraschall.GetProject_UseRecConfig(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RECMODE_WR lua": {
        "prefix": "ultraschallwr.GetProject_RecMode",
        "scope": "lua",
        "description": "Returns the rec-mode-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RECMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrec_mode:recording-mode-state\n",
        "body": "${1:local }${2:integer rec_mode} = ultraschall.GetProject_RecMode(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_SMPTESYNC_WR lua": {
        "prefix": "ultraschallwr.GetProject_SMPTESync",
        "scope": "lua",
        "description": "Returns the smpte-sync-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry SMPTESYNC\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nsmptesync_state1:smptesync-state\nsmptesync_fps:framerate in fps\nsmptesync_resyncdrift:\"Re-synchronize if drift exceeds\" in ms (0 = never)\nsmptesync_skipdropframes:\"skip/drop frames if drift exceeds\" in ms(0 - never)\nsmptesync_syncseek:\"Synchronize by seeking ahead\" in ms (default = 1000)\nsmptesync_freewheel:\"Freewheel on missing time code for up to\" in ms(0 = forever)\nsmptesync_userinput:User Input-flag\nsmptesync_offsettimecode:Offset incoming timecode by in seconds\nsmptesync_stop_rec_drift:\"Stop recording if drift exceeds\" in ms(0 = never)\nsmptesync_state10:smptesync-state\ninteger smptesync_stop_rec_lacktime:\"stop recording on lack of timecode after\" in ms(0 = never)\n",
        "body": "${1:local }${2:integer smptesync_state1},${3:number smptesync_fps},${4:integer smptesync_resyncdrift},${5:integer smptesync_skipdropframes},${6:integer smptesync_syncseek},${7:integer smptesync_freewheel},${8:integer smptesync_userinput},${9:number smptesync_offsettimecode},${10:integer smptesync_stop_rec_drift},${11:integer smptesync_state10},${12:integer smptesync_stop_rec_lacktime} = ultraschall.GetProject_SMPTESync(${13:string projectfilename_with_path},${14:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LOOP_WR lua": {
        "prefix": "ultraschallwr.GetProject_Loop",
        "scope": "lua",
        "description": "Returns the loop-button-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry LOOP\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\n",
        "body": "${1:local }${2:integer loopbutton_state} = ultraschall.GetProject_Loop(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LOOPGRAN_WR lua": {
        "prefix": "ultraschallwr.GetProject_LoopGran",
        "scope": "lua",
        "description": "Returns the loop_gran-state from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry LOOPGRAN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nloopgran_state1:loopgran_state1\nloopgran_state2:loopgran_state2\n",
        "body": "${1:local }${2:integer loopgran_state1},${3:number loopgran_state2} = ultraschall.GetProject_LoopGran(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RECPATH_WR lua": {
        "prefix": "ultraschallwr.GetProject_RecPath",
        "scope": "lua",
        "description": "Returns the primary and secondary recording-path from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RECORD_PATH\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nprim_recpath:the primary recording path\nsec_recpath:the secondary recording path\n",
        "body": "${1:local }${2:string prim_recpath},${3:string sec_recpath} = ultraschall.GetProject_RecPath(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_APPLYFXCFG_WR lua": {
        "prefix": "ultraschallwr.GetProject_ApplyFXCFG",
        "scope": "lua",
        "description": "Returns the audioformat-configuration, for fx-appliance-operation, as an encoded BASE64-string from an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Media->Format for Apply FX, Glue, Freeze, etc\nIt's the entry <APPLY_CFG\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\napplyfx_cfg_string:the file-format-configuration for fx-appliance as encoded string\n",
        "body": "${1:local }${2:string applyfx_cfg_string} = ultraschall.GetProject_ApplyFXCFG(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERPATTERN_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderPattern",
        "scope": "lua",
        "description": "Returns the render-pattern, that tells Reaper, how to automatically name the render-file, from an RPP-Projectfile or a ProjectStateChunk. If it contains nothing, you should check the Render_Pattern using GetProject_RenderFilename, as a render-pattern influences the rendering-filename as well.\nIt's the entry RENDER_PATTERN\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_pattern:the pattern, with which the rendering-filename will be automatically created. Check also GetProject_RenderFilename\n",
        "body": "${1:local }${2:string render_pattern} = ultraschall.GetProject_RenderPattern(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERFREQNCHANS_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderFreqNChans",
        "scope": "lua",
        "description": "Returns an unknown number, the render-frequency and rendernumber of channels from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RENDER_FMT\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nunknown:unknown number\nrendernum_chans:Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels\nrender_frequency:RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency\n",
        "body": "${1:local }${2:integer unknown},${3:integer rendernum_chans},${4:integer render_frequency} = ultraschall.GetProject_RenderFreqNChans(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERSPEED_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderSpeed",
        "scope": "lua",
        "description": "Returns the rendering-speed from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RENDER_1X\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_speed:render_speed \n",
        "body": "${1:local }${2:integer render_speed} = ultraschall.GetProject_RenderSpeed(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERRANGE_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderRange",
        "scope": "lua",
        "description": "Returns the render-range, render-timestart, render-timeend, render-tail and render-taillength from an RPP-Projectfile or a ProjectStateChunk. To get RENDER_STEMS, refer GetProject_RenderStems\nIt's the entry RENDER_RANGE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nbounds:the bounds of the project to be rendered\ntime_start:TimeStart in milliseconds -2147483647 to 2147483647\ntime_end:TimeEnd in milliseconds 2147483647 to 2147483647\ntail:TailLength in milliseconds, valuerange 0 - 2147483647\ntail_length:TailLength in milliseconds, valuerange 0 - 2147483647\n",
        "body": "${1:local }${2:integer bounds},${3:number time_start},${4:number time_end},${5:integer tail},${6:integer tail_length} = ultraschall.GetProject_RenderRange(${7:string projectfilename_with_path},${8:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERRESAMPLE_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderResample",
        "scope": "lua",
        "description": "Returns Resamplemode for a)Rendering and b)Playback as well as c)if both are combined from an RPP-Projectfile or a ProjectStateChunk.\nIt's the entry RENDER_RESAMPLE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nresample_mode:Playback Resample Mode (as set in the Project-Settings)\nplayback_resample_mode:Playback Resample Mode (as set in the Project-Settings)\nproject_smplrate4mix_and_fx:Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\n",
        "body": "${1:local }${2:integer resample_mode},${3:integer playback_resample_mode},${4:integer project_smplrate4mix_and_fx} = ultraschall.GetProject_RenderResample(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_ADDMEDIATOPROJECTAFTERRENDER_WR lua": {
        "prefix": "ultraschallwr.GetProject_AddMediaToProjectAfterRender",
        "scope": "lua",
        "description": "Returns, if rendered media shall be added to the project afterwards as well as if likely silent files shall be rendered-state, from an RPP-Projectfile or a ProjectStateChunk.\nIt's the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox, as set in the Render to file-dialog.\nIt's the entry RENDER_ADDTOPROJ\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nstate:the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox \n",
        "body": "${1:local }${2:integer state} = ultraschall.GetProject_AddMediaToProjectAfterRender(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERSTEMS_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderStems",
        "scope": "lua",
        "description": "Returns the render-stems-state from an rpp-project-file or a ProjectStateChunk.\nIt's the entry RENDER_STEMS\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_stems:the state of Render Stems\n",
        "body": "${1:local }${2:integer render_stems} = ultraschall.GetProject_RenderStems(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERDITHERSTATE_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderDitherState",
        "scope": "lua",
        "description": "Returns the render-dither-state from an rpp-project-file or a ProjectStateChunk.\nIt's the entry RENDER_DITHER\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrenderdither_state:the state of render dithering\n",
        "body": "${1:local }${2:integer renderdither_state} = ultraschall.GetProject_RenderDitherState(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TIMEBASE_WR lua": {
        "prefix": "ultraschallwr.GetProject_TimeBase",
        "scope": "lua",
        "description": "Returns the timebase-state from an rpp-project-file or a ProjectStateChunk.\nIt's the entry TIMELOCKMODE x\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntimebase:the timebase for items/envelopes/markers as set in the project settings\n",
        "body": "${1:local }${2:integer timebase} = ultraschall.GetProject_TimeBase(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPOTIMESIGNATURE_WR lua": {
        "prefix": "ultraschallwr.GetProject_TempoTimeSignature",
        "scope": "lua",
        "description": "Returns the timebase for tempo/time-signature as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry TEMPOENVLOCKMODE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntempotimesignature:the timebase for tempo/time-signature as set in the project settings\n",
        "body": "${1:local }${2:integer tempotimesignature} = ultraschall.GetProject_TempoTimeSignature(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_ITEMMIXBEHAVIOR_WR lua": {
        "prefix": "ultraschallwr.GetProject_ItemMixBehavior",
        "scope": "lua",
        "description": "Returns the item mix behavior, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry ITEMMIX\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nitem_mix_behav_state:item mix behavior\n",
        "body": "${1:local }${2:integer item_mix_behav_state} = ultraschall.GetProject_ItemMixBehavior(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_SAMPLERATE_WR lua": {
        "prefix": "ultraschallwr.GetProject_SampleRate",
        "scope": "lua",
        "description": "Returns the take-lane-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry SAMPLERATE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nsample_rate:Checkbox: Project Sample Rate\nproject_sample_rate:Checkbox: Project Sample Rate\nforce_tempo_time_sig:Checkbox: Force Project Tempo/Time Signature changes to occur on whole samples \n",
        "body": "${1:local }${2:integer sample_rate},${3:integer project_sample_rate},${4:integer force_tempo_time_sig} = ultraschall.GetProject_SampleRate(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TRACKMIXINGDEPTH_WR lua": {
        "prefix": "ultraschallwr.GetProject_TrackMixingDepth",
        "scope": "lua",
        "description": "Returns the track-mixing-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nIt's the entry INTMIXMODE\nReturns -1 in case of error, nil if it's set to 64bit(default)!\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntrack_mixing_depth:track mixing depth\n",
        "body": "${1:local }${2:integer track_mixing_depth} = ultraschall.GetProject_TrackMixingDepth(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_TrackStateChunk",
        "scope": "lua",
        "description": "Returns an RPPXML-trackstatechunk from an rpp-project-file or a ProjectStateChunk, with tracknumber idx. IDX is 1 for the first track in the project-file, 2 for the second, etc\nReturns -1 in case of error.\nUse GetProject_NumberOfTracks to get the number of tracks within an rpp-file.\nThe returned trackstatechunk can be inserted into the current project with InsertTrack_TrackStateChunk.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nidx:the tracknumber you want to have\ndeletetrackid:deletes the trackID in the trackstate-chunk, to avoid possible conflicts within a project, where it shall be imported to\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ntrackstatechunk:an RPP-XML-Trackstate-chunk, that can be used by functions like reaper.SetTrackStateChunk()\n",
        "body": "${1:local }${2:string trackstatechunk} = ultraschall.GetProject_TrackStateChunk(${3:string projectfilename_with_path},${4:integer idx},${5:boolean deletetrackid},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_NUMBEROFTRACKS_WR lua": {
        "prefix": "ultraschallwr.GetProject_NumberOfTracks",
        "scope": "lua",
        "description": "Returns the number of tracks within an rpp-project-file or a GetProject_NumberOfTracks.\nReturns -1 in case of error.\nNote: Huge projectfiles with thousands of items may take some seconds to load.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nnumber_of_tracks:the number of tracks within an projectfile\n",
        "body": "${1:local }${2:integer number_of_tracks} = ultraschall.GetProject_NumberOfTracks(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_SELECTION_WR lua": {
        "prefix": "ultraschallwr.GetProject_Selection",
        "scope": "lua",
        "description": "Returns the state of the checkbox Delay queued render to allow samples to load-checkbox and the length of the delay.\nIt's the entry RENDER_QDELAY\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nqdelay_checkstate:true, the checkbox is checked; false, it is unchecked\nqdelay_seconds:the length of the queued-render-delay in seconds\n",
        "body": "${1:local }${2:boolean qdelay_checkstate},${3:integer qdelay_seconds} = ultraschall.GetProject_Selection(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_QRENDERORIGINALPROJECT_WR lua": {
        "prefix": "ultraschallwr.GetProject_QRenderOriginalProject",
        "scope": "lua",
        "description": "Returns the original-filename of a queue-render-projectfile. Will return empty string, if the queued-render-project hadn't been saved before it was added to the render-queue.\nIt's the entry QUEUED_RENDER_ORIGINAL_FILENAME\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nqrender_originalproject_file:the original-projectfilename of the queue-render-project\n",
        "body": "${1:local }${2:string qrender_originalproject_file} = ultraschall.GetProject_QRenderOriginalProject(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_QRENDEROUTFILES_WR lua": {
        "prefix": "ultraschallwr.GetProject_QRenderOutFiles",
        "scope": "lua",
        "description": "Returns the outfiles of the rendered files, stored in a queue-render-projectfile. This includes the path and files of the files, that will be rendered.\nIt's the entry QUEUED_RENDER_OUTFILE\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ncount_outfiles:the number of render-outfiles\nQRenderOutFilesList:the guids of the rendered outfiles\nQRenderOutFilesListGuid:the guids of the rendered outfiles\nAutoCloseWhenFinished:true, the render-dialog will be closed after render is finished; false, the render-dialog keeps open\nAutoIncrementFilename:true, autoincrement filename if the file already exists; false, don't autoincrement filename\nSaveCopyToOutfile:true, save a copy of the project as e.g. \"outfile.wav.RPP\"; false, don't save a copy of the project\n",
        "body": "${1:local }${2:integer count_outfiles},${3:table QRenderOutFilesList},${4:table QRenderOutFilesListGuid},${5:boolean AutoCloseWhenFinished},${6:boolean AutoIncrementFilename},${7:boolean SaveCopyToOutfile} = ultraschall.GetProject_QRenderOutFiles(${8:string projectfilename_with_path},${9:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RIPPLESTATE_WR lua": {
        "prefix": "ultraschallwr.SetProject_RippleState",
        "scope": "lua",
        "description": "Sets the ripple-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nripple_state:0, no Ripple; 1, Ripple One Track; 2, Ripple All\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RippleState(${4:string projectfilename_with_path},${5:integer ripple_state},${6:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERQUEUEDELAY_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderQueueDelay",
        "scope": "lua",
        "description": "Sets the render-queue-delay-time in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrenderqdelay:0 and higher, sets the checkbox \"Delay queued render to allow samples to load and the amount of time to wait in seconds\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RenderQueueDelay(${4:string projectfilename_with_path},${5:integer renderqdelay},${6:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_SELECTION_WR lua": {
        "prefix": "ultraschallwr.SetProject_Selection",
        "scope": "lua",
        "description": "Sets the ripple-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstarttime:start of the second selection in seconds\nendtime:end of the second selection in seconds\nstarttime2:start of the second selection in seconds\nendtime2:end of the second selection in seconds\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_Selection(${4:string projectfilename_with_path},${5:number starttime},${6:number endtime},${7:number starttime2},${8:number endtime2},${9:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_GROUPOVERRIDE_WR lua": {
        "prefix": "ultraschallwr.SetProject_GroupOverride",
        "scope": "lua",
        "description": "Sets the group-override-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ngroup_override1:the group-override state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_GroupOverride(${4:string projectfilename_with_path},${5:integer group_override1},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MIXERUIFLAGS_WR lua": {
        "prefix": "ultraschallwr.SetProject_MixerUIFlags",
        "scope": "lua",
        "description": "Sets the Mixer-UI-state-flags in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstate_bitfield1:folders, receives, etc \nstate_bitfield2:master-track, FX, Mixer\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_MixerUIFlags(${4:string projectfilename_with_path},${5:integer state_bitfield1},${6:integer state_bitfield2},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PEAKGAIN_WR lua": {
        "prefix": "ultraschallwr.SetProject_PeakGain",
        "scope": "lua",
        "description": "Sets the peak-gain-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npeakgain_state:peak-gain-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_PeakGain(${4:string projectfilename_with_path},${5:number peakgain_state},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_FEEDBACK_WR lua": {
        "prefix": "ultraschallwr.SetProject_Feedback",
        "scope": "lua",
        "description": "Sets the feedback-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nfeedback_state:feedback-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_Feedback(${4:string projectfilename_with_path},${5:integer feedback_state},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PANLAW_WR lua": {
        "prefix": "ultraschallwr.SetProject_PanLaw",
        "scope": "lua",
        "description": "Sets the panlaw-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npanlaw_state:state of the panlaw, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db). 0.5(-6.02 db) to 1(default +0.0 db)\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_PanLaw(${4:string projectfilename_with_path},${5:number panlaw_state},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PROJOFFSETS_WR lua": {
        "prefix": "ultraschallwr.SetProject_ProjOffsets",
        "scope": "lua",
        "description": "Sets the project-offset-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nThe project-offset, as set in the ProjectSettings -> Project Time Start, Project start measure and Base Ruler Marking Off This Measure-checkbox\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstart_time:the project-start-time in seconds\nstart_measure:the start-measure; starting with 0, unlike in the Project-Settings-window, where the 0 becomes 1 as startmeasure\nbase_ruler_marking_off_this_measure:0, checkbox unchecked; 1, checkbox checked\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_ProjOffsets(${4:string projectfilename_with_path},${5:number start_time},${6:integer start_measure},${7:integer base_ruler_marking_off_this_measure},${8:optional ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MAXPROJECTLENGTH_WR lua": {
        "prefix": "ultraschallwr.SetProject_MaxProjectLength",
        "scope": "lua",
        "description": "Sets the max-project-length-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nlimit_project_length:checkbox \"Limit project length, stop playback/recording at:\" - 0 off, 1 on\nprojectlength_limit:projectlength-limit in seconds\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_MaxProjectLength(${4:string projectfilename_with_path},${5:integer limit_project_length},${6:number projectlength_limit},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_GRID_WR lua": {
        "prefix": "ultraschallwr.SetProject_Grid",
        "scope": "lua",
        "description": "Sets the setproject-grid-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ngridstate1:gridstate1\ngridstate2:gridstate2\ngridstate3:gridstate3\ngridstate4:gridstate4\ngridstate5:gridstate5\ngridstate6:gridstate6\ngridstate7:gridstate7\ngridstate8:gridstate8\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_Grid(${4:string projectfilename_with_path},${5:integer gridstate1},${6:integer gridstate2},${7:number gridstate3},${8:integer gridstate4},${9:number gridstate5},${10:integer gridstate6},${11:integer gridstate7},${12:number gridstate8},${13:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TIMEMODE_WR lua": {
        "prefix": "ultraschallwr.SetProject_Timemode",
        "scope": "lua",
        "description": "Sets the timemode-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntimemode2:timemode-state\nshowntime:Transport shown time\ntimemode4:timemode-state\ntimemode5:timemode-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_Timemode(${4:string projectfilename_with_path},${5:integer timemode1},${6:integer timemode2},${7:integer showntime},${8:integer timemode4},${9:integer timemode5},${10:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_VIDEOCONFIG_WR lua": {
        "prefix": "ultraschallwr.SetProject_VideoConfig",
        "scope": "lua",
        "description": "Sets the video-config-settings, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npreferredVidSizeX:preferred video size, x pixels\npreferredVidSizeY:preferred video size, y pixels\nsettingsBitfield:settings\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_VideoConfig(${4:string projectfilename_with_path},${5:integer preferredVidSizeX},${6:integer preferredVidSizeY},${7:integer settingsBitfield},${8:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PANMODE_WR lua": {
        "prefix": "ultraschallwr.SetProject_PanMode",
        "scope": "lua",
        "description": "Sets the panmode-settings, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npanmode_state:panmode-state - ProjectSettings->Advanced->Pan law/mode->Pan mode\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_PanMode(${4:string projectfilename_with_path},${5:integer panmode_state},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_CURSORPOS_WR lua": {
        "prefix": "ultraschallwr.SetProject_CursorPos",
        "scope": "lua",
        "description": "Sets the cursor-position in an rpp-project-file or a ProjectStateChunk\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ncursorpos:editcursorposition in seconds\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_CursorPos(${4:string projectfilename_with_path},${5:number cursorpos},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_HORIZONTALZOOM_WR lua": {
        "prefix": "ultraschallwr.SetProject_HorizontalZoom",
        "scope": "lua",
        "description": "Sets the horizontal-zoom in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nhzoom:horizontalscrollbarposition - 0 - 4294967296\nhzoomscrollpos:horizontalscrollbarposition - 0 - 4294967296\nscrollbarfactor:0 to 500837, counts up, when maximum hzoomscrollpos overflows\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_HorizontalZoom(${4:string projectfilename_with_path},${5:number hzoom},${6:integer hzoomscrollpos},${7:integer scrollbarfactor},${8:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_VERTICALZOOM_WR lua": {
        "prefix": "ultraschallwr.SetProject_VerticalZoom",
        "scope": "lua",
        "description": "Sets the vertical-zoom from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nvzoom:vertical zoomfactor(0-40)\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_VerticalZoom(${4:string projectfilename_with_path},${5:integer vzoom},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_USERECCONFIG_WR lua": {
        "prefix": "ultraschallwr.SetProject_UseRecConfig",
        "scope": "lua",
        "description": "Sets the UseRec-Config in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrec_cfg:recording-cfg-state\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_UseRecConfig(${4:string projectfilename_with_path},${5:integer rec_cfg},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RECMODE_WR lua": {
        "prefix": "ultraschallwr.SetProject_RecMode",
        "scope": "lua",
        "description": "Sets the recording-mode-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrec_mode:recording mode\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RecMode(${4:string projectfilename_with_path},${5:integer rec_mode},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_SMPTESYNC_WR lua": {
        "prefix": "ultraschallwr.SetProject_SMPTESync",
        "scope": "lua",
        "description": "Sets the TimeCodeSyncronization-SMPTE-Config in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nsmptesync_state1:smptesync-state\nsmptesync_fps:framerate in fps\nsmptesync_resyncdrift:\"Re-synchronize if drift exceeds\" in ms (0 = never)\nsmptesync_skipdropframes:\"skip/drop frames if drift exceeds\" in ms(0 - never)\nsmptesync_syncseek:\"Synchronize by seeking ahead\" in ms (default = 1000)\nsmptesync_freewheel:\"Freewheel on missing time code for up to\" in ms(0 = forever)\nsmptesync_userinput:User Input-flag\nsmptesync_offsettimecode:Offset incoming timecode by in seconds\nsmptesync_stop_rec_drift:\"Stop recording if drift exceeds\" in ms(0 = never)\nsmptesync_state10:smptesync-state\nsmptesync_stop_rec_lacktime:\"stop recording on lack of timecode after\" in ms(0 = never)\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_SMPTESync(${4:string projectfilename_with_path},${5:integer smptesync_state1},${6:number smptesync_fps},${7:integer smptesync_resyncdrift},${8:integer smptesync_skipdropframes},${9:integer smptesync_syncseek},${10:integer smptesync_freewheel},${11:integer smptesync_userinput},${12:number smptesync_offsettimecode},${13:integer smptesync_stop_rec_drift},${14:integer smptesync_state10},${15:integer smptesync_stop_rec_lacktime},${16:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_LOOP_WR lua": {
        "prefix": "ultraschallwr.SetProject_Loop",
        "scope": "lua",
        "description": "Sets the UseRec-Config in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_Loop(${4:string projectfilename_with_path},${5:integer loopbutton_state},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_LOOPGRAN_WR lua": {
        "prefix": "ultraschallwr.SetProject_LoopGran",
        "scope": "lua",
        "description": "Sets the Loop-Gran-state in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nloopgran_state1:loopgran_state1\nloopgran_state2:loopgran_state2\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_LoopGran(${4:string projectfilename_with_path},${5:integer loopgran_state1},${6:number loopgran_state2},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RECPATH_WR lua": {
        "prefix": "ultraschallwr.SetProject_RecPath",
        "scope": "lua",
        "description": "Sets the primary and secondary recording-paths in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nprim_recpath:primary recording path\nsec_recpath:secondary recording path\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RecPath(${4:string projectfilename_with_path},${5:string prim_recpath},${6:string sec_recpath},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERCFG_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderCFG",
        "scope": "lua",
        "description": "Sets the primary and secondary render-configuration as encoded string in an RPP-Projectfile or a ProjectStateChunk, as set in Render-Settings\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrendercfg_string:the secondary render-configuration as encoded string; use \"\" or nil to not set it\nrendercfg_string2:the secondary render-configuration as encoded string; use \"\" or nil to not set it\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RenderCFG(${4:string projectfilename_with_path},${5:string rendercfg_string},${6:string rendercfg_string2},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERFILENAME_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderFilename",
        "scope": "lua",
        "description": "Sets the render-filename in an rpp-projectfile or a ProjectStateChunk. Set to \"\", if you want to set a render-pattern with SetProject_RenderPattern.\nThe rendername is influenced by the settings in the RENDER_PATTERN-entry in the RPP-file, see SetProject_RenderPattern to influence or remove the RENDER_PATTERN-entry(Removing RENDER_PATTERN may help when Reaper rendering it to the name given in parameter render_filename.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk insteadO\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RenderFilename(${4:string projectfilename_with_path},${5:string renderfilename},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERFREQNCHANS_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderFreqNChans",
        "scope": "lua",
        "description": "Returns an unknown number, the render-frequency and rendernumber of channels from an RPP-Projectfile or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nunknown:unknown number\nrendernum_chans:Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels\nrender_frequency:RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RenderFreqNChans(${4:string projectfilename_with_path},${5:integer unknown},${6:integer rendernum_chans},${7:integer render_frequency},${8:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERRANGE_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderRange",
        "scope": "lua",
        "description": "Sets the render-range, render-timestart, render-timeend, render-tail and render-taillength in an RPP-Projectfile or a ProjectStateChunk.\nTo get RENDER_STEMS, refer GetProject_RenderStems\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nbounds:the bounds of the project to be rendered\ntime_start:TimeStart in milliseconds -2147483647 to 2147483647\ntime_end:TimeEnd in milliseconds 2147483647 to 2147483647\ntail:TailLength in milliseconds, valuerange 0 - 2147483647\ntail_length:TailLength in milliseconds, valuerange 0 - 2147483647\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RenderRange(${4:string projectfilename_with_path},${5:integer bounds},${6:number time_start},${7:number time_end},${8:integer tail},${9:integer tail_length},${10:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERRESAMPLE_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderResample",
        "scope": "lua",
        "description": "Resamplemode for a)Rendering and b)Playback as well as c)if both are combined from an RPP-Projectfile or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nresample_mode:Playback Resample Mode (as set in the Project-Settings)\nplayback_resample_mode:Playback Resample Mode (as set in the Project-Settings)\nproject_smplrate4mix_and_fx:Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RenderResample(${4:string projectfilename_with_path},${5:integer resample_mode},${6:integer playback_resample_mode},${7:integer project_smplrate4mix_and_fx},${8:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_ADDMEDIATOPROJECTAFTERRENDER_WR lua": {
        "prefix": "ultraschallwr.SetProject_AddMediaToProjectAfterRender",
        "scope": "lua",
        "description": "Sets, if rendered media shall be added to the project afterwards as well as if likely silent files shall be rendered-state, from an RPP-Projectfile or a ProjectStateChunk.\nIt's the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox, as set in the Render to file-dialog.\nIt's the entry RENDER_ADDTOPROJ\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nstate:the state of the \"Add rendered items to new tracks in project\"- checkbox and \"Do not render files that are likely silent\"-checkbox \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_AddMediaToProjectAfterRender(${4:string projectfilename_with_path},${5:integer state},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERSTEMS_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderStems",
        "scope": "lua",
        "description": "Sets the render-stems-state from an RPP-Projectfile or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrender_stems:the state of Render Stems\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_RenderStems(${4:string projectfilename_with_path},${5:integer render_stems},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TIMEBASE_WR lua": {
        "prefix": "ultraschallwr.SetProject_TimeBase",
        "scope": "lua",
        "description": "Sets the timebase, as set in the project-settings, in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntimebase:the timebase for items/envelopes/markers as set in the project settings\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_TimeBase(${4:string projectfilename_with_path},${5:integer timebase},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TEMPOTIMESIGNATURE_WR lua": {
        "prefix": "ultraschallwr.SetProject_TempoTimeSignature",
        "scope": "lua",
        "description": "Sets the timebase, as set in the project-settings, in an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntempotimesignature:the timebase for tempo/time-signature as set in the project settings\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_TempoTimeSignature(${4:string projectfilename_with_path},${5:integer tempotimesignature},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_ITEMMIXBEHAVIOR_WR lua": {
        "prefix": "ultraschallwr.SetProject_ItemMixBehavior",
        "scope": "lua",
        "description": "Sets the item mix behavior, as set in the project-settings, from an rpp-project-file.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path of the rpp-project-file\nitem_mix_behav_state:item mix behavior\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_ItemMixBehavior(${4:string projectfilename_with_path},${5:integer item_mix_behav_state},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_DEFPITCHMODE_WR lua": {
        "prefix": "ultraschallwr.SetProject_DefPitchMode",
        "scope": "lua",
        "description": "Sets the default-pitch-mode, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ndef_pitch_mode_state:the default pitch mode\nstretch_marker_mode:the stretch marker mode\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_DefPitchMode(${4:string projectfilename_with_path},${5:integer def_pitch_mode_state},${6:integer stretch_marker_mode},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TRACKMIXINGDEPTH_WR lua": {
        "prefix": "ultraschallwr.SetProject_TrackMixingDepth",
        "scope": "lua",
        "description": "Sets the project-samplerate-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nmixingdepth:the track mixing depth\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_TrackMixingDepth(${4:string projectfilename_with_path},${5:integer mixingdepth},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_COUNTMARKERSANDREGIONS_WR lua": {
        "prefix": "ultraschallwr.GetProject_CountMarkersAndRegions",
        "scope": "lua",
        "description": "returns the number of all markers, the number of regions and the number of markers(that are not regions) in the project.\nIt's the entry MARKER\nreturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename in which to count the markers\nRETURNS:\nnumber_of_markers_and_regions:the number of all markers and regions\nnumber_of_regions_only:the number of regions\nnumber_of_markers_only:the number of markers only\n",
        "body": "${1:local }${2:integer number_of_markers_and_regions},${3:integer number_of_regions_only},${4:integer number_of_markers_only} = ultraschall.GetProject_CountMarkersAndRegions(${5:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.GETPROJECT_GETMARKER_WR lua": {
        "prefix": "ultraschallwr.GetProject_GetMarker",
        "scope": "lua",
        "description": "returns the information of the marker idx in a projectfile.\nIt's the entry MARKER\nreturns false in case of error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename from where to get the marker\nidx:the number of the marker, you want to have the information of\nRETURNS:\nretval:true, in case of success; false in case of failure\nshownnumber:the number that is shown with the marker in the arrange-view\nmarkerposition:the position of the marker in seconds\nmarkertitle:the name of the marker. \"\" if no name is given.\nmarkercolor:the colorvalue of the marker\n",
        "body": "${1:local }${2:boolean retval},${3:integer shownnumber},${4:number markerposition},${5:string markertitle},${6:integer markercolor} = ultraschall.GetProject_GetMarker(${7:string projectfilename_with_path},${8:integer idx})$0"
    },
    "ULTRASCHALL.GETPROJECT_GETREGION_WR lua": {
        "prefix": "ultraschallwr.GetProject_GetRegion",
        "scope": "lua",
        "description": "returns the information of the region idx in a projectfile.\nIt's the entry MARKER\nreturns false in case of error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename from where to get the region\nidx:the number of the marker, you want to have the information of\nRETURNS:\nretval:true, in case of success; false in case of failure\nshownnumber:the number that is shown with the region in the arrange-view\nstart_of_region:the startposition of the region in seconds\nend_of_region:the endposition of the region in seconds\nregionname:the name of the region. \"\" if no name is given.\nregioncolor:the colorvalue of the region\n",
        "body": "${1:local }${2:boolean retval},${3:integer shownnumber},${4:number start_of_region},${5:number end_of_region},${6:string regionname},${7:integer regioncolor} = ultraschall.GetProject_GetRegion(${8:string projectfilename_with_path},${9:integer idx})$0"
    },
    "ULTRASCHALL.ISVALIDREAPROJECT_WR lua": {
        "prefix": "ultraschallwr.IsValidReaProject",
        "scope": "lua",
        "description": "Returns, if parameter ReaProject is a valid ReaProject(means, an existing opened project) or not.\nreturns false in case of an error\nPARAMETERS:\nReaProject:the object that you want to check for being a valid ReaProject\nRETURNS:\nretval:true, if parameter ReaProject is a valid ReaProject; false, if parameter ReaProject isn't a valid ReaProject\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidReaProject(${3:ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.NEWPROJECTTAB_WR lua": {
        "prefix": "ultraschallwr.NewProjectTab",
        "scope": "lua",
        "description": "Opens a new projecttab and optionally switches to it. Returns the newly created ReaProject.\nreturns nil in case of an error\nPARAMETERS:\nswitch_to_new_tab:true, switch to the newly created project-tab; false, stay in the \"old\" project-tab\nRETURNS:\nnewproject:the newly created project-object of the projecttab\n",
        "body": "${1:local }${2:ReaProject newproject} = ultraschall.NewProjectTab(${3:boolean switch_to_new_tab})$0"
    },
    "ULTRASCHALL.GETCURRENTTIMELENGTHOFFRAME_WR lua": {
        "prefix": "ultraschallwr.GetCurrentTimeLengthOfFrame",
        "scope": "lua",
        "description": "Returns a project's length of a frame in seconds. Depends on the fps set in the Project's settings of ReaProject.\nReturns -1 in case of an error\nPARAMETERS:\nReaProject:the project to check for; use nil or 0 for the current project\nRETURNS:\nlength:the current length of a frame of ReaProject in seconds\n",
        "body": "${1:local }${2:number length} = ultraschall.GetCurrentTimeLengthOfFrame(${3:ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.GETLENGTHOFFRAMES_WR lua": {
        "prefix": "ultraschallwr.GetLengthOfFrames",
        "scope": "lua",
        "description": "Returns the length of a number of frames of a ReaProject. Depends on the fps set in the Project's settings of ReaProject.\nReturns -1 in case of an error\nPARAMETERS:\nframes:the number of frames, whose length you would love to know\nReaProject:the project to check for; use nil or 0 for the current project\nRETURNS:\nlength:the current length of frames of ReaProject in seconds\n",
        "body": "${1:local }${2:number length} = ultraschall.GetLengthOfFrames(${3:integer frames},${4:ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.CONVERTOLDPROJECTTOCURRENTREAPERVERSION_WR lua": {
        "prefix": "ultraschallwr.ConvertOldProjectToCurrentReaperVersion",
        "scope": "lua",
        "description": "Convert an old Reaper-project to the current Reaper-version.\nIt creates a backup-copy of the old version of the project.rpp to project.rpp~0\nAfter that, it will open the project and save it again, so it is saved with the newest version of Reaper.\nMaybe helpful, when you want to use the Ultraschall-API Get/SetProject-State-functions on older projects, where some states were saved differently.\nJust create a \"new\" version of it and use the aforementioned functions on the new project-version.\nReturns false in case of an error.\nPARAMETERS:\nfilename_with_path:the filename with path of the rpp-projectfile to be converted.\nRETURNS:\nretval:true, conversion was successfull; false, conversion wasn't successful(file doesn't exist or a copy can't be created)\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ConvertOldProjectToCurrentReaperVersion(${3:string filename_with_path})$0"
    },
    "ULTRASCHALL.GETPROJECT_PROJECTBAY_WR lua": {
        "prefix": "ultraschallwr.GetProject_ProjectBay",
        "scope": "lua",
        "description": "returns the ProjectBay-StateChunk, that holds MediaItems, that shall be retained in the \"background\" of the project, even if they are deleted from the project.\nThese MediaItems can be seen and set to retain from within the ProjectBay-window.\nIt's the entry <PROJBAY ... >\nreturns nil in case of an error\nPARAMETERS:\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nProjectBayStateChunk:the statechunk of the ProjectBay\n",
        "body": "${1:local }${2:string ProjectBayStateChunk} = ultraschall.GetProject_ProjectBay(${3:string ProjectStateChunk},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_METRONOME_WR lua": {
        "prefix": "ultraschallwr.GetProject_Metronome",
        "scope": "lua",
        "description": "returns the Metronome-StateChunk, that holds metronome-settings.\nIt's the entry <METRONOME ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the metronome-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMetronomeStateChunk:the statechunk of the Metronome\n",
        "body": "${1:local }${2:string MetronomeStateChunk} = ultraschall.GetProject_Metronome(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERPLAYSPEED_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterPlayspeed",
        "scope": "lua",
        "description": "returns the Master-Playspeed-StateChunk, that holds Playspeed-settings of the master.\nIt's the entry <MASTERPLAYSPEEDENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-playspeed-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterPlayspeedStateChunk:the statechunk of the MasterPlaySpeed\n",
        "body": "${1:local }${2:string MasterPlayspeedStateChunk} = ultraschall.GetProject_MasterPlayspeed(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPOENVEX_WR lua": {
        "prefix": "ultraschallwr.GetProject_TempoEnvEx",
        "scope": "lua",
        "description": "returns the Tempo-StateChunk, that holds tempo-settings of the master.\nIt's the entry <TEMPOENVEX ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the tempo-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nTempoStateChunk:the statechunk of the Tempo\n",
        "body": "${1:local }${2:string TempoStateChunk} = ultraschall.GetProject_TempoEnvEx(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_EXTENSIONS_WR lua": {
        "prefix": "ultraschallwr.GetProject_Extensions",
        "scope": "lua",
        "description": "returns the Extensions-settings-StateChunk, that holds tempo-settings of the master.\nIt's the entry <EXTENSIONS ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the extension-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nExtensionsStateChunk:the statechunk of the Extensions-settings\n",
        "body": "${1:local }${2:string ExtensionsStateChunk} = ultraschall.GetProject_Extensions(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LOCK_WR lua": {
        "prefix": "ultraschallwr.GetProject_Lock",
        "scope": "lua",
        "description": "returns the individual lock-settings of the project, as set in menu Options -> Locking -> Locking Settings\nIt's the entry LOCK\nIt is the one before(!) any\nstring projectfilename_with_path - the projectfile+path, from which to get the lock-state; nil to use ProjectStateChunk\noptional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file\ninteger lock_state - the lock-state, which is a bitfield\n- &1     - Time selection\n- &2     - Items (full)\n- &4     - Track envelopes\n- &8     - Markers\n- &16    - Regions\n- &32    - Time signature markers\n- &64    - Items (prevent left/right movement)\n- &128   - Items (prevent up/down movement)\n- &256   - Item edges\n- &512   - Item fade/volume handles\n- &1024  - Loop points locked\n- &2048  - Item envelopes\n- &4096  - Item stretch markers\n- &16384 - Enable locking\nProject-Management\nRPP-Files Get\nUS_Api_Functions\nModules/ultraschall_functions_ProjectManagement_ProjectFiles_Module.lua\nprojectmanagement, get, lock, projectstatechunk\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the lock-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nlock_state:the lock-state, which is a bitfield\n",
        "body": "${1:local }${2:integer lock_state} = ultraschall.GetProject_Lock(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GLOBALAUTO_WR lua": {
        "prefix": "ultraschallwr.GetProject_GlobalAuto",
        "scope": "lua",
        "description": "returns the global-automation-settings of the project.\nIt's the entry GLOBAL_AUTO\nreturns nil in case of an error or if the setting isn't existing\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the global-automation-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nglobalauto_state:the global automation override state, this sets the same automation mode to all tracks!\n",
        "body": "${1:local }${2:integer globalauto_state} = ultraschall.GetProject_GlobalAuto(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPO_WR lua": {
        "prefix": "ultraschallwr.GetProject_Tempo",
        "scope": "lua",
        "description": "returns the tempo-settings of the project, as set in the Project Settings -> Project Settings-tab\nIt's the entry TEMPO\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the tempo-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nbpm:the tempo of the project in bpm\nbeat:the beat of the project\ndenominator:the denominator for the beat\n",
        "body": "${1:local }${2:number bpm},${3:integer beat},${4:integer denominator} = ultraschall.GetProject_Tempo(${5:string projectfilename_with_path},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_PLAYRATE_WR lua": {
        "prefix": "ultraschallwr.GetProject_Playrate",
        "scope": "lua",
        "description": "returns the tempo-settings of the project, as set in the Project Settings -> Project Settings-tab\nIt's the entry PLAYRATE\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the playrate-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nplayrate:the maximum playrate possible in the project; 0.01 to 10\npreserve_pitch:0, don't preserve pitch, when changing playrate; 1, preserve pitch, when changing playrate\nmin_playrate:the minimum playrate possible in the project; 0.01 to 10\nmax_playrate:the maximum playrate possible in the project; 0.01 to 10\n",
        "body": "${1:local }${2:number playrate},${3:integer preserve_pitch},${4:number min_playrate},${5:number max_playrate} = ultraschall.GetProject_Playrate(${6:string projectfilename_with_path},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERAUTOMODE_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterAutomode",
        "scope": "lua",
        "description": "returns the automation-mode of the master-track of the project, as set in the \"Envelopes for Master Track\"-dialog or the context-menu for the Master Track -> Set track automation mode -> ...\nIt's the entry MASTERAUTOMODE\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-automation-mode; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nautomode:the automation-mode, as set in the Envelopes for Master Track\n",
        "body": "${1:local }${2:integer automode} = ultraschall.GetProject_MasterAutomode(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERSEL_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterSel",
        "scope": "lua",
        "description": "returns the master-track-selection-state of the master-track of the project.\nIt's the entry MASTER_SEL\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-selection; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nselection:the selection-state; 0, master-track unselected; 1, master-track selected\n",
        "body": "${1:local }${2:integer selection} = ultraschall.GetProject_MasterSel(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERFXBYP_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterFXByp",
        "scope": "lua",
        "description": "returns the fx-bypass-state of the master-track of the project.\nIt's the entry MASTER_FX\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-fx-bypass-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nfx_byp_state:the fx-bypass-state; 0, master-track-fx bypassed; 1, master-track-fx normal\n",
        "body": "${1:local }${2:integer fx_byp_state} = ultraschall.GetProject_MasterFXByp(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERMUTESOLO_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterMuteSolo",
        "scope": "lua",
        "description": "returns the mute-solo-state of the master-track of the project.\nHas no exclusive-solo/mute-settings!\nIt's the entry MASTERMUTESOLO\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-mute-solo-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nmute_solo_state:the mute-solo-state; it is a bitfield\n",
        "body": "${1:local }${2:integer mute_solo_state} = ultraschall.GetProject_MasterMuteSolo(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERNCHANS_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterNChans",
        "scope": "lua",
        "description": "returns the number of output channels-settings and the vu-peak-metering-settings of the master-track of the project.\nIt's the entry MASTER_NCH\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-nchans; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nnumber_of_channels:the number of output-channels, as set in the \"Outputs for the Master Channel -> Track Channels\"-dialog\npeak_metering:2, Multichannel peak metering-setting, as set in the \"Master VU settings\"-dialog\n",
        "body": "${1:local }${2:integer number_of_channels},${3:integer peak_metering} = ultraschall.GetProject_MasterNChans(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERTRACKHEIGHT_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterTrackHeight",
        "scope": "lua",
        "description": "returns the master-trackheight-states of the master-track of the project.\nIt's the entry MASTERTRACKHEIGHT\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the mastertrackheight-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nheight_state:the current-height of the master-track, from 24 to 260\nheight_lock:0, height-lock is off; 1, height-lock is on\n",
        "body": "${1:local }${2:integer height_state},${3:integer height_lock} = ultraschall.GetProject_MasterTrackHeight(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERTRACKCOLOR_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterTrackColor",
        "scope": "lua",
        "description": "returns the master-color of the master-track of the project.\nIt's the entry MASTERPEAKCOL\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the mastertrack-color; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ncolor:the color for the master-track\n",
        "body": "${1:local }${2:integer color} = ultraschall.GetProject_MasterTrackColor(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERTRACKVIEW_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterTrackView",
        "scope": "lua",
        "description": "returns the master-view-state of the master-track of the project or a ProjectStateChunk.\nIt's the entry MASTERTRACKVIEW\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the trackview-states; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ntcp_visibility:0, Master-track is invisible in MCP; 1, Master-track is visible in MCP\nstate2:unknown\nstate3:unknown\nstate4:unknown\nstate5:unknown\nstate6:unknown\nstate7:unknown\nstate8:unknown\nstate9:unknown\nstate10:unknown\n",
        "body": "${1:local }${2:integer tcp_visibility},${3:number state2},${4:number state3},${5:number state4},${6:integer state5},${7:integer state6},${8:integer state7},${9:integer state8},${10:integer state9},${11:integer state10} = ultraschall.GetProject_MasterTrackView(${12:string projectfilename_with_path},${13:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_COUNTMASTERHWOUTS_WR lua": {
        "prefix": "ultraschallwr.GetProject_CountMasterHWOuts",
        "scope": "lua",
        "description": "returns the number of available hwouts in an rpp-project or ProjectStateChunk\nIt's the entry MASTERHWOUT\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to count the master-hwouts; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ncount_of_hwouts:the number of available hwouts in an rpp-project or ProjectStateChunk\n",
        "body": "${1:local }${2:integer count_of_hwouts} = ultraschall.GetProject_CountMasterHWOuts(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERHWOUT_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterHWOut",
        "scope": "lua",
        "description": "returns the HWOut of the master-track of the project, as set in the \"Outputs for Master Track\"-dialog\nThere can be multiple HWOuts for the Master-Track.\nIt's the entry MASTERHWOUT\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-hwout-states; nil to use ProjectStateChunk\nidx:the number of the requested HWOut-setting; 1 for the first, etc.\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nstate1:unknown\nstate2:unknown\nvolume:volume of the HWOut; \npan:the panning; -1(left), 1(right), 0(center)\nmute:mute-state; 0, unmuted; 1, muted\nphase:phase-inversion; 0, normal phase; 1, inversed phase\noutput_channels:       -1 - None\nstate8:unknown\n",
        "body": "${1:local }${2:integer state1},${3:integer state2},${4:number volume},${5:number pan},${6:integer mute},${7:integer phase},${8:integer output_channels},${9:number state8} = ultraschall.GetProject_MasterHWOut(${10:string projectfilename_with_path},${11:integer idx},${12:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLUME_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterVolume",
        "scope": "lua",
        "description": "returns the Master-volume-state of the master-track of the project.\nIt's the entry MASTER_VOLUME\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volume-states; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nvolume:Volume; 0(-inf dB) to 3.981071705535(+12dB);1 for 0dB\npan:the second pan_knob for pan-mode \"Dual Pan\" \npan_law:Pan_Law, as set in the \"Pan Law: Master Track\"-dialog; 1(0dB); 0.5(-6.02dB)\nstate4:unknown\npan_knob3:the second pan_knob for pan-mode \"Dual Pan\" \n",
        "body": "${1:local }${2:number volume},${3:number pan},${4:number pan_law},${5:number state4},${6:number pan_knob3} = ultraschall.GetProject_MasterVolume(${7:string projectfilename_with_path},${8:integer idx},${9:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERPANMODE_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterPanMode",
        "scope": "lua",
        "description": "returns the master-panmode of the master-track of the project.\nIt's the entry MASTER_PANMODE\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-panmode; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\npanmode:the panmode for the master-track; \n",
        "body": "${1:local }${2:integer panmode} = ultraschall.GetProject_MasterPanMode(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERWIDTH_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterWidth",
        "scope": "lua",
        "description": "returns the master-width for the second pan-knob in stereo pan-modes, of the master-track of the project.\nIt's the entry MASTER_WIDTH\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the masterwidth-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\npan_knob_two:-1(left), 1(right), 0(center)\n",
        "body": "${1:local }${2:number pan_knob_two} = ultraschall.GetProject_MasterWidth(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERGROUPFLAGSSTATE_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterGroupFlagsState",
        "scope": "lua",
        "description": "returns the state of the group-flags for the Master-Track, as set in the menu Track Grouping Parameters; from an rpp-projectfile or a ProjectStateChunk.\nReturns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 1 to 32. To get Groups 33 to 64, use GetTrackGroupFlags_HighState instead!\nIt's the entry MASTER_GROUP_FLAGS\nreturns -1 in case of failure\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the groups-state-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "${1:local }${2:integer GroupState_as_Flags},${3:array IndividualGroupState_Flags} = ultraschall.GetProject_MasterGroupFlagsState(${4:string projectfilename_with_path},${5:optional stirng ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERGROUPFLAGSHIGHSTATE_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterGroupFlagsHighState",
        "scope": "lua",
        "description": "returns the state of the group-high-flags for the Master-Track, as set in the menu Track Grouping Parameters; from an rpp-projectfile or a ProjectStateChunk.\nReturns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 1 to 32. To get Groups 33 to 64, use GetTrackGroupFlags_HighState instead!\nIt's the entry MASTER_GROUP_FLAGS_HIGH\nreturns -1 in case of failure\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the groupshigh-state-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "${1:local }${2:integer GroupState_as_Flags},${3:array IndividualGroupState_Flags} = ultraschall.GetProject_MasterGroupFlagsHighState(${4:string projectfilename_with_path},${5:optional stirng ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GROUPDISABLED_WR lua": {
        "prefix": "ultraschallwr.GetProject_GroupDisabled",
        "scope": "lua",
        "description": "returns the group-disabled-stated, of the master-track of the project.\nIt's the entry GROUPS_DISABLED\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the groups-disabled-state; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\ndisabled1:the disabled groups; it is a bitfield, with &1 for group 1; &32 for group 32; if it's set, the accompanying group is disabled\ndisabled2:the disabled groups_high; it is a bitfield, with &1 for group 33; &32 for group 64; if it's set, the accompanying group is disabled\n",
        "body": "${1:local }${2:integer disabled1},${3:integer disabled2} = ultraschall.GetProject_GroupDisabled(${4:string projectfilename_with_path},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERHWVOLENVSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterHWVolEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-HWVolEnv-StateChunk, that holds MasterHWVolEnv-settings of the master.\nIt's the entry <MASTERHWVOLENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-hwvolenv-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterHWVolEnvStateChunk:the statechunk of the HWVolEnv\n",
        "body": "${1:local }${2:string MasterHWVolEnvStateChunk} = ultraschall.GetProject_MasterHWVolEnvStateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERFXLISTSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterFXListStateChunk",
        "scope": "lua",
        "description": "returns the Master-FX_List-StateChunk, that holds Master-FX-settings for the window as well as the FX themselves, of the master.\nIt's the entry <MASTERFXLIST ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-fxlist-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterFXListStateChunk:the statechunk of the Master-FX-list\n",
        "body": "${1:local }${2:string MasterFXListStateChunk} = ultraschall.GetProject_MasterFXListStateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENVSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterDualPanEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-DualPanEnv-StateChunk, that holds MasterDualPanEnv-settings of the master.\nIt's the entry <MASTERDUALPANENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-env-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterDualPanEnvStateChunk:the statechunk of the Master-DualPan-Env-state\n",
        "body": "${1:local }${2:string MasterDualPanEnvStateChunk} = ultraschall.GetProject_MasterDualPanEnvStateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENV2STATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterDualPanEnv2StateChunk",
        "scope": "lua",
        "description": "returns the Master-DualPanEnv2-StateChunk, that holds master-DualPanEnv2-settings of the master.\nIt's the entry <MASTERDUALPANENV2 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-env2-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\n",
        "body": "${1:local }${2:string MasterDualPanEnv2StateChunk} = ultraschall.GetProject_MasterDualPanEnv2StateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENVLSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterDualPanEnvLStateChunk",
        "scope": "lua",
        "description": "returns the Master-DualPan-EnvL-StateChunk, that holds Master-DualPan-EnvL-settings of the master.\nIt's the entry <MASTERDUALPANENVL ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-envL-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterDualPanEnvLStateChunk:the statechunk of the Master-DualPan-EnvL-state\n",
        "body": "${1:local }${2:string MasterDualPanEnvLStateChunk} = ultraschall.GetProject_MasterDualPanEnvLStateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERDUALPANENVL2STATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterDualPanEnvL2StateChunk",
        "scope": "lua",
        "description": "returns the Master-Dual-Pan-EnvL2-StateChunk, that holds Master-FX-Dual-Pan-EnvL2-settings of the master.\nIt's the entry <MASTERDUALPANENVL2 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-dualpan-envL2-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterDualPanEnvL2StateChunk:the statechunk of the Master-DualPan-EnvL2-state\n",
        "body": "${1:local }${2:string MasterDualPanEnvL2StateChunk} = ultraschall.GetProject_MasterDualPanEnvL2StateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLENVSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterVolEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-Vol-Env-StateChunk, that holds Master-Vol-Env-settings of the master.\nIt's the entry <MASTERVOLENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volenv-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterVolEnvStateChunk:the statechunk of the Master-volenv-state\n",
        "body": "${1:local }${2:string MasterVolEnvStateChunk} = ultraschall.GetProject_MasterVolEnvStateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLENV2STATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterVolEnv2StateChunk",
        "scope": "lua",
        "description": "returns the Master-Vol-Env2-StateChunk, that holds Master-Vol-Env2-settings of the master.\nIt's the entry <MASTERVOLENV2 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volenv2-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterVolEnv2StateChunk:the statechunk of the Master-volenv2-state\n",
        "body": "${1:local }${2:string MasterVolEnv2StateChunk} = ultraschall.GetProject_MasterVolEnv2StateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERVOLENV3STATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterVolEnv3StateChunk",
        "scope": "lua",
        "description": "returns the Master-Vol-Env3-StateChunk, that holds Master-Vol-Env3-settings of the master.\nIt's the entry <MASTERVOLENV3 ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-volenv3-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterVolEnv3StateChunk:the statechunk of the Master-volenv3-state\n",
        "body": "${1:local }${2:string MasterVolEnv3StateChunk} = ultraschall.GetProject_MasterVolEnv3StateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERHWPANENVSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterHWPanEnvStateChunk",
        "scope": "lua",
        "description": "returns the Master-HW-pan-env-StateChunk, that holds Master-pan-env-settings of the master.\nIt's the entry <MASTERHWPANENV ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-HW-pan-env-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterHWPanEnvStateChunk:the statechunk of the Master-volenv3-state\n",
        "body": "${1:local }${2:string MasterHWPanEnvStateChunk} = ultraschall.GetProject_MasterHWPanEnvStateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_MASTERPANMODE_EX_WR lua": {
        "prefix": "ultraschallwr.GetProject_MasterPanMode_Ex",
        "scope": "lua",
        "description": "returns the Master-HW-pan-mode-ex-StateChunk, that holds Master-pan-mode-ex-settings of the master.\nIt's the entry <MASTER_PANMODE_EX ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the master-HW-pan-env-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nMasterHWPanModeEx_StateChunk:the statechunk of the Master-pan-mode-ex\n",
        "body": "${1:local }${2:string MasterHWPanModeEx_StateChunk} = ultraschall.GetProject_MasterPanMode_Ex(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_TEMPOENV_EXSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetProject_TempoEnv_ExStateChunk",
        "scope": "lua",
        "description": "returns the TempoEnv_ExStateChunk, that holds TempoEnv_Ex-settings of an rpp-project or ProjectStateChunk.\nIt's the entry <TEMPOENVEX ... >\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile+path, from which to get the tempo-env-ex-statechunk; nil to use ProjectStateChunk\nProjectStateChunk:a statechunk of a project, usually the contents of a rpp-project-file\nRETURNS:\nTempoEnv_ExStateChunk:the statechunk of the Tempo-Env-Ex\n",
        "body": "${1:local }${2:string TempoEnv_ExStateChunk} = ultraschall.GetProject_TempoEnv_ExStateChunk(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_LENGTH_WR lua": {
        "prefix": "ultraschallwr.GetProject_Length",
        "scope": "lua",
        "description": "Returns the projectlength of an rpp-project-file.\nIt's eturning the position of the overall length, as well as the position of the last itemedge/regionedge/marker/time-signature-marker of the project.\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the filename of the project, that you want to know it's length of; nil, to use Parameter ProjectStateChunk instead\nProjectStateChunk:a ProjectStateChunk to count the length of; only available when projectfilename_with_path=nil\nRETURNS:\nlength:the length of the project\nlast_itemedge:the postion of the last itemedge in the project\nlast_marker_reg_edge:the position of the last marker/regionedge in the project\nlast_timesig_marker:the position of the last time-signature-marker in the project\n",
        "body": "${1:local }${2:number length},${3:number last_itemedge},${4:number last_marker_reg_edge},${5:number last_timesig_marker} = ultraschall.GetProject_Length(${6:string projectfilename_with_path},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.CREATETEMPORARYFILEOFPROJECTFILE_WR lua": {
        "prefix": "ultraschallwr.CreateTemporaryFileOfProjectfile",
        "scope": "lua",
        "description": "Creates a temporary copy of an rpp-projectfile, which can be altered and rendered again.\nMust be deleted by hand using os.remove(tempfile) after you're finished.\nreturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the project to render; nil, for the currently opened project(needs to be saved first)\nRETURNS:\ntempfile:the temporary-file, that is a valid copy of the projectfilename_with_path\n",
        "body": "${1:local }${2:string tempfile} = ultraschall.CreateTemporaryFileOfProjectfile(${3:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.SETPROJECT_RENDERPATTERN_WR lua": {
        "prefix": "ultraschallwr.SetProject_RenderPattern",
        "scope": "lua",
        "description": "Sets the render-filename in an rpp-projectfile or a ProjectStateChunk. Set it to \"\", if you want to set the render-filename with SetProject_RenderFilename.\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nrender_pattern:the pattern, with which the rendering-filename will be automatically created. Check also GetProject_RenderFilename\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_RenderPattern(${3:string projectfilename_with_path},${4:string render_pattern},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_RENDERFILENAME_WR lua": {
        "prefix": "ultraschallwr.GetProject_RenderFilename",
        "scope": "lua",
        "description": "Returns the render-filename from an RPP-Projectfile or a ProjectStateChunk. If it contains only a path or nothing, you should check the Render_Pattern using GetProject_RenderPattern, as a render-pattern influences the rendering-filename as well.\nIt's the entry RENDER_FILE\nReturns nil in case of error.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\nrender_filename:the filename for rendering, check also GetProject_RenderPattern\n",
        "body": "${1:local }${2:string render_filename} = ultraschall.GetProject_RenderFilename(${3:string projectfilename_with_path},${4:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETPROJECT_GROUPNAME_WR lua": {
        "prefix": "ultraschallwr.GetProject_GroupName",
        "scope": "lua",
        "description": "Returns the name associated to a specific group of items. There can be more than one!\nIt is the GROUP-entry in the root of the ProjectStateChunk.\nReturns nil in case of error or if no such entry exists.\nPARAMETERS:\nprojectfilename_with_path:filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk\nidx:the index of the item-group, whose name you want to know\nProjectStateChunk:a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil\nRETURNS:\ngroupname:the associated groupname of the itemgroup; nil, no such group or no name is given(default Group idx)\n",
        "body": "${1:local }${2:string groupname} = ultraschall.GetProject_GroupName(${3:string projectfilename_with_path},${4:integer idx},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_LOCK_WR lua": {
        "prefix": "ultraschallwr.SetProject_Lock",
        "scope": "lua",
        "description": "Sets the Locked-state of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry LOCK\nIt is the one before(!) any\nstring projectfilename_with_path - the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ninteger lock_state - the lock-state, which is a bitfield\n- &1     - Time selection\n- &2     - Items (full)\n- &4     - Track envelopes\n- &8     - Markers\n- &16    - Regions\n- &32    - Time signature markers\n- &64    - Items (prevent left/right movement)\n- &128   - Items (prevent up/down movement)\n- &256   - Item edges\n- &512   - Item fade/volume handles\n- &1024  - Loop points locked\n- &2048  - Item envelopes\n- &4096  - Item stretch markers\n- &16384 - Enable locking\noptional string ProjectStateChunk - a projectstatechunk, that you want to be changed\ninteger retval - -1 in case of error, 1 in case of success\nProject-Management\nRPP-Files Set\nUS_Api_Functions\nModules/ultraschall_functions_ProjectManagement_ProjectFiles_Module.lua\nprojectfiles, rpp, state, set, lock state\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nlock_state:the lock-state, which is a bitfield\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_Lock(${3:string projectfilename_with_path},${4:integer lock_state},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_GLOBALAUTO_WR lua": {
        "prefix": "ultraschallwr.SetProject_GlobalAuto",
        "scope": "lua",
        "description": "Sets the global-auto-override-state of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry GLOBAL_AUTO\nThis sets the same automation mode to all tracks!\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nglobal_auto_state:the global automation override state, this sets the same automation mode to all tracks!\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_GlobalAuto(${3:string projectfilename_with_path},${4:integer global_auto_state},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_TEMPO_WR lua": {
        "prefix": "ultraschallwr.SetProject_Tempo",
        "scope": "lua",
        "description": "Sets the tempo, bpm, beat, denominator-state of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry TEMPO\nThey are set in the Project Settings -> \"Project BPM\" and \"Time signature\"\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nbpm:the tempo of the project in bpm\nbeat:the beat of the project \ndenominator:the denominator for the beat \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_Tempo(${3:string projectfilename_with_path},${4:integer bpm},${5:integer beat},${6:integer denominator},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_PLAYRATE_WR lua": {
        "prefix": "ultraschallwr.SetProject_Playrate",
        "scope": "lua",
        "description": "Sets the playrate of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry PLAYRATE\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nplayrate:the maximum playrate possible in the project; 0.01 to 10\npreserve_pitch:0, don't preserve pitch, when changing playrate; 1, preserve pitch, when chaning playrate \nmin_playrate:the minimum playrate possible in the project; 0.01 to 10\nmax_playrate:the maximum playrate possible in the project; 0.01 to 10\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_Playrate(${3:string projectfilename_with_path},${4:number playrate},${5:integer preserve_pitch},${6:number min_playrate},${7:number max_playrate},${8:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERAUTOMODE_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterAutomode",
        "scope": "lua",
        "description": "Sets the automation-mode for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTERAUTOMODE\nThis sets the same automation mode to all tracks!\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nautomode:the automation mode for the master-track\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterAutomode(${3:string projectfilename_with_path},${4:integer automode},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERSEL_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterSel",
        "scope": "lua",
        "description": "Sets the selection-state for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_SEL\nThis sets the same automation mode to all tracks!\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nselection_state:the selection-state of the MasterTrack; 0, unselected; 1, selected\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterSel(${3:string projectfilename_with_path},${4:integer selection_state},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERMUTESOLO_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterMuteSolo",
        "scope": "lua",
        "description": "Sets the mute/solo-state for the master-track of an rpp-projectfile or a ProjectStateChunk.\nHas no exclusive-solo/mute-settings!\nIt's the entry MASTERMUTESOLO\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nmute_solo_state:the mute-solo-state; it is a bitfield\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterMuteSolo(${3:string projectfilename_with_path},${4:integer mute_solo_state},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERFXBYP_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterFXByp",
        "scope": "lua",
        "description": "Sets the fx-bypass-state for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_FX\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nfx_byp_state:the fx-bypass-state; 0, master-track-fx bypassed; 1, master-track-fx normal \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterFXByp(${3:string projectfilename_with_path},${4:integer fx_byp_state},${5:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERNCHANS_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterNChans",
        "scope": "lua",
        "description": "Sets the number of channels and vu-meter-settings for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_NCH\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nnumber_of_channels:the number of output-channels, as set in the \"Outputs for the Master Channel -> Track Channels\"-dialog \npeak_metering:2, Multichannel peak metering-setting, as set in the \"Master VU settings\"-dialog \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterNChans(${3:string projectfilename_with_path},${4:integer number_of_channels},${5:integer peak_metering},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERTRACKHEIGHT_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterTrackHeight",
        "scope": "lua",
        "description": "Sets the trackheight for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTERTRACKHEIGHT\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\nheight_state:the current-height of the master-track, from 24 to 260 \nheight_lock:0, height-lock is off; 1, height-lock is on \nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterTrackHeight(${3:string projectfilename_with_path},${4:integer height_state},${5:integer height_lock},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERTRACKCOLOR_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterTrackColor",
        "scope": "lua",
        "description": "Sets the color for the master-track of an rpp-projectfile or a ProjectStateChunk.\nTo generate the correct color-value, use ConvertColor.\nNote: This color reverses red and blue component on Mac, so it looks different on Mac compared to Windows and Linux!\nIt's the entry MASTERPEAKCOL\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ncolor:the color-value of the MasterTrack\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterTrackColor(${3:string projectfilename_with_path},${4:integer color},${5:integer peak_metering},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERPANMODE_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterPanMode",
        "scope": "lua",
        "description": "Sets the panmode for the master-track of an rpp-projectfile or a ProjectStateChunk.\nIt's the entry MASTER_PANMODE\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\npanmode:the panmode for the master-track;\nProjectStateChunk:a projectstatechunk, that you want to be changed\nRETURNS:\nretval:-1 in case of error, 1 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetProject_MasterPanMode(${3:string projectfilename_with_path},${4:integer panmode},${5:integer peak_metering},${6:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.SETPROJECT_MASTERTRACKVIEW_WR lua": {
        "prefix": "ultraschallwr.SetProject_MasterTrackView",
        "scope": "lua",
        "description": "Sets the master-view-state of the master-track of the project or a ProjectStateChunk.\nIt is the entry: MASTERTRACKVIEW\nReturns -1 in case of error.\nPARAMETERS:\nprojectfilename_with_path:the filename of the projectfile; nil, to use Parameter ProjectStateChunk instead\ntcp_visibility:0, Master-track is invisible in MCP; 1, Master-track is visible in MCP\nstate2:unknown\nstate3:unknown\nstate4:unknown\nstate5:unknown\nstate6:unknown\nstate7:unknown\nRETURNS:\nretval:-1 in case of error, 1 in case of success\nProjectStateChunk:the altered ProjectStateChunk\n",
        "body": "${1:local }${2:integer retval},${3:optional string ProjectStateChunk} = ultraschall.SetProject_MasterTrackView(${4:string projectfilename_with_path},${5:integer tcp_visibility},${6:number state2},${7:number state3},${8:number state4},${9:integer state5},${10:integer state6},${11:integer state7},${12:optional string ProjectStatechunk})$0"
    },
    "ULTRASCHALL.GETVERTICALZOOM_WR lua": {
        "prefix": "ultraschallwr.GetVerticalZoom",
        "scope": "lua",
        "description": "Returns the vertical-zoom-factor.\nReturns -1 in case of error\nRETURNS:\nvertical_zoom_factor:the current vertical zoom-factor\n",
        "body": "${1:local }${2:integer vertical_zoom_factor} = ultraschall.GetVerticalZoom()$0"
    },
    "ULTRASCHALL.SETVERTICALZOOM_WR lua": {
        "prefix": "ultraschallwr.SetVerticalZoom",
        "scope": "lua",
        "description": "Sets the vertical zoom factor.\nTo set it relative to the current vertical-zoom-value, use Reaper's own API-function [CSurf_OnZoom](Reaper_Api_Documentation.html#CSurf_OnZoom)\nReturns -1 in case of error.\nPARAMETERS:\nvertical_zoom_factor:the current vertical zoom-factor\nRETURNS:\nretval:-1, in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetVerticalZoom(${3:integer vertical_zoom_factor})$0"
    },
    "ULTRASCHALL.STOREARRANGEVIEWSNAPSHOT_WR lua": {
        "prefix": "ultraschallwr.StoreArrangeviewSnapshot",
        "scope": "lua",
        "description": "Stores a new Arrangeview-snapshot, that includes the position, horizontal zoom, vertical zoom and vertical scroll.\nReturns -1 in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\ndescription:a description for this arrangeview-snapshot\nposition:true, store start and endposition of the current arrangeview; false, don't store start and endposition of current arrangeview(keep old position in slot, if existing)\nvzoom:true, store current vertical-zoom-factor; false, don't store current vertical-zoom-factor(keep old zoomfactor in slot, if existing)\nvscroll:true, store current vertical scroll-factor; false, don't store current vertival-scroll-factor\nRETURNS:\nretval:-1, in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.StoreArrangeviewSnapshot(${3:integer slot},${4:string description},${5:boolean position},${6:boolean vzoom},${7:boolean vscroll})$0"
    },
    "ULTRASCHALL.ISVALIDARRANGEVIEWSNAPSHOT_WR lua": {
        "prefix": "ultraschallwr.IsValidArrangeviewSnapshot",
        "scope": "lua",
        "description": "Checks, if an Arrangeview-snapshot-slot is valid(means set).\nReturns false in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nRETURNS:\nretval:true, if Arrangeview-Snapshot is valid; false, if Arrangeview-Snapshot is not existing\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidArrangeviewSnapshot(${3:integer slot})$0"
    },
    "ULTRASCHALL.RETRIEVEARRANGEVIEWSNAPSHOT_WR lua": {
        "prefix": "ultraschallwr.RetrieveArrangeviewSnapshot",
        "scope": "lua",
        "description": "Retrieves an Arrangeview-snapshot and returns the startposition, endposition and vertical and horizontal zoom-factor as well as the number vertical-scroll-factor..\nReturns false in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nRETURNS:\nretval:false, in case of error; true, in case of success\ndescription:a description for this arrangeview-snapshot\nstartposition:the startposition of the arrangeview\nendposition:the endposition of the arrangeview\nhzoomfactor:the horizontal zoomfactor\nvertical_scroll:the vertical scroll-value\n",
        "body": "${1:local }${2:boolean retval},${3:string description},${4:number startposition},${5:number endposition},${6:integer vzoomfactor},${7:number hzoomfactor},${8:number vertical_scroll} = ultraschall.RetrieveArrangeviewSnapshot(${9:integer slot})$0"
    },
    "ULTRASCHALL.RESTOREARRANGEVIEWSNAPSHOT_WR lua": {
        "prefix": "ultraschallwr.RestoreArrangeviewSnapshot",
        "scope": "lua",
        "description": "Sets arrangeview to start/endposition and horizontal and vertical-zoom, as received from Arrangeview-Snapshot-slot. It returns the newly set start/endposition, vertical zoom, horizontal zoom and description of slot.\nReturns false in case of error.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nposition:nil or true, set arrange to stored start and endposition(and it's horizontal-zoom); false, set only horizontal-zoom\nvzoom:nil or true, set vertical-zoom; false, don't set vertical zoom\nhcentermode:decides, what shall be in the center of the zoomed horizontal view. Only available when position==false\nverticalscroll:true, sets vertical scroll-value as well; false, doesn't set vertical-scroll-value\nRETURNS:\nretval:false, in case of error; true, in case of success\ndescription:a description for this arrangeview-snapshot\nstartposition:the startposition of the arrangeview\nendposition:the endposition of the arrangeview\nhzoomfactor:the horizontal zoomfactor\nvertical_scroll_factor:the vertical-scroll-factor\n",
        "body": "${1:local }${2:boolean retval},${3:string description},${4:number startposition},${5:number endposition},${6:integer vzoomfactor},${7:number hzoomfactor},${8:number vertical_scroll_factor} = ultraschall.RestoreArrangeviewSnapshot(${9:integer slot},${10:optional boolean position},${11:optional boolean vzoom},${12:optional integer hcentermode},${13:optional boolean verticalscroll})$0"
    },
    "ULTRASCHALL.DELETEARRANGEVIEWSNAPSHOT_WR lua": {
        "prefix": "ultraschallwr.DeleteArrangeviewSnapshot",
        "scope": "lua",
        "description": "Deletes an ArrangeviewSnapshot-slot.\nReturns -1 if the slot is unset or slot is an invalid value.\nPARAMETERS:\nslot:the slot for arrangeview-snapshot\nRETURNS:\nretval:-1 in case of an error; 0 in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.DeleteArrangeviewSnapshot(${3:integer slot})$0"
    },
    "ULTRASCHALL.SETIDEFONTSIZE_WR lua": {
        "prefix": "ultraschallwr.SetIDEFontSize",
        "scope": "lua",
        "description": "Sets the fontsize of Reaper's IDE (ReaScript/Video Processor/JSFX)\nNew fontsize is valid for all IDE's opened after calling this function.\nReturns false in case of an error\nPARAMETERS:\nfontsize:the new font-size for Reaper's IDEs\nRETURNS:\nretval:true, if setting was successful; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetIDEFontSize(${3:integer fontsize})$0"
    },
    "ULTRASCHALL.GETIDEFONTSIZE_WR lua": {
        "prefix": "ultraschallwr.GetIDEFontSize",
        "scope": "lua",
        "description": "Returns the current fontsize of Reaper's IDE (ReaScript/Video Processor/JSFX)\n",
        "body": "${1:local }${2:integer retval} = ultraschall.GetIDEFontSize()$0"
    },
    "ULTRASCHALL.GETPLAYCURSORWIDTH_WR lua": {
        "prefix": "ultraschallwr.GetPlayCursorWidth",
        "scope": "lua",
        "description": "Returns the width of the playcursor in pixels\nsee SetPlayCursorWidth for setting the playcursor-width.\nRETURNS:\nplay_cursor_width:the width of the playcursor in pixels\n",
        "body": "${1:local }${2:integer play_cursor_width} = ultraschall.GetPlayCursorWidth()$0"
    },
    "ULTRASCHALL.SETPLAYCURSORWIDTH_WR lua": {
        "prefix": "ultraschallwr.SetPlayCursorWidth",
        "scope": "lua",
        "description": "Sets a new playcursor-width.\nsee GetPlayCursorWidth for getting the playcursor-width.\nReturns false in case of an error\nPARAMETERS:\nplay_cursor_width:the new width of the playcursor\npersist:true, set the setting to reaper.ini so it persists after restarting Reaper; false, set it only for the time, until Reaper is restarted\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetPlayCursorWidth(${3:integer play_cursor_width},${4:boolean persist})$0"
    },
    "ULTRASCHALL.GETSCREENWIDTH_WR lua": {
        "prefix": "ultraschallwr.GetScreenWidth",
        "scope": "lua",
        "description": "returns the width of the screen in pixels.\nreturns -1 in case of an error\nPARAMETERS:\nwant_workarea:true, returns workspace only; false, full monitor coordinates of the returned viewport; nil, will be seen as true\nRETURNS:\nwidth:the width of the screen in pixels\n",
        "body": "${1:local }${2:integer width} = ultraschall.GetScreenWidth(${3:optional boolean want_workarea})$0"
    },
    "ULTRASCHALL.GETSCREENHEIGHT_WR lua": {
        "prefix": "ultraschallwr.GetScreenHeight",
        "scope": "lua",
        "description": "returns the height of the screen in pixels.\nreturns -1 in case of an error\nPARAMETERS:\nwant_workarea:true, returns workspace only; false, full monitor coordinates of the returned viewport; nil, will be seen as true\n",
        "body": "${1:local }${2:integer height} = ultraschall.GetScreenHeight(${3:optional boolean want_workarea})$0"
    },
    "ULTRASCHALL.SHOWMENU_WR lua": {
        "prefix": "ultraschallwr.ShowMenu",
        "scope": "lua",
        "description": "Draws a menu at position x,y.\nEntries is the string, that contains the Menuentries, separated by |\nExample: \"Entry1|Entry2|Entry3\"\nEach field can start with a special character\n# grays out the entry\n! entry is checked\n> starts a new submenu, where every following entry will be part of the submenu\n< ends a submenu with this entry being the last one\nThese special characters can be combined, however, grayed out entries don't open submenus, even if they are shown as submenus.\nA field with nothing in it || creates a separator.\nThe returned number follows the numbering of the clickable(!) entries. Even if grayed out-entries can't be selected, they count as well.\nHowever, opening-submenu-entries and separators don't count as clickable.\nThat said, if you have one grayed out entry and one normal entry, the grayed out entry is 1, the normal entry(the only selectable one) is 2.\nThe following entry\nNormal1|>SubmenuOpener|Submenuentry1|\nSubmenuentry1\nSubmenuEntry2Closer\nGrayed Out\nOne last thing: the title does not count as entry!\nNote for Mac-users: y-coordinates are \"reversed\", so y=0 is at the bottom\nNote for Linux: does not work on Linux yet.\nreturns -1 in case of an error\nPARAMETERS:\nTitle:the title shown on top of the menu\nEntries:the individual entries. See above on how to create such an entry.\nx:the x-position of the menu\ny:the y-position of the menu\nRETURNS:\nretval:the selected entry; 0, nothing selected\n",
        "body": "${1:local }${2:integer retval} = ultraschall.ShowMenu(${3:string Title},${4:string Entries},${5:integer x},${6:integer y})$0"
    },
    "ULTRASCHALL.ISVALIDHWND_WR lua": {
        "prefix": "ultraschallwr.IsValidHWND",
        "scope": "lua",
        "description": "Checks, if a HWND-handler is a valid one.\nReturns false in case of an error\nPARAMETERS:\nhwnd:the HWND-handler to check for\nRETURNS:\nretval:true, if running it was successful; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidHWND(${3:HWND hwnd})$0"
    },
    "ULTRASCHALL.BROWSEFOROPENFILES_WR lua": {
        "prefix": "ultraschallwr.BrowseForOpenFiles",
        "scope": "lua",
        "description": "Opens a filechooser-dialog which optionally allows selection of multiple files.\nUnlike Reaper's own GetUserFileNameForRead, this dialog allows giving non-existant files as well(for saving operations).\nReturns nil in case of an error\nPARAMETERS:\nwindowTitle:the title shown in the filechooser-dialog\ninitialFolder:the initial-folder opened in the filechooser-dialog\ninitialFile:the initial-file selected in the filechooser-dialog, good for giving default filenames\nextensionList:a list of extensions that can be selected in the selection-list.\nallowMultiple:true, allows selection of multiple files; false, only allows selection of single files\nRETURNS:\npath:the path, in which the selected file(s) lie; nil, in case of an error; \"\" if no file was selected\nnumber_of_files:the number of files selected; 0, if no file was selected\nfilearray:an array with all the selected files\n",
        "body": "${1:local }${2:string path},${3:integer number_of_files},${4:array filearray} = ultraschall.BrowseForOpenFiles(${5:string windowTitle},${6:string initialFolder},${7:string initialFile},${8:string extensionList},${9:boolean allowMultiple})$0"
    },
    "ULTRASCHALL.HASHWNDCHILDWINDOWNAMES_WR lua": {
        "prefix": "ultraschallwr.HasHWNDChildWindowNames",
        "scope": "lua",
        "description": "Returns, whether the given HWND has childhwnds with a certain name in them. This is good for checking for valid Reaper-windows.\nAs gfx.init()-windows can have the same as Reaper's original-windows, this function gives you the chance for aditional checks.\ngfx.init windows don't have child-hwnds and other applications probably have child-hwnds with different names.\nreturns false in case of an error\nPARAMETERS:\nhwnd:the HWND, whose child-hwnd-names you want to check\nchildwindownames:a string with the names of the child-HWNDs the parameter hwnd must have. It is a \\0-separated string, means, you put \\0 in between the child-Hwnd-names.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.HasHWNDChildWindowNames(${3:HWND hwnd},${4:string childwindownames})$0"
    },
    "ULTRASCHALL.CLOSEREASCRIPTCONSOLE_WR lua": {
        "prefix": "ultraschallwr.CloseReaScriptConsole",
        "scope": "lua",
        "description": "Closes the ReaConsole-window, if opened.\nReturns false in case of an error\nRETURNS:\nretval:true, if there is a mute-point; false, if there isn't one\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.CloseReaScriptConsole()$0"
    },
    "ULTRASCHALL.MB_WR lua": {
        "prefix": "ultraschallwr.MB",
        "scope": "lua",
        "description": "Shows Messagebox with user-clickable buttons. Works like reaper.MB() but unlike reaper.MB, this function accepts omitting some parameters for quicker use.\nImportant: This works only on Windows, due some bug on Mac which I couldn't work out yet.\nYou can change the text in the buttons with button1_caption, button2_caption and button3_caption.\nReturns -1 in case of an error\nPARAMETERS:\nmsg:the message, that shall be shown in messagebox\ntitle:the title of the messagebox\ntype:which buttons shall be shown in the messagebox, in that order\nbutton1_caption:caption of the first button\nbutton2_caption:caption of the second button\nbutton3_caption:caption of the third button\n",
        "body": "${1:local }${2:integer retval} = ultraschall.MB(${3:string msg},${4:optional string title},${5:optional integer type},${6:optional string button1_caption},${7:optional string button2_caption},${8:optional string button3_caption})$0"
    },
    "ULTRASCHALL.GETTOPMOSTHWND_WR lua": {
        "prefix": "ultraschallwr.GetTopmostHWND",
        "scope": "lua",
        "description": "returns the topmost-parent hwnd of a hwnd, as sometimes, hwnds are children of a higher hwnd. It also returns the number of parent hwnds available and a list of all parent hwnds for this hwnd.\nA hwnd is a window-handler, which contains all attributes of a certain window.\nreturns nil in case of an error\nPARAMETERS:\nhwnd:the HWND, whose topmost parent-HWND you want to have\nRETURNS:\nnumber_of_parent_hwnd:the number of parent hwnds, that are above the parameter hwnd\nall_parent_hwnds:all available parent hwnds, above the parameter hwnd, including the topmost-hwnd\n",
        "body": "${1:local }${2:HWND topmost_hwnd},${3:integer number_of_parent_hwnd},${4:table all_parent_hwnds} = ultraschall.GetTopmostHWND(${5:HWND hwnd})$0"
    },
    "ULTRASCHALL.GETREAPERWINDOWATTRIBUTES_WR lua": {
        "prefix": "ultraschallwr.GetReaperWindowAttributes",
        "scope": "lua",
        "description": "returns many attributes of the Reaper Main-window, like position, size, active, visibility, childwindows\nA hwnd is a window-handler, which contains all attributes of a certain window.\nreturns nil in case of an error\nRETURNS:\nleft:the left position of the Reaper-window in pixels\ntop:the top position of the Reaper-window in pixels\nright:the right position of the Reaper-window in pixels\nbottom:the bottom position of the Reaper-window in pixels\nactive:true, if the window is active(any child-hwnd of the Reaper-window has focus currently); false, if not\nvisible:true, Reaper-window is visible; false, Reaper-window is not visible\ntitle:the current title of the Reaper-window\nnumber_of_childhwnds:the number of available child-hwnds that the Reaper-window currently has\nchildhwnds:a table with all child-hwnds in the following format:\n",
        "body": "${1:local }${2:integer left},${3:integer top},${4:integer right},${5:integer bottom},${6:boolean active},${7:boolean visible},${8:string title},${9:integer number_of_childhwnds},${10:table childhwnds} = ultraschall.GetReaperWindowAttributes()$0"
    },
    "ULTRASCHALL.WINDOWS_FIND_WR lua": {
        "prefix": "ultraschallwr.Windows_Find",
        "scope": "lua",
        "description": "Returns all Reaper-window-HWND-handler, with a given title. Can be further used with the JS\\_Window\\_functions of the JS-function-plugin.\nDoesn't return IDE-windows! Use GetAllReaScriptIDEWindows to get them.\nreturns -1 in case of an error\n",
        "body": "${1:local }${2:integer count_hwnds},${3:array hwnd_array},${4:array hwnd_adresses} = ultraschall.Windows_Find(${5:string title},${6:boolean strict})$0"
    },
    "ULTRASCHALL.GETALLREASCRIPTIDEWINDOWS_WR lua": {
        "prefix": "ultraschallwr.GetAllReaScriptIDEWindows",
        "scope": "lua",
        "description": "Returns the hwnds and all titles of all Reaper-IDE-windows currently opened.\nRETURNS:\ncount_ide_hwnds:the number of windows found\nide_hwnd_array:the hwnd-handler of all found windows\nide_titles:the titles of all found windows\n",
        "body": "${1:local }${2:integer count_ide_hwnds},${3:array ide_hwnd_array},${4:array ide_titles} = ultraschall.GetAllReaScriptIDEWindows()$0"
    },
    "ULTRASCHALL.GETREASCRIPTCONSOLEWINDOW_WR lua": {
        "prefix": "ultraschallwr.GetReaScriptConsoleWindow",
        "scope": "lua",
        "description": "Returns the hwnd of the ReaScript-Console-window, if opened.\nreturns nil when ReaScript-console isn't opened\nRETURNS:\nreascript_console_hwnd:the window-handler to the ReaScript-console, if opened\n",
        "body": "${1:local }${2:HWND reascript_console_hwnd} = ultraschall.GetReaScriptConsoleWindow()$0"
    },
    "ULTRASCHALL.GETHWND_ARRANGEVIEWANDTIMELINE_WR lua": {
        "prefix": "ultraschallwr.GetHWND_ArrangeViewAndTimeLine",
        "scope": "lua",
        "description": "Returns the HWND-Reaper-Windowhandler for the tracklist- and timeline-area in the arrange-view\nreturns nil in case of an error. Please report such an error, which means, that you should use ultraschall.ShowLastErrorMessage() to show that error and report the information requested(fruitful bugreports lead to a handwritten postcard as reward :) )\nRETURNS:\narrange_view:the HWND-window-handler for the tracklist-area of the arrangeview\ntimeline:the HWND-window-handler for the timeline/markerarea of the arrangeview\nTrackControlPanel:the HWND-window-handler for the track-control-panel(TCP)(may not work anymore in an upcoming Reaper-release!)\n",
        "body": "${1:local }${2:HWND arrange_view},${3:HWND timeline},${4:HWND TrackControlPanel} = ultraschall.GetHWND_ArrangeViewAndTimeLine()$0"
    },
    "ULTRASCHALL.GETVERTICALSCROLL_WR lua": {
        "prefix": "ultraschallwr.GetVerticalScroll",
        "scope": "lua",
        "description": "Gets the current vertical_scroll_value. The valuerange is dependent on the vertical zoom.\nRETURNS:\nvertical_scroll_factor:the vertical-scroll-factor\n",
        "body": "${1:local }${2:integer vertical_scroll_factor} = ultraschall.GetVerticalScroll()$0"
    },
    "ULTRASCHALL.SETVERTICALSCROLL_WR lua": {
        "prefix": "ultraschallwr.SetVerticalScroll",
        "scope": "lua",
        "description": "Sets the absolute vertical-scroll-factor.\nThe possible value-range depends on the vertical-zoom.\nreturns false in case of an error or if scrolling is impossible(e.g. zoomed out fully)\nPARAMETERS:\nscrollposition:the vertical scrolling-position\nRETURNS:\nretval:true, if setting was successful; false, if setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetVerticalScroll(${3:integer scrollposition})$0"
    },
    "ULTRASCHALL.SETVERTICALRELATIVESCROLL_WR lua": {
        "prefix": "ultraschallwr.SetVerticalRelativeScroll",
        "scope": "lua",
        "description": "Sets the vertical-scroll-factor, relative to it's current position.\nThe possible value-range depends on the vertical-zoom.\nreturns false in case of an error or if scrolling is impossible(e.g. zoomed out fully)\nRETURNS:\nretval:true, if setting was successful; false, if setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetVerticalRelativeScroll(${3:integer relative_scrollposition})$0"
    },
    "ULTRASCHALL.GETRENDERTOFILEHWND_WR lua": {
        "prefix": "ultraschallwr.GetRenderToFileHWND",
        "scope": "lua",
        "description": "returns the HWND of the Render to File-dialog, if the window is opened.\nreturns nil if Render to File-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Render to File-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetRenderToFileHWND()$0"
    },
    "ULTRASCHALL.GETACTIONSHWND_WR lua": {
        "prefix": "ultraschallwr.GetActionsHWND",
        "scope": "lua",
        "description": "returns the HWND of the Actions-dialog, if the window is opened.\nreturns nil if the Actions-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Actions-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetActionsHWND()$0"
    },
    "ULTRASCHALL.GETVIDEOHWND_WR lua": {
        "prefix": "ultraschallwr.GetVideoHWND",
        "scope": "lua",
        "description": "returns the HWND of the Video window, if the window is opened.\ndue API-limitations on Mac and Linux: if more than one window called \"Video Window\" is opened, it will return -1\nI hope to find a workaround for that problem at some point...\nreturns nil if the Video Window is closed or can't be determined\nRETURNS:\nhwnd:the window-handler of the Video Window\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetVideoHWND()$0"
    },
    "ULTRASCHALL.GETRENDERQUEUEHWND_WR lua": {
        "prefix": "ultraschallwr.GetRenderQueueHWND",
        "scope": "lua",
        "description": "returns the HWND of the Render-Queue-dialog, if the window is opened.\nreturns nil if the Render-Queue-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Render-Queue-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetRenderQueueHWND()$0"
    },
    "ULTRASCHALL.GETPROJECTSETTINGSHWND_WR lua": {
        "prefix": "ultraschallwr.GetProjectSettingsHWND",
        "scope": "lua",
        "description": "returns the HWND of the Project Settings-dialog, if the window is opened.\nreturns nil if the Project-Settings-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Project Settings-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetProjectSettingsHWND()$0"
    },
    "ULTRASCHALL.GETPREFERENCESHWND_WR lua": {
        "prefix": "ultraschallwr.GetPreferencesHWND",
        "scope": "lua",
        "description": "returns the HWND of the Preferences-dialog, if the window is opened.\nreturns nil if the Preferences-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Preferences-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetPreferencesHWND()$0"
    },
    "ULTRASCHALL.GETSAVELIVEOUTPUTTODISKHWND_WR lua": {
        "prefix": "ultraschallwr.GetSaveLiveOutputToDiskHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Save live output to disk(bounce)\"-dialog, if the window is opened.\nreturns nil if the \"Save live output to disk(bounce)\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Save live output to disk(bounce)\"-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetSaveLiveOutputToDiskHWND()$0"
    },
    "ULTRASCHALL.GETCONSOLIDATETRACKSHWND_WR lua": {
        "prefix": "ultraschallwr.GetConsolidateTracksHWND",
        "scope": "lua",
        "description": "returns the HWND of the Consolidate Tracks-dialog, if the window is opened.\nreturns nil if the Consolidate Tracks-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Consolidate Tracks-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetConsolidateTracksHWND()$0"
    },
    "ULTRASCHALL.GETEXPORTPROJECTMIDIHWND_WR lua": {
        "prefix": "ultraschallwr.GetExportProjectMIDIHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Export Project MIDI\"-dialog, if the window is opened.\nreturns nil if the \"Export Project MIDI\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Export Project MIDI\"-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetExportProjectMIDIHWND()$0"
    },
    "ULTRASCHALL.GETPROJECTDIRECTORYCLEANUPHWND_WR lua": {
        "prefix": "ultraschallwr.GetProjectDirectoryCleanupHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Project Directory Cleanup\"-dialog, if the window is opened.\nreturns nil if the \"Project Directory Cleanup\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Project Directory Cleanup\"-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetProjectDirectoryCleanupHWND()$0"
    },
    "ULTRASCHALL.GETBATCHFILEITEMCONVERTERHWND_WR lua": {
        "prefix": "ultraschallwr.GetBatchFileItemConverterHWND",
        "scope": "lua",
        "description": "returns the HWND of the \"Batch File/Item Converter\"-dialog, if the window is opened.\nreturns nil if the \"Batch File/Item Converter\"-dialog is closed\nRETURNS:\nhwnd:the window-handler of the \"Batch File/Item Converter\"-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetBatchFileItemConverterHWND()$0"
    },
    "ULTRASCHALL.MOVECHILDWITHINPARENTHWND_WR lua": {
        "prefix": "ultraschallwr.MoveChildWithinParentHWND",
        "scope": "lua",
        "description": "Moves a childhwnd within the coordinates of its parenthwnd.\nGood for moving gui-elements around without having to deal with screen-coordinates.\nYou can decide, whether the new position shall be relative to its old position or absolute within the parenthwnd-position.\nThe parent-hwnd must not be necessarily the parenthwnd of the childhwnd, so you can move the childhwnd relative to other hwnds as well, but\nkeep in mind, that the childhwnd is only seeable within the boundaries of it's own parenthwnd!\nReturns nil in case of an error\nPARAMETERS:\nparenthwnd:the parenthwnd of the childhwnd, within whose dimensions you want to move the childhwnd\nchildhwnd:the childhwnd, that you want to move\nrelative:true, new position will be relative to the old position; false, new position will be absolute within the boundaries of the parenthwnd\nleft:the new x-position of the childhwnd in pixels\ntop:the new y-position of the childhwnd in pixels\nwidth:the new width of the childhwnd in pixels; when relative=true then 0 keeps the old width; when relative=false then 0 is width of 0 pixels\nheight:the new height of the childhwnd in pixels; when relative=true then 0 keeps the old height; when relative=false then 0 is height of 0 pixels\nRETURNS:\nnewxpos:the new x-position on the screen in pixels\nnewypos:the new y-position on the screen in pixels\nnewrightpos:the new right-position on the screen in pixels\nnewbottompos:the new bottom-position on the screen in pixels\nnewwidth:the new width of the childhwnd in pixels\nnewheight:the new height of the childhwnd in pixels\n",
        "body": "${1:local }${2:integer newxpos},${3:integer newypos},${4:integer newrightpos},${5:integer newbottompos},${6:integer newrelativeleft},${7:integer newrelativetop},${8:integer newwidth},${9:integer newheight} = ultraschall.MoveChildWithinParentHWND(${10:hwnd parenthwnd},${11:hwnd childhwnd},${12:boolean relative},${13:integer left},${14:integer top},${15:integer width},${16:integer height})$0"
    },
    "ULTRASCHALL.GETCHILDSIZEWITHINPARENTHWND_WR lua": {
        "prefix": "ultraschallwr.GetChildSizeWithinParentHWND",
        "scope": "lua",
        "description": "Returns the position, height and width of a childhwnd, relative to the position of parenthwnd\nReturns nil in case of an error\nPARAMETERS:\nparenthwnd:the parenthwnd of the childhwnd, whose position will be the base for position-calculation of the childhwnd\nchildhwnd:the childhwnd, whose dimensions you want to get, relative to the position of the parenthwnd\nRETURNS:\nxpos:the x-position of the childhwnd relative to the position of the parenthwnd in pixels\nypos:the y-position of the childhwnd relative to the position of the parenthwnd in pixels\nwidth:the width of the childhwnd in pixels\nheight:the height of the childhwnd in pixels\n",
        "body": "${1:local }${2:integer xpos},${3:integer ypos},${4:integer width},${5:integer height} = ultraschall.GetChildSizeWithinParentHWND(${6:hwnd parenthwnd},${7:hwnd childhwnd})$0"
    },
    "ULTRASCHALL.GETCHECKBOXSTATE_WR lua": {
        "prefix": "ultraschallwr.GetCheckboxState",
        "scope": "lua",
        "description": "Gets the checked-state of a checkbox-hwnd.\nThis function will not check, whether the hwnd is an actual checkbox!\nReturns nil in case of an error\nPARAMETERS:\nhwnd:the hwnd-handler of the checkbox\nRETURNS:\nretval:true, checkbox is checked; false, checkbox isn't checked\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GetCheckboxState(${3:HWND hwnd})$0"
    },
    "ULTRASCHALL.SETCHECKBOXSTATE_WR lua": {
        "prefix": "ultraschallwr.SetCheckboxState",
        "scope": "lua",
        "description": "Sets the checked-state of a checkbox-hwnd.\nThis function will not check, whether the hwnd is an actual checkbox!\nReturns nil in case of an error\nPARAMETERS:\nhwnd:the hwnd-handler of the checkbox\nstate:true, checkbox will be checked; false, checkbox will be unchecked\nRETURNS:\nretval:0, in case of success\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetCheckboxState(${3:HWND hwnd},${4:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDERINGTOFILEHWND_WR lua": {
        "prefix": "ultraschallwr.GetRenderingToFileHWND",
        "scope": "lua",
        "description": "Gets the HWND of the Rendering to File-dialog, which is displayed while Reaper is rendering.\nreturns nil in case of an error\nRETURNS:\nrendertofile_dialog:the HWND of the render to file-dialog; nil, in case of an error\n",
        "body": "${1:local }${2:HWND rendertofile_dialog} = ultraschall.GetRenderingToFileHWND()$0"
    },
    "ULTRASCHALL.CONVERTSCREEN2CLIENTXCOORDINATE_REAPERWINDOW_WR lua": {
        "prefix": "ultraschallwr.ConvertScreen2ClientXCoordinate_ReaperWindow",
        "scope": "lua",
        "description": "Converts an x-screencoordinate into a x-coordinate within the Reaper-Main-Window.\nDue to Api-limitations, if the Reaper-window is too small, the position might be wrong up to about 74 pixels!\nreturns -1 in case of error\nPARAMETERS:\nXscreencoordinate:the screen-coordinate, you want to have converted to.\nRETURNS:\nXclientcoordinate:coordinate within the main Reaper-window. Negative, if the coordinate is left of the edge of the window; -1, in case of error\n",
        "body": "${1:local }${2:integer Xclientcoordinate} = ultraschall.ConvertScreen2ClientXCoordinate_ReaperWindow(${3:integer Xscreencoordinate})$0"
    },
    "ULTRASCHALL.CONVERTCLIENT2SCREENXCOORDINATE_REAPERWINDOW_WR lua": {
        "prefix": "ultraschallwr.ConvertClient2ScreenXCoordinate_ReaperWindow",
        "scope": "lua",
        "description": "Converts an x-clientcoordinate from within the main Reaper-window into a x-screencoordinate.\nDue to Api-limitations, if the Reaper-window is too small, the position might be wrong up to about 74 pixels!\nreturns -1 in case of error\nPARAMETERS:\nXclientcoordinate:the screen-coordinate, you want to have converted to. Negative, if left of the left edge of the main Reaper-window.\nRETURNS:\nXscreencoordinate:coordinate within the screen.\n",
        "body": "${1:local }${2:integer Xscreencoordinate} = ultraschall.ConvertClient2ScreenXCoordinate_ReaperWindow(${3:integer Xclientcoordinate})$0"
    },
    "ULTRASCHALL.SETREAPERWINDOWTOSIZE_WR lua": {
        "prefix": "ultraschallwr.SetReaperWindowToSize",
        "scope": "lua",
        "description": "Sets the Reaper-Window to the size of w and h. The x and y-windowposition will be retained.\nReturns -1 in case of error.\nRETURNS:\nretval:-1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetReaperWindowToSize(${3:integer width},${4:integer height})$0"
    },
    "ULTRASCHALL.CONVERTYCOORDSMAC2WIN_WR lua": {
        "prefix": "ultraschallwr.ConvertYCoordsMac2Win",
        "scope": "lua",
        "description": "Converts the y-coordinate between Windows/Linux and MacOS-based systems.\nNote: MacOS y-coordinates begin at the bottom of the screen, while Windows and Linux y-coordinates begin at the top.\nWith this function, you can convert between these two coordinate-systems\nreturns nil in case of error\nPARAMETERS:\nycoord:the y-coordinate to convert in pixels\nheight:the height of the screen in pixels, which is the base for the conversion; nil, uses current screenheight\nRETURNS:\nconv_ycoord:the converted coordinate in pixels\n",
        "body": "${1:local }${2:integer conv_ycoord} = ultraschall.ConvertYCoordsMac2Win(${3:integer ycoord},${4:optional integer height})$0"
    },
    "ULTRASCHALL.GETMEDIAEXPLORERHWND_WR lua": {
        "prefix": "ultraschallwr.GetMediaExplorerHWND",
        "scope": "lua",
        "description": "returns the HWND of the Media Explorer, if the window is opened.\nreturns nil if Media Explorer is closed\nRETURNS:\nhwnd:the window-handler of the Media Explorer\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetMediaExplorerHWND()$0"
    },
    "ULTRASCHALL.GETTIMEBYMOUSEXPOSITION_WR lua": {
        "prefix": "ultraschallwr.GetTimeByMouseXPosition",
        "scope": "lua",
        "description": "Returns the projectposition at x-mouseposition.\nReturns nil in case of an error\nPARAMETERS:\nxposition:the x-position in pixels, from which you would love to have the projectposition\nRETURNS:\nposition:the projectposition at x-coordinate in seconds\n",
        "body": "${1:local }${2:number position} = ultraschall.GetTimeByMouseXPosition(${3:integer xposition})$0"
    },
    "ULTRASCHALL.SHOWTRACKINPUTMENU_WR lua": {
        "prefix": "ultraschallwr.ShowTrackInputMenu",
        "scope": "lua",
        "description": "Opens a TrackInput-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaTrack:the MediaTrack, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowTrackInputMenu(${3:integer x},${4:integer y},${5:optional MediaTrack MediaTrack},${6:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWTRACKPANELMENU_WR lua": {
        "prefix": "ultraschallwr.ShowTrackPanelMenu",
        "scope": "lua",
        "description": "Opens a TrackPanel-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaTrack:the MediaTrack, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowTrackPanelMenu(${3:integer x},${4:integer y},${5:optional MediaTrack MediaTrack},${6:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWTRACKAREAMENU_WR lua": {
        "prefix": "ultraschallwr.ShowTrackAreaMenu",
        "scope": "lua",
        "description": "Opens a TrackArea-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowTrackAreaMenu(${3:integer x},${4:integer y},${5:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWTRACKROUTINGMENU_WR lua": {
        "prefix": "ultraschallwr.ShowTrackRoutingMenu",
        "scope": "lua",
        "description": "Opens a TrackRouting-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaTrack:the MediaTrack, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowTrackRoutingMenu(${3:integer x},${4:integer y},${5:optional MediaTrack MediaTrack},${6:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWRULERMENU_WR lua": {
        "prefix": "ultraschallwr.ShowRulerMenu",
        "scope": "lua",
        "description": "Opens a Ruler-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowRulerMenu(${3:integer x},${4:integer y},${5:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWMEDIAITEMMENU_WR lua": {
        "prefix": "ultraschallwr.ShowMediaItemMenu",
        "scope": "lua",
        "description": "Opens a MediaItem-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nMediaItem:the MediaItem, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected one\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowMediaItemMenu(${3:integer x},${4:integer y},${5:optional MediaItem MediaItem},${6:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWENVELOPEMENU_WR lua": {
        "prefix": "ultraschallwr.ShowEnvelopeMenu",
        "scope": "lua",
        "description": "Opens a Track/TakeEnvelope-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowEnvelopeMenu(${3:integer x},${4:integer y},${5:optional TrackEnvelope TrackEnvelope},${6:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWENVELOPEPOINTMENU_WR lua": {
        "prefix": "ultraschallwr.ShowEnvelopePointMenu",
        "scope": "lua",
        "description": "Opens a Track/TakeEnvelope-Point-context menu\nReturns false in case of error.\nPARAMETERS:\nx:the envelope-point, which shall be influenced by the context-menu\ny:y position of the context-menu in pixels\nPointidx:the envelope-point, which shall be influenced by the context-menu\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowEnvelopePointMenu(${3:integer x},${4:integer y},${5:integer Pointidx},${6:optional TrackEnvelope TrackEnvelope},${7:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWENVELOPEPOINTMENU_AUTOMATIONITEM_WR lua": {
        "prefix": "ultraschallwr.ShowEnvelopePointMenu_AutomationItem",
        "scope": "lua",
        "description": "Opens a Track/TakeEnvelope-Point-context menu for AutomationItems\nReturns false in case of error.\nPARAMETERS:\nx:the envelope-point, which shall be influenced by the context-menu\ny:y position of the context-menu in pixels\nPointidx:the envelope-point, which shall be influenced by the context-menu\nAutomationIDX:the automation item-id within this Envelope, beginning with 1 for the first\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowEnvelopePointMenu_AutomationItem(${3:integer x},${4:integer y},${5:integer Pointidx},${6:integer AutomationIDX},${7:optional TrackEnvelope TrackEnvelope},${8:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.SHOWAUTOMATIONITEMMENU_WR lua": {
        "prefix": "ultraschallwr.ShowAutomationItemMenu",
        "scope": "lua",
        "description": "Opens an AutomationItem-context menu\nReturns false in case of error.\nPARAMETERS:\nx:x position of the context-menu in pixels\ny:y position of the context-menu in pixels\nAutomationIDX:the automation item-id within this Envelope which shall be influenced by the menu-selection of the opened context-menu, beginning with 1 for the first\nTrackEnvelope:the TrackEnvelope/TakeEnvelope, which shall be influenced by the menu-selection of the opened context-menu; nil, use the currently selected TrackEnvelope\nHWNDParent:a HWND, in which the context-menu shall be shown in; nil, use Reaper's main window\nRETURNS:\nretval:true, opening the menu worked; false, there was an error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ShowAutomationItemMenu(${3:integer x},${4:integer y},${5:integer AutomationIDX},${6:optional TrackEnvelope TrackEnvelope},${7:optional HWND HWNDParent})$0"
    },
    "ULTRASCHALL.GETSAVEPROJECTASHWND_WR lua": {
        "prefix": "ultraschallwr.GetSaveProjectAsHWND",
        "scope": "lua",
        "description": "returns the HWND of the Save As-dialog, if the window is opened.\nreturns nil if the Save As-dialog is closed\nRETURNS:\nhwnd:the window-handler of the Save As-dialog\n",
        "body": "${1:local }${2:HWND hwnd} = ultraschall.GetSaveProjectAsHWND()$0"
    },
    "ULTRASCHALL.SETHELPDISPLAYMODE_WR lua": {
        "prefix": "ultraschallwr.SetHelpDisplayMode",
        "scope": "lua",
        "description": "sets the help-display-mode, as shown in the area beneath the track control panels.\nreturns false in case of an error\nPARAMETERS:\nhelpcontent:0, No information display  \nmouseediting:true, show mouse editing-help; false, don't show mouse editing-help\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetHelpDisplayMode(${3:integer helpcontent},${4:boolean mouseediting})$0"
    },
    "ULTRASCHALL.GETHELPDISPLAYMODE_WR lua": {
        "prefix": "ultraschallwr.GetHelpDisplayMode",
        "scope": "lua",
        "description": "gets the current help-display-mode, as shown in the area beneath the track control panels.\nRETURNS:\nhelpcontent:0, No information display  \nmouseediting:true, show mouse editing-help; false, don't show mouse editing-help\n",
        "body": "${1:local }${2:integer helpcontent},${3:boolean mouseediting} = ultraschall.GetHelpDisplayMode()$0"
    },
    "ULTRASCHALL.WIRINGDIAGRAM_SETOPTIONS_WR lua": {
        "prefix": "ultraschallwr.WiringDiagram_SetOptions",
        "scope": "lua",
        "description": "sets the current wiring-display-options\nPARAMETERS:\nshow_send_wires:only show send wires on track mouseover; true, it's set; false, it's unset\nshow_routing_controls:show routing controls when creating send/hardware output; true, it's set; false, it's unset\nshow_hardware_outputs:only show hardware output/input wires on track mouseover; true, it's set; false, it's unset\nRETURNS:\nretval:true, setting was successful; false, setting was not successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.WiringDiagram_SetOptions(${3:boolean show_send_wires},${4:boolean show_routing_controls},${5:boolean show_hardware_outputs})$0"
    },
    "ULTRASCHALL.WIRINGDIAGRAM_GETOPTIONS_WR lua": {
        "prefix": "ultraschallwr.WiringDiagram_GetOptions",
        "scope": "lua",
        "description": "gets the current wiring-display-options\nRETURNS:\nshow_send_wires:only show send wires on track mouseover; true, it's set; false, it's unset\nshow_routing_controls:show routing controls when creating send/hardware output; true, it's set; false, it's unset\nshow_hardware_outputs:only show hardware output/input wires on track mouseover; true, it's set; false, it's unset\n",
        "body": "${1:local }${2:boolean show_send_wires},${3:boolean show_routing_controls},${4:boolean show_hardware_outputs} = ultraschall.WiringDiagram_GetOptions()$0"
    },
    "ULTRASCHALL.GETTCPWIDTH_WR lua": {
        "prefix": "ultraschallwr.GetTCPWidth",
        "scope": "lua",
        "description": "Returns the current width of the TrackControlPanel.\nRETURNS:\nwidth:the width of the TCP\n",
        "body": "${1:local }${2:integer width} = ultraschall.GetTCPWidth()$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_FLAC_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_FLAC",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for flac.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nencoding_depth:the encoding-depth of the flac in bits(16 to 24)\ncompression:the data-compression speed from fastest and worst efficiency(0) to slowest but best efficiency(8); default is 5\n",
        "body": "${1:local }${2:integer encoding_depth},${3:integer compression} = ultraschall.GetRenderCFG_Settings_FLAC(${4:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_AIFF_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_AIFF",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for aiff.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nbitdepth:the bitdepth of the AIFF-file(8, 16, 24, 32)\nEmbedBeatLength:Embed beat length if exact-checkbox; true, checked; false, unchecked\n",
        "body": "${1:local }${2:integer bitdepth},${3:boolean EmbedBeatLength} = ultraschall.GetRenderCFG_Settings_AIFF(${4:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_AUDIOCD_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_AudioCD",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for AudioCD.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\ntrackmode:the trackmode\nuse_markers_hashes:Only use markers starting with #-checkbox; only available when trackmode=0, otherwise it will be ignored\nleadin_silence_tracks:the leadin-silence for tracks in milliseconds(0 to 2147483647)\nleadin_silence_disc:the leadin-silence for discs in milliseconds(0 to 2147483647)\nburn_cd_after_render:burn cd image after render-checkbox\n",
        "body": "${1:local }${2:integer trackmode},${3:boolean use_markers_hashes},${4:integer leadin_silence_tracks},${5:integer leadin_silence_disc},${6:boolean burn_cd_after_render} = ultraschall.GetRenderCFG_Settings_AudioCD(${7:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MP3",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:the encoding-mode\nenc_quality:the encoding-quality\nvbr_quality:target-quality for VBR; 0(best 100%) to 9(worst 10%); 4, when Mode is set to  ABR, CBR or Maximum bitrate/quality\nabr_bitrate:the average bitrate for ABR in kbps\ncbr_bitrate:the bitrate for CBR in kbps\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "${1:local }${2:integer Mode},${3:integer enc_quality},${4:integer vbr_quality},${5:integer abr_bitrate},${6:integer cbr_bitrate},${7:boolean no_joint_stereo},${8:boolean write_replay_gain} = ultraschall.GetRenderCFG_Settings_MP3(${9:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3MAXQUALITY_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MP3MaxQuality",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 with maximum quality-settings.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nretval:0, the renderstring is a valid MP3-MaxQuality-setting; -1, it is not a valid renderstring for MP3-MaxQuality\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "${1:local }${2:integer retval},${3:boolean write_replay_gain} = ultraschall.GetRenderCFG_Settings_MP3MaxQuality(${4:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3CBR_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MP3CBR",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 CBR.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\ncbr_bitrate:the bitrate for CBR in kbps\nenc_quality:the encoding-quality\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "${1:local }${2:integer cbr_bitrate},${3:integer enc_quality},${4:boolean no_joint_stereo},${5:boolean write_replay_gain} = ultraschall.GetRenderCFG_Settings_MP3CBR(${6:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3VBR_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MP3VBR",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 VBR.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nenc_quality:the encoding-quality\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "${1:local }${2:integer vbr_bitrate},${3:integer enc_quality},${4:boolean no_joint_stereo},${5:boolean write_replay_gain} = ultraschall.GetRenderCFG_Settings_MP3VBR(${6:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP3ABR_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MP3ABR",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP3 ABR.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nbitrate:  the encoding quality for the mp3\nenc_quality:the encoding-quality\nno_joint_stereo:the do not allow joint stereo-checkbox\nwrite_replay_gain:the write ReplayGain tag-checkbox\n",
        "body": "${1:local }${2:integer bitrate},${3:integer enc_quality},${4:boolean no_joint_stereo},${5:boolean write_replay_gain} = ultraschall.GetRenderCFG_Settings_MP3ABR(${6:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_OGG_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_OGG",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for OGG.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:the mode for the ogg-file; 0, VBR; 1, CBR; 2, ABR \nVBR_quality:the quality for VBR-mode; a floating-value between 0 and 1\nCBR_KBPS:the bitrate for CBR-mode; 0 to 4294967295 \nABR_KBPS:the maximum bitrate for ABR-mode; 0 to 4294967295\nABR_KBPS_MIN:the minimum bitrate for ABR-mode; 0 to 4294967295\nABR_KBPS_MAX:the maximum bitrate for ABR-mode; 0 to 4294967295\n",
        "body": "${1:local }${2:integer Mode},${3:integer VBR_quality},${4:integer CBR_KBPS},${5:integer ABR_KBPS},${6:integer ABR_KBPS_MIN},${7:integer ABR_KBPS_MAX} = ultraschall.GetRenderCFG_Settings_OGG(${8:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_OPUS_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_OPUS",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for Opus.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:the Mode for the Opus-file; 0, VBR; 1, CVBR; 2, HARDCBR \nBitrate:the kbps of the opus-file; between 1 and 256 \nComplexity:the complexity-setting between 0(lowest quality) and 10(highest quality, slow encoding) \nchannel_audio:true, Encode 3-8 channel audio as 2.1-7.1(LFE) -> checked; false, DON'T Encode 3-8 channel audio as 2.1-7.1(LFE) -> unchecked\nper_channel:true, kbps per channel (6-256); false, kbps combined for all channels \n",
        "body": "${1:local }${2:integer Mode},${3:integer Bitrate},${4:integer Complexity},${5:boolean channel_audio},${6:boolean per_channel} = ultraschall.GetRenderCFG_Settings_OPUS(${7:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_GIF_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_GIF",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for Gif.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nWidth:the width of the gif in pixels; 1 to 2147483647 pixels\nHeight:the height of the gif in pixels; 1 to 2147483647 pixels\nMaxFramerate:the maximum framerate of the gif\nPreserveAspectRatio:Preserve aspect ratio (black bars, if necessary)-checkbox; true, checked; false, unchecked\nIgnoreLowBits:Ignore changed in low bits of color (0-7, 0 = full quality)-inputbox\nTransparency:Encode transparency (bad for normal video, good for some things possibly)-checkbox; true, checked; false, unchecked\n",
        "body": "${1:local }${2:integer Width},${3:integer Height},${4:number MaxFramerate},${5:boolean PreserveAspectRatio},${6:integer IgnoreLowBits},${7:boolean Transparency} = ultraschall.GetRenderCFG_Settings_GIF(${8:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_LCF_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_LCF",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for LCF.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nWidth:the width of the gif in pixels; 1 to 2147483647 pixels\nHeight:the height of the gif in pixels; 1 to 2147483647 pixels\nMaxFramerate:the maximum framerate of the gif\nPreserveAspectRatio:Preserve aspect ratio (black bars, if necessary)-checkbox; true, checked; false, unchecked\nTweakSettings:the tweak-settings for LCF, default is \"t20 x128 y16\"\n",
        "body": "${1:local }${2:integer Width},${3:integer Height},${4:number MaxFramerate},${5:boolean PreserveAspectRatio},${6:string TweakSettings} = ultraschall.GetRenderCFG_Settings_LCF(${7:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_WAV_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_WAV",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for WAV.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nBitDepth:the bitdepth of the WAV-file\nLargeFiles:how shall Reaper treat large WAV-files\nBWFChunk:The \"Write BWF ('bext') chunk\" and \"Include project filename in BWF data\" - checkboxes\nIncludeMarkers: The include markerlist-dropdownlist\nEmbedProjectTempo:Embed project tempo (use with care)-checkbox; true, checked; false, unchecked \n",
        "body": "${1:local }${2:integer BitDepth},${3:integer LargeFiles},${4:integer BWFChunk},${5:integer IncludeMarkers},${6:boolean EmbedProjectTempo} = ultraschall.GetRenderCFG_Settings_WAV(${7:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_WAVPACK_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_WAVPACK",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for WAVPACK.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMode:0, Normal; 1, Fast; 2, High; 3, Very High(slowest) \nBitdepth:  the bitdepth of the WAVPACK-file\nWritemarkers:Write markers as cues-checkboxes\nWriteBWFChunk:the Write BWF chunk-checkbox; true, checked; false, unchecked \nIncludeFilenameBWF:the include project filename in BWF data-checkbox; true, checked; false, unchecked \n",
        "body": "${1:local }${2:integer Mode},${3:integer Bitdepth},${4:integer Writemarkers},${5:boolean WriteBWFChunk},${6:boolean IncludeFilenameBWF} = ultraschall.GetRenderCFG_Settings_WAVPACK(${7:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_WEBMVIDEO_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_WebMVideo",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for WEBM_Video.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVIDKBPS: the video-bitrate of the video in kbps\nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "${1:local }${2:integer VIDKBPS},${3:integer AUDKBPS},${4:integer WIDTH},${5:integer HEIGHT},${6:integer FPS},${7:boolean AspectRatio} = ultraschall.GetRenderCFG_Settings_WebMVideo(${8:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MKV_VIDEO_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MKV_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MKV-Video.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVIDEO_CODEC:the used VideoCodec for the MKV-video\nMJPEG_quality:the MJPEG-quality of the MKV-video, if VIDEO_CODEC=2\nAUDIO_CODEC:the audio-codec of the MKV-video\nWIDTH:the width of the video in pixels\nHEIGHT:the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "${1:local }${2:integer VIDEO_CODEC},${3:integer MJPEG_quality},${4:integer AUDIO_CODEC},${5:integer WIDTH},${6:integer HEIGHT},${7:integer FPS},${8:boolean AspectRatio} = ultraschall.GetRenderCFG_Settings_MKV_Video(${9:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_AVI_VIDEO_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_AVI_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for AVI_Video.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVIDEO_CODEC:the used VideoCodec for the AVI-video\nMJPEG_quality:the MJPEG-quality of the AVI-video, if VIDEO_CODEC=1\nAUDIO_CODEC:the audio-codec of the avi-video\nWIDTH:the width of the video in pixels\nHEIGHT:the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "${1:local }${2:integer VIDEO_CODEC},${3:integer MJPEG_quality},${4:integer AUDIO_CODEC},${5:integer WIDTH},${6:integer HEIGHT},${7:integer FPS},${8:boolean AspectRatio} = ultraschall.GetRenderCFG_Settings_AVI_Video(${9:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_QTMOVMP4_VIDEO_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_QTMOVMP4_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for QT/MOV/MP4-video.\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nMJPEG_quality:the MJPEG-quality of the video\nAUDIO_CODEC:the audio-codec of the video\nWIDTH:the width of the video in pixels\nHEIGHT:the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "${1:local }${2:integer MJPEG_quality},${3:integer AUDIO_CODEC},${4:integer WIDTH},${5:integer HEIGHT},${6:integer FPS},${7:boolean AspectRatio} = ultraschall.GetRenderCFG_Settings_QTMOVMP4_Video(${8:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_DDP_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_DDP",
        "scope": "lua",
        "description": "Returns, if a renderstring is a valid DDP-render-string\nYou can get this from the current RENDER\\_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nretval:true, if renderstring is of the format DDP; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GetRenderCFG_Settings_DDP(${3:string rendercfg})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_GIF_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_GIF",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the GIF-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nWidth:the width of the gif in pixels; 1 to 2147483647\nHeight:the height of the gif in pixels; 1 to 2147483647 \nMaxFPS:the maximum framerate of the gif in fps; 0.01 to 2000.01 supported by the Ultraschall API\nAspectRatio:Preserve aspect ratio-checkbox; true, checked; false, unchecked\nIgnoreLowBits:Ignore changes in low bits of color-inputbox, 0-7\nEncodeTransparency:Encode transparency-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected GIF-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_GIF(${3:integer Width},${4:integer Height},${5:number MaxFPS},${6:boolean AspectRatio},${7:integer IgnoreLowBits},${8:boolean EncodeTransparency})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_LCF_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_LCF",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the LCF-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nWidth:the width of the lcf in pixels; 1 to 2147483647\nHeight:the height of the lcf in pixels; 1 to 2147483647 \nMaxFPS:the maximum framerate of the lcf in fps; 0.01 to 2000.01 supported by the Ultraschall API\nAspectRatio:Preserve aspect ratio-checkbox; true, checked; false, unchecked\nLCFoptionstweak:a 64bytes string, which can hold tweak-settings for lcf; default is \"t20 x128 y16\"; this function does not check for these options to be valid!\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected LCF-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_LCF(${3:integer Width},${4:integer Height},${5:number MaxFPS},${6:boolean AspectRatio},${7:optional string LCFoptionstweak})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_WEBMVIDEO_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_WebMVideo",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the WebM-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVIDKBPS:the video-bitrate of the video in kbps; 1 to 2147483647\nAUDKBPS:the audio-bitrate of the video in kbps; 1 to 2147483647\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected WebM-Video-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_WebMVideo(${3:integer VIDKBPS},${4:integer AUDKBPS},${5:integer WIDTH},${6:integer HEIGHT},${7:integer FPS},${8:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MKV_VIDEO_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_MKV_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the MKV-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for the video;\nMJPEG_quality:set here the MJPEG-quality in percent, when VideoCodec=3; otherwise just set it to 0\nAudioCodec:the audiocodec to use for the video\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MKV-Video-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_MKV_Video(${3:integer VideoCodec},${4:integer MJPEG_quality},${5:integer AudioCodec},${6:integer WIDTH},${7:integer HEIGHT},${8:integer FPS},${9:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_QTMOVMP4_VIDEO_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_QTMOVMP4_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the QT/MOV/MP4-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for the video;\nMJPEG_quality:set here the MJPEG-quality in percent\nAudioCodec:the audiocodec to use for the video\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected QT/MOV/MP4-Video-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_QTMOVMP4_Video(${3:integer VideoCodec},${4:integer MJPEG_quality},${5:integer AudioCodec},${6:integer WIDTH},${7:integer HEIGHT},${8:integer FPS},${9:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_AVI_VIDEO_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_AVI_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the AVI-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for the video;\nMJPEG_quality:set here the MJPEG-quality in percent when VideoCodec=2, otherwise just set it to 0\nAudioCodec:the audiocodec to use for the video\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected QT/MOV/MP4-Video-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_AVI_Video(${3:integer VideoCodec},${4:integer MJPEG_quality},${5:integer AudioCodec},${6:integer WIDTH},${7:integer HEIGHT},${8:integer FPS},${9:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MP4MAC_VIDEO_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MP4Mac_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MP4 for Mac_Video(stream optimised and non-stream optimised).\nThis is Mac-OS only!\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nStream:true, mp4-video would be stream-optimized; false, mp4-video would not be stream-optimized\nVIDKBPS: the video-bitrate of the video in kbps\nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "${1:local }${2:boolean Stream},${3:integer VIDKBPS},${4:integer AUDKBPS},${5:integer WIDTH},${6:integer HEIGHT},${7:integer FPS},${8:boolean AspectRatio} = ultraschall.GetRenderCFG_Settings_MP4Mac_Video(${9:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_MOVMAC_VIDEO_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_MOVMac_Video",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for MOV for Mac_Video.\nThis is MacOS-only.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nVideoCodec:the videocodec used for this setting\nVIDKBPS: the video-bitrate of the video in kbps\nMJPEG_quality:when VideoCodec==3, then MJPEG is used; given in percent\nAudioCodec:the audiocodec used \nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "${1:local }${2:integer VideoCodec},${3:integer VIDKBPS},${4:integer MJPEG_quality},${5:integer AudioCodec},${6:integer AUDKBPS},${7:integer WIDTH},${8:integer HEIGHT},${9:integer FPS},${10:boolean AspectRatio} = ultraschall.GetRenderCFG_Settings_MOVMac_Video(${11:string rendercfg})$0"
    },
    "ULTRASCHALL.GETRENDERCFG_SETTINGS_M4AMAC_WR lua": {
        "prefix": "ultraschallwr.GetRenderCFG_Settings_M4AMac",
        "scope": "lua",
        "description": "Returns the settings stored in a render-cfg-string for M4A for Mac_Video(even though this stores only audio-files).\nThis is MacOS-only.\nYou can get this from the current RENDER_FORMAT using reaper.GetSetProjectInfo_String or from ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns -1 in case of an error\nRETURNS:\nAUDKBPS: the audio-bitrate of the audio in kbps\nWIDTH:the width of the audio in pixels\nHEIGHT: the height of the audio in pixels\nFPS:the fps of the audio; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \n",
        "body": "${1:local }${2:integer AUDKBPS},${3:integer WIDTH},${4:integer HEIGHT},${5:integer FPS},${6:boolean AspectRatio} = ultraschall.GetRenderCFG_Settings_M4AMac(${7:string rendercfg})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP4MAC_VIDEO_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_MP4MAC_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the MP4-Mac-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nOnly available on MacOS!\nReturns nil in case of an error\nPARAMETERS:\nVIDKBPS:the video-bitrate for the video; 0 to 2147483647kbps\nAUDKBPS:the audio-bitrate for the video; 0 to 2147483647kbps\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP4-Mac-Video-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_MP4MAC_Video(${3:boolean stream},${4:integer VIDKBPS},${5:integer AUDKBPS},${6:integer WIDTH},${7:integer HEIGHT},${8:integer FPS},${9:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_M4AMAC_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_M4AMAC",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the M4A-Mac-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nOnly available on MacOS!\nReturns nil in case of an error\nPARAMETERS:\nAUDKBPS:the audio-bitrate for the video; 0 to 2147483647 kbps\nWIDTH:the width of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nHEIGHT:the height of the video in pixels; 1 to 2147483647; only even values(2,4,6,etc) will be accepted by Reaper, uneven will be rounded up!\nFPS:the fps of the video; must be a double-precision-float value (e.g. 9.09 or 25.00); 0.01 to 2000.00\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected M4A-Mac-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_M4AMAC(${3:integer AUDKBPS},${4:integer WIDTH},${5:integer HEIGHT},${6:integer FPS},${7:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MOVMAC_VIDEO_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_MOVMAC_Video",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the MOV-Mac-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nOnly available on MacOS!\nReturns nil in case of an error\nPARAMETERS:\nVideoCodec:the videocodec used for this setting\nVIDKBPS: the video-bitrate of the video in kbps\nMJPEG_quality:when VideoCodec==3, then MJPEG is used; given in percent\nAudioCodec:the audiocodec used \nAUDKBPS: the audio-bitrate of the video in kbps\nWIDTH:the width of the video in pixels\nHEIGHT: the height of the video in pixels\nFPS:the fps of the video; must be a double-precision-float value (9.09 or 25.00); due API-limitations, this supports 0.01fps to 2000.00fps\nAspectRatio:the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio \nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP4-Mac-Video-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_MOVMAC_Video(${3:integer VideoCodec},${4:integer VIDKBPS},${5:integer MJPEG_quality},${6:integer AudioCodec},${7:integer AUDKBPS},${8:integer WIDTH},${9:integer HEIGHT},${10:integer FPS},${11:boolean AspectRatio})$0"
    },
    "ULTRASCHALL.GETRENDERTABLE_PROJECT_WR lua": {
        "prefix": "ultraschallwr.GetRenderTable_Project",
        "scope": "lua",
        "description": "Returns all stored render-settings for the current project, as a handy table.\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - true, closes rendering to file-dialog after render; false, doesn't close it\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; true, checked; false, unchecked\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; true, checked; false, unchecked\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns nil in case of an error\nRETURNS:\nRenderTable:a table with all of the current project's render-settings\n",
        "body": "${1:local }${2:table RenderTable} = ultraschall.GetRenderTable_Project()$0"
    },
    "ULTRASCHALL.GETRENDERTABLE_PROJECTFILE_WR lua": {
        "prefix": "ultraschallwr.GetRenderTable_ProjectFile",
        "scope": "lua",
        "description": "Returns all stored render-settings in a projectfile, as a handy table.\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - close rendering to file-dialog after render; always true, as this isn't stored in projectfiles\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checkbox is checked; false, checkbox is unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; always true(checked), as this isn't stored in projectfiles\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; always false, as this is not stored in projectfiles\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns nil in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfile, whose render-settings you want to get\nRETURNS:\nRenderTable:a table with all of the current project's render-settings\n",
        "body": "${1:local }${2:table RenderTable} = ultraschall.GetRenderTable_ProjectFile(${3:string projectfilename_with_path})$0"
    },
    "ULTRASCHALL.GETOUTPUTFORMAT_RENDERCFG_WR lua": {
        "prefix": "ultraschallwr.GetOutputFormat_RenderCfg",
        "scope": "lua",
        "description": "Returns the output-format set in a render-cfg-string, as stored in rpp-files and the render-presets file reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nRenderstring:the render-cfg-string from a rpp-projectfile or the reaper-render.ini\nReaProject:a ReaProject, whose renderformat you want to know; only available, when Renderstring=nil\nRETURNS:\noutputformat:the outputformat, set in the render-cfg-string\nrenderstring:the renderstringm which is either the renderstring you've passed or the one from the ReaProject you passed as second parameter\n",
        "body": "${1:local }${2:string outputformat},${3:string renderstring} = ultraschall.GetOutputFormat_RenderCfg(${4:string Renderstring},${5:optional ReaProject ReaProject})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_OPUS_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_Opus",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the Opus-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nMode:the Mode for the Opus-file; 0, VBR; 1, CVBR; 2, HARDCBR\nKbps:the kbps of the opus-file; Ultraschall-Api supports between 1 and 10256 \nComplexity:the complexity-setting between 0(lowest quality) and 10(highest quality, slow encoding)\nchannel_audio:true, Encode 3-8 channel audio as 2.1-7.1(LFE); false, DON'T Encode 3-8 channel audio as 2.1-7.1(LFE) \nper_channel:true, kbps per channel (6-256); false, kbps combined for all channels \nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected Opus-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_Opus(${3:integer Mode},${4:integer Kbps},${5:integer Complexity},${6:optional boolean channel_audio},${7:optional boolean per_channel})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_OGG_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_OGG",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the OGG-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nFor all mode-settings that you don't need(kbps or quality), you can safely set them to 1.\nReturns nil in case of an error\nPARAMETERS:\nMode:the mode for the ogg-file; 0, VBR; 1, CBR; 2, ABR\nVBR_Quality:the quality for VBR-mode; a floating-value between 0 and 1\nCBR_KBPS:the bitrate for CBR-mode; 0 to 2048\nABR_KBPS:the maximum-bitrate for ABR-mode; 0 to 2048\nABR_KBPS_MIN:the minimum-bitrate for ABR-mode; 0 to 2048\nABR_KBPS_MAX:the maximum-bitrate for ABR-mode; 0 to 2048\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected OGG-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_OGG(${3:integer Mode},${4:number VBR_Quality},${5:integer CBR_KBPS},${6:integer ABR_KBPS},${7:integer ABR_KBPS_MIN},${8:integer ABR_KBPS_MAX})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_DDP_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_DDP",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the DDP-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected DDP-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_DDP()$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_FLAC_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_FLAC",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the FLAC-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nBitrate:the bitrate of the flac-file; \nEncSpeed:the encoding speed; 0(fastest) to 8(slowest); 5(default)\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected FLAC-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_FLAC(${3:integer Bitrate},${4:integer EncSpeed})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_WAVPACK_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_WAVPACK",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the WAVPACK-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nMode:0, Normal; 1, Fast; 2, High; 3, Very High(slowest)\nBitdepth:the bitdepth of the WAVPACK-file\nWritemarkers:Write markers as cues-checkboxes\nWriteBWFChunk:the Write BWF chunk-checkbox; true, checked; false, unchecked\nIncludeFilenameBWF:the include project filename in BWF data-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected WAVPACK-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_WAVPACK(${3:integer Mode},${4:integer Bitdepth},${5:integer Writemarkers},${6:boolean WriteBWFChunk},${7:boolean IncludeFilenameBWF})$0"
    },
    "ULTRASCHALL.ISVALIDRENDERTABLE_WR lua": {
        "prefix": "ultraschallwr.IsValidRenderTable",
        "scope": "lua",
        "description": "returns, if the table RenderTable is a valid RenderTable.\nReturns false in case of an error; the error-message contains the faulty table-entry.\nPARAMETERS:\nRenderTable:the table, that you want to check for validity\nRETURNS:\nretval:true, RenderTable is a valid RenderTable; false, it is not a valid RenderTable\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsValidRenderTable(${3:RenderTable RenderTable})$0"
    },
    "ULTRASCHALL.APPLYRENDERTABLE_PROJECT_WR lua": {
        "prefix": "ultraschallwr.ApplyRenderTable_Project",
        "scope": "lua",
        "description": "Sets all stored render-settings from a RenderTable as the current project-settings.\nNote: On Reaper 6.10, you cannot set AddToProj and NoSilentRender simultaneously due a bug in Reaper; is fixed in higher versions.\nExpected table is of the following structure:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - true, close rendering to file-dialog after render; false, don't close it\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; true, checked; false, unchecked\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; true, checked; false, unchecked\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns false in case of an error\nPARAMETERS:\nRenderTable:a RenderTable, that contains all render-dialog-settings\napply_rendercfg_string:true or nil, apply it as well; false, don't apply it\nRETURNS:\nretval:true, setting the render-settings was successful; false, it wasn't successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyRenderTable_Project(${3:RenderTable RenderTable},${4:optional boolean apply_rendercfg_string})$0"
    },
    "ULTRASCHALL.APPLYRENDERTABLE_PROJECTFILE_WR lua": {
        "prefix": "ultraschallwr.ApplyRenderTable_ProjectFile",
        "scope": "lua",
        "description": "Sets all stored render-settings from a RenderTable as the current project-settings.\nExpected table is of the following structure:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - close rendering to file-dialog after render; ignored, as this can't be set in projectfiles\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle);\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; ignored, as this can't be stored in projectfiles\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; ignored, as this can't be stored in projectfiles\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns false in case of an error\nPARAMETERS:\nRenderTable:a RenderTable, that contains all render-dialog-settings\nprojectfilename_with_path:the rpp-projectfile, to which you want to apply the RenderTable; nil, to use parameter ProjectStateChunk instead\napply_rendercfg_string:true or nil, apply it as well; false, don't apply it\nProjectStateChunk:the ProjectStateChunkk, to which you want to apply the RenderTable\nRETURNS:\nretval:true, setting the render-settings was successful; false, it wasn't successful\nProjectStateChunk:the altered project/ProjectStateChunk as a string\n",
        "body": "${1:local }${2:boolean retval},${3:string ProjectStateChunk} = ultraschall.ApplyRenderTable_ProjectFile(${4:RenderTable RenderTable},${5:string projectfilename_with_path},${6:optional boolean apply_rendercfg_string},${7:optional string ProjectStateChunk})$0"
    },
    "ULTRASCHALL.GETRENDER_SAVECOPYOFPROJECT_WR lua": {
        "prefix": "ultraschallwr.GetRender_SaveCopyOfProject",
        "scope": "lua",
        "description": "Gets the current state of the \"Save copy of project to outfile.wav.RPP\"-checkbox from the Render to File-dialog.\nReturns false in case of an error\nRETURNS:\nretval:true, checkbox is checked; false, checkbox is unchecked\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GetRender_SaveCopyOfProject()$0"
    },
    "ULTRASCHALL.SETRENDER_QUEUEDELAY_WR lua": {
        "prefix": "ultraschallwr.SetRender_QueueDelay",
        "scope": "lua",
        "description": "Sets the \"Delay queued render to allow samples to load\"-checkbox of the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nlength:the number of seconds the delay shall be\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRender_QueueDelay(${3:boolean state},${4:integer length})$0"
    },
    "ULTRASCHALL.SETRENDER_SAVECOPYOFPROJECT_WR lua": {
        "prefix": "ultraschallwr.SetRender_SaveCopyOfProject",
        "scope": "lua",
        "description": "Sets the \"Save copy of project to outfile.wav.RPP\"-checkbox of the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRender_SaveCopyOfProject(${3:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDER_QUEUEDELAY_WR lua": {
        "prefix": "ultraschallwr.GetRender_QueueDelay",
        "scope": "lua",
        "description": "Gets the current checkstate of the \"Delay queued render to allow samples to load\"-checkbox from the Render to File-dialog,\nas well as the length of the queue-render-delay.\nRETURNS:\nlength:the number of seconds the delay shall be\n",
        "body": "${1:local }${2:boolean retval},${3:integer length} = ultraschall.GetRender_QueueDelay()$0"
    },
    "ULTRASCHALL.SETRENDER_PROJECTSAMPLERATEFORMIX_WR lua": {
        "prefix": "ultraschallwr.SetRender_ProjectSampleRateForMix",
        "scope": "lua",
        "description": "Sets the \"Use project sample rate for mixing and FX/synth processing\"-checkbox of the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRender_ProjectSampleRateForMix(${3:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDER_PROJECTSAMPLERATEFORMIX_WR lua": {
        "prefix": "ultraschallwr.GetRender_ProjectSampleRateForMix",
        "scope": "lua",
        "description": "Gets the current state of the \"Use project sample rate for mixing and FX/synth processing\"-checkbox from the Render to File-dialog.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GetRender_ProjectSampleRateForMix()$0"
    },
    "ULTRASCHALL.SETRENDER_AUTOINCREMENTFILENAME_WR lua": {
        "prefix": "ultraschallwr.SetRender_AutoIncrementFilename",
        "scope": "lua",
        "description": "Gets the current state of the \"Silently increment filenames to avoid overwriting\"-checkbox from the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRender_AutoIncrementFilename(${3:boolean state})$0"
    },
    "ULTRASCHALL.GETRENDER_AUTOINCREMENTFILENAME_WR lua": {
        "prefix": "ultraschallwr.GetRender_AutoIncrementFilename",
        "scope": "lua",
        "description": "Gets the current state of the \"Silently increment filenames to avoid overwriting\"-checkbox from the Render to File-dialog.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GetRender_AutoIncrementFilename()$0"
    },
    "ULTRASCHALL.GETRENDERPRESET_NAMES_WR lua": {
        "prefix": "ultraschallwr.GetRenderPreset_Names",
        "scope": "lua",
        "description": "Returns all render-preset-names for a) Bounds and output pattern/filename b) Options and format c) both presets, who share the same name\nRETURNS:\nbounds_presets:the number of found bounds and output-pattern-presets\nbounds_names:the names of all found bounds and output-pattern-presets\noptions_format_presets:the number of found options and format-presets\noptions_format_names:the names of all found options and format-presets\nboth_presets:the number of found presets, who both share the same name\nboth_names:the names of all found presets, who both share the same name\n",
        "body": "${1:local }${2:integer bounds_presets},${3:table bounds_names},${4:integer options_format_presets},${5:table options_format_names},${6:integer both_presets},${7:table both_names} = ultraschall.GetRenderPreset_Names()$0"
    },
    "ULTRASCHALL.GETRENDERPRESET_RENDERTABLE_WR lua": {
        "prefix": "ultraschallwr.GetRenderPreset_RenderTable",
        "scope": "lua",
        "description": "returns a rendertable, that contains all settings of a specific render-preset.\nuse GetRenderPreset_Names to get the available render-preset-names.\nSome settings aren't stored in Presets and will get default values:\nTailMS=0, SilentlyIncrementFilename=false, AddToProj=false, SaveCopyOfProject=false, RenderQueueDelay=false, RenderQueueDelaySeconds=false, NoSilentRender=false\nreturned table if of the following format:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; always false, as this isn't stored in render-presets\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - close rendering to file-dialog after rendering; always true, as this isn't stored in render-presets\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"NoSilentRender\"] - Do not render files that are likely silent-checkbox; can't be set in render-presets, therefore always set to false\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; always false, as this isn't stored in render-presets\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay; always 0, as this isn't stored in render-presets\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; always false, as this isn't stored in render-presets\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; always true, as this isn't stored in Presets\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail; always 0, as this isn't stored in render-presets\nReturns nil in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to get\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to get\nRETURNS:\nRenderTable:a render-table, which contains all settings from a render-preset\n",
        "body": "${1:local }${2:RenderTable RenderTable} = ultraschall.GetRenderPreset_RenderTable(${3:string Bounds_Name},${4:string Options_and_Format_Name})$0"
    },
    "ULTRASCHALL.DELETERENDERPRESET_BOUNDS_WR lua": {
        "prefix": "ultraschallwr.DeleteRenderPreset_Bounds",
        "scope": "lua",
        "description": "deletes a Bounds-render-preset from Reaper's render-presets.\nThis deletes all(!) occurrences of the Bounds-render-preset with the same name.\nThough, you shouldn't store multiple Bounds-render-presets with the same name into reaper-render.ini in the first place.\nuse GetRenderPreset_Names to get the available render-preset-names.\nReturns false in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to get\nRETURNS:\nretval:true, deleting was successful; false, deleting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteRenderPreset_Bounds(${3:string Bounds_Name})$0"
    },
    "ULTRASCHALL.DELETERENDERPRESET_FORMATOPTIONS_WR lua": {
        "prefix": "ultraschallwr.DeleteRenderPreset_FormatOptions",
        "scope": "lua",
        "description": "deletes a Render-Format-Options-render-preset from Reaper's render-presets.\nThis deletes all(!) occurrences of the Render-Format-Options-render-preset with the same name.\nThough, you shouldn't store multiple Render-Format-Options-render-preset with the same name into reaper-render.ini in the first place.\nuse GetRenderPreset_Names to get the available render-preset-names.\nReturns false in case of an error\nPARAMETERS:\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to get\nRETURNS:\nretval:true, deleting was successful; false, deleting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteRenderPreset_FormatOptions(${3:string Options_and_Format_Name})$0"
    },
    "ULTRASCHALL.ADDRENDERPRESET_WR lua": {
        "prefix": "ultraschallwr.AddRenderPreset",
        "scope": "lua",
        "description": "adds a new render-preset into reaper-render.ini.\nThis function will check, whether the chosen names are already in use.\nAdded render-presets are available after (re-)opening in the Render to File-dialog\nNote: You can choose, whether to include only Bounds, only RenderFormatOptions of both. The Bounds and the RenderFormatOptions store different parts of the render-presets.\nSome settings aren't stored in Presets and will get default values:\nTailMS=0, SilentlyIncrementFilename=false, AddToProj=false, SaveCopyOfProject=false, RenderQueueDelay=false, RenderQueueDelaySeconds=false, NoSilentRender=false\nBounds_Name stores only:\nRenderTable[\"Bounds\"] - the bounds-dropdownlist,\n0, Custom time range\n1, Entire project\n2, Time selection\n3, Project regions\n4, Selected Media Items(in combination with Source 32)\n5, Selected regions\nRenderTable[\"Startposition\"] - the startposition of the render\nRenderTable[\"Endposition\"] - the endposition of the render\nRenderTable[\"Source\"] - the source dropdownlist, includes\n0, Master mix\n1, Master mix + stems\n3, Stems (selected tracks)\n8, Region render matrix\n32, Selected media items\n64, selected media items via master\n128, selected tracks via master\n\"0\"    - unknown, default setting is 0\nRenderTable[\"RenderPattern\"] - the renderpattern, which hold also the wildcards\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked?\n&1, custom time bounds\n&2, entire project\n&4, time selection\n&8, all project regions\n&16, selected media items\n&32, selected project regions\nOptions_and_Format_Name stores only:\nRenderTable[\"SampleRate\"] - the samplerate, with which to render; 0, use project-settings\nRenderTable[\"Channels\"] - the number of channels for the output-file\nRenderTable[\"OfflineOnlineRendering\"] - the offline/online-dropdownlist\n0, Full-speed Offline\n1, 1x Offline\n2, Online Render\n3, Online Render(Idle)\n4, Offline Render(Idle);\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist;\n0, Medium (64pt Sinc)\n1, Low (Linear Interpolation)\n2, Lowest (Point Sampling)\n3, Good (192pt Sinc)\n4, Better (348 pt Sinc)\n5, Fast (IIR + Linear Interpolation)\n6, Fast (IIRx2 + Linear Interpolation)\n7, Fast (16pt Sinc)\n8, HQ (512 pt)\n9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"Dither\"] - the Dither/Noise shaping-checkboxes:\n&1, dither master mix\n&2, noise shaping master mix\n&4, dither stems\n&8, dither noise shaping stems\nRenderTable[\"MultiChannelFiles\"] - multichannel-files-checkbox\nRenderTable[\"OnlyMonoMedia\"] - only mono media-checkbox\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides-checkbox\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers-checkbox\nRenderTable[\"RenderString\"] - the render-cfg-string, which holds the render-outformat-settings\nRenderTable[\"RenderString2\"] - the render-cfg-string, which holds the secondary render-outformat-settings\nReturns false in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to add; nil, to not add a new Bounds-render-preset\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to add; to not add a new Render-Format-Options-render-preset\nRenderTable:the RenderTable, which holds all information for inclusion into the Render-Preset\nRETURNS:\nretval:true, adding was successful; false, adding was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AddRenderPreset(${3:string Bounds_Name},${4:string Options_and_Format_Name},${5:RenderTable RenderTable})$0"
    },
    "ULTRASCHALL.SETRENDERPRESET_WR lua": {
        "prefix": "ultraschallwr.SetRenderPreset",
        "scope": "lua",
        "description": "sets an already existing render-preset in reaper-render.ini.\nThis function will check, whether the chosen names aren't given yet in any preset.\nChanged render-presets are updated after (re-)opening in the Render to File-dialog\nNote: You can choose, whether to include only Bounds, only RenderFormatOptions of both. The Bounds and the RenderFormatOptions store different parts of the render-presets.\nSome settings aren't stored in Presets and will get default values:\nTailMS=0, SilentlyIncrementFilename=false, AddToProj=false, SaveCopyOfProject=false, RenderQueueDelay=false, RenderQueueDelaySeconds=false, NoSilentRender=false\nBounds_Name stores only:\nRenderTable[\"Bounds\"] - the bounds-dropdownlist,\n0, Custom time range\n1, Entire project\n2, Time selection\n3, Project regions\n4, Selected Media Items(in combination with Source 32)\n5, Selected regions\nRenderTable[\"Startposition\"] - the startposition of the render\nRenderTable[\"Endposition\"] - the endposition of the render\nRenderTable[\"Source\"]+RenderTable[\"MultiChannelFiles\"]+RenderTable[\"OnlyMonoMedia\"] - the source dropdownlist, includes\n0, Master mix\n1, Master mix + stems\n3, Stems (selected tracks)\n&4, Multichannel tracks to multichannel files\n8, Region render matrix\n&16, Tracks with only mono media to mono files\n32, Selected media items\n64, selected media items via master\n128, selected tracks via master\n\"0\"    - unknown, default setting is 0\nRenderTable[\"RenderPattern\"] - the renderpattern, which hold also the wildcards\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked?\n&1, custom time bounds\n&2, entire project\n&4, time selection\n&8, all project regions\n&16, selected media items\n&32, selected project regions\nOptions_and_Format_Name stores only:\nRenderTable[\"SampleRate\"] - the samplerate, with which to render; 0, use project-settings\nRenderTable[\"Channels\"] - the number of channels for the output-file\nRenderTable[\"OfflineOnlineRendering\"] - the offline/online-dropdownlist\n0, Full-speed Offline\n1, 1x Offline\n2, Online Render\n3, Online Render(Idle)\n4, Offline Render(Idle);\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; 1, checked; 0, unchecked\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist;\n0, Medium (64pt Sinc)\n1, Low (Linear Interpolation)\n2, Lowest (Point Sampling)\n3, Good (192pt Sinc)\n4, Better (348 pt Sinc)\n5, Fast (IIR + Linear Interpolation)\n6, Fast (IIRx2 + Linear Interpolation)\n7, Fast (16pt Sinc)\n8, HQ (512 pt)\n9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"Dither\"] - the Dither/Noise shaping-checkboxes:\n&1, dither master mix\n&2, noise shaping master mix\n&4, dither stems\n&8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides-checkbox\nRenderTable[\"EmbedTakeMarkers\"] - Embed Take markers-checkbox\nRenderTable[\"RenderString\"] - the render-cfg-string, which holds the render-outformat-settings\nRenderTable[\"RenderString2\"] - the render-cfg-string, which holds the secondary render-outformat-settings; \"\" to remove it from this preset\nReturns false in case of an error\nPARAMETERS:\nBounds_Name:the name of the Bounds-render-preset you want to add; nil, to not add a new Bounds-render-preset\nOptions_and_Format_Name:the name of the Renderformat-options-render-preset you want to add; to not add a new Render-Format-Options-render-preset\nRenderTable:the RenderTable, which holds all information for inclusion into the Render-Preset\nRETURNS:\nretval:true, setting was successful; false, setting was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRenderPreset(${3:string Bounds_Name},${4:string Options_and_Format_Name},${5:RenderTable RenderTable})$0"
    },
    "ULTRASCHALL.RENDERPROJECT_RENDERTABLE_WR lua": {
        "prefix": "ultraschallwr.RenderProject_RenderTable",
        "scope": "lua",
        "description": "Renders a projectfile or the current active project, using the settings from a RenderTable.\nExpected RenderTable is of the following structure:\nRenderTable[\"AddToProj\"] - Add rendered items to new tracks in project-checkbox; true, checked; false, unchecked\nRenderTable[\"Bounds\"] - 0, Custom time range; 1, Entire project; 2, Time selection; 3, Project regions; 4, Selected Media Items(in combination with Source 32); 5, Selected regions\nRenderTable[\"Channels\"] - the number of channels in the rendered file; 1, mono; 2, stereo; higher, the number of channels\nRenderTable[\"CloseAfterRender\"] - true, close rendering to file-dialog after render; false, don't close it\nRenderTable[\"Dither\"] - &1, dither master mix; &2, noise shaping master mix; &4, dither stems; &8, dither noise shaping stems\nRenderTable[\"EmbedStretchMarkers\"] - Embed stretch markers/transient guides; true, checked; false, unchecked\nRenderTable[\"Endposition\"] - the endposition of the rendering selection in seconds\nRenderTable[\"MultiChannelFiles\"] - Multichannel tracks to multichannel files-checkbox; true, checked; false, unchecked\nRenderTable[\"OfflineOnlineRendering\"] - Offline/Online rendering-dropdownlist; 0, Full-speed Offline; 1, 1x Offline; 2, Online Render; 3, Online Render(Idle); 4, Offline Render(Idle)\nRenderTable[\"OnlyMonoMedia\"] - Tracks with only mono media to mono files-checkbox; true, checked; false, unchecked\nRenderTable[\"ProjectSampleRateFXProcessing\"] - Use project sample rate for mixing and FX/synth processing-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderFile\"] - the contents of the Directory-inputbox of the Render to File-dialog\nRenderTable[\"RenderPattern\"] - the render pattern as input into the File name-inputbox of the Render to File-dialog\nRenderTable[\"RenderQueueDelay\"] - Delay queued render to allow samples to load-checkbox; true, checked; false, unchecked\nRenderTable[\"RenderQueueDelaySeconds\"] - the amount of seconds for the render-queue-delay\nRenderTable[\"RenderResample\"] - Resample mode-dropdownlist; 0, Medium (64pt Sinc); 1, Low (Linear Interpolation); 2, Lowest (Point Sampling); 3, Good (192pt Sinc); 4, Better (348 pt Sinc); 5, Fast (IIR + Linear Interpolation); 6, Fast (IIRx2 + Linear Interpolation); 7, Fast (16pt Sinc); 8, HQ (512 pt); 9, Extreme HQ(768pt HQ Sinc)\nRenderTable[\"RenderString\"] - the render-cfg-string, that holds all settings of the currently set render-output-format as BASE64 string\nRenderTable[\"RenderString2\"] - the render-cfg-string, that holds all settings of the currently set secondary-render-output-format as BASE64 string\nRenderTable[\"RenderTable\"]=true - signals, this is a valid render-table\nRenderTable[\"SampleRate\"] - the samplerate of the rendered file(s)\nRenderTable[\"SaveCopyOfProject\"] - the \"Save copy of project to outfile.wav.RPP\"-checkbox; true, checked; false, unchecked\nRenderTable[\"SilentlyIncrementFilename\"] - Silently increment filenames to avoid overwriting-checkbox; true, checked; false, unchecked\nRenderTable[\"Source\"] - 0, Master mix; 1, Master mix + stems; 3, Stems (selected tracks); 8, Region render matrix; 16, Tracks with only Mono-Media to Mono Files; 32, Selected media items; 64, selected media items via master; 128, selected tracks via master\nRenderTable[\"Startposition\"] - the startposition of the rendering selection in seconds\nRenderTable[\"TailFlag\"] - in which bounds is the Tail-checkbox checked? &1, custom time bounds; &2, entire project; &4, time selection; &8, all project regions; &16, selected media items; &32, selected project regions\nRenderTable[\"TailMS\"] - the amount of milliseconds of the tail\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the projectfilename with path of the rpp-file that you want to render; nil, to render the current active project\nRenderTable:the RenderTable with all render-settings, that you want to apply; nil, use the project's existing settings\nAddToProj:true, add the rendered files to the project; nil or false, don't add them; \nCloseAfterRender:true or nil, closes rendering to file-dialog after rendering is finished; false, keep it open\nSilentlyIncrementFilename:true or nil, silently increment filename, when file already exists; false, ask for overwriting\nRETURNS:\ncount:the number of files that have been rendered\nMediaItemStateChunkArray:the MediaItemStateChunks of all the rendered files\nFilearray:filenames with path of all rendered files\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemStateChunkArray},${4:array Filearray} = ultraschall.RenderProject_RenderTable(${5:optional string projectfilename_with_path},${6:optional RenderTable RenderTable},${7:optional boolean AddToProj},${8:optional boolean CloseAfterRender},${9:optional boolean SilentlyIncrementFilename})$0"
    },
    "ULTRASCHALL.GETRENDERQUEUEDPROJECTS_WR lua": {
        "prefix": "ultraschallwr.GetRenderQueuedProjects",
        "scope": "lua",
        "description": "Gets the number and names of files currently in the render-queue\nRETURNS:\nFilecount:the number of project-files in the render-queue\nFilearray:filenames with path of all queued-projectfiles\n",
        "body": "${1:local }${2:integer Filecount},${3:array Filearray} = ultraschall.GetRenderQueuedProjects()$0"
    },
    "ULTRASCHALL.RENDERPROJECT_RENDERQUEUE_WR lua": {
        "prefix": "ultraschallwr.RenderProject_RenderQueue",
        "scope": "lua",
        "description": "Renders a specific project from the render-queue.\nSee GetRenderQueuedProjects to get the names of the currently existing render-queue-projects, where the filename-order reflects the index needed for this function.\nreturns false in case of an error\nPARAMETERS:\nindex:the index of the render-queued-project; beginning with 1; -1 to render all projects in the render-queue\nRETURNS:\nretval:false, a problem occurred; true, rendering went through; returns true as well, when rendering is aborted!\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.RenderProject_RenderQueue(${3:integer index})$0"
    },
    "ULTRASCHALL.RENDERPROJECT_WR lua": {
        "prefix": "ultraschallwr.RenderProject",
        "scope": "lua",
        "description": "Renders a project, using a specific render-cfg-string.\nTo get render-cfg-strings, see functions starting with CreateRenderCFG_, like CreateRenderCFG_AIFF, CreateRenderCFG_DDP, CreateRenderCFG_FLAC, CreateRenderCFG_OGG, CreateRenderCFG_Opus, etc.\nWill use the render-settings currently set in projectfilename_with_path/the currently active project, except bound(set to Custom time range), render file and render-pattern, as they are set by this function!\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the project to render; nil, for the currently opened project\nrenderfilename_with_path:the filename with path of the output-file. If you give the wrong extension, Reaper will exchange it by the correct one.\nstartposition:the startposition of the render-area in seconds; \nendposition:the endposition of the render-area in seconds; \noverwrite_without_asking:true, overwrite an existing renderfile; false, don't overwrite an existing renderfile\nrenderclosewhendone:true, automatically close the render-window after rendering; false, keep rendering window open after rendering; nil, use current settings\nfilenameincrease:true, silently increase filename, if it already exists; false, ask before overwriting an already existing outputfile; nil, use current settings\nrendercfg:just like rendercfg, but for the secondary render-format\nrendercfg2:just like rendercfg, but for the secondary render-format\nRETURNS:\nretval:-1, in case of error; 0, in case of success\nrenderfilecount:the number of rendered files\nMediaItemStateChunkArray:the MediaItemStateChunks of all rendered files, with the one in entry 1 being the rendered master-track(when rendering stems+master)\nFilearray:the filenames of the rendered files, including their paths. The filename in entry 1 is the one of the mastered track(when rendering stems+master)\n",
        "body": "${1:local }${2:integer retval},${3:integer renderfilecount},${4:array MediaItemStateChunkArray},${5:array Filearray} = ultraschall.RenderProject(${6:string projectfilename_with_path},${7:string renderfilename_with_path},${8:number startposition},${9:number endposition},${10:boolean overwrite_without_asking},${11:boolean renderclosewhendone},${12:boolean filenameincrease},${13:optional string rendercfg},${14:optional string rendercfg2})$0"
    },
    "ULTRASCHALL.RENDERPROJECT_REGIONS_WR lua": {
        "prefix": "ultraschallwr.RenderProject_Regions",
        "scope": "lua",
        "description": "Renders a region of a project, using a specific render-cfg-string.\nTo get render-cfg-strings, see CreateRenderCFG_AIFF, CreateRenderCFG_DDP, CreateRenderCFG_FLAC, CreateRenderCFG_OGG, CreateRenderCFG_Opus\nReturns -1 in case of an error\nPARAMETERS:\nprojectfilename_with_path:the project to render; nil, for the currently opened project\nrenderfilename_with_path:the filename of the output-file. \nregion:when addregionname==true, this parameter allows you to set a separator between renderfilename_with_path and regionname. \naddregionname:when addregionname==true, this parameter allows you to set a separator between renderfilename_with_path and regionname. \noverwrite_without_asking:true, overwrite an existing renderfile; false, don't overwrite an existing renderfile\nrenderclosewhendone:true, automatically close the render-window after rendering; false, keep rendering window open after rendering; nil, use current settings\nfilenameincrease:true, silently increase filename, if it already exists; false, ask before overwriting an already existing outputfile; nil, use current settings\nrendercfg:the render-cfg-string for secondary render-format\naddregionnameseparator:when addregionname==true, this parameter allows you to set a separator between renderfilename_with_path and regionname. \nrendercfg2:the render-cfg-string for secondary render-format\nRETURNS:\nretval:-1, in case of error; 0, in case of success\nrenderfilecount:the number of rendered files\nMediaItemStateChunkArray:the MediaItemStateChunks of all rendered files, with the one in entry 1 being the rendered master-track(when rendering stems)\nFilearray:the filenames of the rendered files, including their paths. The filename in entry 1 is the one of the mastered track(when rendering stems)\n",
        "body": "${1:local }${2:integer retval},${3:integer renderfilecount},${4:array MediaItemStateChunkArray},${5:array Filearray} = ultraschall.RenderProject_Regions(${6:string projectfilename_with_path},${7:string renderfilename_with_path},${8:integer region},${9:boolean addregionname},${10:boolean overwrite_without_asking},${11:boolean renderclosewhendone},${12:boolean filenameincrease},${13:string rendercfg},${14:optional string addregionnameseparator},${15:optional string rendercfg2})$0"
    },
    "ULTRASCHALL.ADDSELECTEDITEMSTORENDERQUEUE_WR lua": {
        "prefix": "ultraschallwr.AddSelectedItemsToRenderQueue",
        "scope": "lua",
        "description": "Adds the selected MediaItems to the render-queue.\nreturns false in case of an error\nPARAMETERS:\nrender_items_individually:false or nil, render all selected MediaItems in one render-queued-project; true, render all selected MediaItems individually as separate Queued-projects\nrender_items_through_master:false or nil, just render the MediaItems; true, render the MediaItems through the Master-channel\nRenderTables:a RenderTable to apply for the renders in the render-queue\nRETURNS:\nretval:true, adding was successful; false, adding was unsuccessful\nnum_queued_projects:the number of newly created projects in the render-queue\n",
        "body": "${1:local }${2:boolean retval},${3:integer num_queued_projects} = ultraschall.AddSelectedItemsToRenderQueue(${4:optional boolean render_items_individually},${5:optional boolean render_items_through_master},${6:optional RenderTable RenderTables})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3MAXQUALITY_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_MP3MaxQuality",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with highest quality-settings. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nPARAMETERS:\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the renderstring for MP3 with maximum quality\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_MP3MaxQuality(${3:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3VBR_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_MP3VBR",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with variable bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nvbr_quality:the variable-bitrate quality; 1(for 10%) to 10(for 100%)\nquality:the encoding speed for the mp3\nno_joint_stereo:the \"Do not allow joint stereo\"-checkbox; true, checked; false, unchecked; default is unchecked\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP3-VBR-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_MP3VBR(${3:integer vbr_quality},${4:integer quality},${5:optional boolean no_joint_stereo},${6:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3ABR_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_MP3ABR",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with average bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nbitrate:the encoding quality for the mp3\nquality:the encoding speed for the mp3\nno_joint_stereo:the \"Do not allow joint stereo\"-checkbox; true, checked; false, unchecked; default is unchecked\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP3-ABR-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_MP3ABR(${3:integer bitrate},${4:integer quality},${5:optional boolean no_joint_stereo},${6:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_MP3CBR_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_MP3CBR",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the MP3-format with constant bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nbitrate:the encoding quality for the mp3\nquality:the encoding speed for the mp3\nno_joint_stereo:the \"Do not allow joint stereo\"-checkbox; true, checked; false, unchecked; default is unchecked\nwrite_replay_gain:the \"Write ReplayGain-tag\"-checkbox; true, checked; false, unchecked; default is unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected MP3-CBR-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_MP3CBR(${3:integer bitrate},${4:integer quality},${5:optional boolean no_joint_stereo},${6:optional boolean write_replay_gain})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_WAV_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_WAV",
        "scope": "lua",
        "description": "Creates the render-cfg-string for the WAV-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nBitDepth:the bitdepth of the WAV-file\nLargeFiles:how shall Reaper treat large WAV-files\nBWFChunk:Write BWF ('bext') chunk and Include project filename in BWF data - checkboxes\nIncludeMarkers:The include markerlist-dropdownlist\nEmbedProjectTempo:Embed project tempo (use with care)-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected WAV-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_WAV(${3:integer BitDepth},${4:integer LargeFiles},${5:integer BWFChunk},${6:integer IncludeMarkers},${7:boolean EmbedProjectTempo})$0"
    },
    "ULTRASCHALL.GETLASTUSEDRENDERPATTERNS_WR lua": {
        "prefix": "ultraschallwr.GetLastUsedRenderPatterns",
        "scope": "lua",
        "description": "returns the last 12 used render-patterns, that have been used for rendering by any project in Reaper.\nRETURNS:\nlast_render_patterns:a table, which holds the last 12 used render-patterns, used by any project in Reaper\n",
        "body": "${1:local }${2:array last_render_patterns} = ultraschall.GetLastUsedRenderPatterns()$0"
    },
    "ULTRASCHALL.GETLASTRENDERPATHS_WR lua": {
        "prefix": "ultraschallwr.GetLastRenderPaths",
        "scope": "lua",
        "description": "returns the last 20 used render-output-paths, that have been used for rendering by any project in Reaper.\nRETURNS:\nlast_render_paths:a table, which holds the last 20 used render-output-paths, used by any project in Reaper\n",
        "body": "${1:local }${2:array last_render_paths} = ultraschall.GetLastRenderPaths()$0"
    },
    "ULTRASCHALL.ISREAPERRENDERING_WR lua": {
        "prefix": "ultraschallwr.IsReaperRendering",
        "scope": "lua",
        "description": "Returns, if Reaper is currently rendering and the rendering position and projectlength of the rendered project\nRETURNS:\nretval:true, Reaper is rendering; false, Reaper does not render\nrender_position:the current rendering-position of the rendering project\nrender_projectlength:the length of the currently rendering project\nproj:the project currently rendering\nqueue_render:true, if a project from the queued-folder is currently being rendered; false, if not; a hint if queued-rendering is currently active\n",
        "body": "${1:local }${2:boolean retval},${3:optional number render_position},${4:optional number render_projectlength},${5:optional ReaProject proj},${6:optional boolean queue_render} = ultraschall.IsReaperRendering()$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_AIFF_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_AIFF",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the AIFF-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nReturns nil in case of an error\nPARAMETERS:\nbits:the bitdepth of the aiff-file; 8, 16, 24 and 32 are supported\nEmbedBeatLength:Embed beat length if exact-checkbox; true, checked; false or nil, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected AIFF-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_AIFF(${3:integer bits},${4:optional boolean EmbedBeatLength})$0"
    },
    "ULTRASCHALL.CREATERENDERCFG_AUDIOCD_WR lua": {
        "prefix": "ultraschallwr.CreateRenderCFG_AudioCD",
        "scope": "lua",
        "description": "Returns the render-cfg-string for the AudioCD-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini\nYou can also check, whether to burn the created cd-image after rendering.\nReturns nil in case of an error\nPARAMETERS:\ntrackmode:Track mode-dropdownlist: 1, Markers define new track; 2, Regions define tracks (other areas ignored); 3, One Track\nonly_markers_starting_with_hash:Only use markers starting with #-checkbox; true, checked; false, unchecked\nleadin_silence_tracks:Lead-in silence for tracks-inputbox, in milliseconds\nleadin_silence_disc:Extra lead-in silence for disc-inputbox, in milliseconds\nburncd_image_after_render:Burn CD image after render-checkbox; true, checked; false, unchecked\nRETURNS:\nrender_cfg_string:the render-cfg-string for the selected AudioCD-image-settings\n",
        "body": "${1:local }${2:string render_cfg_string} = ultraschall.CreateRenderCFG_AudioCD(${3:integer trackmode},${4:boolean only_markers_starting_with_hash},${5:integer leadin_silence_tracks},${6:integer leadin_silence_disc},${7:boolean burncd_image_after_render})$0"
    },
    "ULTRASCHALL.GETRENDER_EMBEDSTRETCHMARKERS_WR lua": {
        "prefix": "ultraschallwr.GetRender_EmbedStretchMarkers",
        "scope": "lua",
        "description": "Gets the current state of the \"Embed stretch markers/transient guides\"-checkbox from the Render to File-dialog.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.GetRender_EmbedStretchMarkers()$0"
    },
    "ULTRASCHALL.SETRENDER_EMBEDSTRETCHMARKERS_WR lua": {
        "prefix": "ultraschallwr.SetRender_EmbedStretchMarkers",
        "scope": "lua",
        "description": "Sets the new state of the \"Embed stretch markers/transient guides\"-checkbox from the Render to File-dialog.\nReturns false in case of an error\nPARAMETERS:\nstate:true, check the checkbox; false, uncheck the checkbox\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetRender_EmbedStretchMarkers(${3:boolean state})$0"
    },
    "ULTRASCHALL.RENDER_LOOP_WR lua": {
        "prefix": "ultraschallwr.Render_Loop",
        "scope": "lua",
        "description": "Renders a part of a project using 2 passes. Good for rendering loops, including wetloops.\nThe first pass will be set by FirstStart and FirstStart. This is the one for possible fx-buildups(reverbs, etc).\nThe second pass will be set by SecondStart and SecondEnd. This is the one, which \"crops\" the first-pass to its correct length.\nYou can also influence the second pass by setting fadein and fadeout, including the fadein/fadeout-shape.\nThat way, you can control, how the beginning and the end of the loop-item sounds.\nSecondStart and SecondEnd are in relation of the original source project. SecondStart is from the beginning of the source-project, NOT FirstStart!\nreturns -1 in case of an error\nPARAMETERS:\nRenderTable:the RenderTable, which holds the render-settings for the second pass\nRenderFilename:the filename with path of the final rendered file\nAutoIncrement:true, autoincrement the filename(if it already exists); false, ask before rendering(if file already exists)\nFirstStart:the beginning of the first-pass-render in seconds\nFirstEnd:the end of the first-pass-render in seconds\nSecondStart:the beginning of the second-pass-render in seconds\nSecondEnd:the end of the second-pass-render in seconds\nFadeIn:the shape of the fade-in-curve; fadein shape, 0..6, 0=linear\nFadeOut:the shape of the fade-out-curve; fadeout shape, 0..6, 0=linear\nFadeInShape:the shape of the fade-in-curve; fadein shape, 0..6, 0=linear\nFadeOutShape:the shape of the fade-out-curve; fadeout shape, 0..6, 0=linear\nRETURNS:\ncount:the number of rendered files\nMediaItemStateChunkArray:all MediaItemStateChunks within an array\nFilearray:all rendered filenames including path\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemStateChunkArray},${4:array Filearray} = ultraschall.Render_Loop(${5:table RenderTable},${6:string RenderFilename},${7:boolean AutoIncrement},${8:number FirstStart},${9:number FirstEnd},${10:number SecondStart},${11:number SecondEnd},${12:number FadeIn},${13:number FadeOut},${14:integer FadeInShape},${15:integer FadeOutShape})$0"
    },
    "ULTRASCHALL.GETALLTHEMELAYOUTNAMES_WR lua": {
        "prefix": "ultraschallwr.GetAllThemeLayoutNames",
        "scope": "lua",
        "description": "returns all layout-names and values of the current theme\nthe table ThemeLayoutNames is of the following format:\nThemeLayoutNames[parameter_index][\"layout section\"] - the name of the layout-section of the parameter\nThemeLayoutNames[parameter_index][\"value\"] - the value of the parameter\nThemeLayoutNames[parameter_index][\"description\"] - the description of the parameter\nreturns nil in case of an error\nRETURNS:\nindex:the number of theme-layout-parameters available\n",
        "body": "${1:local }${2:integer index},${3:table ThemeLayoutNames=} = ultraschall.GetAllThemeLayoutNames()$0"
    },
    "ULTRASCHALL.GETALLTHEMELAYOUTPARAMETERS_WR lua": {
        "prefix": "ultraschallwr.GetAllThemeLayoutParameters",
        "scope": "lua",
        "description": "returns all theme-layout-parameter attributes of the current theme\nthe table ThemeLayoutParameters is of the following format:\nThemeLayoutParameters[parameter_index][\"name\"] - the name of the parameter\nThemeLayoutParameters[parameter_index][\"description\"] - the description of the parameter\nThemeLayoutParameters[parameter_index][\"value\"] - the value of the parameter\nThemeLayoutParameters[parameter_index][\"value default\"] - the defult value of the parameter\nThemeLayoutParameters[parameter_index][\"value min\"] - the minimum value of the parameter\nThemeLayoutParameters[parameter_index][\"value max\"] - the maximum value of the parameter\nreturns nil in case of an error\nRETURNS:\nindex:the number of theme-layout-parameters available\nThemeLayoutParameters:a table with all theme-layout-parameter available in the current theme\n",
        "body": "${1:local }${2:integer index},${3:table ThemeLayoutParameters} = ultraschall.GetAllThemeLayoutParameters()$0"
    },
    "ULTRASCHALL.ISVALIDTRACKSTRING_WR lua": {
        "prefix": "ultraschallwr.IsValidTrackString",
        "scope": "lua",
        "description": "checks, whether a given trackstring is a valid one. Will also return all valid numbers, from trackstring, that can be used as tracknumbers, as an array.\nreturns false in case of an error\nPARAMETERS:\ntrackstring:the trackstring to check, if it's a valid one\nRETURNS:\nvalid:true, is a valid trackstring; false, is not a valid trackstring\ncount:the number of entries found in trackstring\nindividual_tracknumbers:an array that contains all available tracknumbers\n",
        "body": "${1:local }${2:boolean valid},${3:integer count},${4:array individual_tracknumbers} = ultraschall.IsValidTrackString(${5:string trackstring})$0"
    },
    "ULTRASCHALL.ISVALIDTRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.IsValidTrackStateChunk",
        "scope": "lua",
        "description": "returns, if a TrackStateChunk is a valid statechunk\nreturns false in case of an error\nPARAMETERS:\nTrackStateChunk:a string to check, if it's a valid TrackStateChunk\nRETURNS:\nvalid:true, if the string is a valid statechunk; false, if not a valid statechunk\n",
        "body": "${1:local }${2:boolean valid} = ultraschall.IsValidTrackStateChunk(${3:string TrackStateChunk})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_WR lua": {
        "prefix": "ultraschallwr.CreateTrackString",
        "scope": "lua",
        "description": "returns a string with the all numbers from firstnumber to lastnumber, separated by a ,\ne.g. firstnumber=4, lastnumber=8 -> 4,5,6,7,8\nreturns nil in case of an error\nPARAMETERS:\nfirstnumber:the number, with which the string starts\nlastnumber:the number, with which the string ends\nstep:how many numbers shall be skipped inbetween. Can lead to a different lastnumber, when step is not 1! nil or invalid value=1\nRETURNS:\ntrackstring:a string with all tracknumbers, separated by a ,\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackString(${3:integer firstnumber},${4:integer lastnumber},${5:optional integer step})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_SELECTEDTRACKS_WR lua": {
        "prefix": "ultraschallwr.CreateTrackString_SelectedTracks",
        "scope": "lua",
        "description": "Creates a string with all numbers from selected tracks, separated by a ,\nReturns an empty string, if no tracks are selected.\nRETURNS:\ntrackstring:a string with the tracknumbers, separated by a string\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackString_SelectedTracks()$0"
    },
    "ULTRASCHALL.INSERTTRACK_TRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.InsertTrack_TrackStateChunk",
        "scope": "lua",
        "description": "Creates a new track at the end of the project and sets it's trackstate, using the parameter trackstatechunk.\nReturns true, if it succeeded and the newly created MediaTrack.\nPARAMETERS:\ntrackstatechunk:the rpp-xml-Trackstate-Chunk, as created by reaper.GetTrackStateChunk or GetProject_TrackStateChunk\nRETURNS:\nretval:true, if creation succeeded, false if not\nMediaTrack:the newly created track, as MediaItem-trackobject\n",
        "body": "${1:local }${2:boolean retval},${3:MediaTrack MediaTrack} = ultraschall.InsertTrack_TrackStateChunk(${4:string trackstatechunk})$0"
    },
    "ULTRASCHALL.REMOVEDUPLICATETRACKSINTRACKSTRING_WR lua": {
        "prefix": "ultraschallwr.RemoveDuplicateTracksInTrackstring",
        "scope": "lua",
        "description": "Sorts tracknumbers in trackstring and throws out duplicates. It also throws out entries, that are no numbers.\nReturns the \"cleared\" trackstring as string and as array, as well as the number of entries.\nReturns -1 in case of failure.\nPARAMETERS:\ntrackstring:the tracknumbers, separated by a comma\nRETURNS:\nretval:-1 in case of error, 1 in case of success\ntrackstring:the \"cleared\" trackstring as an array\ntrackstringarray:the \"cleared\" trackstring as an array\nnumber_of_entries:the number of entries in the trackstring\n",
        "body": "${1:local }${2:integer retval},${3:string trackstring},${4:array trackstringarray},${5:integer number_of_entries} = ultraschall.RemoveDuplicateTracksInTrackstring(${6:string trackstring})$0"
    },
    "ULTRASCHALL.ISTRACKOBJECTTRACKNUMBER_WR lua": {
        "prefix": "ultraschallwr.IsTrackObjectTracknumber",
        "scope": "lua",
        "description": "returns true, if MediaTrack has the tracknumber \"tracknumber\"; false if not.\nReturns nil in case of error.\nPARAMETERS:\ntrack:the tracknumber you want to check for\ntracknumber:the tracknumber you want to check for\nRETURNS:\nretval:true if track is tracknumber, false if not\ntracknumber:the number of track, so in case of false, you know it's number\n",
        "body": "${1:local }${2:boolean retval},${3:integer tracknumber} = ultraschall.IsTrackObjectTracknumber(${4:MediaTrack track},${5:integer tracknumber})$0"
    },
    "ULTRASCHALL.INVERSETRACKSTRING_WR lua": {
        "prefix": "ultraschallwr.InverseTrackstring",
        "scope": "lua",
        "description": "returns a newtrackstring with numbers, that are NOT in trackstring, in the range between 0 and limit\nreturns -1 in case of error\nPARAMETERS:\ntrackstring:the tracknumbers, separated with a ,\nlimit:the maximum tracknumber to include. Use reaper.CountTracks(0) function to use the maximum tracks in current project\nRETURNS:\ninv_trackstring:the tracknumbers, that are NOT in the parameter trackstring, from 0 to limit\n",
        "body": "${1:local }${2:string inv_trackstring} = ultraschall.InverseTrackstring(${3:string trackstring},${4:integer limit})$0"
    },
    "ULTRASCHALL.COUNTITEMSINTRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.CountItemsInTrackStateChunk",
        "scope": "lua",
        "description": "returns the number of items in a trackstatechunk\nreturns -1 in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nRETURNS:\ncountitems:number of items in the trackstatechunk\n",
        "body": "${1:local }${2:integer countitems} = ultraschall.CountItemsInTrackStateChunk(${3:string trackstatechunk})$0"
    },
    "ULTRASCHALL.GETITEMSTATECHUNKFROMTRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetItemStateChunkFromTrackStateChunk",
        "scope": "lua",
        "description": "Returns a mediaitemstatechunk of the idx'th item in trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nidx:the number of the item you want to have returned as mediaitemstatechunk\nRETURNS:\nretval:true in case of success, false in case of error\nmediaitemstatechunk:number of items in the trackstatechunk\n",
        "body": "${1:local }${2:boolean retval},${3:string mediaitemstatechunk} = ultraschall.GetItemStateChunkFromTrackStateChunk(${4:string trackstatechunk},${5:integer idx})$0"
    },
    "ULTRASCHALL.ADDMEDIAITEMSTATECHUNK_TO_TRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.AddMediaItemStateChunk_To_TrackStateChunk",
        "scope": "lua",
        "description": "Adds the item mediaitemstatechunk into trackstatechunk and returns this altered trackstatechunk.\nreturns nil in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nmediaitemstatechunk:a mediaitemstatechunk, as returned by reaper's api function reaper.GetItemStateChunk\nRETURNS:\ntrackstatechunk:the new trackstatechunk with mediaitemstatechunk added\n",
        "body": "${1:local }${2:string trackstatechunk} = ultraschall.AddMediaItemStateChunk_To_TrackStateChunk(${3:string trackstatechunk},${4:string mediaitemstatechunk})$0"
    },
    "ULTRASCHALL.REMOVEMEDIAITEM_TRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.RemoveMediaItem_TrackStateChunk",
        "scope": "lua",
        "description": "Deletes the idx'th item from trackstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nidx:the number of the item you want to delete\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the idx'th item deleted\n",
        "body": "${1:local }${2:boolean retval},${3:string trackstatechunk} = ultraschall.RemoveMediaItem_TrackStateChunk(${4:string trackstatechunk},${5:integer idx})$0"
    },
    "ULTRASCHALL.REMOVEMEDIAITEMBYIGUID_TRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.RemoveMediaItemByIGUID_TrackStateChunk",
        "scope": "lua",
        "description": "Deletes the item with the iguid IGUID from trackstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nIGUID:the IGUID of the item you want to delete\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the IGUID-item deleted\n",
        "body": "${1:local }${2:boolean retval},${3:string trackstatechunk} = ultraschall.RemoveMediaItemByIGUID_TrackStateChunk(${4:string trackstatechunk},${5:string IGUID})$0"
    },
    "ULTRASCHALL.REMOVEMEDIAITEMBYGUID_TRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.RemoveMediaItemByGUID_TrackStateChunk",
        "scope": "lua",
        "description": "Deletes the item with the guid GUID from trackstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nGUID:the GUID of the item you want to delete\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the GUID-item deleted\n",
        "body": "${1:local }${2:boolean retval},${3:string trackstatechunk} = ultraschall.RemoveMediaItemByGUID_TrackStateChunk(${4:string trackstatechunk},${5:string GUID})$0"
    },
    "ULTRASCHALL.ONLYTRACKSINBOTHTRACKSTRINGS_WR lua": {
        "prefix": "ultraschallwr.OnlyTracksInBothTrackstrings",
        "scope": "lua",
        "description": "returns a new trackstring, that contains only the tracknumbers, that are in trackstring1 and trackstring2.\nreturns -1 in case of error\nPARAMETERS:\ntrackstring1:a string with the tracknumbers, separated by commas\ntrackstring2:a string with the tracknumbers, separated by commas\nRETURNS:\nretval:-1 in case of error, 1 in case of success\ntrackstring:the \"cleared\" trackstring as an array\ntrackstringarray:the \"cleared\" trackstring as an array\nnumber_of_entries:the number of entries in the trackstring\n",
        "body": "${1:local }${2:integer retval},${3:string trackstring},${4:array trackstringarray},${5:integer number_of_entries} = ultraschall.OnlyTracksInBothTrackstrings(${6:string trackstring1},${7:string trackstring2})$0"
    },
    "ULTRASCHALL.ONLYTRACKSINONETRACKSTRING_WR lua": {
        "prefix": "ultraschallwr.OnlyTracksInOneTrackstring",
        "scope": "lua",
        "description": "returns a new trackstring, that contains only the tracknumbers, that are in either trackstring1 or trackstring2, NOT in both!\nreturns -1 in case of error\nPARAMETERS:\ntrackstring1:a string with the tracknumbers, separated by commas\ntrackstring2:a string with the tracknumbers, separated by commas\nRETURNS:\nretval:-1 in case of error, 1 in case of success\ntrackstring:the \"cleared\" trackstring as an array\ntrackstringarray:the \"cleared\" trackstring as an array\nnumber_of_entries:the number of entries in the trackstring\n",
        "body": "${1:local }${2:integer retval},${3:string trackstring},${4:array trackstringarray},${5:integer number_of_entries} = ultraschall.OnlyTracksInOneTrackstring(${6:string trackstring1},${7:string trackstring2})$0"
    },
    "ULTRASCHALL.SETMEDIAITEMSTATECHUNK_IN_TRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.SetMediaItemStateChunk_in_TrackStateChunk",
        "scope": "lua",
        "description": "Overwrites the idx'th item from trackstatechunk with mediaitemstatechunk and returns this altered trackstatechunk.\nreturns false in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk\nidx:the number of the item you want to delete\nmediaitemstatechunk:a mediaitemstatechunk, as returned by reaper's api function reaper.GetItemStateChunk\nRETURNS:\nretval:true in case of success, false in case of error\ntrackstatechunk:the new trackstatechunk with the idx'th item replaced\n",
        "body": "${1:local }${2:boolean retval},${3:string trackstatechunk} = ultraschall.SetMediaItemStateChunk_in_TrackStateChunk(${4:string trackstatechunk},${5:integer idx},${6:string mediaitemstatechunk})$0"
    },
    "ULTRASCHALL.GETALLMEDIAITEMSFROMTRACKSTATECHUNK_WR lua": {
        "prefix": "ultraschallwr.GetAllMediaItemsFromTrackStateChunk",
        "scope": "lua",
        "description": "Returns a MediaItemStateChunkArray with all items in trackstatechunk.\nreturns -1 in case of error\nPARAMETERS:\ntrackstatechunk:a trackstatechunk, as returned by functions like reaper.GetTrackStateChunk\nRETURNS:\ncount:number of MediaItemStateChunks in the returned array. -1 in case of error\nMediaItemStateChunkArray:an array with all MediaItemStateChunks from trackstatechunk\n",
        "body": "${1:local }${2:integer count},${3:array MediaItemStateChunkArray} = ultraschall.GetAllMediaItemsFromTrackStateChunk(${4:string trackstatechunk})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_ALLTRACKS_WR lua": {
        "prefix": "ultraschallwr.CreateTrackString_AllTracks",
        "scope": "lua",
        "description": "Returns a trackstring with all tracknumbers from the current project.\nReturns an empty string, if no track is available.\nRETURNS:\ntrackstring:a string with all tracknumbers, separated by commas.\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackString_AllTracks()$0"
    },
    "ULTRASCHALL.GETTRACKLENGTH_WR lua": {
        "prefix": "ultraschallwr.GetTrackLength",
        "scope": "lua",
        "description": "Returns the length of a track, that means, the end of the last item in track Tracknumber.\nWill return -1, in case of error\nPARAMETERS:\nTracknumber:the tracknumber, whose length you want to know\nRETURNS:\nlength:the length of the track in seconds\n",
        "body": "${1:local }${2:integer length} = ultraschall.GetTrackLength(${3:integer Tracknumber})$0"
    },
    "ULTRASCHALL.GETLENGTHOFALLMEDIAITEMS_TRACK_WR lua": {
        "prefix": "ultraschallwr.GetLengthOfAllMediaItems_Track",
        "scope": "lua",
        "description": "Returns the length of all MediaItems in track, combined.\nWill return -1, in case of error\nPARAMETERS:\nTracknumber:the tracknumber, whose length you want to know; 1, track 1; 2, track 2, etc\nRETURNS:\nlength:the length of all MediaItems in the track combined, in seconds\n",
        "body": "${1:local }${2:integer length} = ultraschall.GetLengthOfAllMediaItems_Track(${3:integer Tracknumber})$0"
    },
    "ULTRASCHALL.APPLYACTIONTOTRACK_WR lua": {
        "prefix": "ultraschallwr.ApplyActionToTrack",
        "scope": "lua",
        "description": "Applies action to the tracks, given by trackstring\nThe action given must support applying itself to selected tracks.\nReturns false in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers, separated by a comma; 1 for the first track, 2 for the second\nRETURNS:\nretval:true, running action was successful; false, running the action was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyActionToTrack(${3:string trackstring},${4:string/number actioncommandid})$0"
    },
    "ULTRASCHALL.INSERTTRACKATINDEX_WR lua": {
        "prefix": "ultraschallwr.InsertTrackAtIndex",
        "scope": "lua",
        "description": "Inserts one or more tracks at index.\nReturns nil in case of an error\nPARAMETERS:\nindex:the index, at which to include the new tracks; 0, for including before the first track\nnumber_of_tracks:the number of tracks that you want to create; 0 for including before track 1; number of tracks+1, include new tracks after last track\nwantdefaults:true, set the tracks with default settings/fx/etc; false, create new track without any defaults\nRETURNS:\ntrackarray:an array with the MediaTrack-objects of all newly created tracks\nnew_track_count:the number of newly created tracks\ntrackarray_newtracks:an array with the MediaTrack-objects of all newly created tracks\n",
        "body": "${1:local }${2:string trackarray},${3:integer new_track_count},${4:array trackarray_newtracks} = ultraschall.InsertTrackAtIndex(${5:integer index},${6:integer number_of_tracks},${7:boolean wantdefaults})$0"
    },
    "ULTRASCHALL.MOVETRACKS_WR lua": {
        "prefix": "ultraschallwr.MoveTracks",
        "scope": "lua",
        "description": "Moves tracks in trackstring to position targetindex. You can also set, if the tracks shall become folders.\nMultiple tracks in trackstring will be put together, so track 2, 4, 6 would become 1, 2, 3, when moved above the first track!\nReturns false in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers of the tracks you want to move, separated by commas\ntargetindex:the index, to which to move the tracks; 0, move tracks before track 1; number of tracks+1, move after the last track\nmakepreviousfolder:make tracks a folder or not\nRETURNS:\nretval:true, moving was successful; false, moving wasn't successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.MoveTracks(${3:string trackstring},${4:integer targetindex},${5:integer makepreviousfolder})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_ARMEDTRACKS_WR lua": {
        "prefix": "ultraschallwr.CreateTrackString_ArmedTracks",
        "scope": "lua",
        "description": "Gets a trackstring with tracknumbers of all armed tracks in it.\nReturns \"\" if no track is armed.\nRETURNS:\ntrackstring:a trackstring with the tracknumbers of all armed tracks as comma separated csv-string, eg: \"1,3,4,7\"\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackString_ArmedTracks()$0"
    },
    "ULTRASCHALL.CREATETRACKSTRING_UNARMEDTRACKS_WR lua": {
        "prefix": "ultraschallwr.CreateTrackString_UnarmedTracks",
        "scope": "lua",
        "description": "Gets a trackstring with tracknumbers of all unarmed tracks in it.\nReturns \"\" if all tracks are armed.\nRETURNS:\ntrackstring:a trackstring with the tracknumbers of all unarmed tracks as comma separated csv-string, eg: \"1,3,4,7\"\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackString_UnarmedTracks()$0"
    },
    "ULTRASCHALL.CREATETRACKSTRINGBYGUID_WR lua": {
        "prefix": "ultraschallwr.CreateTrackStringByGUID",
        "scope": "lua",
        "description": "returns a trackstring with all tracks, as given by the GUIDs in the comma-separated-csv-string guid_csv_string.\nreturns \"\" in case of an error, like no track available or an invalid string\nPARAMETERS:\nguid_csv_string:a comma-separated csv-string, that includes all GUIDs of all track to be included in the trackstring.\nRETURNS:\ntrackstring:a string with all the tracknumbers of the tracks given as GUIDs in guid_csv_string\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackStringByGUID(${3:string guid_csv_string})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRINGBYTRACKNAMES_WR lua": {
        "prefix": "ultraschallwr.CreateTrackStringByTracknames",
        "scope": "lua",
        "description": "returns a trackstring with all tracks, as given by the tracknames in the newline(!)-separated-csv-string guid_csv_string.\nreturns \"\" in case of an error, like no track available or an invalid string\nPARAMETERS:\ntracknames_csv_string:a newline(!)-separated csv-string, that includes all tracknames of all track to be included in the trackstring. Tracknames are case sensitive!\nRETURNS:\ntrackstring:a string with all the tracknumbers of the tracks given as tracknames in tracknames_csv_string\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackStringByTracknames(${3:string tracknames_csv_string})$0"
    },
    "ULTRASCHALL.CREATETRACKSTRINGBYMEDIATRACKS_WR lua": {
        "prefix": "ultraschallwr.CreateTrackStringByMediaTracks",
        "scope": "lua",
        "description": "returns a trackstring with all tracks, as given in the array MediaTrackArray\nreturns \"\" in case of an error, like no track available or an invalid string\nPARAMETERS:\nMediaTrackArray:an array, that includes all MediaTrack-objects to be included in the trackstring; a nil-entry is seen as the end of the array\nRETURNS:\ntrackstring:a string with all the tracknumbers of the MediaTrack-objects given in parameter MediaTrackArray\n",
        "body": "${1:local }${2:string trackstring} = ultraschall.CreateTrackStringByMediaTracks(${3:array MediaTrackArray})$0"
    },
    "ULTRASCHALL.GETTRACKNUMBERBYGUID_WR lua": {
        "prefix": "ultraschallwr.GetTracknumberByGuid",
        "scope": "lua",
        "description": "returns the tracknumber and track of a guid. The track must be in the currently active project!\nSupports the returned guids by reaper.BR_GetMediaTrackGUID and reaper.GetTrackGUID.\nreturns -1 in case of an error\nRETURNS:\ntracknumber:the number of the track; 0, for master track; 1, for track 1; 2, for track 2, etc. -1, in case of an error\ntr:the MediaTrack-object of the requested track; nil, if no track is found\n",
        "body": "${1:local }${2:integer tracknumber},${3:MediaTrack tr} = ultraschall.GetTracknumberByGuid(${4:string guid})$0"
    },
    "ULTRASCHALL.DELETETRACKS_TRACKSTRING_WR lua": {
        "prefix": "ultraschallwr.DeleteTracks_TrackString",
        "scope": "lua",
        "description": "deletes all tracks in trackstring\nReturns false in case of an error\nPARAMETERS:\ntrackstring:a string with all tracknumbers, separated by commas\nRETURNS:\nretval:true, setting it was successful; false, setting it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteTracks_TrackString(${3:string trackstring})$0"
    },
    "ULTRASCHALL.ANYTRACKMUTE_WR lua": {
        "prefix": "ultraschallwr.AnyTrackMute",
        "scope": "lua",
        "description": "returns true, if any track is muted, otherwise returns false.\nPARAMETERS:\nmaster:true, include the master-track as well; false, don't include master-track\nRETURNS:\nretval:true, if any track is muted; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackMute(${3:optional boolean master})$0"
    },
    "ULTRASCHALL.ANYTRACKRECARMED_WR lua": {
        "prefix": "ultraschallwr.AnyTrackRecarmed",
        "scope": "lua",
        "description": "Returns true, if any track is recarmed.\nRETURNS:\nretval:true, at least one track is recarmed; false, no track is recarmed\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackRecarmed()$0"
    },
    "ULTRASCHALL.ANYTRACKPHASED_WR lua": {
        "prefix": "ultraschallwr.AnyTrackPhased",
        "scope": "lua",
        "description": "Returns true, if any track has phase-invert activated.\nRETURNS:\nretval:true, at least one track has an activated phase-invert; false, no track is phase-inverted\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackPhased()$0"
    },
    "ULTRASCHALL.ANYTRACKRECMONITORED_WR lua": {
        "prefix": "ultraschallwr.AnyTrackRecMonitored",
        "scope": "lua",
        "description": "Returns true, if any track has monitoring of recinput activated.\nRETURNS:\nretval:true, at least one track has an activated rec-monitoring; false, no track is rec-monitored\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackRecMonitored()$0"
    },
    "ULTRASCHALL.ANYTRACKHIDDENTCP_WR lua": {
        "prefix": "ultraschallwr.AnyTrackHiddenTCP",
        "scope": "lua",
        "description": "Returns true, if any track is hidden in Track Control Panel.\nPARAMETERS:\nmaster:true, include the master-track; false, don't include the master-track\nRETURNS:\nretval:true, at least one track is hidden in TCP; false, no track is hidden\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackHiddenTCP(${3:optional boolean master})$0"
    },
    "ULTRASCHALL.ANYTRACKHIDDENMCP_WR lua": {
        "prefix": "ultraschallwr.AnyTrackHiddenMCP",
        "scope": "lua",
        "description": "Returns true, if any track is hidden in Mixer Control Panel.\nPARAMETERS:\nmaster:true, include the master-track; false, don't include the master-track\nRETURNS:\nretval:true, at least one track is hidden in MCP; false, no track is hidden\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackHiddenMCP(${3:optional boolean master})$0"
    },
    "ULTRASCHALL.ANYTRACKFREEITEMPOSITIONINGMODE_WR lua": {
        "prefix": "ultraschallwr.AnyTrackFreeItemPositioningMode",
        "scope": "lua",
        "description": "Returns true, if any track has free item positioning mode(freemode) activated.\nRETURNS:\nretval:true, at least one track has freemode activated; false, no track has freemode-activated\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackFreeItemPositioningMode()$0"
    },
    "ULTRASCHALL.ANYTRACKFXBYPASS_WR lua": {
        "prefix": "ultraschallwr.AnyTrackFXBypass",
        "scope": "lua",
        "description": "Returns true, if any track has fx-bypass activated.\nPARAMETERS:\nmaster:true, include the master-track; false, don't include the master-track\nRETURNS:\nretval:true, at least one track has fx bypass activated; false, no track has fx-bypass activated\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AnyTrackFXBypass(${3:optional boolean master})$0"
    },
    "ULTRASCHALL.SETTRACK_LASTTOUCHED_WR lua": {
        "prefix": "ultraschallwr.SetTrack_LastTouched",
        "scope": "lua",
        "description": "Sets a track to be last touched track.\nreturns false in case of an error\nPARAMETERS:\ntrack:the track, which you want to set as last touched track\nRETURNS:\nretval:true, setting was successful; false, setting was not successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetTrack_LastTouched(${3:integer track})$0"
    },
    "ULTRASCHALL.GETTRACKBYTRACKNAME_WR lua": {
        "prefix": "ultraschallwr.GetTrackByTrackName",
        "scope": "lua",
        "description": "returns all tracks with a certain name.\nYou can set case-sensitivity, whether pattern-matchin is possible and whether the name shall be used strictly.\nFor instance, if you want to look for a track named exactly \"JaM.-Enlightened\" you set case_sensitive=false and escaped_strict=2. That way, tracks names \"JaM.*Enlightened\" will be ignored.\nreturns -1 in case of an error\nPARAMETERS:\ntrackname:the trackname to look for\ncase_sensitive:true, take care of case-sensitivity; false, don't take case-sensitivity into account\nescaped_strict:0, use trackname as matching-pattern, will find all tracknames following the pattern(Ja.-m -> Jam, Jam123Police, JaABBAm)\nRETURNS:\nnumber_of_found_tracks:the number of found tracks\nfound_tracks:the found tracks as table\nfound_tracknames:the found tracknames\n",
        "body": "${1:local }${2:integer number_of_found_tracks},${3:table found_tracks},${4:table found_tracknames} = ultraschall.GetTrackByTrackName(${5:string trackname},${6:boolean case_sensitive},${7:integer escaped_strict})$0"
    },
    "ULTRASCHALL.COLLAPSETRACKHEIGHT_WR lua": {
        "prefix": "ultraschallwr.CollapseTrackHeight",
        "scope": "lua",
        "description": "Collapses the height of a track to the minimum height as set by the theme\nreturns false in case of an error\nPARAMETERS:\ntrack:the track, which you want to collapse in height\nRETURNS:\nretval:true, collapsing was successful; false, collapsing was not successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.CollapseTrackHeight(${3:integer track})$0"
    },
    "ULTRASCHALL.SETTRACK_TRACKHEIGHT_FORCE_WR lua": {
        "prefix": "ultraschallwr.SetTrack_Trackheight_Force",
        "scope": "lua",
        "description": "Sets the trackheight of a track. Forces trackheight beyond limits set by the theme.\nreturns false in case of an error\nPARAMETERS:\ntrack:the trackheight in pixels, 0 and higher\nRETURNS:\nretval:true, collapsing was successful; false, collapsing was not successful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetTrack_Trackheight_Force(${3:integer track},${4:integer trackheight})$0"
    },
    "ULTRASCHALL.GETTRACKHWOUT_WR lua": {
        "prefix": "ultraschallwr.GetTrackHWOut",
        "scope": "lua",
        "description": "Returns the settings of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, which you can choose with idx.\nIt's the entry HWOUT\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOut you want, 0 for Master Track\nidx:the id-number of the HWOut, beginning with 1 for the first HWOut-Settings\nTrackStateChunk:a TrackStateChunk, whose HWOUT-entries you want to get\nRETURNS:\noutputchannel:outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels\npost_pre_fader:0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination \"Controls for Track\"-dialogue\nvolume:volume, as set in the Destination \"Controls for Track\"-dialogue; see MKVOL2DB to convert it into a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:mute, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nphase:Phase, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nsource:source, as set in the Destination \"Controls for Track\"-dialogue\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nautomationmode:automation mode, as set in the Destination \"Controls for Track\"-dialogue\n",
        "body": "${1:local }${2:integer outputchannel},${3:integer post_pre_fader},${4:number volume},${5:number pan},${6:integer mute},${7:integer phase},${8:integer source},${9:number pan_law},${10:integer automationmode} = ultraschall.GetTrackHWOut(${11:integer tracknumber},${12:integer idx},${13:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKAUXSENDRECEIVES_WR lua": {
        "prefix": "ultraschallwr.GetTrackAUXSendReceives",
        "scope": "lua",
        "description": "Returns the settings of the Send/Receive, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, which you can choose with idx.\nRemember, if you want to get the sends of a track, you need to check the recv_tracknumber-returnvalues of the OTHER(!) tracks, as you can only get the receives. With the receives checked, you know, which track sends.\nIt's the entry AUXRECV\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose Send/Receive you want\nidx:the id-number of the Send/Receive, beginning with 1 for the first Send/Receive-Settings\nTrackStateChunk:a TrackStateChunk, whose AUXRECV-entries you want to get\nRETURNS:\nrecv_tracknumber:Tracknumber, from where to receive the audio from\npost_pre_fader:0-PostFader, 1-PreFX, 3-Pre-Fader\nvolume:Volume; see MKVOL2DB to convert it into a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:Mute this send(1) or not(0)\nmono_stereo:Mono(1), Stereo(0)\nphase:Phase of this send on(1) or off(0)\nchan_src:Audio-Channel Source\nsnd_chan:send to channel\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmidichanflag:All Midi Tracks\nautomation:Automation Mode\n",
        "body": "${1:local }${2:integer recv_tracknumber},${3:integer post_pre_fader},${4:number volume},${5:number pan},${6:integer mute},${7:integer mono_stereo},${8:integer phase},${9:integer chan_src},${10:integer snd_chan},${11:number pan_law},${12:integer midichanflag},${13:integer automation} = ultraschall.GetTrackAUXSendReceives(${14:integer tracknumber},${15:integer idx},${16:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.COUNTTRACKHWOUTS_WR lua": {
        "prefix": "ultraschallwr.CountTrackHWOuts",
        "scope": "lua",
        "description": "Counts and returns the number of existing HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber.\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOUTs you want to count. 0 for Master Track; -1, to use optional parameter TrackStateChunk instead\nTrackStateChunk:the TrackStateChunk, whose hwouts you want to count; only when tracknumber=-1\nRETURNS:\ncount_HWOuts:the number of HWOuts in tracknumber\n",
        "body": "${1:local }${2:integer count_HWOuts} = ultraschall.CountTrackHWOuts(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.COUNTTRACKAUXSENDRECEIVES_WR lua": {
        "prefix": "ultraschallwr.CountTrackAUXSendReceives",
        "scope": "lua",
        "description": "Counts and returns the number of existing Send/Receives/Routing-settings, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber.\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose Send/Receive you want; -1, if you want to pass a TrackStateChunk instead\nTrackStateChunk:the TrackStateChunk, whose hwouts you want to count; only when tracknumber=-1\nRETURNS:\ncount_SendReceives:the number of Send/Receives-Settings in tracknumber\n",
        "body": "${1:local }${2:integer count_SendReceives} = ultraschall.CountTrackAUXSendReceives(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.ADDTRACKHWOUT_WR lua": {
        "prefix": "ultraschallwr.AddTrackHWOut",
        "scope": "lua",
        "description": "Adds a setting of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber.\nThis function does not check the parameters for plausability, so check your settings twice!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOut you want. 0 for Master Track; -1, use parameter TrackStateChunk instead\noutputchannel:outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels\npost_pre_fader:0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination \"Controls for Track\"-dialogue\nvolume:volume, as set in the Destination \"Controls for Track\"-dialogue; see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:mute, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nphase:Phase, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nsource:source, as set in the Destination \"Controls for Track\"-dialogue\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nautomationmode:automation mode, as set in the Destination \"Controls for Track\"-dialogue\nTrackStateChunk:a TrackStateChunk into which to add the hwout-setting; only available, when tracknumber=-1\nRETURNS:\nretval:true, if it worked; false if it didn't\nTrackStateChunk:an altered TrackStateChunk into which you added the new hwout-setting\n",
        "body": "${1:local }${2:boolean retval},${3:optional string TrackStateChunk} = ultraschall.AddTrackHWOut(${4:integer tracknumber},${5:integer outputchannel},${6:integer post_pre_fader},${7:number volume},${8:number pan},${9:integer mute},${10:integer phase},${11:integer source},${12:number pan_law},${13:integer automationmode},${14:optional parameter TrackStateChunk})$0"
    },
    "ULTRASCHALL.ADDTRACKAUXSENDRECEIVES_WR lua": {
        "prefix": "ultraschallwr.AddTrackAUXSendReceives",
        "scope": "lua",
        "description": "Adds a setting of Send/Receive, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one.\nRemember, if you want to set the sends of a track, you need to add it to the track, that shall receive, not the track that sends! Set recv_tracknumber in the track that receives with the tracknumber that sends, and you've set it successfully.\nDue to the complexity of send/receive-settings, this function does not check, whether the parameters are plausible. So check twice, whether the added sends/receives appear, as they might not appear!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:Tracknumber, from where to receive the audio from\nrecv_tracknumber:Tracknumber, from where to receive the audio from\npost_pre_fader:0-PostFader, 1-PreFX, 3-Pre-Fader\nvolume:Volume, see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:Mute this send(1) or not(0)\nmono_stereo:Mono(1), Stereo(0)\nphase:Phase of this send on(1) or off(0)\nchan_src:Audio-Channel Source\nsnd_chan:send to channel\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmidichanflag:All Midi Tracks\nautomation:Automation Mode\nTrackStateChunk:the TrackStateChunk, to which you want to add a new receive-routing\nRETURNS:\nretval:true if it worked, false if it didn't.\nTrackStateChunk:an altered TrackStateChunk into which you added a new receive/routing; only available, when tracknumber=-1\n",
        "body": "${1:local }${2:boolean retval},${3:optional string TrackStateChunk} = ultraschall.AddTrackAUXSendReceives(${4:integer tracknumber},${5:integer recv_tracknumber},${6:integer post_pre_fader},${7:number volume},${8:number pan},${9:integer mute},${10:integer mono_stereo},${11:integer phase},${12:integer chan_src},${13:integer snd_chan},${14:number pan_law},${15:integer midichanflag},${16:integer automation},${17:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.DELETETRACKHWOUT_WR lua": {
        "prefix": "ultraschallwr.DeleteTrackHWOut",
        "scope": "lua",
        "description": "Deletes the idxth HWOut-Setting of tracknumber.\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOUTs you want to delete. 0 for Master Track. -1, if you want to use the parameter TrackStateChunk instead\nidx:the number of the HWOut-setting, that you want to delete; -1, to delete all HWOuts from this track\nTrackStateChunk:the TrackStateChunk, from which you want to delete HWOut-entries\nRETURNS:\nretval:true if it worked, false if it didn't.\nTrackStateChunk:the altered TrackStateChunk, from which you deleted HWOut-entries; only available, when tracknumber=-1\n",
        "body": "${1:local }${2:boolean retval},${3:optional string TrackStateChunk} = ultraschall.DeleteTrackHWOut(${4:integer tracknumber},${5:integer idx},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.DELETETRACKAUXSENDRECEIVES_WR lua": {
        "prefix": "ultraschallwr.DeleteTrackAUXSendReceives",
        "scope": "lua",
        "description": "Deletes the idxth Send/Receive-Setting of tracknumber.\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose Send/Receive you want; -1, if you want to use the parameter TrackStateChunk\nidx:the number of the send/receive-setting, that you want to delete; -1, deletes all AuxReceives on this track\nTrackStateChunk:a TrackStateChunk, from which you want to delete Send/Receive-entries; only available, when tracknumber=-1\nRETURNS:\nretval:true if it worked, false if it didn't.\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteTrackAUXSendReceives(${3:integer tracknumber},${4:integer idx},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKHWOUT_WR lua": {
        "prefix": "ultraschallwr.SetTrackHWOut",
        "scope": "lua",
        "description": "Sets a setting of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, so choose the one you want to change with idx.\nTo retain old-settings, use nil with the accompanying parameters.\nThis function does not check the parameters for plausability, so check your settings twice, or the HWOut-setting might disappear with faulty parameters!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:the number of the track, whose HWOut you want. 0 for Master Track\nidx:the number of the HWOut-setting, you want to change\noutputchannel:outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels\npost_pre_fader:0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination \"Controls for Track\"-dialogue\nvolume:volume, as set in the Destination \"Controls for Track\"-dialogue; see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:mute, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nphase:Phase, 1-on, 0-off, as set in the Destination \"Controls for Track\"-dialogue\nsource:source, as set in the Destination \"Controls for Track\"-dialogue\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nautomationmode:automation mode, as set in the Destination \"Controls for Track\"-dialogue\nTrackStateChunk:sets an HWOUT-entry in a TrackStateChunk\nRETURNS:\nretval:true, if it worked; false if it didn't\nTrackStateChunk:an altered TrackStateChunk, in which you've set a send/receive-setting; only available when track=-1\n",
        "body": "${1:local }${2:boolean retval},${3:optional string TrackStateChunk} = ultraschall.SetTrackHWOut(${4:integer tracknumber},${5:integer idx},${6:integer outputchannel},${7:integer post_pre_fader},${8:number volume},${9:number pan},${10:integer mute},${11:integer phase},${12:integer source},${13:number pan_law},${14:integer automationmode},${15:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKAUXSENDRECEIVES_WR lua": {
        "prefix": "ultraschallwr.SetTrackAUXSendReceives",
        "scope": "lua",
        "description": "Alters a setting of Send/Receive, as set in the routing-matrix, as well as in the Destination \"Controls for Track\"-dialogue, of tracknumber. There can be more than one, so choose the right one with idx.\nYou can keep the old-setting by using nil as a parametervalue.\nRemember, if you want to set the sends of a track, you need to add it to the track, that shall receive, not the track that sends! Set recv_tracknumber in the track that receives with the tracknumber that sends, and you've set it successfully.\nDue to the complexity of send/receive-settings, this function does not check, whether the parameters are plausible. So check twice, whether the change sends/receives still appear, as they might disappear with faulty settings!\nreturns false in case of failure\nPARAMETERS:\ntracknumber:Tracknumber, from where to receive the audio from\nidx:the send/receive-setting, you want to set\nrecv_tracknumber:Tracknumber, from where to receive the audio from\npost_pre_fader:0-PostFader, 1-PreFX, 3-Pre-Fader\nvolume:Volume; see DB2MKVOL to convert from a dB-value\npan:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmute:Mute this send(1) or not(0)\nmono_stereo:Mono(1), Stereo(0)\nphase:Phase of this send on(1) or off(0)\nchan_src:Audio-Channel Source\nsnd_chan:send to channel\npan_law:pan-law, as set in the dialog that opens, when you right-click on the pan-slider in the routing-settings-dialog; default is -1 for +0.0dB\nmidichanflag:All Midi Tracks\nautomation:Automation Mode\nTrackStateChunk:a TrackStateChunk, whose AUXRECV-entries you want to set\nRETURNS:\nretval:true if it worked, false if it didn't.\nTrackStateChunk:an altered TrackStateChunk, whose AUXRECV-entries you've altered\n",
        "body": "${1:local }${2:boolean retval},${3:optional string TrackStateChunk} = ultraschall.SetTrackAUXSendReceives(${4:integer tracknumber},${5:integer idx},${6:integer recv_tracknumber},${7:integer post_pre_fader},${8:number volume},${9:number pan},${10:integer mute},${11:integer mono_stereo},${12:integer phase},${13:integer chan_src},${14:integer snd_chan},${15:number pan_law},${16:integer midichanflag},${17:integer automation},${18:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.CLEARROUTINGMATRIX_WR lua": {
        "prefix": "ultraschallwr.ClearRoutingMatrix",
        "scope": "lua",
        "description": "Clears all routing-matrix-settings or optionally part of them\nreturns false in case of an error\nPARAMETERS:\nClearHWOuts:nil or true, clear all HWOuts; false, keep the HWOuts intact\nClearAuxRecvs:nil or true, clear all Send/Receive-settings; false, keep the Send/Receive-settings intact\nClearTrackMasterSends:nil or true, clear all send to master-checkboxes; false, keep them intact\nClearMasterTrack:nil or true, include the Mastertrack as well; false, don't include it\nundo:true, set undo point; false or nil, don't set undo point\nRETURNS:\nretval:true, clearing was successful; false, clearing was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ClearRoutingMatrix(${3:boolean ClearHWOuts},${4:boolean ClearAuxRecvs},${5:boolean ClearTrackMasterSends},${6:boolean ClearMasterTrack},${7:boolean undo})$0"
    },
    "ULTRASCHALL.APPLYALLHWOUTS_WR lua": {
        "prefix": "ultraschallwr.ApplyAllHWOuts",
        "scope": "lua",
        "description": "Takes a table, as returned by GetAllHWOuts with all HWOut-settings of all tracks and applies it to all tracks.\nWhen you set option to 2, the individual entries will be applied to the tracks, that have the guids stored in table\ntable[tracknumber][\"TrackID\"], otherwise, this function will apply it to track0 to trackn, which is the same as table[\"number\\_of_tracks\"].\nThat way, you can create RoutingSnapshots, that will stay in the right tracks, even if they are ordered differently or when tracks have been added/deleted.\nThis influences the MasterTrack as well!\nexpected table is of structure:\ntable[\"HWOuts\"]=true                              - signals, this is a HWOuts-table; don't change that!\ntable[\"number\\_of_tracks\"]                         - the number of tracks in this table, from track 0(master) to track n\ntable[tracknumber][\"HWOut_count\"]                 - the number of HWOuts of tracknumber, beginning with 1\ntable[tracknumber][\"TrackID\"]                     - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\ntable[tracknumber][HWOutIndex][\"outputchannel\"]   - the number of outputchannels of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"post\\_pre_fader\"] - the setting of post-pre-fader of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"volume\"]          - the volume of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\"]             - the panning of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"mute\"]            - the mute-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"phase\"]           - the phase-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"source\"]          - the source/input of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\\_law\"]         - pan-law, default is -1\ntable[tracknumber][HWOutIndex][\"automationmode\"]  - the automation-mode of this HWOutIndex of tracknumber\nSee GetTrackHWOut for more details on the individual settings, stored in the entries.\nreturns false in case of an error\nPARAMETERS:\nAllHWOuts:a table with all AllHWOut-entries of the current project\noption:nil or 1, HWOuts will be applied to Track 0(MasterTrack) to table[\"number_of_tracks\"]; 2, HWOuts will be applied to the tracks with the guid TrackID\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyAllHWOuts(${3:table AllHWOuts},${4:optional integer option})$0"
    },
    "ULTRASCHALL.APPLYALLAUXSENDRECEIVES_WR lua": {
        "prefix": "ultraschallwr.ApplyAllAUXSendReceives",
        "scope": "lua",
        "description": "takes a table, as returned by GetAllAUXSendReceive with all AUXSendReceive-settings of all tracks and applies it to all tracks.\nWhen you set option to 2, the individual entries will be applied to the tracks, that have the guids stored in table\ntable[tracknumber][\"TrackID\"], otherwise, this function will apply it to track1 to trackn, which is the same as table[\"number\\_of_tracks\"].\nThat way, you can create RoutingSnapshots, that will stay in the right tracks, even if they are ordered differently or when tracks have been added/deleted.\nexpected table is of structure:\ntable[\"AllAUXSendReceive\"]=true                               - signals, this is an AllAUXSendReceive-table. Don't alter!\ntable[\"number\\_of_tracks\"]                                     - the number of tracks in this table, from track 1 to track n\ntable[tracknumber][\"AUXSendReceives_count\"]                   - the number of AUXSendReceives of tracknumber, beginning with 1\ntable[tracknumber][\"TrackID\"]                                 - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\ntable[tracknumber][AUXSendReceivesIndex][\"recv\\_tracknumber\"] - the track, from which to receive audio in this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"recv\\_track\\_guid\"] - the guid of the receive-track; with that, you can be sure to get the right receive-track, even if trackorder changes\ntable[tracknumber][AUXSendReceivesIndex][\"post\\_pre_fader\"]   - the setting of post-pre-fader of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"volume\"]            - the volume of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\"]               - the panning of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mute\"]              - the mute-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mono\\_stereo\"]      - the mono/stereo-button-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"phase\"]             - the phase-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"chan\\_src\"]         - the audiochannel-source of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"snd\\_src\"]          - the send-to-channel-target of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\\_law\"]           - pan-law, default is -1\ntable[tracknumber][AUXSendReceivesIndex][\"midichanflag\"]      - the Midi-channel of this AUXSendReceivesIndex of tracknumber, leave it 0\ntable[tracknumber][AUXSendReceivesIndex][\"automation\"]        - the automation-mode of this AUXSendReceivesIndex  of tracknumber\nSee GetTrackAUXSendReceives for more details on the individual settings, stored in the entries.\nreturns false in case of an error\nPARAMETERS:\nAllAUXSendReceives:a table with all AllAUXSendReceive-entries of the current project\noption:nil or 1, AUXRecvs will be applied to Track 1 to table[\"number_of_tracks\"]; 2, AUXRecvs will be applied to the tracks with the guid TrackID\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyAllAUXSendReceives(${3:table AllAUXSendReceives},${4:optional integer option})$0"
    },
    "ULTRASCHALL.GETALLMAINSENDSTATES_WR lua": {
        "prefix": "ultraschallwr.GetAllMainSendStates",
        "scope": "lua",
        "description": "returns a table with all MainSend-settings of all tracks, excluding master-track.\nThe MainSend-settings are the settings, if a certain track sends it's signal to the Master Track\nreturned table is of structure:\nTable[\"number\\_of_tracks\"]            - The number of tracks in this table, from track 1 to track n\nTable[\"MainSend\"]=true               - signals, this is an AllMainSends-table\ntable[tracknumber][\"TrackID\"]        - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\nTable[tracknumber][\"MainSendOn\"]     - Send to Master on(1) or off(1)\nTable[tracknumber][\"ParentChannels\"] - the parent channels of this track\nSee GetTrackMainSendState for more details on the individual settings, stored in the entries.\nRETURNS:\nAllMainSends:a table with all AllMainSends-entries of the current project.\ninteger number_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "${1:local }${2:table AllMainSends},${3:integer number_of_tracks} = ultraschall.GetAllMainSendStates()$0"
    },
    "ULTRASCHALL.APPLYALLMAINSENDSTATES_WR lua": {
        "prefix": "ultraschallwr.ApplyAllMainSendStates",
        "scope": "lua",
        "description": "takes a table, as returned by GetAllMainSendStates with all MainSend-settings of all tracks and applies it to all tracks.\nThe MainSend-settings are the settings, if a certain track sends it's signal to the Master Track.\nWhen you set option to 2, the individual entries will be applied to the tracks, that have the guids stored in table\ntable[tracknumber][\"TrackID\"], otherwise, this function will apply it to track0 to trackn, which is the same as table[\"number\\_of_tracks\"].\nThat way, you can create RoutingSnapshots, that will stay in the right tracks, even if they are ordered differently or when tracks have been added/deleted.\nThis influences the MasterTrack as well!\nexpected table is of structure:\nTable[\"number\\_of_tracks\"]            - The number of tracks in this table, from track 1 to track n\nTable[\"MainSend\"]=true               - signals, this is an AllMainSends-table\ntable[tracknumber][\"TrackID\"]        - the unique id of the track as guid; can be used to get the MediaTrack using reaper.BR_GetMediaTrackByGUID(0, guid)\nTable[tracknumber][\"MainSendOn\"]     - Send to Master on(1) or off(1)\nTable[tracknumber][\"ParentChannels\"] - the parent channels of this track\nSee GetTrackMainSendState for more details on the individual settings, stored in the entries.\nreturns false in case of an error\nPARAMETERS:\noption:nil or 1, MainSend-settings will be applied to Track 1 to table[\"number_of_tracks\"]; 2, MasterSends will be applied to the tracks with the guid stored in table[tracknumber][\"TrackID\"].\nRETURNS:\nretval:true, setting was successful; false, it was unsuccessful\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.ApplyAllMainSendStates(${3:table AllMainSendsTable},${4:optional integer option})$0"
    },
    "ULTRASCHALL.AREHWOUTSTABLESEQUAL_WR lua": {
        "prefix": "ultraschallwr.AreHWOutsTablesEqual",
        "scope": "lua",
        "description": "Compares two HWOuts-tables, as returned by GetAllHWOuts](#GetAllHWOuts) or [GetAllHWOuts2\nif option=2 then it will also compare, if the stored track-guids are the equal. Otherwise, it will only check the individual settings, even if the guids are different between the two tables.\nreturns false in case of an error\nPARAMETERS:\nAllHWOuts:a table with all HWOut-settings of all tracks, that you want to compare to AllHWOuts\nAllHWOuts2:a table with all HWOut-settings of all tracks, that you want to compare to AllHWOuts\noption:nil or 1, to compare everything, except the stored TrackGuids; 2, include comparing the stored TrackGuids as well\nRETURNS:\nboolean retval:true, if the two tables are equal HWOuts; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AreHWOutsTablesEqual(${3:table AllHWOuts},${4:table AllHWOuts2},${5:optional integer option})$0"
    },
    "ULTRASCHALL.AREMAINSENDSTABLESEQUAL_WR lua": {
        "prefix": "ultraschallwr.AreMainSendsTablesEqual",
        "scope": "lua",
        "description": "Compares two AllMainSends-tables, as returned by GetAllMainSendStates](#GetAllMainSendStates) or [GetAllMainSendStates2\nif option=2 then it will also compare, if the stored track-guids are the equal. Otherwise, it will only check the individual settings, even if the guids are different between the two tables.\nreturns false in case of an error\nPARAMETERS:\nAllMainSends:a table with all AllMainSends-settings of all tracks, that you want to compare to AllMainSends\nAllMainSends2:a table with all AllMainSends-settings of all tracks, that you want to compare to AllMainSends\noption:nil or 1, to compare everything, except the stored TrackGuids; 2, include comparing the stored TrackGuids as well\nRETURNS:\nboolean retval:true, if the two tables are equal AllMainSends; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AreMainSendsTablesEqual(${3:table AllMainSends},${4:table AllMainSends2},${5:optional integer option})$0"
    },
    "ULTRASCHALL.AREAUXSENDRECEIVESTABLESEQUAL_WR lua": {
        "prefix": "ultraschallwr.AreAUXSendReceivesTablesEqual",
        "scope": "lua",
        "description": "Compares two AllAUXSendReceives-tables, as returned by GetAllAUXSendReceives](#GetAllAUXSendReceives) or [GetAllAUXSendReceives2\nif option=2 then it will also compare, if the stored track-guids are the equal. Otherwise, it will only check the individual settings, even if the guids are different between the two tables.\nreturns false in case of an error\nPARAMETERS:\nAllAUXSendReceives:a table with all AllAUXSendReceives-settings of all tracks, that you want to compare to AllAUXSendReceives\nAllAUXSendReceives2:a table with all AllAUXSendReceives-settings of all tracks, that you want to compare to AllAUXSendReceives\noption:nil or 1, to compare everything, except the stored TrackGuids; 2, include comparing the stored TrackGuids as well\nRETURNS:\nboolean retval:true, if the two tables are equal AllMainSends; false, if not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.AreAUXSendReceivesTablesEqual(${3:table AllAUXSendReceives},${4:table AllAUXSendReceives2},${5:optional integer option})$0"
    },
    "ULTRASCHALL.GETTRACKSTATECHUNK_TRACKNUMBER_WR lua": {
        "prefix": "ultraschallwr.GetTrackStateChunk_Tracknumber",
        "scope": "lua",
        "description": "returns the trackstatechunk for track tracknumber\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber, 0 for master track, 1 for track 1, 2 for track 2, etc.    \nRETURNS:\nretval:true in case of success; false in case of error\ntrackstatechunk:the trackstatechunk for track tracknumber\n",
        "body": "${1:local }${2:boolean retval},${3:string trackstatechunk} = ultraschall.GetTrackStateChunk_Tracknumber(${4:integer tracknumber})$0"
    },
    "ULTRASCHALL.GETTRACKSTATE_NUMBERSONLY_WR lua": {
        "prefix": "ultraschallwr.GetTrackState_NumbersOnly",
        "scope": "lua",
        "description": "returns a state of a TrackStateChunk.\nIt only supports single-entry-states with numbers/integers, separated by spaces!\nAll other values will be set to nil and strings with spaces will produce weird results!\nreturns nil in case of an error\nPARAMETERS:\nstate:the state, whose attributes you want to retrieve\nTrackStateChunk:a statechunk of a track\nfunctionname:if this function is used within specific gettrackstate-functions, pass here the \"host\"-functionname, so error-messages will reflect that\nnumbertoggle:true or nil; converts all values to numbers; false, keep them as string versions\nRETURNS:\nvalues:all values found as numerical indexed array\n",
        "body": "${1:local }${2:table values} = ultraschall.GetTrackState_NumbersOnly(${3:string state},${4:optional string TrackStateChunk},${5:optional string functionname},${6:optional boolean numbertoggle})$0"
    },
    "ULTRASCHALL.GETTRACKNAME_WR lua": {
        "prefix": "ultraschallwr.GetTrackName",
        "scope": "lua",
        "description": "returns name of the track.\nIt's the entry NAME\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\ntrackname:the name of the track\n",
        "body": "${1:local }${2:string trackname} = ultraschall.GetTrackName(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKPEAKCOLORSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackPeakColorState",
        "scope": "lua",
        "description": "returns state of the PeakColor-number, which is the trackcolor. Will be returned as string, to avoid losing trailing or preceding zeros.\nIt's the entry PEAKCOL\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nPeakColorState:the color of the track\n",
        "body": "${1:local }${2:integer PeakColorState} = ultraschall.GetTrackPeakColorState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKBEATSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackBeatState",
        "scope": "lua",
        "description": "returns Track-BeatState.\nIt's the entry BEAT\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nBeatState:-1 - Project time base; 0 - Time; 1 - Beats position, length, rate; 2 - Beats position only\n",
        "body": "${1:local }${2:number BeatState} = ultraschall.GetTrackBeatState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMUTESOLOSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackMuteSoloState",
        "scope": "lua",
        "description": "returns states of Mute and Solo-Buttons.\nIt's the entry MUTESOLO\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMute:Mute set to 0 - Mute off, 1 - Mute On\nSolo:SoloDefeat set to 0 - off, 1 - on\nSoloDefeat:SoloDefeat set to 0 - off, 1 - on\n",
        "body": "${1:local }${2:integer Mute},${3:integer Solo},${4:integer SoloDefeat} = ultraschall.GetTrackMuteSoloState(${5:integer tracknumber},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKIPHASESTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackIPhaseState",
        "scope": "lua",
        "description": "returns state of the IPhase. If the Phase-button is pressed, it will return 1, else it will return 0.\nIt's the entry IPHASE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nIPhase:state of the phase-button; 0, normal phase; 1, inverted phase(180\u00b0)\n",
        "body": "${1:local }${2:number IPhase} = ultraschall.GetTrackIPhaseState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKBUSCOMPSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackBusCompState",
        "scope": "lua",
        "description": "returns BusCompState, if the tracks in a folder are compacted or not.\nIt's the entry BUSCOMP\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nBusCompState1:0 - no compacting, 1 - compacted tracks, 2 - minimized tracks\nBusCompState2:0 - unknown,1 - unknown\nBusCompState3:0 - unknown,1 - unknown\nBusCompState4:0 - unknown,1 - unknown\nBusCompState5:0 - unknown,1 - unknown\n",
        "body": "${1:local }${2:number BusCompState1},${3:number BusCompState2},${4:number BusCompState3},${5:number BusCompState4},${6:number BusCompState5} = ultraschall.GetTrackBusCompState(${7:integer tracknumber},${8:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKSHOWINMIXSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackShowInMixState",
        "scope": "lua",
        "description": "returns Show in Mix-state.\nIt's the entry SHOWINMIX\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMCPvisible:0 invisible, 1 visible\nMCP_FX_visible:0 visible, 1 FX-Parameters visible, 2 invisible\nMCPTrackSendsVisible:0 & 1.1 and higher TrackSends in MCP visible, every other number makes them invisible\nTCPvisible:0 track is invisible in TCP, 1 track is visible in TCP\nShowInMix5:unknown\nShowInMix6:unknown\nShowInMix7:unknown\nShowInMix8:unknown\n",
        "body": "${1:local }${2:integer MCPvisible},${3:number MCP_FX_visible},${4:number MCPTrackSendsVisible},${5:integer TCPvisible},${6:number ShowInMix5},${7:number ShowInMix6},${8:number ShowInMix7},${9:number ShowInMix8} = ultraschall.GetTrackShowInMixState(${10:integer tracknumber},${11:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKFREEMODESTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackFreeModeState",
        "scope": "lua",
        "description": "returns if the track has track free item positioning enabled(1) or not(0).\nIt's the entry FREEMODE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nFreeModeState:1 - enabled, 0 - not enabled\n",
        "body": "${1:local }${2:integer FreeModeState} = ultraschall.GetTrackFreeModeState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKRECSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackRecState",
        "scope": "lua",
        "description": "returns Track Rec State.\nIt's the entry REC\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nArmState:returns 1(armed) or 0(unarmed)\nInputChannel:returns the InputChannel\nMonitorInput:0 monitor off, 1 monitor on, 2 monitor on tape audio style\nRecInput:returns rec-input type\nMonitorWhileRec:Monitor Trackmedia when recording, 0 is off, 1 is on\npresPDCdelay:preserve PDC delayed monitoring in media items\nRecordingPath:recording path used \n",
        "body": "${1:local }${2:integer ArmState},${3:integer InputChannel},${4:integer MonitorInput},${5:integer RecInput},${6:integer MonitorWhileRec},${7:integer presPDCdelay},${8:integer RecordingPath} = ultraschall.GetTrackRecState(${9:integer tracknumber},${10:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKHEIGHTSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackHeightState",
        "scope": "lua",
        "description": "returns height of the track.\nIt's the entry TRACKHEIGHT\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nheight:0, don't lock the trackheight; 1, lock the trackheight\nheightstate2:0 - use height, 1 - compact the track and ignore the height\n",
        "body": "${1:local }${2:integer height},${3:integer heightstate2},${4:integer unknown} = ultraschall.GetTrackHeightState(${5:integer tracknumber},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKINQSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackINQState",
        "scope": "lua",
        "description": "Gets INQ-state, mostly the quantize-settings for MIDI, as set in the \"Track: View track recording settings (MIDI quantize, file format/path) for last touched track\"-dialog (action 40604)\nIt's the entry INQ\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nquantMIDI: quantize MIDI; 0 or 1\nquantPOS: quantize to position; -1,prev; 0, nearest; 1, next\nquantNoteOffs: quantize note-offs; 0 or 1\nquantToFractBeat: quantize to (fraction of beat)\nquantStrength: quantize strength; -128 to 127\nswingStrength: swing strength; -128 to 127\nquantRangeMin: quantize range minimum; -128 to 127\ninteger quantRangeMax: quantize range maximum; -128 to 127\n",
        "body": "${1:local }${2:integer quantMIDI},${3:integer quantPOS},${4:integer quantNoteOffs},${5:number quantToFractBeat},${6:integer quantStrength},${7:integer swingStrength},${8:integer quantRangeMin},${9:integer quantRangeMax} = ultraschall.GetTrackINQState(${10:integer tracknumber},${11:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKNCHANSSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackNChansState",
        "scope": "lua",
        "description": "returns the number of channels for this track, as set in the routing.\nIt's the entry NCHAN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nchannelnumber:number of channels for this track\n",
        "body": "${1:local }${2:integer channelnumber} = ultraschall.GetTrackNChansState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKBYPFXSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackBypFXState",
        "scope": "lua",
        "description": "returns the off/bypass(0) or nobypass(1) state of the FX-Chain\nIt's the entry FX\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nFXState:off/bypass(0) or nobypass(1)\n",
        "body": "${1:local }${2:integer FXState} = ultraschall.GetTrackBypFXState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKPERFSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackPerfState",
        "scope": "lua",
        "description": "returns TrackPerformance-state\nIt's the entry PERF\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nTrackPerfState:TrackPerformance-state\n",
        "body": "${1:local }${2:integer TrackPerfState} = ultraschall.GetTrackPerfState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDIOUTSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackMIDIOutState",
        "scope": "lua",
        "description": "returns MIDI_Out-State, as set in the Routing-Settings\nIt's the entry MIDIOUT\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiOutState:MIDI_Out-State, as set in the Routing-Settings\n",
        "body": "${1:local }${2:integer MidiOutState} = ultraschall.GetTrackMIDIOutState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMAINSENDSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackMainSendState",
        "scope": "lua",
        "description": "returns, if Main-Send is on(1) or off(0) and the ParentChannels(0-63), as set in the Routing-Settings.\nIt's the entry MAINSEND\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMainSendOn:Main-Send is on(1) or off(0)\nParentChannels:ParentChannels(0-63)\n",
        "body": "${1:local }${2:integer MainSendOn},${3:integer ParentChannels} = ultraschall.GetTrackMainSendState(${4:integer tracknumber},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKGROUPFLAGSSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackGroupFlagsState",
        "scope": "lua",
        "description": "returns the state of the group-flags, as set in the menu Track Grouping Parameters. Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 1 to 32. To get Groups 33 to 64, use GetTrackGroupFlags_HighState instead!\nIt's the entry GROUP_FLAGS\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "${1:local }${2:integer GroupState_as_Flags},${3:array IndividualGroupState_Flags} = ultraschall.GetTrackGroupFlagsState(${4:integer tracknumber},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKGROUPFLAGS_HIGHSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackGroupFlags_HighState",
        "scope": "lua",
        "description": "returns the state of the group-flags, as set in the menu Track Grouping Parameters. Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to get Volume Master(table entry 1) to check if it's set in Group 33(2^0=1) and 35(2^2=4):\ngroup1=groups_bitfield_table[1]&1\ngroup2=groups_bitfield_table[1]&4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThe GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.\nThis function will work only for Groups 33(2^0) to 64(2^31). To get Groups 1 to 32, use GetTrackGroupFlagsState instead!\nIt's the entry GROUP_FLAGS_HIGH\nreturns -1 in case of failure\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nGroupState_as_Flags:returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.\nIndividualGroupState_Flags:returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.\n",
        "body": "${1:local }${2:integer GroupState_as_Flags},${3:array IndividualGroupState_Flags} = ultraschall.GetTrackGroupFlags_HighState(${4:integer tracknumber},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKLOCKSTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackLockState",
        "scope": "lua",
        "description": "returns, if the track-controls of this track are locked(1) or not(nil).\nIt's the entry LOCK\nOnly the LOCK within TrackStateChunks, but not MediaItemStateChunks\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nlockedstate:locked(1) or not(nil)\n",
        "body": "${1:local }${2:integer lockedstate} = ultraschall.GetTrackLockState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKLAYOUTNAMES_WR lua": {
        "prefix": "ultraschallwr.GetTrackLayoutNames",
        "scope": "lua",
        "description": "returns the current selected layouts for TrackControlPanel and MixerControlPanel for this track as strings. Returns nil, if default is set.\nIt's the entry LAYOUTS\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nTCP_Layoutname:name of the TCP-Layoutname\nMCP_Layoutname:name of the MCP-Layoutname\n",
        "body": "${1:local }${2:string TCP_Layoutname},${3:string MCP_Layoutname} = ultraschall.GetTrackLayoutNames(${4:integer tracknumber},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKAUTOMODESTATE_WR lua": {
        "prefix": "ultraschallwr.GetTrackAutomodeState",
        "scope": "lua",
        "description": "returns, if the automation-mode for envelopes of this track\nIt's the entry AUTOMODE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nautomodestate:is set to 0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch.\n",
        "body": "${1:local }${2:integer automodestate} = ultraschall.GetTrackAutomodeState(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKICON_FILENAME_WR lua": {
        "prefix": "ultraschallwr.GetTrackIcon_Filename",
        "scope": "lua",
        "description": "returns the filename with path for the track-icon of the current track. Returns nil, if no trackicon has been set.\nIt's the entry TRACKIMGFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nfilename_with_path:filename with path for the current track-icon.\n",
        "body": "${1:local }${2:string filename_with_path} = ultraschall.GetTrackIcon_Filename(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKRECCFG_WR lua": {
        "prefix": "ultraschallwr.GetTrackRecCFG",
        "scope": "lua",
        "description": "returns the Rec-configuration-string, with which recordings are made. Returns nil, if no reccfg exists.\nIt's the entry\nstring reccfg - the string, that encodes the recording configuration of the track.\ninteger reccfgnr - the number of the recording-configuration of the track;\n- 0, use default project rec-setting\n- 1, use track-customized rec-setting, as set in the \"Track: View track recording settings (MIDI quantize, file format/path) for last touched track\"-dialog (action 40604)\ninteger tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\noptional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track\nTrack Management\nGet Track States\nUS_Api_Functions\nModules/ultraschall_functions_TrackManagement_TrackStates_Module.lua\ntrackmanagement, state, get, reccfg, trackstatechunk\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nreccfg:the number of the recording-configuration of the track; \n",
        "body": "${1:local }${2:string reccfg} = ultraschall.GetTrackRecCFG(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDIINPUTCHANMAP_WR lua": {
        "prefix": "ultraschallwr.GetTrackMidiInputChanMap",
        "scope": "lua",
        "description": "returns the state of the MIDIInputChanMap for the current track, as set in the Input-MIDI->Map Input to Channel menu. 0 for channel 1, 2 for channel 2, etc. Nil, if not existing.\nIt's the entry MIDI_INPUT_CHANMAP\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiInputChanMap_state:0 for channel 1, 1 for channel 2, ... 15 for channel 16; nil, source channel.\n",
        "body": "${1:local }${2:integer MidiInputChanMap_state} = ultraschall.GetTrackMidiInputChanMap(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDICTL_WR lua": {
        "prefix": "ultraschallwr.GetTrackMidiCTL",
        "scope": "lua",
        "description": "returns linked to Midi channel and an unknown value. Nil if not existing.\nIt's the entry MIDICTL\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nLinkedToMidiChannel:linked to midichannel\nunknown:unknown\n",
        "body": "${1:local }${2:integer LinkedToMidiChannel},${3:integer unknown} = ultraschall.GetTrackMidiCTL(${4:integer tracknumber},${5:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKWIDTH_WR lua": {
        "prefix": "ultraschallwr.GetTrackWidth",
        "scope": "lua",
        "description": "returns width of the track. 1 if set to +100%.\nNote for TrackStateChunk-enthusiasts: When set to +100%, it is not stored in the TrackStateChunk\nIt's the entry WIDTH\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nwidth:width of the track, from -1(-100%) to 1(+100%)\n",
        "body": "${1:local }${2:number width} = ultraschall.GetTrackWidth(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKPANMODE_WR lua": {
        "prefix": "ultraschallwr.GetTrackPanMode",
        "scope": "lua",
        "description": "returns Panmode of the track.\nIt's the entry PANMODE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nPanMode:the Panmode of the track\n",
        "body": "${1:local }${2:integer PanMode} = ultraschall.GetTrackPanMode(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDICOLORMAPFN_WR lua": {
        "prefix": "ultraschallwr.GetTrackMidiColorMapFn",
        "scope": "lua",
        "description": "returns MidiColorMap-Filename of the track. Nil if not existing.\nIt's the entry MIDICOLORMAPFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiColorMapFn:the MidiColorMap-Filename; nil if not existing\n",
        "body": "${1:local }${2:string MidiColorMapFn} = ultraschall.GetTrackMidiColorMapFn(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDIBANKPROGFN_WR lua": {
        "prefix": "ultraschallwr.GetTrackMidiBankProgFn",
        "scope": "lua",
        "description": "returns MidiBankProg-Filename of the track. Nil if not existing.\nIt's the entry MIDIBANKPROGFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiBankProgFn:the MidiBankProg-Filename; nil if not existing\n",
        "body": "${1:local }${2:string MidiBankProgFn} = ultraschall.GetTrackMidiBankProgFn(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKMIDITEXTSTRFN_WR lua": {
        "prefix": "ultraschallwr.GetTrackMidiTextStrFn",
        "scope": "lua",
        "description": "returns MidiTextStrFn-Filename of the track. Nil if not existing.\nIt's the entry MIDIEXTSTRFN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nMidiTextStrFn:the MidiTextStrFn-Filename; nil if not existing\n",
        "body": "${1:local }${2:string MidiTextStrFn} = ultraschall.GetTrackMidiTextStrFn(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKID_WR lua": {
        "prefix": "ultraschallwr.GetTrackID",
        "scope": "lua",
        "description": "returns TrackID of the track.\nIt's the entry TRACKID\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nTrackID:the TrackID as GUID\n",
        "body": "${1:local }${2:string TrackID} = ultraschall.GetTrackID(${3:integer tracknumber},${4:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKSCORE_WR lua": {
        "prefix": "ultraschallwr.GetTrackScore",
        "scope": "lua",
        "description": "returns Score of the track.\nIt's the entry SCORE\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nScore1:unknown \nScore2:unknown\nScore3:unknown\nnumber Score4:unknown\n",
        "body": "${1:local }${2:integer Score1},${3:integer Score2},${4:number Score3},${5:number Score4} = ultraschall.GetTrackScore(${6:integer tracknumber},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETTRACKVOLPAN_WR lua": {
        "prefix": "ultraschallwr.GetTrackVolPan",
        "scope": "lua",
        "description": "returns Vol and Pan-states of the track.\nIt's the entry VOLPAN\nreturns nil in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.\nTrackStateChunk:a TrackStateChunk that you want to use, instead of a given track\nRETURNS:\nVol:Volume Settings\nPan:Override Default Pan Track Law\nOverridePanLaw:Override Default Pan Track Law\nunknown:unknown\nunknown2:unknown\n",
        "body": "${1:local }${2:number Vol},${3:number Pan},${4:number OverridePanLaw},${5:number unknown},${6:number unknown2} = ultraschall.GetTrackVolPan(${7:integer tracknumber},${8:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKNAME_WR lua": {
        "prefix": "ultraschallwr.SetTrackName",
        "scope": "lua",
        "description": "Set the name of a track or a trackstatechunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nname:new name of the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackName(${4:integer tracknumber},${5:string name},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKPEAKCOLORSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackPeakColorState",
        "scope": "lua",
        "description": "Set the color of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\ncolorvalue:the color for the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackPeakColorState(${4:integer tracknumber},${5:integer colorvalue},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKBEATSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackBeatState",
        "scope": "lua",
        "description": "Set the timebase for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nbeatstate:tracktimebase for this track; -1 - Project time base, 0 - Time, 1 - Beats position, length, rate, 2 - Beats position only\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackBeatState(${4:integer tracknumber},${5:integer beatstate},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKAUTORECARMSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackAutoRecArmState",
        "scope": "lua",
        "description": "Set the AutoRecArmState for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nautorecarmstate:autorecarmstate - 1 - autorecarm on, <> than 1 - off\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackAutoRecArmState(${4:integer tracknumber},${5:integer autorecarmstate},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMUTESOLOSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackMuteSoloState",
        "scope": "lua",
        "description": "Set the Track Mute/Solo/Solodefeat for a track or a TrackStateChunk.\nHas no real effect on master track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMute:Mute set to 0 - Mute off, 1 - Mute On\nSolo:SoloDefeat set to 0 - off, 1 - on\nSoloDefeat:SoloDefeat set to 0 - off, 1 - on\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackMuteSoloState(${4:integer tracknumber},${5:integer Mute},${6:integer Solo},${7:integer SoloDefeat},${8:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKIPHASESTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackIPhaseState",
        "scope": "lua",
        "description": "Sets IPhase, the Phase-Buttonstate of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\niphasestate:0-off, <> than 0-on\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackIPhaseState(${4:integer tracknumber},${5:integer iphasestate},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKISBUSSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackIsBusState",
        "scope": "lua",
        "description": "Sets ISBUS-state of the track or a TrackStateChunk; if it's a folder track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nbusstate1:track is last track in folder(no tracks of subfolders follow)\nbusstate2:track is last track in folder(no tracks of subfolders follow)\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackIsBusState(${4:integer tracknumber},${5:integer busstate1},${6:integer busstate2},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKBUSCOMPSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackBusCompState",
        "scope": "lua",
        "description": "Sets BUSCOMP-state of the track or a TrackStateChunk; This is the state, if tracks in a folder are compacted or not.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackBusCompState(${4:integer tracknumber},${5:integer buscompstate1},${6:integer buscompstate2},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKSHOWINMIXSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackShowInMixState",
        "scope": "lua",
        "description": "Sets SHOWINMIX, that sets visibility of track or TrackStateChunk in MCP and TCP.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMCPvisible:0 invisible, 1 visible\nMCP_FX_visible:0 visible, 1 FX-Parameters visible, 2 invisible\nTCPvisible:0 track is invisible in TCP, 1 track is visible in TCP\nShowInMix5:unknown\nShowInMix6:unknown\nShowInMix7:unknown\nShowInMix8:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackShowInMixState(${4:integer tracknumber},${5:integer MCPvisible},${6:number MCP_FX_visible},${7:number MCP_TrackSendsVisible},${8:integer TCPvisible},${9:number ShowInMix5},${10:integer ShowInMix6},${11:integer ShowInMix7},${12:integer ShowInMix8},${13:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKFREEMODESTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackFreeModeState",
        "scope": "lua",
        "description": "Sets FREEMODE-state of a track or a TrackStateChunk; enables Track-Free Item Positioning.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nfreemodestate:0 - off, 1 - on\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackFreeModeState(${4:integer tracknumber},${5:integer freemodestate},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKRECSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackRecState",
        "scope": "lua",
        "description": "Sets REC, that sets the Recording-state of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nArmState:set to 1(armed) or 0(unarmed)\nInputChannel:the InputChannel\nRecInput:the rec-input type\nMonitorWhileRec:Monitor Trackmedia when recording, 0 is off, 1 is on\npresPDCdelay:preserve PDC delayed monitoring in media items\nRecordingPath:0 Primary Recording-Path only, 1 Secondary Recording-Path only, 2 Primary Recording Path and Secondary Recording Path(for invisible backup)\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackRecState(${4:integer tracknumber},${5:integer ArmState},${6:integer InputChannel},${7:integer MonitorInput},${8:integer RecInput},${9:integer MonitorWhileRec},${10:integer presPDCdelay},${11:integer RecordingPath},${12:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKVUSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackVUState",
        "scope": "lua",
        "description": "Sets VU-state of a track or a TrackStateChunk; the way metering shows.\nHas no real effect on master track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nVUState: 0 MultiChannelMetering is off, 2 MultichannelMetering is on, 3 Metering is off;seems to have no effect on MasterTrack\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackVUState(${4:integer tracknumber},${5:integer VUState},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKHEIGHTSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackHeightState",
        "scope": "lua",
        "description": "Sets TRACKHEIGHT-state; the height and compacted state of the track or a TrackStateChunk.\nHas no visible effect on the master-track.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nheight:0, trackheight is not locked; 1, trackheight is locked\nlockedtrackheight:0, trackheight is not locked; 1, trackheight is locked\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackHeightState(${4:integer tracknumber},${5:integer height},${6:integer heightstate2},${7:integer lockedtrackheight},${8:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKINQSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackINQState",
        "scope": "lua",
        "description": "Sets INQ-state, mostly the quantize-settings for MIDI, of a track or a TrackStateChunk, as set in the \"Track: View track recording settings (MIDI quantize, file format/path) for last touched track\"-dialog (action 40604)\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nquantMIDI: quantize MIDI; 0 or 1\nquantPOS: quantize to position; -1,prev; 0, nearest; 1, next\nquantNoteOffs: quantize note-offs; 0 or 1\nquantToFractBeat: quantize to (fraction of beat)\nquantStrength: quantize strength; -128 to 127\nswingStrength: swing strength; -128 to 127\nquantRangeMin: quantize range minimum; -128 to 127\nquantRangeMax: quantize range maximum; -128 to 127\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackINQState(${4:integer tracknumber},${5:integer quantMIDI},${6:integer quantPOS},${7:integer quantNoteOffs},${8:number quantToFractBeat},${9:integer quantStrength},${10:integer swingStrength},${11:integer quantRangeMin},${12:integer quantRangeMax},${13:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKNCHANSSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackNChansState",
        "scope": "lua",
        "description": "Sets NCHAN-state; the number of channels in this track or a TrackStateChunk, as set in the routing.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nNChans:2 to 64, counted every second channel (2,4,6,8,etc) with stereo-tracks. Unknown, if Multichannel and Mono-tracks count differently.\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackNChansState(${4:integer tracknumber},${5:integer NChans},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKBYPFXSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackBypFXState",
        "scope": "lua",
        "description": "Sets FX, FX-Bypass-state of the track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nFXBypassState:0 bypass, 1 activate fx; has only effect, if FX or instruments are added to this track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackBypFXState(${4:integer tracknumber},${5:integer FXBypassState},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKPERFSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackPerfState",
        "scope": "lua",
        "description": "Sets PERF, the TrackPerformance-State of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nPerf:performance-state\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackPerfState(${4:integer tracknumber},${5:integer Perf},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDIOUTSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackMIDIOutState",
        "scope": "lua",
        "description": "Sets MIDIOUT, the state of MIDI out for this track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackMIDIOutState(${4:integer tracknumber},${5:integer MIDIOutState},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMAINSENDSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackMainSendState",
        "scope": "lua",
        "description": "Sets MAINSEND, as set in the routing-settings, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMainSendOn:on(1) or off(0)\nParentChannels:the ParentChannels(0-64), interpreted as beginning with ParentChannels to ParentChannels+NCHAN\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk, if tracknumber=-1\n",
        "body": "${1:local }${2:boolean retval},${3:optional string TrackStateChunk} = ultraschall.SetTrackMainSendState(${4:integer tracknumber},${5:integer MainSendOn},${6:integer ParentChannels},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKLOCKSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackLockState",
        "scope": "lua",
        "description": "Sets LOCK-State, as set by the menu entry Lock Track Controls, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nLockedState:1 - locked, 0 - unlocked\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackLockState(${4:integer tracknumber},${5:integer LockedState},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKLAYOUTNAMES_WR lua": {
        "prefix": "ultraschallwr.SetTrackLayoutNames",
        "scope": "lua",
        "description": "Sets LAYOUTS, the MCP and TCP-layout by name of the layout as defined in the theme, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nTCP_Layoutname:name of the TrackControlPanel-Layout from the theme to use\nMCP_Layoutname:name of the MixerControlPanel-Layout from the theme to use\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackLayoutNames(${4:integer tracknumber},${5:string TCP_Layoutname},${6:string MCP_Layoutname},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKAUTOMODESTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackAutomodeState",
        "scope": "lua",
        "description": "Sets AUTOMODE-State, as set by the menu entry Set Track Automation Mode, for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nautomodestate:0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackAutomodeState(${4:integer tracknumber},${5:integer automodestate},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKICON_FILENAME_WR lua": {
        "prefix": "ultraschallwr.SetTrackIcon_Filename",
        "scope": "lua",
        "description": "Sets TRACKIMGFN, the trackicon-filename with path, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk\nIconfilename_with_path:filename+path of the imagefile to use as the trackicon; \"\", to remove track-icon\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackIcon_Filename(${4:integer tracknumber},${5:string Iconfilename_with_path},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDIINPUTCHANMAP_WR lua": {
        "prefix": "ultraschallwr.SetTrackMidiInputChanMap",
        "scope": "lua",
        "description": "Sets MIDI_INPUT_CHANMAP, as set in the Input-MIDI->Map Input to Channel menu, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nInputChanMap:0 for channel 1, 2 for channel 2, etc. -1 if not existing; nil, to remove MidiInputChanMap\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackMidiInputChanMap(${4:integer tracknumber},${5:integer InputChanMap},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDICTL_WR lua": {
        "prefix": "ultraschallwr.SetTrackMidiCTL",
        "scope": "lua",
        "description": "sets MIDICTL-state, the linkage to Midi-Channels of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nLinkedToMidiChannel:unknown; nil, to remove this setting completely\nunknown:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackMidiCTL(${4:integer tracknumber},${5:integer LinkedToMidiChannel},${6:integer unknown},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKID_WR lua": {
        "prefix": "ultraschallwr.SetTrackID",
        "scope": "lua",
        "description": "sets the track-id, which must be a valid GUID, of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nguid:a valid GUID. Can be generated with the native Reaper-function reaper.genGuid()\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackID(${4:integer tracknumber},${5:string guid},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDICOLORMAPFN_WR lua": {
        "prefix": "ultraschallwr.SetTrackMidiColorMapFn",
        "scope": "lua",
        "description": "sets the filename+path to the MIDI-ColorMap-graphicsfile of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMIDI_ColorMapFN:filename+path to the MIDI-ColorMap-file; \"\", to remove it\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackMidiColorMapFn(${4:integer tracknumber},${5:string MIDI_ColorMapFN},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDIBANKPROGFN_WR lua": {
        "prefix": "ultraschallwr.SetTrackMidiBankProgFn",
        "scope": "lua",
        "description": "sets the filename+path to the MIDI-Bank-Prog-file of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMIDIBankProgFn:filename+path to the MIDI-Bank-Prog-file; \"\", to remove it\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackMidiBankProgFn(${4:integer tracknumber},${5:string MIDIBankProgFn},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKMIDITEXTSTRFN_WR lua": {
        "prefix": "ultraschallwr.SetTrackMidiTextStrFn",
        "scope": "lua",
        "description": "sets the filename+path to the MIDI-Text-Str-file of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nMIDITextStrFn:filename+path to the MIDI-Text-Str-file; \"\", to remove it\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackMidiTextStrFn(${4:integer tracknumber},${5:string MIDITextStrFn},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKPANMODE_WR lua": {
        "prefix": "ultraschallwr.SetTrackPanMode",
        "scope": "lua",
        "description": "sets the panmode for a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\npanmode:the Panmode of the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackPanMode(${4:integer tracknumber},${5:integer panmode},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKWIDTH_WR lua": {
        "prefix": "ultraschallwr.SetTrackWidth",
        "scope": "lua",
        "description": "sets the width of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nwidth:width of the track, from -1(-100%) to 1(+100%)\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackWidth(${4:integer tracknumber},${5:number width},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKSCORE_WR lua": {
        "prefix": "ultraschallwr.SetTrackScore",
        "scope": "lua",
        "description": "sets the SCORE of a track or a TrackStateChunk.\nset unknown1 to unknown4 to 0 to remove the entry from the TrackStateChunk\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nunknown1:unknown\nunknown2:unknown\nunknown3:unknown\nunknown4:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackScore(${4:integer tracknumber},${5:integer unknown1},${6:integer unknown2},${7:number unknown3},${8:number unknown4},${9:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKVOLPAN_WR lua": {
        "prefix": "ultraschallwr.SetTrackVolPan",
        "scope": "lua",
        "description": "sets the VOLPAN-state of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1, if you want to use parameter TrackStateChunk\nVol:Volume Settings; -Inf dB(0) to +12dB (3.98107170553497)\nPan:Override Default Pan Track Law; 0dB(1) to -144dB(0.00000006309573)\nOverridePanLaw:Override Default Pan Track Law; 0dB(1) to -144dB(0.00000006309573)\nunknown:unknown\nunknown2:unknown\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackVolPan(${4:integer tracknumber},${5:number Vol},${6:number Pan},${7:number OverridePanLaw},${8:number unknown},${9:number unknown2},${10:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKRECCFG_WR lua": {
        "prefix": "ultraschallwr.SetTrackRecCFG",
        "scope": "lua",
        "description": "sets the RECCFG of a track or a TrackStateChunk.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\nreccfg_string: the string, that encodes the recording configuration of the track\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackRecCFG(${4:integer tracknumber},${5:string reccfg_string},${6:integer reccfg_nr},${7:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.GETALLLOCKEDTRACKS_WR lua": {
        "prefix": "ultraschallwr.GetAllLockedTracks",
        "scope": "lua",
        "description": "returns a trackstring with all tracknumbers of tracks, that are locked, as well as one with all tracknumbers of tracks, that are unlocked.\nreturns an empty locked_trackstring, if none is locked, returns an empty unlocked_trackstring if all are locked.\nRETURNS:\nlocked_trackstring:the tracknumbers of all tracks, that are NOT locked; empty string if all are locked\nunlocked_trackstring:the tracknumbers of all tracks, that are NOT locked; empty string if all are locked\n",
        "body": "${1:local }${2:string locked_trackstring},${3:string unlocked_trackstring} = ultraschall.GetAllLockedTracks()$0"
    },
    "ULTRASCHALL.GETALLSELECTEDTRACKS_WR lua": {
        "prefix": "ultraschallwr.GetAllSelectedTracks",
        "scope": "lua",
        "description": "returns a trackstring with all tracknumbers of tracks, that are selected, as well as one with all tracknumbers of tracks, that are unselected.\nreturns an empty selected_trackstring, if none is selected, returns an empty unselected_trackstring if all are selected.\nRETURNS:\nselected_trackstring:the tracknumbers of all tracks, that are NOT selected; empty string if all are selected\nunselected_trackstring:the tracknumbers of all tracks, that are NOT selected; empty string if all are selected\n",
        "body": "${1:local }${2:string selected_trackstring},${3:string unselected_trackstring} = ultraschall.GetAllSelectedTracks()$0"
    },
    "ULTRASCHALL.SETALLTRACKSSELECTED_WR lua": {
        "prefix": "ultraschallwr.SetAllTracksSelected",
        "scope": "lua",
        "description": "Sets all tracks selected(if selected is true) of unselected(if selected is false)\nreturns -1 in case of error\nPARAMETERS:\nselected:true, if all tracks shall be selected, false if all shall be deselected\nRETURNS:\nretval:returns -1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetAllTracksSelected(${3:boolean selected})$0"
    },
    "ULTRASCHALL.SETTRACKSSELECTED_WR lua": {
        "prefix": "ultraschallwr.SetTracksSelected",
        "scope": "lua",
        "description": "Sets tracks in trackstring selected. If reset is set to true, then the previous selection will be discarded.\nreturns -1 in case of error\nPARAMETERS:\ntrackstring:a string with the tracknumbers, separated by a comma; nil or \"\", deselects all\nreset:true, any previous selection will be discarded; false, it will be kept\nRETURNS:\nretval:returns -1 in case of error\n",
        "body": "${1:local }${2:integer retval} = ultraschall.SetTracksSelected(${3:string trackstring},${4:boolean reset})$0"
    },
    "ULTRASCHALL.SETTRACKSTOLOCKED_WR lua": {
        "prefix": "ultraschallwr.SetTracksToLocked",
        "scope": "lua",
        "description": "sets tracks in trackstring locked.\nreturns false in case or error, true in case of success\nPARAMETERS:\ntrackstring:the tracknumbers, separated with a ,\nreset:reset lockedstate of other tracks\nRETURNS:\nretval:true in case of success, false in case of error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetTracksToLocked(${3:string trackstring},${4:boolean reset})$0"
    },
    "ULTRASCHALL.SETTRACKSTOUNLOCKED_WR lua": {
        "prefix": "ultraschallwr.SetTracksToUnlocked",
        "scope": "lua",
        "description": "sets tracks in trackstring unlocked.\nreturns false in case or error, true in case of success\nPARAMETERS:\ntrackstring:the tracknumbers, separated with a ,\nRETURNS:\nretval:true in case of success, false in case of error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetTracksToUnlocked(${3:string trackstring})$0"
    },
    "ULTRASCHALL.SETTRACKSTATECHUNK_TRACKNUMBER_WR lua": {
        "prefix": "ultraschallwr.SetTrackStateChunk_Tracknumber",
        "scope": "lua",
        "description": "Sets the trackstatechunk for track tracknumber. Undo flag is a performance/caching hint.\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber, 0 for master track, 1 for track 1, 2 for track 2, etc.\ntrackstatechunk:the trackstatechunk, you want to set this track with\nundo:Undo flag is a performance/caching hint.\nRETURNS:\nretval:true in case of success; false in case of error\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.SetTrackStateChunk_Tracknumber(${3:integer tracknumber},${4:string trackstatechunk},${5:boolean undo})$0"
    },
    "ULTRASCHALL.SETTRACKGROUPFLAGSSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackGroupFlagsState",
        "scope": "lua",
        "description": "Set the GroupFlags-state of a track or trackstatechunk.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table can contain up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to set Volume Master(table entry 1) to checked in Group 1(2^0=1) and 3(2^2=4):\ngroups_bitfield_table[1]=groups_bitfield_table[1]+1+4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThis function will work only for Groups 1 to 32. To set Groups 33 to 64, use SetTrackGroupFlags_HighState instead!\nReturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\ngroups_bitfield_table:an array with all bitfields with all groupflag-settings\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackGroupFlagsState(${4:integer tracknumber},${5:array groups_bitfield_table},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.SETTRACKGROUPFLAGS_HIGHSTATE_WR lua": {
        "prefix": "ultraschallwr.SetTrackGroupFlags_HighState",
        "scope": "lua",
        "description": "Set the GroupFlags-state of a track or trackstatechunk.\nYou can reach the Group-Flag-Settings in the context-menu of a track.\nThe groups_bitfield_table can contain up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog\nEach entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.\nSo if you want to set Volume Master(table entry 1) to checked in Group 33(2^0=1) and 35(2^2=4):\ngroups_bitfield_table[1]=groups_bitfield_table[1]+1+4\nThe following flags(and their accompanying array-entry-index) are available:\n1 - Volume Master\n2 - Volume Slave\n3 - Pan Master\n4 - Pan Slave\n5 - Mute Master\n6 - Mute Slave\n7 - Solo Master\n8 - Solo Slave\n9 - Record Arm Master\n10 - Record Arm Slave\n11 - Polarity/Phase Master\n12 - Polarity/Phase Slave\n13 - Automation Mode Master\n14 - Automation Mode Slave\n15 - Reverse Volume\n16 - Reverse Pan\n17 - Do not master when slaving\n18 - Reverse Width\n19 - Width Master\n20 - Width Slave\n21 - VCA Master\n22 - VCA Slave\n23 - VCA pre-FX slave\nThis function will work only for Groups 33(2^0) to 64(2^31). To set Groups 1 to 32, use SetTrackGroupFlagsState instead!\nReturns false in case of an error\nPARAMETERS:\ntracknumber:number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk\ngroups_bitfield_table:an array with all bitfields with all groupflag-settings\nTrackStateChunk:use a trackstatechunk instead of a track; only used when tracknumber is -1\nRETURNS:\nretval:true, if successful, false if unsuccessful\nTrackStateChunk:the altered TrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string TrackStateChunk} = ultraschall.SetTrackGroupFlags_HighState(${4:integer tracknumber},${5:array groups_bitfield_table},${6:optional string TrackStateChunk})$0"
    },
    "ULTRASCHALL.ISTRACKSOUNDBOARD_WR lua": {
        "prefix": "ultraschallwr.IsTrackSoundboard",
        "scope": "lua",
        "description": "Returns, if this track is a soundboard-track, means, contains an Ultraschall-Soundboard-plugin.\nOnly relevant in Ultraschall-installations\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\nretval:true, it is an Ultraschall-Soundboard-track; false, it is not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsTrackSoundboard(${3:integer tracknumber})$0"
    },
    "ULTRASCHALL.ISTRACKSTUDIOLINK_WR lua": {
        "prefix": "ultraschallwr.IsTrackStudioLink",
        "scope": "lua",
        "description": "Returns, if this track is a StudioLink-track, means, contains a StudioLink-Plugin\nOnly relevant in Ultraschall-installations\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\nretval:true, it is a StudioLink-track; false, it is not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsTrackStudioLink(${3:integer tracknumber})$0"
    },
    "ULTRASCHALL.ISTRACKSTUDIOLINKONAIR_WR lua": {
        "prefix": "ultraschallwr.IsTrackStudioLinkOnAir",
        "scope": "lua",
        "description": "Returns, if this track is a StudioLinkOnAir-track, means, contains a StudioLinkOnAir-Plugin\nOnly relevant in Ultraschall-installations\nreturns false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\nretval:true, it is a StudioLinkOnAir-track; false, it is not\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.IsTrackStudioLinkOnAir(${3:integer tracknumber})$0"
    },
    "ULTRASCHALL.GETTYPEOFTRACK_WR lua": {
        "prefix": "ultraschallwr.GetTypeOfTrack",
        "scope": "lua",
        "description": "Returns the tracktype of a specific track. Will return the type of the first valid SoundBoard, StudioLink, StudioLinkOnAir-plugin in the track-fx-chain.\nIf there are multiple valid plugins and therefore types, the second retval multiple will be set to true, else to false.\nOnly relevant in Ultraschall-installations\nreturns \"\", false in case of an error\nPARAMETERS:\ntracknumber:the tracknumber to check for; 0, for master-track; 1, for track 1; n for track n\nRETURNS:\ntype:Either \"StudioLink\", \"StudioLinkOnAir\", \"SoundBoard\" or \"Other\". \"\", in case of an error\nmultiple:true, the track has other valid plugins as well; false, it is a \"pure typed\" track\n",
        "body": "${1:local }${2:string type},${3:boolean multiple} = ultraschall.GetTypeOfTrack(${4:integer tracknumber})$0"
    },
    "ULTRASCHALL.GETALLAUXSENDRECEIVES2_WR lua": {
        "prefix": "ultraschallwr.GetAllAUXSendReceives2",
        "scope": "lua",
        "description": "returns a table with all AUX-SendReceive-settings of all tracks, excluding master-track\nlike GetAllAUXSendReceives, but returns the type of a track as well\nreturned table is of structure:\ntable[\"AllAUXSendReceive\"]=true                               - signals, this is an AllAUXSendReceive-table. Don't alter!\ntable[\"number\\_of_tracks\"]                                     - the number of tracks in this table, from track 1 to track n\ntable[tracknumber][\"type\"]                                    - type of the track, SoundBoard, StudioLink, StudioLinkOnAir or Other\ntable[tracknumber][\"AUXSendReceives_count\"]                   - the number of AUXSendReceives of tracknumber, beginning with 1\ntable[tracknumber][AUXSendReceivesIndex][\"recv\\_tracknumber\"] - the track, from which to receive audio in this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"post\\_pre_fader\"]   - the setting of post-pre-fader of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"volume\"]            - the volume of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\"]               - the panning of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mute\"]              - the mute-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"mono\\_stereo\"]      - the mono/stereo-button-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"phase\"]             - the phase-setting of this AUXSendReceivesIndex  of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"chan\\_src\"]         - the audiochannel-source of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"snd\\_src\"]          - the send-to-channel-target of this AUXSendReceivesIndex of tracknumber\ntable[tracknumber][AUXSendReceivesIndex][\"pan\\_law\"]           - pan-law, default is -1\ntable[tracknumber][AUXSendReceivesIndex][\"midichanflag\"]      - the Midi-channel of this AUXSendReceivesIndex of tracknumber, leave it 0\ntable[tracknumber][AUXSendReceivesIndex][\"automation\"]        - the automation-mode of this AUXSendReceivesIndex  of tracknumber\nSee GetTrackAUXSendReceives for more details on the individual settings, stored in the entries.\nRETURNS:\nAllAUXSendReceives:a table with all SendReceive-entries of the current project.\nnumber_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "${1:local }${2:table AllAUXSendReceives},${3:integer number_of_tracks} = ultraschall.GetAllAUXSendReceives2()$0"
    },
    "ULTRASCHALL.GETALLHWOUTS2_WR lua": {
        "prefix": "ultraschallwr.GetAllHWOuts2",
        "scope": "lua",
        "description": "returns a table with all HWOut-settings of all tracks, including master-track(track index: 0)\nlike GetAllHWOuts but includes the type of a track as well\nreturned table is of structure:\ntable[\"HWOuts\"]=true                              - signals, this is a HWOuts-table; don't change that!\ntable[\"number\\_of_tracks\"]                         - the number of tracks in this table, from track 0(master) to track n\ntable[tracknumber][\"type\"]                        - type of the track, SoundBoard, StudioLink, StudioLinkOnAir or Other\ntable[tracknumber][\"HWOut_count\"]                 - the number of HWOuts of tracknumber, beginning with 1\ntable[tracknumber][HWOutIndex][\"outputchannel\"]   - the number of outputchannels of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"post\\_pre_fader\"] - the setting of post-pre-fader of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"volume\"]          - the volume of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\"]             - the panning of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"mute\"]            - the mute-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"phase\"]           - the phase-setting of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"source\"]          - the source/input of this HWOutIndex of tracknumber\ntable[tracknumber][HWOutIndex][\"pan\\law\"]         - pan-law, default is -1\ntable[tracknumber][HWOutIndex][\"automationmode\"]  - the automation-mode of this HWOutIndex of tracknumber\nSee GetTrackHWOut for more details on the individual settings, stored in the entries.\nRETURNS:\nAllHWOuts:a table with all HWOuts of the current project.\nnumber_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "${1:local }${2:table AllHWOuts},${3:integer number_of_tracks} = ultraschall.GetAllHWOuts2()$0"
    },
    "ULTRASCHALL.GETALLMAINSENDSTATES2_WR lua": {
        "prefix": "ultraschallwr.GetAllMainSendStates2",
        "scope": "lua",
        "description": "returns a table with all MainSend-settings of all tracks, excluding master-track.\nlike GetAllMainSendStates, but includes the type of the track as well.\nThe MainSend-settings are the settings, if a certain track sends it's signal to the Master Track\nreturned table is of structure:\nTable[\"number\\_of_tracks\"]            - The number of tracks in this table, from track 1 to track n\nTable[tracknumber][\"type\"]           - type of the track, SoundBoard, StudioLink, StudioLinkOnAir or Other\nTable[tracknumber][\"MainSend\"]       - Send to Master on(1) or off(1)\nTable[tracknumber][\"ParentChannels\"] - the parent channels of this track\nSee GetTrackMainSendState for more details on the individual settings, stored in the entries.\nRETURNS:\nAllMainSends:a table with all AllMainSends-entries of the current project.\ninteger number_of_tracks:the number of tracks in the AllMainSends-table\n",
        "body": "${1:local }${2:table AllMainSends},${3:integer number_of_tracks} = ultraschall.GetAllMainSendStates2()$0"
    },
    "ULTRASCHALL.DELETEUSEXTERNALSTATE_WR lua": {
        "prefix": "ultraschallwr.DeleteUSExternalState",
        "scope": "lua",
        "description": "Deletes an external state from the ultraschall.ini\nReturns false in case of error.\nPARAMETERS:\nsection:the section, in which the to be deleted-key is located\nkey:the key to delete\nfilename:set this to a filename, if you don't want to use ultraschall.ini; it will be stored into the resource-path of Reaper, so no path needed\nRETURNS:\nretval:false in case of error; true in case of success\n",
        "body": "${1:local }${2:boolean retval} = ultraschall.DeleteUSExternalState(${3:string section},${4:string key},${5:optional string filename})$0"
    },
    "ULTRASCHALL.SOUNDBOARD_PLAYLIST_CURRENTINDEX_WR lua": {
        "prefix": "ultraschallwr.Soundboard_PlayList_CurrentIndex",
        "scope": "lua",
        "description": "Returns the position within the playlist of the Ultraschall Soundboard.\nPlaylist means, the player within all players of the Ultraschall-Soundboard.\nNeeds ultraschall-Soundboard installed to be useable!\nTrack(s) who hold the soundboard must be recarmed and recinput set to MIDI or VKB.\nFor other playlist-related functions, see also SoundBoard\\_PlayList\\_SetIndex](#SoundBoard_PlayList_SetIndex), [SoundBoard\\_PlayList\\_Next](#SoundBoard_PlayList_Next) and [SoundBoard\\_PlayList\\_Previous\nRETURNS:\ncurrent_playlist_position:the position in the playlist\n",
        "body": "${1:local }${2:integer current_playlist_position} = ultraschall.Soundboard_PlayList_CurrentIndex()$0"
    },
    "ULTRASCHALL.WEBINTERFACE_GETINSTALLEDINTERFACES_WR lua": {
        "prefix": "ultraschallwr.WebInterface_GetInstalledInterfaces",
        "scope": "lua",
        "description": "Returns the currently installed web-interface-pages.\nWill return Reaper's default ones(resources-folder/Plugins/reaper_www_root/) as well as your customized ones(resources-folder/reaper_www_root/)\nRETURNS:\nreapers_count_of_webinterface:the number of factory-default webinterfaces, installed by Reaper\nreapers_webinterface_filenames_with_path:the filenames with path of the webinterfaces(can be .htm or .html)\nreapers_webinterface_titles:the titles of the webinterfaces, as shown in the titlebar of the browser\nusers_count_of_webinterface:the number of user-customized webinterfaces\nusers_webinterface_filenames_with_path:the filenames with path of the webinterfaces(can be .htm or .html)\nusers_webinterface_titles:the titles of the webinterfaces, as shown in the titlebar of the browser\n",
        "body": "${1:local }${2:integer reapers_count_of_webinterface},${3:array reapers_webinterface_filenames_with_path},${4:array reapers_webinterface_titles},${5:integer users_count_of_webinterface},${6:array users_webinterface_filenames_with_path},${7:array users_webinterface_titles} = ultraschall.WebInterface_GetInstalledInterfaces()$0"
    }
}