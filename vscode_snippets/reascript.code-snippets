{
    "ADDMEDIAITEMTOTRACK c": {
        "prefix": "AddMediaItemToTrack",
        "scope": "c",
        "description": "creates a new media item.\n",
        "body": "AddMediaItemToTrack(${1:MediaTrack* tr})$0"
    },
    "ADDMEDIAITEMTOTRACK eel2": {
        "prefix": "AddMediaItemToTrack",
        "scope": "eel2",
        "description": "creates a new media item.\n",
        "body": "AddMediaItemToTrack(${1:MediaTrack tr})$0"
    },
    "REAPER.ADDMEDIAITEMTOTRACK lua": {
        "prefix": "reaper.AddMediaItemToTrack",
        "scope": "lua",
        "description": "creates a new media item.\n",
        "body": "reaper.AddMediaItemToTrack(${1:MediaTrack tr})$0"
    },
    "RPR_ADDMEDIAITEMTOTRACK python": {
        "prefix": "RPR_AddMediaItemToTrack",
        "scope": "python",
        "description": "creates a new media item.\n",
        "body": "RPR_AddMediaItemToTrack(${1:MediaTrack tr})$0"
    },
    "ADDPROJECTMARKER c": {
        "prefix": "AddProjectMarker",
        "scope": "c",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "AddProjectMarker(${1:ReaProject* proj},${2:bool isrgn},${3:double pos},${4:double rgnend},${5:const char* name},${6:int wantidx})$0"
    },
    "ADDPROJECTMARKER eel2": {
        "prefix": "AddProjectMarker",
        "scope": "eel2",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "AddProjectMarker(${1:ReaProject proj},${2:bool isrgn},${3:pos},${4:rgnend},${5:\"name\"},${6:int wantidx})$0"
    },
    "REAPER.ADDPROJECTMARKER lua": {
        "prefix": "reaper.AddProjectMarker",
        "scope": "lua",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "reaper.AddProjectMarker(${1:ReaProject proj},${2:boolean isrgn},${3:number pos},${4:number rgnend},${5:string name},${6:integer wantidx})$0"
    },
    "RPR_ADDPROJECTMARKER python": {
        "prefix": "RPR_AddProjectMarker",
        "scope": "python",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "RPR_AddProjectMarker(${1:ReaProject proj},${2:Boolean isrgn},${3:Float pos},${4:Float rgnend},${5:String name},${6:Int wantidx})$0"
    },
    "ADDPROJECTMARKER2 c": {
        "prefix": "AddProjectMarker2",
        "scope": "c",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "AddProjectMarker2(${1:ReaProject* proj},${2:bool isrgn},${3:double pos},${4:double rgnend},${5:const char* name},${6:int wantidx},${7:int color})$0"
    },
    "ADDPROJECTMARKER2 eel2": {
        "prefix": "AddProjectMarker2",
        "scope": "eel2",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "AddProjectMarker2(${1:ReaProject proj},${2:bool isrgn},${3:pos},${4:rgnend},${5:\"name\"},${6:int wantidx},${7:int color})$0"
    },
    "REAPER.ADDPROJECTMARKER2 lua": {
        "prefix": "reaper.AddProjectMarker2",
        "scope": "lua",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "reaper.AddProjectMarker2(${1:ReaProject proj},${2:boolean isrgn},${3:number pos},${4:number rgnend},${5:string name},${6:integer wantidx},${7:integer color})$0"
    },
    "RPR_ADDPROJECTMARKER2 python": {
        "prefix": "RPR_AddProjectMarker2",
        "scope": "python",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "RPR_AddProjectMarker2(${1:ReaProject proj},${2:Boolean isrgn},${3:Float pos},${4:Float rgnend},${5:String name},${6:Int wantidx},${7:Int color})$0"
    },
    "ADDREMOVEREASCRIPT c": {
        "prefix": "AddRemoveReaScript",
        "scope": "c",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "AddRemoveReaScript(${1:bool add},${2:int sectionID},${3:const char* scriptfn},${4:bool commit})$0"
    },
    "ADDREMOVEREASCRIPT eel2": {
        "prefix": "AddRemoveReaScript",
        "scope": "eel2",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "AddRemoveReaScript(${1:bool add},${2:int sectionID},${3:\"scriptfn\"},${4:bool commit})$0"
    },
    "REAPER.ADDREMOVEREASCRIPT lua": {
        "prefix": "reaper.AddRemoveReaScript",
        "scope": "lua",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "reaper.AddRemoveReaScript(${1:boolean add},${2:integer sectionID},${3:string scriptfn},${4:boolean commit})$0"
    },
    "RPR_ADDREMOVEREASCRIPT python": {
        "prefix": "RPR_AddRemoveReaScript",
        "scope": "python",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "RPR_AddRemoveReaScript(${1:Boolean add},${2:Int sectionID},${3:String scriptfn},${4:Boolean commit})$0"
    },
    "ADDTAKETOMEDIAITEM c": {
        "prefix": "AddTakeToMediaItem",
        "scope": "c",
        "description": "creates a new take in an item\n",
        "body": "AddTakeToMediaItem(${1:MediaItem* item})$0"
    },
    "ADDTAKETOMEDIAITEM eel2": {
        "prefix": "AddTakeToMediaItem",
        "scope": "eel2",
        "description": "creates a new take in an item\n",
        "body": "AddTakeToMediaItem(${1:MediaItem item})$0"
    },
    "REAPER.ADDTAKETOMEDIAITEM lua": {
        "prefix": "reaper.AddTakeToMediaItem",
        "scope": "lua",
        "description": "creates a new take in an item\n",
        "body": "reaper.AddTakeToMediaItem(${1:MediaItem item})$0"
    },
    "RPR_ADDTAKETOMEDIAITEM python": {
        "prefix": "RPR_AddTakeToMediaItem",
        "scope": "python",
        "description": "creates a new take in an item\n",
        "body": "RPR_AddTakeToMediaItem(${1:MediaItem item})$0"
    },
    "ADDTEMPOTIMESIGMARKER c": {
        "prefix": "AddTempoTimeSigMarker",
        "scope": "c",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "AddTempoTimeSigMarker(${1:ReaProject* proj},${2:double timepos},${3:double bpm},${4:int timesig_num},${5:int timesig_denom},${6:bool lineartempochange})$0"
    },
    "ADDTEMPOTIMESIGMARKER eel2": {
        "prefix": "AddTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "AddTempoTimeSigMarker(${1:ReaProject proj},${2:timepos},${3:bpm},${4:int timesig_num},${5:int timesig_denom},${6:bool lineartempochange})$0"
    },
    "REAPER.ADDTEMPOTIMESIGMARKER lua": {
        "prefix": "reaper.AddTempoTimeSigMarker",
        "scope": "lua",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "reaper.AddTempoTimeSigMarker(${1:ReaProject proj},${2:number timepos},${3:number bpm},${4:integer timesig_num},${5:integer timesig_denom},${6:boolean lineartempochange})$0"
    },
    "RPR_ADDTEMPOTIMESIGMARKER python": {
        "prefix": "RPR_AddTempoTimeSigMarker",
        "scope": "python",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "RPR_AddTempoTimeSigMarker(${1:ReaProject proj},${2:Float timepos},${3:Float bpm},${4:Int timesig_num},${5:Int timesig_denom},${6:Boolean lineartempochange})$0"
    },
    "ADJUSTZOOM c": {
        "prefix": "adjustZoom",
        "scope": "c",
        "description": "forceset=0,doupd=true,centermode=-1 for default\n",
        "body": "adjustZoom(${1:double amt},${2:int forceset},${3:bool doupd},${4:int centermode})$0"
    },
    "ADJUSTZOOM eel2": {
        "prefix": "adjustZoom",
        "scope": "eel2",
        "description": "forceset=0,doupd=true,centermode=-1 for default\n",
        "body": "adjustZoom(${1:amt},${2:int forceset},${3:bool doupd},${4:int centermode})$0"
    },
    "REAPER.ADJUSTZOOM lua": {
        "prefix": "reaper.adjustZoom",
        "scope": "lua",
        "description": "forceset=0,doupd=true,centermode=-1 for default\n",
        "body": "reaper.adjustZoom(${1:number amt},${2:integer forceset},${3:boolean doupd},${4:integer centermode})$0"
    },
    "RPR_ADJUSTZOOM python": {
        "prefix": "RPR_adjustZoom",
        "scope": "python",
        "description": "forceset=0,doupd=true,centermode=-1 for default\n",
        "body": "RPR_adjustZoom(${1:Float amt},${2:Int forceset},${3:Boolean doupd},${4:Int centermode})$0"
    },
    "ANYTRACKSOLO c": {
        "prefix": "AnyTrackSolo",
        "scope": "c",
        "description": "\n",
        "body": "AnyTrackSolo(${1:ReaProject* proj})$0"
    },
    "ANYTRACKSOLO eel2": {
        "prefix": "AnyTrackSolo",
        "scope": "eel2",
        "description": "\n",
        "body": "AnyTrackSolo(${1:ReaProject proj})$0"
    },
    "REAPER.ANYTRACKSOLO lua": {
        "prefix": "reaper.AnyTrackSolo",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.AnyTrackSolo(${1:ReaProject proj})$0"
    },
    "RPR_ANYTRACKSOLO python": {
        "prefix": "RPR_AnyTrackSolo",
        "scope": "python",
        "description": "\n",
        "body": "RPR_AnyTrackSolo(${1:ReaProject proj})$0"
    },
    "APIEXISTS c": {
        "prefix": "APIExists",
        "scope": "c",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "APIExists(${1:const char* function_name})$0"
    },
    "APIEXISTS eel2": {
        "prefix": "APIExists",
        "scope": "eel2",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "APIExists(${1:\"function_name\"})$0"
    },
    "REAPER.APIEXISTS lua": {
        "prefix": "reaper.APIExists",
        "scope": "lua",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "reaper.APIExists(${1:string function_name})$0"
    },
    "RPR_APIEXISTS python": {
        "prefix": "RPR_APIExists",
        "scope": "python",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "RPR_APIExists(${1:String function_name})$0"
    },
    "APITEST c": {
        "prefix": "APITest",
        "scope": "c",
        "description": "Displays a message window if the API was successfully called.\n",
        "body": "APITest()$0"
    },
    "APITEST eel2": {
        "prefix": "APITest",
        "scope": "eel2",
        "description": "Displays a message window if the API was successfully called.\n",
        "body": "APITest()$0"
    },
    "REAPER.APITEST lua": {
        "prefix": "reaper.APITest",
        "scope": "lua",
        "description": "Displays a message window if the API was successfully called.\n",
        "body": "reaper.APITest()$0"
    },
    "RPR_APITEST python": {
        "prefix": "RPR_APITest",
        "scope": "python",
        "description": "Displays a message window if the API was successfully called.\n",
        "body": "RPR_APITest()$0"
    },
    "APPLYNUDGE c": {
        "prefix": "ApplyNudge",
        "scope": "c",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "ApplyNudge(${1:ReaProject* project},${2:int nudgeflag},${3:int nudgewhat},${4:int nudgeunits},${5:double value},${6:bool reverse},${7:int copies})$0"
    },
    "APPLYNUDGE eel2": {
        "prefix": "ApplyNudge",
        "scope": "eel2",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "ApplyNudge(${1:ReaProject project},${2:int nudgeflag},${3:int nudgewhat},${4:int nudgeunits},${5:value},${6:bool reverse},${7:int copies})$0"
    },
    "REAPER.APPLYNUDGE lua": {
        "prefix": "reaper.ApplyNudge",
        "scope": "lua",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "reaper.ApplyNudge(${1:ReaProject project},${2:integer nudgeflag},${3:integer nudgewhat},${4:integer nudgeunits},${5:number value},${6:boolean reverse},${7:integer copies})$0"
    },
    "RPR_APPLYNUDGE python": {
        "prefix": "RPR_ApplyNudge",
        "scope": "python",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "RPR_ApplyNudge(${1:ReaProject project},${2:Int nudgeflag},${3:Int nudgewhat},${4:Int nudgeunits},${5:Float value},${6:Boolean reverse},${7:Int copies})$0"
    },
    "ARMCOMMAND c": {
        "prefix": "ArmCommand",
        "scope": "c",
        "description": "arms a command (or disarms if 0 passed) in section sectionname (empty string for main)\n",
        "body": "ArmCommand(${1:int cmd},${2:const char* sectionname})$0"
    },
    "ARMCOMMAND eel2": {
        "prefix": "ArmCommand",
        "scope": "eel2",
        "description": "arms a command (or disarms if 0 passed) in section sectionname (empty string for main)\n",
        "body": "ArmCommand(${1:int cmd},${2:\"sectionname\"})$0"
    },
    "REAPER.ARMCOMMAND lua": {
        "prefix": "reaper.ArmCommand",
        "scope": "lua",
        "description": "arms a command (or disarms if 0 passed) in section sectionname (empty string for main)\n",
        "body": "reaper.ArmCommand(${1:integer cmd},${2:string sectionname})$0"
    },
    "RPR_ARMCOMMAND python": {
        "prefix": "RPR_ArmCommand",
        "scope": "python",
        "description": "arms a command (or disarms if 0 passed) in section sectionname (empty string for main)\n",
        "body": "RPR_ArmCommand(${1:Int cmd},${2:String sectionname})$0"
    },
    "AUDIO_INIT c": {
        "prefix": "Audio_Init",
        "scope": "c",
        "description": "open all audio and MIDI devices, if not open\n",
        "body": "Audio_Init()$0"
    },
    "AUDIO_INIT eel2": {
        "prefix": "Audio_Init",
        "scope": "eel2",
        "description": "open all audio and MIDI devices, if not open\n",
        "body": "Audio_Init()$0"
    },
    "REAPER.AUDIO_INIT lua": {
        "prefix": "reaper.Audio_Init",
        "scope": "lua",
        "description": "open all audio and MIDI devices, if not open\n",
        "body": "reaper.Audio_Init()$0"
    },
    "RPR_AUDIO_INIT python": {
        "prefix": "RPR_Audio_Init",
        "scope": "python",
        "description": "open all audio and MIDI devices, if not open\n",
        "body": "RPR_Audio_Init()$0"
    },
    "AUDIO_ISPREBUFFER c": {
        "prefix": "Audio_IsPreBuffer",
        "scope": "c",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "Audio_IsPreBuffer()$0"
    },
    "AUDIO_ISPREBUFFER eel2": {
        "prefix": "Audio_IsPreBuffer",
        "scope": "eel2",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "Audio_IsPreBuffer()$0"
    },
    "REAPER.AUDIO_ISPREBUFFER lua": {
        "prefix": "reaper.Audio_IsPreBuffer",
        "scope": "lua",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "reaper.Audio_IsPreBuffer()$0"
    },
    "RPR_AUDIO_ISPREBUFFER python": {
        "prefix": "RPR_Audio_IsPreBuffer",
        "scope": "python",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "RPR_Audio_IsPreBuffer()$0"
    },
    "AUDIO_ISRUNNING c": {
        "prefix": "Audio_IsRunning",
        "scope": "c",
        "description": "is audio running at all? threadsafe\n",
        "body": "Audio_IsRunning()$0"
    },
    "AUDIO_ISRUNNING eel2": {
        "prefix": "Audio_IsRunning",
        "scope": "eel2",
        "description": "is audio running at all? threadsafe\n",
        "body": "Audio_IsRunning()$0"
    },
    "REAPER.AUDIO_ISRUNNING lua": {
        "prefix": "reaper.Audio_IsRunning",
        "scope": "lua",
        "description": "is audio running at all? threadsafe\n",
        "body": "reaper.Audio_IsRunning()$0"
    },
    "RPR_AUDIO_ISRUNNING python": {
        "prefix": "RPR_Audio_IsRunning",
        "scope": "python",
        "description": "is audio running at all? threadsafe\n",
        "body": "RPR_Audio_IsRunning()$0"
    },
    "AUDIO_QUIT c": {
        "prefix": "Audio_Quit",
        "scope": "c",
        "description": "close all audio and MIDI devices, if open\n",
        "body": "Audio_Quit()$0"
    },
    "AUDIO_QUIT eel2": {
        "prefix": "Audio_Quit",
        "scope": "eel2",
        "description": "close all audio and MIDI devices, if open\n",
        "body": "Audio_Quit()$0"
    },
    "REAPER.AUDIO_QUIT lua": {
        "prefix": "reaper.Audio_Quit",
        "scope": "lua",
        "description": "close all audio and MIDI devices, if open\n",
        "body": "reaper.Audio_Quit()$0"
    },
    "RPR_AUDIO_QUIT python": {
        "prefix": "RPR_Audio_Quit",
        "scope": "python",
        "description": "close all audio and MIDI devices, if open\n",
        "body": "RPR_Audio_Quit()$0"
    },
    "AUDIOACCESSORSTATECHANGED c": {
        "prefix": "AudioAccessorStateChanged",
        "scope": "c",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "AudioAccessorStateChanged(${1:AudioAccessor* accessor})$0"
    },
    "AUDIOACCESSORSTATECHANGED eel2": {
        "prefix": "AudioAccessorStateChanged",
        "scope": "eel2",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "AudioAccessorStateChanged(${1:AudioAccessor accessor})$0"
    },
    "REAPER.AUDIOACCESSORSTATECHANGED lua": {
        "prefix": "reaper.AudioAccessorStateChanged",
        "scope": "lua",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "reaper.AudioAccessorStateChanged(${1:AudioAccessor accessor})$0"
    },
    "RPR_AUDIOACCESSORSTATECHANGED python": {
        "prefix": "RPR_AudioAccessorStateChanged",
        "scope": "python",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "RPR_AudioAccessorStateChanged(${1:AudioAccessor accessor})$0"
    },
    "AUDIOACCESSORUPDATE c": {
        "prefix": "AudioAccessorUpdate",
        "scope": "c",
        "description": "Force the accessor to reload its state from the underlying track or media item take. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "AudioAccessorUpdate(${1:AudioAccessor* accessor})$0"
    },
    "AUDIOACCESSORUPDATE eel2": {
        "prefix": "AudioAccessorUpdate",
        "scope": "eel2",
        "description": "Force the accessor to reload its state from the underlying track or media item take. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "AudioAccessorUpdate(${1:AudioAccessor accessor})$0"
    },
    "REAPER.AUDIOACCESSORUPDATE lua": {
        "prefix": "reaper.AudioAccessorUpdate",
        "scope": "lua",
        "description": "Force the accessor to reload its state from the underlying track or media item take. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "reaper.AudioAccessorUpdate(${1:AudioAccessor accessor})$0"
    },
    "RPR_AUDIOACCESSORUPDATE python": {
        "prefix": "RPR_AudioAccessorUpdate",
        "scope": "python",
        "description": "Force the accessor to reload its state from the underlying track or media item take. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "RPR_AudioAccessorUpdate(${1:AudioAccessor accessor})$0"
    },
    "AUDIOACCESSORVALIDATESTATE c": {
        "prefix": "AudioAccessorValidateState",
        "scope": "c",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "AudioAccessorValidateState(${1:AudioAccessor* accessor})$0"
    },
    "AUDIOACCESSORVALIDATESTATE eel2": {
        "prefix": "AudioAccessorValidateState",
        "scope": "eel2",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "AudioAccessorValidateState(${1:AudioAccessor accessor})$0"
    },
    "REAPER.AUDIOACCESSORVALIDATESTATE lua": {
        "prefix": "reaper.AudioAccessorValidateState",
        "scope": "lua",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "reaper.AudioAccessorValidateState(${1:AudioAccessor accessor})$0"
    },
    "RPR_AUDIOACCESSORVALIDATESTATE python": {
        "prefix": "RPR_AudioAccessorValidateState",
        "scope": "python",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "RPR_AudioAccessorValidateState(${1:AudioAccessor accessor})$0"
    },
    "BYPASSFXALLTRACKS c": {
        "prefix": "BypassFxAllTracks",
        "scope": "c",
        "description": "-1 = bypass all if not all bypassed,otherwise unbypass all\n",
        "body": "BypassFxAllTracks(${1:int bypass})$0"
    },
    "BYPASSFXALLTRACKS eel2": {
        "prefix": "BypassFxAllTracks",
        "scope": "eel2",
        "description": "-1 = bypass all if not all bypassed,otherwise unbypass all\n",
        "body": "BypassFxAllTracks(${1:int bypass})$0"
    },
    "REAPER.BYPASSFXALLTRACKS lua": {
        "prefix": "reaper.BypassFxAllTracks",
        "scope": "lua",
        "description": "-1 = bypass all if not all bypassed,otherwise unbypass all\n",
        "body": "reaper.BypassFxAllTracks(${1:integer bypass})$0"
    },
    "RPR_BYPASSFXALLTRACKS python": {
        "prefix": "RPR_BypassFxAllTracks",
        "scope": "python",
        "description": "-1 = bypass all if not all bypassed,otherwise unbypass all\n",
        "body": "RPR_BypassFxAllTracks(${1:Int bypass})$0"
    },
    "CLEARALLRECARMED c": {
        "prefix": "ClearAllRecArmed",
        "scope": "c",
        "description": "\n",
        "body": "ClearAllRecArmed()$0"
    },
    "CLEARALLRECARMED eel2": {
        "prefix": "ClearAllRecArmed",
        "scope": "eel2",
        "description": "\n",
        "body": "ClearAllRecArmed()$0"
    },
    "REAPER.CLEARALLRECARMED lua": {
        "prefix": "reaper.ClearAllRecArmed",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.ClearAllRecArmed()$0"
    },
    "RPR_CLEARALLRECARMED python": {
        "prefix": "RPR_ClearAllRecArmed",
        "scope": "python",
        "description": "\n",
        "body": "RPR_ClearAllRecArmed()$0"
    },
    "CLEARCONSOLE c": {
        "prefix": "ClearConsole",
        "scope": "c",
        "description": "Clear the ReaScript console. See ShowConsoleMsg\n",
        "body": "ClearConsole()$0"
    },
    "CLEARCONSOLE eel2": {
        "prefix": "ClearConsole",
        "scope": "eel2",
        "description": "Clear the ReaScript console. See ShowConsoleMsg\n",
        "body": "ClearConsole()$0"
    },
    "REAPER.CLEARCONSOLE lua": {
        "prefix": "reaper.ClearConsole",
        "scope": "lua",
        "description": "Clear the ReaScript console. See ShowConsoleMsg\n",
        "body": "reaper.ClearConsole()$0"
    },
    "RPR_CLEARCONSOLE python": {
        "prefix": "RPR_ClearConsole",
        "scope": "python",
        "description": "Clear the ReaScript console. See ShowConsoleMsg\n",
        "body": "RPR_ClearConsole()$0"
    },
    "CLEARPEAKCACHE c": {
        "prefix": "ClearPeakCache",
        "scope": "c",
        "description": "resets the global peak caches\n",
        "body": "ClearPeakCache()$0"
    },
    "CLEARPEAKCACHE eel2": {
        "prefix": "ClearPeakCache",
        "scope": "eel2",
        "description": "resets the global peak caches\n",
        "body": "ClearPeakCache()$0"
    },
    "REAPER.CLEARPEAKCACHE lua": {
        "prefix": "reaper.ClearPeakCache",
        "scope": "lua",
        "description": "resets the global peak caches\n",
        "body": "reaper.ClearPeakCache()$0"
    },
    "RPR_CLEARPEAKCACHE python": {
        "prefix": "RPR_ClearPeakCache",
        "scope": "python",
        "description": "resets the global peak caches\n",
        "body": "RPR_ClearPeakCache()$0"
    },
    "COLORFROMNATIVE c": {
        "prefix": "ColorFromNative",
        "scope": "c",
        "description": "Extract RGB values from an OS dependent color. See ColorToNative.\n",
        "body": "ColorFromNative(${1:int col},${2:int* rOut},${3:int* gOut},${4:int* bOut})$0"
    },
    "COLORFROMNATIVE eel2": {
        "prefix": "ColorFromNative",
        "scope": "eel2",
        "description": "Extract RGB values from an OS dependent color. See ColorToNative.\n",
        "body": "ColorFromNative(${1:int col},${2:int &r},${3:int &g},${4:int &b})$0"
    },
    "REAPER.COLORFROMNATIVE lua": {
        "prefix": "reaper.ColorFromNative",
        "scope": "lua",
        "description": "Extract RGB values from an OS dependent color. See ColorToNative.\n",
        "body": "reaper.ColorFromNative(${1:integer col})$0"
    },
    "RPR_COLORFROMNATIVE python": {
        "prefix": "RPR_ColorFromNative",
        "scope": "python",
        "description": "Extract RGB values from an OS dependent color. See ColorToNative.\n",
        "body": "RPR_ColorFromNative(${1:col},${2:rOut},${3:gOut},${4:bOut})$0"
    },
    "COLORTONATIVE c": {
        "prefix": "ColorToNative",
        "scope": "c",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "ColorToNative(${1:int r},${2:int g},${3:int b})$0"
    },
    "COLORTONATIVE eel2": {
        "prefix": "ColorToNative",
        "scope": "eel2",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "ColorToNative(${1:int r},${2:int g},${3:int b})$0"
    },
    "REAPER.COLORTONATIVE lua": {
        "prefix": "reaper.ColorToNative",
        "scope": "lua",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "reaper.ColorToNative(${1:integer r},${2:integer g},${3:integer b})$0"
    },
    "RPR_COLORTONATIVE python": {
        "prefix": "RPR_ColorToNative",
        "scope": "python",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "RPR_ColorToNative(${1:Int r},${2:Int g},${3:Int b})$0"
    },
    "COUNTAUTOMATIONITEMS c": {
        "prefix": "CountAutomationItems",
        "scope": "c",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "CountAutomationItems(${1:TrackEnvelope* env})$0"
    },
    "COUNTAUTOMATIONITEMS eel2": {
        "prefix": "CountAutomationItems",
        "scope": "eel2",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "CountAutomationItems(${1:TrackEnvelope env})$0"
    },
    "REAPER.COUNTAUTOMATIONITEMS lua": {
        "prefix": "reaper.CountAutomationItems",
        "scope": "lua",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "reaper.CountAutomationItems(${1:TrackEnvelope env})$0"
    },
    "RPR_COUNTAUTOMATIONITEMS python": {
        "prefix": "RPR_CountAutomationItems",
        "scope": "python",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "RPR_CountAutomationItems(${1:TrackEnvelope env})$0"
    },
    "COUNTENVELOPEPOINTS c": {
        "prefix": "CountEnvelopePoints",
        "scope": "c",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "CountEnvelopePoints(${1:TrackEnvelope* envelope})$0"
    },
    "COUNTENVELOPEPOINTS eel2": {
        "prefix": "CountEnvelopePoints",
        "scope": "eel2",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "CountEnvelopePoints(${1:TrackEnvelope envelope})$0"
    },
    "REAPER.COUNTENVELOPEPOINTS lua": {
        "prefix": "reaper.CountEnvelopePoints",
        "scope": "lua",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "reaper.CountEnvelopePoints(${1:TrackEnvelope envelope})$0"
    },
    "RPR_COUNTENVELOPEPOINTS python": {
        "prefix": "RPR_CountEnvelopePoints",
        "scope": "python",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "RPR_CountEnvelopePoints(${1:TrackEnvelope envelope})$0"
    },
    "COUNTENVELOPEPOINTSEX c": {
        "prefix": "CountEnvelopePointsEx",
        "scope": "c",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "CountEnvelopePointsEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx})$0"
    },
    "COUNTENVELOPEPOINTSEX eel2": {
        "prefix": "CountEnvelopePointsEx",
        "scope": "eel2",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "CountEnvelopePointsEx(${1:TrackEnvelope envelope},${2:int autoitem_idx})$0"
    },
    "REAPER.COUNTENVELOPEPOINTSEX lua": {
        "prefix": "reaper.CountEnvelopePointsEx",
        "scope": "lua",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "reaper.CountEnvelopePointsEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx})$0"
    },
    "RPR_COUNTENVELOPEPOINTSEX python": {
        "prefix": "RPR_CountEnvelopePointsEx",
        "scope": "python",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "RPR_CountEnvelopePointsEx(${1:TrackEnvelope envelope},${2:Int autoitem_idx})$0"
    },
    "COUNTMEDIAITEMS c": {
        "prefix": "CountMediaItems",
        "scope": "c",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "CountMediaItems(${1:ReaProject* proj})$0"
    },
    "COUNTMEDIAITEMS eel2": {
        "prefix": "CountMediaItems",
        "scope": "eel2",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "CountMediaItems(${1:ReaProject proj})$0"
    },
    "REAPER.COUNTMEDIAITEMS lua": {
        "prefix": "reaper.CountMediaItems",
        "scope": "lua",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "reaper.CountMediaItems(${1:ReaProject proj})$0"
    },
    "RPR_COUNTMEDIAITEMS python": {
        "prefix": "RPR_CountMediaItems",
        "scope": "python",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "RPR_CountMediaItems(${1:ReaProject proj})$0"
    },
    "COUNTPROJECTMARKERS c": {
        "prefix": "CountProjectMarkers",
        "scope": "c",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "CountProjectMarkers(${1:ReaProject* proj},${2:int* num_markersOut},${3:int* num_regionsOut})$0"
    },
    "COUNTPROJECTMARKERS eel2": {
        "prefix": "CountProjectMarkers",
        "scope": "eel2",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "CountProjectMarkers(${1:ReaProject proj},${2:int &num_markers},${3:int &num_regions})$0"
    },
    "REAPER.COUNTPROJECTMARKERS lua": {
        "prefix": "reaper.CountProjectMarkers",
        "scope": "lua",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "reaper.CountProjectMarkers(${1:ReaProject proj})$0"
    },
    "RPR_COUNTPROJECTMARKERS python": {
        "prefix": "RPR_CountProjectMarkers",
        "scope": "python",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "RPR_CountProjectMarkers(${1:proj},${2:num_markersOut},${3:num_regionsOut})$0"
    },
    "COUNTSELECTEDMEDIAITEMS c": {
        "prefix": "CountSelectedMediaItems",
        "scope": "c",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "CountSelectedMediaItems(${1:ReaProject* proj})$0"
    },
    "COUNTSELECTEDMEDIAITEMS eel2": {
        "prefix": "CountSelectedMediaItems",
        "scope": "eel2",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "CountSelectedMediaItems(${1:ReaProject proj})$0"
    },
    "REAPER.COUNTSELECTEDMEDIAITEMS lua": {
        "prefix": "reaper.CountSelectedMediaItems",
        "scope": "lua",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "reaper.CountSelectedMediaItems(${1:ReaProject proj})$0"
    },
    "RPR_COUNTSELECTEDMEDIAITEMS python": {
        "prefix": "RPR_CountSelectedMediaItems",
        "scope": "python",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "RPR_CountSelectedMediaItems(${1:ReaProject proj})$0"
    },
    "COUNTSELECTEDTRACKS c": {
        "prefix": "CountSelectedTracks",
        "scope": "c",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "CountSelectedTracks(${1:ReaProject* proj})$0"
    },
    "COUNTSELECTEDTRACKS eel2": {
        "prefix": "CountSelectedTracks",
        "scope": "eel2",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "CountSelectedTracks(${1:ReaProject proj})$0"
    },
    "REAPER.COUNTSELECTEDTRACKS lua": {
        "prefix": "reaper.CountSelectedTracks",
        "scope": "lua",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "reaper.CountSelectedTracks(${1:ReaProject proj})$0"
    },
    "RPR_COUNTSELECTEDTRACKS python": {
        "prefix": "RPR_CountSelectedTracks",
        "scope": "python",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "RPR_CountSelectedTracks(${1:ReaProject proj})$0"
    },
    "COUNTSELECTEDTRACKS2 c": {
        "prefix": "CountSelectedTracks2",
        "scope": "c",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "CountSelectedTracks2(${1:ReaProject* proj},${2:bool wantmaster})$0"
    },
    "COUNTSELECTEDTRACKS2 eel2": {
        "prefix": "CountSelectedTracks2",
        "scope": "eel2",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "CountSelectedTracks2(${1:ReaProject proj},${2:bool wantmaster})$0"
    },
    "REAPER.COUNTSELECTEDTRACKS2 lua": {
        "prefix": "reaper.CountSelectedTracks2",
        "scope": "lua",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "reaper.CountSelectedTracks2(${1:ReaProject proj},${2:boolean wantmaster})$0"
    },
    "RPR_COUNTSELECTEDTRACKS2 python": {
        "prefix": "RPR_CountSelectedTracks2",
        "scope": "python",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "RPR_CountSelectedTracks2(${1:ReaProject proj},${2:Boolean wantmaster})$0"
    },
    "COUNTTAKEENVELOPES c": {
        "prefix": "CountTakeEnvelopes",
        "scope": "c",
        "description": "See GetTakeEnvelope\n",
        "body": "CountTakeEnvelopes(${1:MediaItem_Take* take})$0"
    },
    "COUNTTAKEENVELOPES eel2": {
        "prefix": "CountTakeEnvelopes",
        "scope": "eel2",
        "description": "See GetTakeEnvelope\n",
        "body": "CountTakeEnvelopes(${1:MediaItem_Take take})$0"
    },
    "REAPER.COUNTTAKEENVELOPES lua": {
        "prefix": "reaper.CountTakeEnvelopes",
        "scope": "lua",
        "description": "See GetTakeEnvelope\n",
        "body": "reaper.CountTakeEnvelopes(${1:MediaItem_Take take})$0"
    },
    "RPR_COUNTTAKEENVELOPES python": {
        "prefix": "RPR_CountTakeEnvelopes",
        "scope": "python",
        "description": "See GetTakeEnvelope\n",
        "body": "RPR_CountTakeEnvelopes(${1:MediaItem_Take take})$0"
    },
    "COUNTTAKES c": {
        "prefix": "CountTakes",
        "scope": "c",
        "description": "count the number of takes in the item\n",
        "body": "CountTakes(${1:MediaItem* item})$0"
    },
    "COUNTTAKES eel2": {
        "prefix": "CountTakes",
        "scope": "eel2",
        "description": "count the number of takes in the item\n",
        "body": "CountTakes(${1:MediaItem item})$0"
    },
    "REAPER.COUNTTAKES lua": {
        "prefix": "reaper.CountTakes",
        "scope": "lua",
        "description": "count the number of takes in the item\n",
        "body": "reaper.CountTakes(${1:MediaItem item})$0"
    },
    "RPR_COUNTTAKES python": {
        "prefix": "RPR_CountTakes",
        "scope": "python",
        "description": "count the number of takes in the item\n",
        "body": "RPR_CountTakes(${1:MediaItem item})$0"
    },
    "COUNTTCPFXPARMS c": {
        "prefix": "CountTCPFXParms",
        "scope": "c",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "CountTCPFXParms(${1:ReaProject* project},${2:MediaTrack* track})$0"
    },
    "COUNTTCPFXPARMS eel2": {
        "prefix": "CountTCPFXParms",
        "scope": "eel2",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "CountTCPFXParms(${1:ReaProject project},${2:MediaTrack track})$0"
    },
    "REAPER.COUNTTCPFXPARMS lua": {
        "prefix": "reaper.CountTCPFXParms",
        "scope": "lua",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "reaper.CountTCPFXParms(${1:ReaProject project},${2:MediaTrack track})$0"
    },
    "RPR_COUNTTCPFXPARMS python": {
        "prefix": "RPR_CountTCPFXParms",
        "scope": "python",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "RPR_CountTCPFXParms(${1:ReaProject project},${2:MediaTrack track})$0"
    },
    "COUNTTEMPOTIMESIGMARKERS c": {
        "prefix": "CountTempoTimeSigMarkers",
        "scope": "c",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "CountTempoTimeSigMarkers(${1:ReaProject* proj})$0"
    },
    "COUNTTEMPOTIMESIGMARKERS eel2": {
        "prefix": "CountTempoTimeSigMarkers",
        "scope": "eel2",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "CountTempoTimeSigMarkers(${1:ReaProject proj})$0"
    },
    "REAPER.COUNTTEMPOTIMESIGMARKERS lua": {
        "prefix": "reaper.CountTempoTimeSigMarkers",
        "scope": "lua",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "reaper.CountTempoTimeSigMarkers(${1:ReaProject proj})$0"
    },
    "RPR_COUNTTEMPOTIMESIGMARKERS python": {
        "prefix": "RPR_CountTempoTimeSigMarkers",
        "scope": "python",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "RPR_CountTempoTimeSigMarkers(${1:ReaProject proj})$0"
    },
    "COUNTTRACKENVELOPES c": {
        "prefix": "CountTrackEnvelopes",
        "scope": "c",
        "description": "see GetTrackEnvelope\n",
        "body": "CountTrackEnvelopes(${1:MediaTrack* track})$0"
    },
    "COUNTTRACKENVELOPES eel2": {
        "prefix": "CountTrackEnvelopes",
        "scope": "eel2",
        "description": "see GetTrackEnvelope\n",
        "body": "CountTrackEnvelopes(${1:MediaTrack track})$0"
    },
    "REAPER.COUNTTRACKENVELOPES lua": {
        "prefix": "reaper.CountTrackEnvelopes",
        "scope": "lua",
        "description": "see GetTrackEnvelope\n",
        "body": "reaper.CountTrackEnvelopes(${1:MediaTrack track})$0"
    },
    "RPR_COUNTTRACKENVELOPES python": {
        "prefix": "RPR_CountTrackEnvelopes",
        "scope": "python",
        "description": "see GetTrackEnvelope\n",
        "body": "RPR_CountTrackEnvelopes(${1:MediaTrack track})$0"
    },
    "COUNTTRACKMEDIAITEMS c": {
        "prefix": "CountTrackMediaItems",
        "scope": "c",
        "description": "count the number of items in the track\n",
        "body": "CountTrackMediaItems(${1:MediaTrack* track})$0"
    },
    "COUNTTRACKMEDIAITEMS eel2": {
        "prefix": "CountTrackMediaItems",
        "scope": "eel2",
        "description": "count the number of items in the track\n",
        "body": "CountTrackMediaItems(${1:MediaTrack track})$0"
    },
    "REAPER.COUNTTRACKMEDIAITEMS lua": {
        "prefix": "reaper.CountTrackMediaItems",
        "scope": "lua",
        "description": "count the number of items in the track\n",
        "body": "reaper.CountTrackMediaItems(${1:MediaTrack track})$0"
    },
    "RPR_COUNTTRACKMEDIAITEMS python": {
        "prefix": "RPR_CountTrackMediaItems",
        "scope": "python",
        "description": "count the number of items in the track\n",
        "body": "RPR_CountTrackMediaItems(${1:MediaTrack track})$0"
    },
    "COUNTTRACKS c": {
        "prefix": "CountTracks",
        "scope": "c",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "CountTracks(${1:ReaProject* proj})$0"
    },
    "COUNTTRACKS eel2": {
        "prefix": "CountTracks",
        "scope": "eel2",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "CountTracks(${1:ReaProject proj})$0"
    },
    "REAPER.COUNTTRACKS lua": {
        "prefix": "reaper.CountTracks",
        "scope": "lua",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "reaper.CountTracks(${1:ReaProject proj})$0"
    },
    "RPR_COUNTTRACKS python": {
        "prefix": "RPR_CountTracks",
        "scope": "python",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "RPR_CountTracks(${1:ReaProject proj})$0"
    },
    "CREATENEWMIDIITEMINPROJ c": {
        "prefix": "CreateNewMIDIItemInProj",
        "scope": "c",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "CreateNewMIDIItemInProj(${1:MediaTrack* track},${2:double starttime},${3:double endtime},${4:const bool* qnInOptional})$0"
    },
    "CREATENEWMIDIITEMINPROJ eel2": {
        "prefix": "CreateNewMIDIItemInProj",
        "scope": "eel2",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "CreateNewMIDIItemInProj(${1:MediaTrack track},${2:starttime},${3:endtime},${4:optional bool qnIn})$0"
    },
    "REAPER.CREATENEWMIDIITEMINPROJ lua": {
        "prefix": "reaper.CreateNewMIDIItemInProj",
        "scope": "lua",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "reaper.CreateNewMIDIItemInProj(${1:MediaTrack track},${2:number starttime},${3:number endtime},${4:optional boolean qnIn})$0"
    },
    "RPR_CREATENEWMIDIITEMINPROJ python": {
        "prefix": "RPR_CreateNewMIDIItemInProj",
        "scope": "python",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "RPR_CreateNewMIDIItemInProj(${1:MediaTrack track},${2:Float starttime},${3:Float endtime},${4:const bool qnInOptional})$0"
    },
    "CREATETAKEAUDIOACCESSOR c": {
        "prefix": "CreateTakeAudioAccessor",
        "scope": "c",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "CreateTakeAudioAccessor(${1:MediaItem_Take* take})$0"
    },
    "CREATETAKEAUDIOACCESSOR eel2": {
        "prefix": "CreateTakeAudioAccessor",
        "scope": "eel2",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "CreateTakeAudioAccessor(${1:MediaItem_Take take})$0"
    },
    "REAPER.CREATETAKEAUDIOACCESSOR lua": {
        "prefix": "reaper.CreateTakeAudioAccessor",
        "scope": "lua",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "reaper.CreateTakeAudioAccessor(${1:MediaItem_Take take})$0"
    },
    "RPR_CREATETAKEAUDIOACCESSOR python": {
        "prefix": "RPR_CreateTakeAudioAccessor",
        "scope": "python",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "RPR_CreateTakeAudioAccessor(${1:MediaItem_Take take})$0"
    },
    "CREATETRACKAUDIOACCESSOR c": {
        "prefix": "CreateTrackAudioAccessor",
        "scope": "c",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "CreateTrackAudioAccessor(${1:MediaTrack* track})$0"
    },
    "CREATETRACKAUDIOACCESSOR eel2": {
        "prefix": "CreateTrackAudioAccessor",
        "scope": "eel2",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "CreateTrackAudioAccessor(${1:MediaTrack track})$0"
    },
    "REAPER.CREATETRACKAUDIOACCESSOR lua": {
        "prefix": "reaper.CreateTrackAudioAccessor",
        "scope": "lua",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "reaper.CreateTrackAudioAccessor(${1:MediaTrack track})$0"
    },
    "RPR_CREATETRACKAUDIOACCESSOR python": {
        "prefix": "RPR_CreateTrackAudioAccessor",
        "scope": "python",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "RPR_CreateTrackAudioAccessor(${1:MediaTrack track})$0"
    },
    "CREATETRACKSEND c": {
        "prefix": "CreateTrackSend",
        "scope": "c",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "CreateTrackSend(${1:MediaTrack* tr},${2:MediaTrack* desttrInOptional})$0"
    },
    "CREATETRACKSEND eel2": {
        "prefix": "CreateTrackSend",
        "scope": "eel2",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "CreateTrackSend(${1:MediaTrack tr},${2:MediaTrack desttrIn})$0"
    },
    "REAPER.CREATETRACKSEND lua": {
        "prefix": "reaper.CreateTrackSend",
        "scope": "lua",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "reaper.CreateTrackSend(${1:MediaTrack tr},${2:MediaTrack desttrIn})$0"
    },
    "RPR_CREATETRACKSEND python": {
        "prefix": "RPR_CreateTrackSend",
        "scope": "python",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "RPR_CreateTrackSend(${1:MediaTrack tr},${2:MediaTrack desttrInOptional})$0"
    },
    "CSURF_FLUSHUNDO c": {
        "prefix": "CSurf_FlushUndo",
        "scope": "c",
        "description": "call this to force flushing of the undo states after using CSurf_On*Change()\n",
        "body": "CSurf_FlushUndo(${1:bool force})$0"
    },
    "CSURF_FLUSHUNDO eel2": {
        "prefix": "CSurf_FlushUndo",
        "scope": "eel2",
        "description": "call this to force flushing of the undo states after using CSurf_On*Change()\n",
        "body": "CSurf_FlushUndo(${1:bool force})$0"
    },
    "REAPER.CSURF_FLUSHUNDO lua": {
        "prefix": "reaper.CSurf_FlushUndo",
        "scope": "lua",
        "description": "call this to force flushing of the undo states after using CSurf_On*Change()\n",
        "body": "reaper.CSurf_FlushUndo(${1:boolean force})$0"
    },
    "RPR_CSURF_FLUSHUNDO python": {
        "prefix": "RPR_CSurf_FlushUndo",
        "scope": "python",
        "description": "call this to force flushing of the undo states after using CSurf_On*Change()\n",
        "body": "RPR_CSurf_FlushUndo(${1:Boolean force})$0"
    },
    "CSURF_GETTOUCHSTATE c": {
        "prefix": "CSurf_GetTouchState",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_GetTouchState(${1:MediaTrack* trackid},${2:int isPan})$0"
    },
    "CSURF_GETTOUCHSTATE eel2": {
        "prefix": "CSurf_GetTouchState",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_GetTouchState(${1:MediaTrack trackid},${2:int isPan})$0"
    },
    "REAPER.CSURF_GETTOUCHSTATE lua": {
        "prefix": "reaper.CSurf_GetTouchState",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_GetTouchState(${1:MediaTrack trackid},${2:integer isPan})$0"
    },
    "RPR_CSURF_GETTOUCHSTATE python": {
        "prefix": "RPR_CSurf_GetTouchState",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_GetTouchState(${1:MediaTrack trackid},${2:Int isPan})$0"
    },
    "CSURF_GOEND c": {
        "prefix": "CSurf_GoEnd",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_GoEnd()$0"
    },
    "CSURF_GOEND eel2": {
        "prefix": "CSurf_GoEnd",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_GoEnd()$0"
    },
    "REAPER.CSURF_GOEND lua": {
        "prefix": "reaper.CSurf_GoEnd",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_GoEnd()$0"
    },
    "RPR_CSURF_GOEND python": {
        "prefix": "RPR_CSurf_GoEnd",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_GoEnd()$0"
    },
    "CSURF_GOSTART c": {
        "prefix": "CSurf_GoStart",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_GoStart()$0"
    },
    "CSURF_GOSTART eel2": {
        "prefix": "CSurf_GoStart",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_GoStart()$0"
    },
    "REAPER.CSURF_GOSTART lua": {
        "prefix": "reaper.CSurf_GoStart",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_GoStart()$0"
    },
    "RPR_CSURF_GOSTART python": {
        "prefix": "RPR_CSurf_GoStart",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_GoStart()$0"
    },
    "CSURF_NUMTRACKS c": {
        "prefix": "CSurf_NumTracks",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_NumTracks(${1:bool mcpView})$0"
    },
    "CSURF_NUMTRACKS eel2": {
        "prefix": "CSurf_NumTracks",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_NumTracks(${1:bool mcpView})$0"
    },
    "REAPER.CSURF_NUMTRACKS lua": {
        "prefix": "reaper.CSurf_NumTracks",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_NumTracks(${1:boolean mcpView})$0"
    },
    "RPR_CSURF_NUMTRACKS python": {
        "prefix": "RPR_CSurf_NumTracks",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_NumTracks(${1:Boolean mcpView})$0"
    },
    "CSURF_ONARROW c": {
        "prefix": "CSurf_OnArrow",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnArrow(${1:int whichdir},${2:bool wantzoom})$0"
    },
    "CSURF_ONARROW eel2": {
        "prefix": "CSurf_OnArrow",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnArrow(${1:int whichdir},${2:bool wantzoom})$0"
    },
    "REAPER.CSURF_ONARROW lua": {
        "prefix": "reaper.CSurf_OnArrow",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnArrow(${1:integer whichdir},${2:boolean wantzoom})$0"
    },
    "RPR_CSURF_ONARROW python": {
        "prefix": "RPR_CSurf_OnArrow",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnArrow(${1:Int whichdir},${2:Boolean wantzoom})$0"
    },
    "CSURF_ONFWD c": {
        "prefix": "CSurf_OnFwd",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnFwd(${1:int seekplay})$0"
    },
    "CSURF_ONFWD eel2": {
        "prefix": "CSurf_OnFwd",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnFwd(${1:int seekplay})$0"
    },
    "REAPER.CSURF_ONFWD lua": {
        "prefix": "reaper.CSurf_OnFwd",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnFwd(${1:integer seekplay})$0"
    },
    "RPR_CSURF_ONFWD python": {
        "prefix": "RPR_CSurf_OnFwd",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnFwd(${1:Int seekplay})$0"
    },
    "CSURF_ONFXCHANGE c": {
        "prefix": "CSurf_OnFXChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnFXChange(${1:MediaTrack* trackid},${2:int en})$0"
    },
    "CSURF_ONFXCHANGE eel2": {
        "prefix": "CSurf_OnFXChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnFXChange(${1:MediaTrack trackid},${2:int en})$0"
    },
    "REAPER.CSURF_ONFXCHANGE lua": {
        "prefix": "reaper.CSurf_OnFXChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnFXChange(${1:MediaTrack trackid},${2:integer en})$0"
    },
    "RPR_CSURF_ONFXCHANGE python": {
        "prefix": "RPR_CSurf_OnFXChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnFXChange(${1:MediaTrack trackid},${2:Int en})$0"
    },
    "CSURF_ONINPUTMONITORCHANGE c": {
        "prefix": "CSurf_OnInputMonitorChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnInputMonitorChange(${1:MediaTrack* trackid},${2:int monitor})$0"
    },
    "CSURF_ONINPUTMONITORCHANGE eel2": {
        "prefix": "CSurf_OnInputMonitorChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnInputMonitorChange(${1:MediaTrack trackid},${2:int monitor})$0"
    },
    "REAPER.CSURF_ONINPUTMONITORCHANGE lua": {
        "prefix": "reaper.CSurf_OnInputMonitorChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnInputMonitorChange(${1:MediaTrack trackid},${2:integer monitor})$0"
    },
    "RPR_CSURF_ONINPUTMONITORCHANGE python": {
        "prefix": "RPR_CSurf_OnInputMonitorChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnInputMonitorChange(${1:MediaTrack trackid},${2:Int monitor})$0"
    },
    "CSURF_ONINPUTMONITORCHANGEEX c": {
        "prefix": "CSurf_OnInputMonitorChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnInputMonitorChangeEx(${1:MediaTrack* trackid},${2:int monitor},${3:bool allowgang})$0"
    },
    "CSURF_ONINPUTMONITORCHANGEEX eel2": {
        "prefix": "CSurf_OnInputMonitorChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnInputMonitorChangeEx(${1:MediaTrack trackid},${2:int monitor},${3:bool allowgang})$0"
    },
    "REAPER.CSURF_ONINPUTMONITORCHANGEEX lua": {
        "prefix": "reaper.CSurf_OnInputMonitorChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnInputMonitorChangeEx(${1:MediaTrack trackid},${2:integer monitor},${3:boolean allowgang})$0"
    },
    "RPR_CSURF_ONINPUTMONITORCHANGEEX python": {
        "prefix": "RPR_CSurf_OnInputMonitorChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnInputMonitorChangeEx(${1:MediaTrack trackid},${2:Int monitor},${3:Boolean allowgang})$0"
    },
    "CSURF_ONMUTECHANGE c": {
        "prefix": "CSurf_OnMuteChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnMuteChange(${1:MediaTrack* trackid},${2:int mute})$0"
    },
    "CSURF_ONMUTECHANGE eel2": {
        "prefix": "CSurf_OnMuteChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnMuteChange(${1:MediaTrack trackid},${2:int mute})$0"
    },
    "REAPER.CSURF_ONMUTECHANGE lua": {
        "prefix": "reaper.CSurf_OnMuteChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnMuteChange(${1:MediaTrack trackid},${2:integer mute})$0"
    },
    "RPR_CSURF_ONMUTECHANGE python": {
        "prefix": "RPR_CSurf_OnMuteChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnMuteChange(${1:MediaTrack trackid},${2:Int mute})$0"
    },
    "CSURF_ONMUTECHANGEEX c": {
        "prefix": "CSurf_OnMuteChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnMuteChangeEx(${1:MediaTrack* trackid},${2:int mute},${3:bool allowgang})$0"
    },
    "CSURF_ONMUTECHANGEEX eel2": {
        "prefix": "CSurf_OnMuteChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnMuteChangeEx(${1:MediaTrack trackid},${2:int mute},${3:bool allowgang})$0"
    },
    "REAPER.CSURF_ONMUTECHANGEEX lua": {
        "prefix": "reaper.CSurf_OnMuteChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnMuteChangeEx(${1:MediaTrack trackid},${2:integer mute},${3:boolean allowgang})$0"
    },
    "RPR_CSURF_ONMUTECHANGEEX python": {
        "prefix": "RPR_CSurf_OnMuteChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnMuteChangeEx(${1:MediaTrack trackid},${2:Int mute},${3:Boolean allowgang})$0"
    },
    "CSURF_ONPANCHANGE c": {
        "prefix": "CSurf_OnPanChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnPanChange(${1:MediaTrack* trackid},${2:double pan},${3:bool relative})$0"
    },
    "CSURF_ONPANCHANGE eel2": {
        "prefix": "CSurf_OnPanChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnPanChange(${1:MediaTrack trackid},${2:pan},${3:bool relative})$0"
    },
    "REAPER.CSURF_ONPANCHANGE lua": {
        "prefix": "reaper.CSurf_OnPanChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnPanChange(${1:MediaTrack trackid},${2:number pan},${3:boolean relative})$0"
    },
    "RPR_CSURF_ONPANCHANGE python": {
        "prefix": "RPR_CSurf_OnPanChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnPanChange(${1:MediaTrack trackid},${2:Float pan},${3:Boolean relative})$0"
    },
    "CSURF_ONPANCHANGEEX c": {
        "prefix": "CSurf_OnPanChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnPanChangeEx(${1:MediaTrack* trackid},${2:double pan},${3:bool relative},${4:bool allowGang})$0"
    },
    "CSURF_ONPANCHANGEEX eel2": {
        "prefix": "CSurf_OnPanChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnPanChangeEx(${1:MediaTrack trackid},${2:pan},${3:bool relative},${4:bool allowGang})$0"
    },
    "REAPER.CSURF_ONPANCHANGEEX lua": {
        "prefix": "reaper.CSurf_OnPanChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnPanChangeEx(${1:MediaTrack trackid},${2:number pan},${3:boolean relative},${4:boolean allowGang})$0"
    },
    "RPR_CSURF_ONPANCHANGEEX python": {
        "prefix": "RPR_CSurf_OnPanChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnPanChangeEx(${1:MediaTrack trackid},${2:Float pan},${3:Boolean relative},${4:Boolean allowGang})$0"
    },
    "CSURF_ONPAUSE c": {
        "prefix": "CSurf_OnPause",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnPause()$0"
    },
    "CSURF_ONPAUSE eel2": {
        "prefix": "CSurf_OnPause",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnPause()$0"
    },
    "REAPER.CSURF_ONPAUSE lua": {
        "prefix": "reaper.CSurf_OnPause",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnPause()$0"
    },
    "RPR_CSURF_ONPAUSE python": {
        "prefix": "RPR_CSurf_OnPause",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnPause()$0"
    },
    "CSURF_ONPLAY c": {
        "prefix": "CSurf_OnPlay",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnPlay()$0"
    },
    "CSURF_ONPLAY eel2": {
        "prefix": "CSurf_OnPlay",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnPlay()$0"
    },
    "REAPER.CSURF_ONPLAY lua": {
        "prefix": "reaper.CSurf_OnPlay",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnPlay()$0"
    },
    "RPR_CSURF_ONPLAY python": {
        "prefix": "RPR_CSurf_OnPlay",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnPlay()$0"
    },
    "CSURF_ONPLAYRATECHANGE c": {
        "prefix": "CSurf_OnPlayRateChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnPlayRateChange(${1:double playrate})$0"
    },
    "CSURF_ONPLAYRATECHANGE eel2": {
        "prefix": "CSurf_OnPlayRateChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnPlayRateChange(${1:playrate})$0"
    },
    "REAPER.CSURF_ONPLAYRATECHANGE lua": {
        "prefix": "reaper.CSurf_OnPlayRateChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnPlayRateChange(${1:number playrate})$0"
    },
    "RPR_CSURF_ONPLAYRATECHANGE python": {
        "prefix": "RPR_CSurf_OnPlayRateChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnPlayRateChange(${1:Float playrate})$0"
    },
    "CSURF_ONRECARMCHANGE c": {
        "prefix": "CSurf_OnRecArmChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnRecArmChange(${1:MediaTrack* trackid},${2:int recarm})$0"
    },
    "CSURF_ONRECARMCHANGE eel2": {
        "prefix": "CSurf_OnRecArmChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnRecArmChange(${1:MediaTrack trackid},${2:int recarm})$0"
    },
    "REAPER.CSURF_ONRECARMCHANGE lua": {
        "prefix": "reaper.CSurf_OnRecArmChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnRecArmChange(${1:MediaTrack trackid},${2:integer recarm})$0"
    },
    "RPR_CSURF_ONRECARMCHANGE python": {
        "prefix": "RPR_CSurf_OnRecArmChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnRecArmChange(${1:MediaTrack trackid},${2:Int recarm})$0"
    },
    "CSURF_ONRECARMCHANGEEX c": {
        "prefix": "CSurf_OnRecArmChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnRecArmChangeEx(${1:MediaTrack* trackid},${2:int recarm},${3:bool allowgang})$0"
    },
    "CSURF_ONRECARMCHANGEEX eel2": {
        "prefix": "CSurf_OnRecArmChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnRecArmChangeEx(${1:MediaTrack trackid},${2:int recarm},${3:bool allowgang})$0"
    },
    "REAPER.CSURF_ONRECARMCHANGEEX lua": {
        "prefix": "reaper.CSurf_OnRecArmChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnRecArmChangeEx(${1:MediaTrack trackid},${2:integer recarm},${3:boolean allowgang})$0"
    },
    "RPR_CSURF_ONRECARMCHANGEEX python": {
        "prefix": "RPR_CSurf_OnRecArmChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnRecArmChangeEx(${1:MediaTrack trackid},${2:Int recarm},${3:Boolean allowgang})$0"
    },
    "CSURF_ONRECORD c": {
        "prefix": "CSurf_OnRecord",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnRecord()$0"
    },
    "CSURF_ONRECORD eel2": {
        "prefix": "CSurf_OnRecord",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnRecord()$0"
    },
    "REAPER.CSURF_ONRECORD lua": {
        "prefix": "reaper.CSurf_OnRecord",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnRecord()$0"
    },
    "RPR_CSURF_ONRECORD python": {
        "prefix": "RPR_CSurf_OnRecord",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnRecord()$0"
    },
    "CSURF_ONRECVPANCHANGE c": {
        "prefix": "CSurf_OnRecvPanChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnRecvPanChange(${1:MediaTrack* trackid},${2:int recv_index},${3:double pan},${4:bool relative})$0"
    },
    "CSURF_ONRECVPANCHANGE eel2": {
        "prefix": "CSurf_OnRecvPanChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnRecvPanChange(${1:MediaTrack trackid},${2:int recv_index},${3:pan},${4:bool relative})$0"
    },
    "REAPER.CSURF_ONRECVPANCHANGE lua": {
        "prefix": "reaper.CSurf_OnRecvPanChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnRecvPanChange(${1:MediaTrack trackid},${2:integer recv_index},${3:number pan},${4:boolean relative})$0"
    },
    "RPR_CSURF_ONRECVPANCHANGE python": {
        "prefix": "RPR_CSurf_OnRecvPanChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnRecvPanChange(${1:MediaTrack trackid},${2:Int recv_index},${3:Float pan},${4:Boolean relative})$0"
    },
    "CSURF_ONRECVVOLUMECHANGE c": {
        "prefix": "CSurf_OnRecvVolumeChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnRecvVolumeChange(${1:MediaTrack* trackid},${2:int recv_index},${3:double volume},${4:bool relative})$0"
    },
    "CSURF_ONRECVVOLUMECHANGE eel2": {
        "prefix": "CSurf_OnRecvVolumeChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnRecvVolumeChange(${1:MediaTrack trackid},${2:int recv_index},${3:volume},${4:bool relative})$0"
    },
    "REAPER.CSURF_ONRECVVOLUMECHANGE lua": {
        "prefix": "reaper.CSurf_OnRecvVolumeChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnRecvVolumeChange(${1:MediaTrack trackid},${2:integer recv_index},${3:number volume},${4:boolean relative})$0"
    },
    "RPR_CSURF_ONRECVVOLUMECHANGE python": {
        "prefix": "RPR_CSurf_OnRecvVolumeChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnRecvVolumeChange(${1:MediaTrack trackid},${2:Int recv_index},${3:Float volume},${4:Boolean relative})$0"
    },
    "CSURF_ONREW c": {
        "prefix": "CSurf_OnRew",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnRew(${1:int seekplay})$0"
    },
    "CSURF_ONREW eel2": {
        "prefix": "CSurf_OnRew",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnRew(${1:int seekplay})$0"
    },
    "REAPER.CSURF_ONREW lua": {
        "prefix": "reaper.CSurf_OnRew",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnRew(${1:integer seekplay})$0"
    },
    "RPR_CSURF_ONREW python": {
        "prefix": "RPR_CSurf_OnRew",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnRew(${1:Int seekplay})$0"
    },
    "CSURF_ONREWFWD c": {
        "prefix": "CSurf_OnRewFwd",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnRewFwd(${1:int seekplay},${2:int dir})$0"
    },
    "CSURF_ONREWFWD eel2": {
        "prefix": "CSurf_OnRewFwd",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnRewFwd(${1:int seekplay},${2:int dir})$0"
    },
    "REAPER.CSURF_ONREWFWD lua": {
        "prefix": "reaper.CSurf_OnRewFwd",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnRewFwd(${1:integer seekplay},${2:integer dir})$0"
    },
    "RPR_CSURF_ONREWFWD python": {
        "prefix": "RPR_CSurf_OnRewFwd",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnRewFwd(${1:Int seekplay},${2:Int dir})$0"
    },
    "CSURF_ONSCROLL c": {
        "prefix": "CSurf_OnScroll",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnScroll(${1:int xdir},${2:int ydir})$0"
    },
    "CSURF_ONSCROLL eel2": {
        "prefix": "CSurf_OnScroll",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnScroll(${1:int xdir},${2:int ydir})$0"
    },
    "REAPER.CSURF_ONSCROLL lua": {
        "prefix": "reaper.CSurf_OnScroll",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnScroll(${1:integer xdir},${2:integer ydir})$0"
    },
    "RPR_CSURF_ONSCROLL python": {
        "prefix": "RPR_CSurf_OnScroll",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnScroll(${1:Int xdir},${2:Int ydir})$0"
    },
    "CSURF_ONSELECTEDCHANGE c": {
        "prefix": "CSurf_OnSelectedChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnSelectedChange(${1:MediaTrack* trackid},${2:int selected})$0"
    },
    "CSURF_ONSELECTEDCHANGE eel2": {
        "prefix": "CSurf_OnSelectedChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnSelectedChange(${1:MediaTrack trackid},${2:int selected})$0"
    },
    "REAPER.CSURF_ONSELECTEDCHANGE lua": {
        "prefix": "reaper.CSurf_OnSelectedChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnSelectedChange(${1:MediaTrack trackid},${2:integer selected})$0"
    },
    "RPR_CSURF_ONSELECTEDCHANGE python": {
        "prefix": "RPR_CSurf_OnSelectedChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnSelectedChange(${1:MediaTrack trackid},${2:Int selected})$0"
    },
    "CSURF_ONSENDPANCHANGE c": {
        "prefix": "CSurf_OnSendPanChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnSendPanChange(${1:MediaTrack* trackid},${2:int send_index},${3:double pan},${4:bool relative})$0"
    },
    "CSURF_ONSENDPANCHANGE eel2": {
        "prefix": "CSurf_OnSendPanChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnSendPanChange(${1:MediaTrack trackid},${2:int send_index},${3:pan},${4:bool relative})$0"
    },
    "REAPER.CSURF_ONSENDPANCHANGE lua": {
        "prefix": "reaper.CSurf_OnSendPanChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnSendPanChange(${1:MediaTrack trackid},${2:integer send_index},${3:number pan},${4:boolean relative})$0"
    },
    "RPR_CSURF_ONSENDPANCHANGE python": {
        "prefix": "RPR_CSurf_OnSendPanChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnSendPanChange(${1:MediaTrack trackid},${2:Int send_index},${3:Float pan},${4:Boolean relative})$0"
    },
    "CSURF_ONSENDVOLUMECHANGE c": {
        "prefix": "CSurf_OnSendVolumeChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnSendVolumeChange(${1:MediaTrack* trackid},${2:int send_index},${3:double volume},${4:bool relative})$0"
    },
    "CSURF_ONSENDVOLUMECHANGE eel2": {
        "prefix": "CSurf_OnSendVolumeChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnSendVolumeChange(${1:MediaTrack trackid},${2:int send_index},${3:volume},${4:bool relative})$0"
    },
    "REAPER.CSURF_ONSENDVOLUMECHANGE lua": {
        "prefix": "reaper.CSurf_OnSendVolumeChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnSendVolumeChange(${1:MediaTrack trackid},${2:integer send_index},${3:number volume},${4:boolean relative})$0"
    },
    "RPR_CSURF_ONSENDVOLUMECHANGE python": {
        "prefix": "RPR_CSurf_OnSendVolumeChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnSendVolumeChange(${1:MediaTrack trackid},${2:Int send_index},${3:Float volume},${4:Boolean relative})$0"
    },
    "CSURF_ONSOLOCHANGE c": {
        "prefix": "CSurf_OnSoloChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnSoloChange(${1:MediaTrack* trackid},${2:int solo})$0"
    },
    "CSURF_ONSOLOCHANGE eel2": {
        "prefix": "CSurf_OnSoloChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnSoloChange(${1:MediaTrack trackid},${2:int solo})$0"
    },
    "REAPER.CSURF_ONSOLOCHANGE lua": {
        "prefix": "reaper.CSurf_OnSoloChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnSoloChange(${1:MediaTrack trackid},${2:integer solo})$0"
    },
    "RPR_CSURF_ONSOLOCHANGE python": {
        "prefix": "RPR_CSurf_OnSoloChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnSoloChange(${1:MediaTrack trackid},${2:Int solo})$0"
    },
    "CSURF_ONSOLOCHANGEEX c": {
        "prefix": "CSurf_OnSoloChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnSoloChangeEx(${1:MediaTrack* trackid},${2:int solo},${3:bool allowgang})$0"
    },
    "CSURF_ONSOLOCHANGEEX eel2": {
        "prefix": "CSurf_OnSoloChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnSoloChangeEx(${1:MediaTrack trackid},${2:int solo},${3:bool allowgang})$0"
    },
    "REAPER.CSURF_ONSOLOCHANGEEX lua": {
        "prefix": "reaper.CSurf_OnSoloChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnSoloChangeEx(${1:MediaTrack trackid},${2:integer solo},${3:boolean allowgang})$0"
    },
    "RPR_CSURF_ONSOLOCHANGEEX python": {
        "prefix": "RPR_CSurf_OnSoloChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnSoloChangeEx(${1:MediaTrack trackid},${2:Int solo},${3:Boolean allowgang})$0"
    },
    "CSURF_ONSTOP c": {
        "prefix": "CSurf_OnStop",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnStop()$0"
    },
    "CSURF_ONSTOP eel2": {
        "prefix": "CSurf_OnStop",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnStop()$0"
    },
    "REAPER.CSURF_ONSTOP lua": {
        "prefix": "reaper.CSurf_OnStop",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnStop()$0"
    },
    "RPR_CSURF_ONSTOP python": {
        "prefix": "RPR_CSurf_OnStop",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnStop()$0"
    },
    "CSURF_ONTEMPOCHANGE c": {
        "prefix": "CSurf_OnTempoChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnTempoChange(${1:double bpm})$0"
    },
    "CSURF_ONTEMPOCHANGE eel2": {
        "prefix": "CSurf_OnTempoChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnTempoChange(${1:bpm})$0"
    },
    "REAPER.CSURF_ONTEMPOCHANGE lua": {
        "prefix": "reaper.CSurf_OnTempoChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnTempoChange(${1:number bpm})$0"
    },
    "RPR_CSURF_ONTEMPOCHANGE python": {
        "prefix": "RPR_CSurf_OnTempoChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnTempoChange(${1:Float bpm})$0"
    },
    "CSURF_ONTRACKSELECTION c": {
        "prefix": "CSurf_OnTrackSelection",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnTrackSelection(${1:MediaTrack* trackid})$0"
    },
    "CSURF_ONTRACKSELECTION eel2": {
        "prefix": "CSurf_OnTrackSelection",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnTrackSelection(${1:MediaTrack trackid})$0"
    },
    "REAPER.CSURF_ONTRACKSELECTION lua": {
        "prefix": "reaper.CSurf_OnTrackSelection",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnTrackSelection(${1:MediaTrack trackid})$0"
    },
    "RPR_CSURF_ONTRACKSELECTION python": {
        "prefix": "RPR_CSurf_OnTrackSelection",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnTrackSelection(${1:MediaTrack trackid})$0"
    },
    "CSURF_ONVOLUMECHANGE c": {
        "prefix": "CSurf_OnVolumeChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnVolumeChange(${1:MediaTrack* trackid},${2:double volume},${3:bool relative})$0"
    },
    "CSURF_ONVOLUMECHANGE eel2": {
        "prefix": "CSurf_OnVolumeChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnVolumeChange(${1:MediaTrack trackid},${2:volume},${3:bool relative})$0"
    },
    "REAPER.CSURF_ONVOLUMECHANGE lua": {
        "prefix": "reaper.CSurf_OnVolumeChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnVolumeChange(${1:MediaTrack trackid},${2:number volume},${3:boolean relative})$0"
    },
    "RPR_CSURF_ONVOLUMECHANGE python": {
        "prefix": "RPR_CSurf_OnVolumeChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnVolumeChange(${1:MediaTrack trackid},${2:Float volume},${3:Boolean relative})$0"
    },
    "CSURF_ONVOLUMECHANGEEX c": {
        "prefix": "CSurf_OnVolumeChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnVolumeChangeEx(${1:MediaTrack* trackid},${2:double volume},${3:bool relative},${4:bool allowGang})$0"
    },
    "CSURF_ONVOLUMECHANGEEX eel2": {
        "prefix": "CSurf_OnVolumeChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnVolumeChangeEx(${1:MediaTrack trackid},${2:volume},${3:bool relative},${4:bool allowGang})$0"
    },
    "REAPER.CSURF_ONVOLUMECHANGEEX lua": {
        "prefix": "reaper.CSurf_OnVolumeChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnVolumeChangeEx(${1:MediaTrack trackid},${2:number volume},${3:boolean relative},${4:boolean allowGang})$0"
    },
    "RPR_CSURF_ONVOLUMECHANGEEX python": {
        "prefix": "RPR_CSurf_OnVolumeChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnVolumeChangeEx(${1:MediaTrack trackid},${2:Float volume},${3:Boolean relative},${4:Boolean allowGang})$0"
    },
    "CSURF_ONWIDTHCHANGE c": {
        "prefix": "CSurf_OnWidthChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnWidthChange(${1:MediaTrack* trackid},${2:double width},${3:bool relative})$0"
    },
    "CSURF_ONWIDTHCHANGE eel2": {
        "prefix": "CSurf_OnWidthChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnWidthChange(${1:MediaTrack trackid},${2:width},${3:bool relative})$0"
    },
    "REAPER.CSURF_ONWIDTHCHANGE lua": {
        "prefix": "reaper.CSurf_OnWidthChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnWidthChange(${1:MediaTrack trackid},${2:number width},${3:boolean relative})$0"
    },
    "RPR_CSURF_ONWIDTHCHANGE python": {
        "prefix": "RPR_CSurf_OnWidthChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnWidthChange(${1:MediaTrack trackid},${2:Float width},${3:Boolean relative})$0"
    },
    "CSURF_ONWIDTHCHANGEEX c": {
        "prefix": "CSurf_OnWidthChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnWidthChangeEx(${1:MediaTrack* trackid},${2:double width},${3:bool relative},${4:bool allowGang})$0"
    },
    "CSURF_ONWIDTHCHANGEEX eel2": {
        "prefix": "CSurf_OnWidthChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnWidthChangeEx(${1:MediaTrack trackid},${2:width},${3:bool relative},${4:bool allowGang})$0"
    },
    "REAPER.CSURF_ONWIDTHCHANGEEX lua": {
        "prefix": "reaper.CSurf_OnWidthChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnWidthChangeEx(${1:MediaTrack trackid},${2:number width},${3:boolean relative},${4:boolean allowGang})$0"
    },
    "RPR_CSURF_ONWIDTHCHANGEEX python": {
        "prefix": "RPR_CSurf_OnWidthChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnWidthChangeEx(${1:MediaTrack trackid},${2:Float width},${3:Boolean relative},${4:Boolean allowGang})$0"
    },
    "CSURF_ONZOOM c": {
        "prefix": "CSurf_OnZoom",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_OnZoom(${1:int xdir},${2:int ydir})$0"
    },
    "CSURF_ONZOOM eel2": {
        "prefix": "CSurf_OnZoom",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_OnZoom(${1:int xdir},${2:int ydir})$0"
    },
    "REAPER.CSURF_ONZOOM lua": {
        "prefix": "reaper.CSurf_OnZoom",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_OnZoom(${1:integer xdir},${2:integer ydir})$0"
    },
    "RPR_CSURF_ONZOOM python": {
        "prefix": "RPR_CSurf_OnZoom",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_OnZoom(${1:Int xdir},${2:Int ydir})$0"
    },
    "CSURF_RESETALLCACHEDVOLPANSTATES c": {
        "prefix": "CSurf_ResetAllCachedVolPanStates",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_ResetAllCachedVolPanStates()$0"
    },
    "CSURF_RESETALLCACHEDVOLPANSTATES eel2": {
        "prefix": "CSurf_ResetAllCachedVolPanStates",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_ResetAllCachedVolPanStates()$0"
    },
    "REAPER.CSURF_RESETALLCACHEDVOLPANSTATES lua": {
        "prefix": "reaper.CSurf_ResetAllCachedVolPanStates",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_ResetAllCachedVolPanStates()$0"
    },
    "RPR_CSURF_RESETALLCACHEDVOLPANSTATES python": {
        "prefix": "RPR_CSurf_ResetAllCachedVolPanStates",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_ResetAllCachedVolPanStates()$0"
    },
    "CSURF_SCRUBAMT c": {
        "prefix": "CSurf_ScrubAmt",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_ScrubAmt(${1:double amt})$0"
    },
    "CSURF_SCRUBAMT eel2": {
        "prefix": "CSurf_ScrubAmt",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_ScrubAmt(${1:amt})$0"
    },
    "REAPER.CSURF_SCRUBAMT lua": {
        "prefix": "reaper.CSurf_ScrubAmt",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_ScrubAmt(${1:number amt})$0"
    },
    "RPR_CSURF_SCRUBAMT python": {
        "prefix": "RPR_CSurf_ScrubAmt",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_ScrubAmt(${1:Float amt})$0"
    },
    "CSURF_SETAUTOMODE c": {
        "prefix": "CSurf_SetAutoMode",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetAutoMode(${1:int mode},${2:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETAUTOMODE eel2": {
        "prefix": "CSurf_SetAutoMode",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetAutoMode(${1:int mode},${2:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETAUTOMODE lua": {
        "prefix": "reaper.CSurf_SetAutoMode",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetAutoMode(${1:integer mode},${2:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETAUTOMODE python": {
        "prefix": "RPR_CSurf_SetAutoMode",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetAutoMode(${1:Int mode},${2:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETPLAYSTATE c": {
        "prefix": "CSurf_SetPlayState",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetPlayState(${1:bool play},${2:bool pause},${3:bool rec},${4:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETPLAYSTATE eel2": {
        "prefix": "CSurf_SetPlayState",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetPlayState(${1:bool play},${2:bool pause},${3:bool rec},${4:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETPLAYSTATE lua": {
        "prefix": "reaper.CSurf_SetPlayState",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetPlayState(${1:boolean play},${2:boolean pause},${3:boolean rec},${4:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETPLAYSTATE python": {
        "prefix": "RPR_CSurf_SetPlayState",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetPlayState(${1:Boolean play},${2:Boolean pause},${3:Boolean rec},${4:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETREPEATSTATE c": {
        "prefix": "CSurf_SetRepeatState",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetRepeatState(${1:bool rep},${2:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETREPEATSTATE eel2": {
        "prefix": "CSurf_SetRepeatState",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetRepeatState(${1:bool rep},${2:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETREPEATSTATE lua": {
        "prefix": "reaper.CSurf_SetRepeatState",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetRepeatState(${1:boolean rep},${2:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETREPEATSTATE python": {
        "prefix": "RPR_CSurf_SetRepeatState",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetRepeatState(${1:Boolean rep},${2:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETSURFACEMUTE c": {
        "prefix": "CSurf_SetSurfaceMute",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetSurfaceMute(${1:MediaTrack* trackid},${2:bool mute},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACEMUTE eel2": {
        "prefix": "CSurf_SetSurfaceMute",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetSurfaceMute(${1:MediaTrack trackid},${2:bool mute},${3:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETSURFACEMUTE lua": {
        "prefix": "reaper.CSurf_SetSurfaceMute",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetSurfaceMute(${1:MediaTrack trackid},${2:boolean mute},${3:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETSURFACEMUTE python": {
        "prefix": "RPR_CSurf_SetSurfaceMute",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetSurfaceMute(${1:MediaTrack trackid},${2:Boolean mute},${3:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETSURFACEPAN c": {
        "prefix": "CSurf_SetSurfacePan",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetSurfacePan(${1:MediaTrack* trackid},${2:double pan},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACEPAN eel2": {
        "prefix": "CSurf_SetSurfacePan",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetSurfacePan(${1:MediaTrack trackid},${2:pan},${3:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETSURFACEPAN lua": {
        "prefix": "reaper.CSurf_SetSurfacePan",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetSurfacePan(${1:MediaTrack trackid},${2:number pan},${3:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETSURFACEPAN python": {
        "prefix": "RPR_CSurf_SetSurfacePan",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetSurfacePan(${1:MediaTrack trackid},${2:Float pan},${3:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETSURFACERECARM c": {
        "prefix": "CSurf_SetSurfaceRecArm",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetSurfaceRecArm(${1:MediaTrack* trackid},${2:bool recarm},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACERECARM eel2": {
        "prefix": "CSurf_SetSurfaceRecArm",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetSurfaceRecArm(${1:MediaTrack trackid},${2:bool recarm},${3:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETSURFACERECARM lua": {
        "prefix": "reaper.CSurf_SetSurfaceRecArm",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetSurfaceRecArm(${1:MediaTrack trackid},${2:boolean recarm},${3:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETSURFACERECARM python": {
        "prefix": "RPR_CSurf_SetSurfaceRecArm",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetSurfaceRecArm(${1:MediaTrack trackid},${2:Boolean recarm},${3:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETSURFACESELECTED c": {
        "prefix": "CSurf_SetSurfaceSelected",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetSurfaceSelected(${1:MediaTrack* trackid},${2:bool selected},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACESELECTED eel2": {
        "prefix": "CSurf_SetSurfaceSelected",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetSurfaceSelected(${1:MediaTrack trackid},${2:bool selected},${3:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETSURFACESELECTED lua": {
        "prefix": "reaper.CSurf_SetSurfaceSelected",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetSurfaceSelected(${1:MediaTrack trackid},${2:boolean selected},${3:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETSURFACESELECTED python": {
        "prefix": "RPR_CSurf_SetSurfaceSelected",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetSurfaceSelected(${1:MediaTrack trackid},${2:Boolean selected},${3:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETSURFACESOLO c": {
        "prefix": "CSurf_SetSurfaceSolo",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetSurfaceSolo(${1:MediaTrack* trackid},${2:bool solo},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACESOLO eel2": {
        "prefix": "CSurf_SetSurfaceSolo",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetSurfaceSolo(${1:MediaTrack trackid},${2:bool solo},${3:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETSURFACESOLO lua": {
        "prefix": "reaper.CSurf_SetSurfaceSolo",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetSurfaceSolo(${1:MediaTrack trackid},${2:boolean solo},${3:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETSURFACESOLO python": {
        "prefix": "RPR_CSurf_SetSurfaceSolo",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetSurfaceSolo(${1:MediaTrack trackid},${2:Boolean solo},${3:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETSURFACEVOLUME c": {
        "prefix": "CSurf_SetSurfaceVolume",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetSurfaceVolume(${1:MediaTrack* trackid},${2:double volume},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACEVOLUME eel2": {
        "prefix": "CSurf_SetSurfaceVolume",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetSurfaceVolume(${1:MediaTrack trackid},${2:volume},${3:IReaperControlSurface ignoresurf})$0"
    },
    "REAPER.CSURF_SETSURFACEVOLUME lua": {
        "prefix": "reaper.CSurf_SetSurfaceVolume",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetSurfaceVolume(${1:MediaTrack trackid},${2:number volume},${3:IReaperControlSurface ignoresurf})$0"
    },
    "RPR_CSURF_SETSURFACEVOLUME python": {
        "prefix": "RPR_CSurf_SetSurfaceVolume",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetSurfaceVolume(${1:MediaTrack trackid},${2:Float volume},${3:IReaperControlSurface ignoresurf})$0"
    },
    "CSURF_SETTRACKLISTCHANGE c": {
        "prefix": "CSurf_SetTrackListChange",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_SetTrackListChange()$0"
    },
    "CSURF_SETTRACKLISTCHANGE eel2": {
        "prefix": "CSurf_SetTrackListChange",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_SetTrackListChange()$0"
    },
    "REAPER.CSURF_SETTRACKLISTCHANGE lua": {
        "prefix": "reaper.CSurf_SetTrackListChange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_SetTrackListChange()$0"
    },
    "RPR_CSURF_SETTRACKLISTCHANGE python": {
        "prefix": "RPR_CSurf_SetTrackListChange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_SetTrackListChange()$0"
    },
    "CSURF_TRACKFROMID c": {
        "prefix": "CSurf_TrackFromID",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_TrackFromID(${1:int idx},${2:bool mcpView})$0"
    },
    "CSURF_TRACKFROMID eel2": {
        "prefix": "CSurf_TrackFromID",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_TrackFromID(${1:int idx},${2:bool mcpView})$0"
    },
    "REAPER.CSURF_TRACKFROMID lua": {
        "prefix": "reaper.CSurf_TrackFromID",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_TrackFromID(${1:integer idx},${2:boolean mcpView})$0"
    },
    "RPR_CSURF_TRACKFROMID python": {
        "prefix": "RPR_CSurf_TrackFromID",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_TrackFromID(${1:Int idx},${2:Boolean mcpView})$0"
    },
    "CSURF_TRACKTOID c": {
        "prefix": "CSurf_TrackToID",
        "scope": "c",
        "description": "\n",
        "body": "CSurf_TrackToID(${1:MediaTrack* track},${2:bool mcpView})$0"
    },
    "CSURF_TRACKTOID eel2": {
        "prefix": "CSurf_TrackToID",
        "scope": "eel2",
        "description": "\n",
        "body": "CSurf_TrackToID(${1:MediaTrack track},${2:bool mcpView})$0"
    },
    "REAPER.CSURF_TRACKTOID lua": {
        "prefix": "reaper.CSurf_TrackToID",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.CSurf_TrackToID(${1:MediaTrack track},${2:boolean mcpView})$0"
    },
    "RPR_CSURF_TRACKTOID python": {
        "prefix": "RPR_CSurf_TrackToID",
        "scope": "python",
        "description": "\n",
        "body": "RPR_CSurf_TrackToID(${1:MediaTrack track},${2:Boolean mcpView})$0"
    },
    "DB2SLIDER c": {
        "prefix": "DB2SLIDER",
        "scope": "c",
        "description": "\n",
        "body": "DB2SLIDER(${1:double x})$0"
    },
    "DB2SLIDER eel2": {
        "prefix": "DB2SLIDER",
        "scope": "eel2",
        "description": "\n",
        "body": "DB2SLIDER(${1:x})$0"
    },
    "REAPER.DB2SLIDER lua": {
        "prefix": "reaper.DB2SLIDER",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DB2SLIDER(${1:number x})$0"
    },
    "RPR_DB2SLIDER python": {
        "prefix": "RPR_DB2SLIDER",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DB2SLIDER(${1:Float x})$0"
    },
    "DELETEENVELOPEPOINTEX c": {
        "prefix": "DeleteEnvelopePointEx",
        "scope": "c",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "DeleteEnvelopePointEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx},${3:int ptidx})$0"
    },
    "DELETEENVELOPEPOINTEX eel2": {
        "prefix": "DeleteEnvelopePointEx",
        "scope": "eel2",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "DeleteEnvelopePointEx(${1:TrackEnvelope envelope},${2:int autoitem_idx},${3:int ptidx})$0"
    },
    "REAPER.DELETEENVELOPEPOINTEX lua": {
        "prefix": "reaper.DeleteEnvelopePointEx",
        "scope": "lua",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "reaper.DeleteEnvelopePointEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx},${3:integer ptidx})$0"
    },
    "RPR_DELETEENVELOPEPOINTEX python": {
        "prefix": "RPR_DeleteEnvelopePointEx",
        "scope": "python",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "RPR_DeleteEnvelopePointEx(${1:TrackEnvelope envelope},${2:Int autoitem_idx},${3:Int ptidx})$0"
    },
    "DELETEENVELOPEPOINTRANGE c": {
        "prefix": "DeleteEnvelopePointRange",
        "scope": "c",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "DeleteEnvelopePointRange(${1:TrackEnvelope* envelope},${2:double time_start},${3:double time_end})$0"
    },
    "DELETEENVELOPEPOINTRANGE eel2": {
        "prefix": "DeleteEnvelopePointRange",
        "scope": "eel2",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "DeleteEnvelopePointRange(${1:TrackEnvelope envelope},${2:time_start},${3:time_end})$0"
    },
    "REAPER.DELETEENVELOPEPOINTRANGE lua": {
        "prefix": "reaper.DeleteEnvelopePointRange",
        "scope": "lua",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "reaper.DeleteEnvelopePointRange(${1:TrackEnvelope envelope},${2:number time_start},${3:number time_end})$0"
    },
    "RPR_DELETEENVELOPEPOINTRANGE python": {
        "prefix": "RPR_DeleteEnvelopePointRange",
        "scope": "python",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "RPR_DeleteEnvelopePointRange(${1:TrackEnvelope envelope},${2:Float time_start},${3:Float time_end})$0"
    },
    "DELETEENVELOPEPOINTRANGEEX c": {
        "prefix": "DeleteEnvelopePointRangeEx",
        "scope": "c",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "DeleteEnvelopePointRangeEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx},${3:double time_start},${4:double time_end})$0"
    },
    "DELETEENVELOPEPOINTRANGEEX eel2": {
        "prefix": "DeleteEnvelopePointRangeEx",
        "scope": "eel2",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "DeleteEnvelopePointRangeEx(${1:TrackEnvelope envelope},${2:int autoitem_idx},${3:time_start},${4:time_end})$0"
    },
    "REAPER.DELETEENVELOPEPOINTRANGEEX lua": {
        "prefix": "reaper.DeleteEnvelopePointRangeEx",
        "scope": "lua",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "reaper.DeleteEnvelopePointRangeEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx},${3:number time_start},${4:number time_end})$0"
    },
    "RPR_DELETEENVELOPEPOINTRANGEEX python": {
        "prefix": "RPR_DeleteEnvelopePointRangeEx",
        "scope": "python",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "RPR_DeleteEnvelopePointRangeEx(${1:TrackEnvelope envelope},${2:Int autoitem_idx},${3:Float time_start},${4:Float time_end})$0"
    },
    "DELETEEXTSTATE c": {
        "prefix": "DeleteExtState",
        "scope": "c",
        "description": "Delete the extended state value for a specific section and key.\npersist=true means the value should remain deleted the next time REAPER\nis opened. See SetExtState, GetExtState, HasExtState.\n",
        "body": "DeleteExtState(${1:const char* section},${2:const char* key},${3:bool persist})$0"
    },
    "DELETEEXTSTATE eel2": {
        "prefix": "DeleteExtState",
        "scope": "eel2",
        "description": "Delete the extended state value for a specific section and key.\npersist=true means the value should remain deleted the next time REAPER\nis opened. See SetExtState, GetExtState, HasExtState.\n",
        "body": "DeleteExtState(${1:\"section\"},${2:\"key\"},${3:bool persist})$0"
    },
    "REAPER.DELETEEXTSTATE lua": {
        "prefix": "reaper.DeleteExtState",
        "scope": "lua",
        "description": "Delete the extended state value for a specific section and key.\npersist=true means the value should remain deleted the next time REAPER\nis opened. See SetExtState, GetExtState, HasExtState.\n",
        "body": "reaper.DeleteExtState(${1:string section},${2:string key},${3:boolean persist})$0"
    },
    "RPR_DELETEEXTSTATE python": {
        "prefix": "RPR_DeleteExtState",
        "scope": "python",
        "description": "Delete the extended state value for a specific section and key.\npersist=true means the value should remain deleted the next time REAPER\nis opened. See SetExtState, GetExtState, HasExtState.\n",
        "body": "RPR_DeleteExtState(${1:String section},${2:String key},${3:Boolean persist})$0"
    },
    "DELETEPROJECTMARKER c": {
        "prefix": "DeleteProjectMarker",
        "scope": "c",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "DeleteProjectMarker(${1:ReaProject* proj},${2:int markrgnindexnumber},${3:bool isrgn})$0"
    },
    "DELETEPROJECTMARKER eel2": {
        "prefix": "DeleteProjectMarker",
        "scope": "eel2",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "DeleteProjectMarker(${1:ReaProject proj},${2:int markrgnindexnumber},${3:bool isrgn})$0"
    },
    "REAPER.DELETEPROJECTMARKER lua": {
        "prefix": "reaper.DeleteProjectMarker",
        "scope": "lua",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "reaper.DeleteProjectMarker(${1:ReaProject proj},${2:integer markrgnindexnumber},${3:boolean isrgn})$0"
    },
    "RPR_DELETEPROJECTMARKER python": {
        "prefix": "RPR_DeleteProjectMarker",
        "scope": "python",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "RPR_DeleteProjectMarker(${1:ReaProject proj},${2:Int markrgnindexnumber},${3:Boolean isrgn})$0"
    },
    "DELETEPROJECTMARKERBYINDEX c": {
        "prefix": "DeleteProjectMarkerByIndex",
        "scope": "c",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "DeleteProjectMarkerByIndex(${1:ReaProject* proj},${2:int markrgnidx})$0"
    },
    "DELETEPROJECTMARKERBYINDEX eel2": {
        "prefix": "DeleteProjectMarkerByIndex",
        "scope": "eel2",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "DeleteProjectMarkerByIndex(${1:ReaProject proj},${2:int markrgnidx})$0"
    },
    "REAPER.DELETEPROJECTMARKERBYINDEX lua": {
        "prefix": "reaper.DeleteProjectMarkerByIndex",
        "scope": "lua",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "reaper.DeleteProjectMarkerByIndex(${1:ReaProject proj},${2:integer markrgnidx})$0"
    },
    "RPR_DELETEPROJECTMARKERBYINDEX python": {
        "prefix": "RPR_DeleteProjectMarkerByIndex",
        "scope": "python",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "RPR_DeleteProjectMarkerByIndex(${1:ReaProject proj},${2:Int markrgnidx})$0"
    },
    "DELETETAKESTRETCHMARKERS c": {
        "prefix": "DeleteTakeStretchMarkers",
        "scope": "c",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "DeleteTakeStretchMarkers(${1:MediaItem_Take* take},${2:int idx},${3:const int* countInOptional})$0"
    },
    "DELETETAKESTRETCHMARKERS eel2": {
        "prefix": "DeleteTakeStretchMarkers",
        "scope": "eel2",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "DeleteTakeStretchMarkers(${1:MediaItem_Take take},${2:int idx},${3:optional int countIn})$0"
    },
    "REAPER.DELETETAKESTRETCHMARKERS lua": {
        "prefix": "reaper.DeleteTakeStretchMarkers",
        "scope": "lua",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "reaper.DeleteTakeStretchMarkers(${1:MediaItem_Take take},${2:integer idx},${3:optional number countIn})$0"
    },
    "RPR_DELETETAKESTRETCHMARKERS python": {
        "prefix": "RPR_DeleteTakeStretchMarkers",
        "scope": "python",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "RPR_DeleteTakeStretchMarkers(${1:MediaItem_Take take},${2:Int idx},${3:const int countInOptional})$0"
    },
    "DELETETEMPOTIMESIGMARKER c": {
        "prefix": "DeleteTempoTimeSigMarker",
        "scope": "c",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "DeleteTempoTimeSigMarker(${1:ReaProject* project},${2:int markerindex})$0"
    },
    "DELETETEMPOTIMESIGMARKER eel2": {
        "prefix": "DeleteTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "DeleteTempoTimeSigMarker(${1:ReaProject project},${2:int markerindex})$0"
    },
    "REAPER.DELETETEMPOTIMESIGMARKER lua": {
        "prefix": "reaper.DeleteTempoTimeSigMarker",
        "scope": "lua",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "reaper.DeleteTempoTimeSigMarker(${1:ReaProject project},${2:integer markerindex})$0"
    },
    "RPR_DELETETEMPOTIMESIGMARKER python": {
        "prefix": "RPR_DeleteTempoTimeSigMarker",
        "scope": "python",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "RPR_DeleteTempoTimeSigMarker(${1:ReaProject project},${2:Int markerindex})$0"
    },
    "DELETETRACK c": {
        "prefix": "DeleteTrack",
        "scope": "c",
        "description": "deletes a track\n",
        "body": "DeleteTrack(${1:MediaTrack* tr})$0"
    },
    "DELETETRACK eel2": {
        "prefix": "DeleteTrack",
        "scope": "eel2",
        "description": "deletes a track\n",
        "body": "DeleteTrack(${1:MediaTrack tr})$0"
    },
    "REAPER.DELETETRACK lua": {
        "prefix": "reaper.DeleteTrack",
        "scope": "lua",
        "description": "deletes a track\n",
        "body": "reaper.DeleteTrack(${1:MediaTrack tr})$0"
    },
    "RPR_DELETETRACK python": {
        "prefix": "RPR_DeleteTrack",
        "scope": "python",
        "description": "deletes a track\n",
        "body": "RPR_DeleteTrack(${1:MediaTrack tr})$0"
    },
    "DELETETRACKMEDIAITEM c": {
        "prefix": "DeleteTrackMediaItem",
        "scope": "c",
        "description": "\n",
        "body": "DeleteTrackMediaItem(${1:MediaTrack* tr},${2:MediaItem* it})$0"
    },
    "DELETETRACKMEDIAITEM eel2": {
        "prefix": "DeleteTrackMediaItem",
        "scope": "eel2",
        "description": "\n",
        "body": "DeleteTrackMediaItem(${1:MediaTrack tr},${2:MediaItem it})$0"
    },
    "REAPER.DELETETRACKMEDIAITEM lua": {
        "prefix": "reaper.DeleteTrackMediaItem",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DeleteTrackMediaItem(${1:MediaTrack tr},${2:MediaItem it})$0"
    },
    "RPR_DELETETRACKMEDIAITEM python": {
        "prefix": "RPR_DeleteTrackMediaItem",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DeleteTrackMediaItem(${1:MediaTrack tr},${2:MediaItem it})$0"
    },
    "DESTROYAUDIOACCESSOR c": {
        "prefix": "DestroyAudioAccessor",
        "scope": "c",
        "description": "Destroy an audio accessor. Must only call from the main thread. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "DestroyAudioAccessor(${1:AudioAccessor* accessor})$0"
    },
    "DESTROYAUDIOACCESSOR eel2": {
        "prefix": "DestroyAudioAccessor",
        "scope": "eel2",
        "description": "Destroy an audio accessor. Must only call from the main thread. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "DestroyAudioAccessor(${1:AudioAccessor accessor})$0"
    },
    "REAPER.DESTROYAUDIOACCESSOR lua": {
        "prefix": "reaper.DestroyAudioAccessor",
        "scope": "lua",
        "description": "Destroy an audio accessor. Must only call from the main thread. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "reaper.DestroyAudioAccessor(${1:AudioAccessor accessor})$0"
    },
    "RPR_DESTROYAUDIOACCESSOR python": {
        "prefix": "RPR_DestroyAudioAccessor",
        "scope": "python",
        "description": "Destroy an audio accessor. Must only call from the main thread. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "RPR_DestroyAudioAccessor(${1:AudioAccessor accessor})$0"
    },
    "DOCK_UPDATEDOCKID c": {
        "prefix": "Dock_UpdateDockID",
        "scope": "c",
        "description": "updates preference for docker window ident_str to be in dock whichDock on next open\n",
        "body": "Dock_UpdateDockID(${1:const char* ident_str},${2:int whichDock})$0"
    },
    "DOCK_UPDATEDOCKID eel2": {
        "prefix": "Dock_UpdateDockID",
        "scope": "eel2",
        "description": "updates preference for docker window ident_str to be in dock whichDock on next open\n",
        "body": "Dock_UpdateDockID(${1:\"ident_str\"},${2:int whichDock})$0"
    },
    "REAPER.DOCK_UPDATEDOCKID lua": {
        "prefix": "reaper.Dock_UpdateDockID",
        "scope": "lua",
        "description": "updates preference for docker window ident_str to be in dock whichDock on next open\n",
        "body": "reaper.Dock_UpdateDockID(${1:string ident_str},${2:integer whichDock})$0"
    },
    "RPR_DOCK_UPDATEDOCKID python": {
        "prefix": "RPR_Dock_UpdateDockID",
        "scope": "python",
        "description": "updates preference for docker window ident_str to be in dock whichDock on next open\n",
        "body": "RPR_Dock_UpdateDockID(${1:String ident_str},${2:Int whichDock})$0"
    },
    "DOCKGETPOSITION c": {
        "prefix": "DockGetPosition",
        "scope": "c",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "DockGetPosition(${1:int whichDock})$0"
    },
    "DOCKGETPOSITION eel2": {
        "prefix": "DockGetPosition",
        "scope": "eel2",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "DockGetPosition(${1:int whichDock})$0"
    },
    "REAPER.DOCKGETPOSITION lua": {
        "prefix": "reaper.DockGetPosition",
        "scope": "lua",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "reaper.DockGetPosition(${1:integer whichDock})$0"
    },
    "RPR_DOCKGETPOSITION python": {
        "prefix": "RPR_DockGetPosition",
        "scope": "python",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "RPR_DockGetPosition(${1:Int whichDock})$0"
    },
    "DOCKISCHILDOFDOCK c": {
        "prefix": "DockIsChildOfDock",
        "scope": "c",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "DockIsChildOfDock(${1:HWND hwnd},${2:bool* isFloatingDockerOut})$0"
    },
    "DOCKISCHILDOFDOCK eel2": {
        "prefix": "DockIsChildOfDock",
        "scope": "eel2",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "DockIsChildOfDock(${1:HWND hwnd},${2:bool &isFloatingDocker})$0"
    },
    "REAPER.DOCKISCHILDOFDOCK lua": {
        "prefix": "reaper.DockIsChildOfDock",
        "scope": "lua",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "reaper.DockIsChildOfDock(${1:HWND hwnd})$0"
    },
    "RPR_DOCKISCHILDOFDOCK python": {
        "prefix": "RPR_DockIsChildOfDock",
        "scope": "python",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "RPR_DockIsChildOfDock(${1:hwnd},${2:isFloatingDockerOut})$0"
    },
    "DOCKWINDOWACTIVATE c": {
        "prefix": "DockWindowActivate",
        "scope": "c",
        "description": "\n",
        "body": "DockWindowActivate(${1:HWND hwnd})$0"
    },
    "DOCKWINDOWACTIVATE eel2": {
        "prefix": "DockWindowActivate",
        "scope": "eel2",
        "description": "\n",
        "body": "DockWindowActivate(${1:HWND hwnd})$0"
    },
    "REAPER.DOCKWINDOWACTIVATE lua": {
        "prefix": "reaper.DockWindowActivate",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DockWindowActivate(${1:HWND hwnd})$0"
    },
    "RPR_DOCKWINDOWACTIVATE python": {
        "prefix": "RPR_DockWindowActivate",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DockWindowActivate(${1:HWND hwnd})$0"
    },
    "DOCKWINDOWADD c": {
        "prefix": "DockWindowAdd",
        "scope": "c",
        "description": "\n",
        "body": "DockWindowAdd(${1:HWND hwnd},${2:const char* name},${3:int pos},${4:bool allowShow})$0"
    },
    "DOCKWINDOWADD eel2": {
        "prefix": "DockWindowAdd",
        "scope": "eel2",
        "description": "\n",
        "body": "DockWindowAdd(${1:HWND hwnd},${2:\"name\"},${3:int pos},${4:bool allowShow})$0"
    },
    "REAPER.DOCKWINDOWADD lua": {
        "prefix": "reaper.DockWindowAdd",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DockWindowAdd(${1:HWND hwnd},${2:string name},${3:integer pos},${4:boolean allowShow})$0"
    },
    "RPR_DOCKWINDOWADD python": {
        "prefix": "RPR_DockWindowAdd",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DockWindowAdd(${1:HWND hwnd},${2:String name},${3:Int pos},${4:Boolean allowShow})$0"
    },
    "DOCKWINDOWADDEX c": {
        "prefix": "DockWindowAddEx",
        "scope": "c",
        "description": "\n",
        "body": "DockWindowAddEx(${1:HWND hwnd},${2:const char* name},${3:const char* identstr},${4:bool allowShow})$0"
    },
    "DOCKWINDOWADDEX eel2": {
        "prefix": "DockWindowAddEx",
        "scope": "eel2",
        "description": "\n",
        "body": "DockWindowAddEx(${1:HWND hwnd},${2:\"name\"},${3:\"identstr\"},${4:bool allowShow})$0"
    },
    "REAPER.DOCKWINDOWADDEX lua": {
        "prefix": "reaper.DockWindowAddEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DockWindowAddEx(${1:HWND hwnd},${2:string name},${3:string identstr},${4:boolean allowShow})$0"
    },
    "RPR_DOCKWINDOWADDEX python": {
        "prefix": "RPR_DockWindowAddEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DockWindowAddEx(${1:HWND hwnd},${2:String name},${3:String identstr},${4:Boolean allowShow})$0"
    },
    "DOCKWINDOWREFRESH c": {
        "prefix": "DockWindowRefresh",
        "scope": "c",
        "description": "\n",
        "body": "DockWindowRefresh()$0"
    },
    "DOCKWINDOWREFRESH eel2": {
        "prefix": "DockWindowRefresh",
        "scope": "eel2",
        "description": "\n",
        "body": "DockWindowRefresh()$0"
    },
    "REAPER.DOCKWINDOWREFRESH lua": {
        "prefix": "reaper.DockWindowRefresh",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DockWindowRefresh()$0"
    },
    "RPR_DOCKWINDOWREFRESH python": {
        "prefix": "RPR_DockWindowRefresh",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DockWindowRefresh()$0"
    },
    "DOCKWINDOWREFRESHFORHWND c": {
        "prefix": "DockWindowRefreshForHWND",
        "scope": "c",
        "description": "\n",
        "body": "DockWindowRefreshForHWND(${1:HWND hwnd})$0"
    },
    "DOCKWINDOWREFRESHFORHWND eel2": {
        "prefix": "DockWindowRefreshForHWND",
        "scope": "eel2",
        "description": "\n",
        "body": "DockWindowRefreshForHWND(${1:HWND hwnd})$0"
    },
    "REAPER.DOCKWINDOWREFRESHFORHWND lua": {
        "prefix": "reaper.DockWindowRefreshForHWND",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DockWindowRefreshForHWND(${1:HWND hwnd})$0"
    },
    "RPR_DOCKWINDOWREFRESHFORHWND python": {
        "prefix": "RPR_DockWindowRefreshForHWND",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DockWindowRefreshForHWND(${1:HWND hwnd})$0"
    },
    "DOCKWINDOWREMOVE c": {
        "prefix": "DockWindowRemove",
        "scope": "c",
        "description": "\n",
        "body": "DockWindowRemove(${1:HWND hwnd})$0"
    },
    "DOCKWINDOWREMOVE eel2": {
        "prefix": "DockWindowRemove",
        "scope": "eel2",
        "description": "\n",
        "body": "DockWindowRemove(${1:HWND hwnd})$0"
    },
    "REAPER.DOCKWINDOWREMOVE lua": {
        "prefix": "reaper.DockWindowRemove",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.DockWindowRemove(${1:HWND hwnd})$0"
    },
    "RPR_DOCKWINDOWREMOVE python": {
        "prefix": "RPR_DockWindowRemove",
        "scope": "python",
        "description": "\n",
        "body": "RPR_DockWindowRemove(${1:HWND hwnd})$0"
    },
    "EDITTEMPOTIMESIGMARKER c": {
        "prefix": "EditTempoTimeSigMarker",
        "scope": "c",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "EditTempoTimeSigMarker(${1:ReaProject* project},${2:int markerindex})$0"
    },
    "EDITTEMPOTIMESIGMARKER eel2": {
        "prefix": "EditTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "EditTempoTimeSigMarker(${1:ReaProject project},${2:int markerindex})$0"
    },
    "REAPER.EDITTEMPOTIMESIGMARKER lua": {
        "prefix": "reaper.EditTempoTimeSigMarker",
        "scope": "lua",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "reaper.EditTempoTimeSigMarker(${1:ReaProject project},${2:integer markerindex})$0"
    },
    "RPR_EDITTEMPOTIMESIGMARKER python": {
        "prefix": "RPR_EditTempoTimeSigMarker",
        "scope": "python",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "RPR_EditTempoTimeSigMarker(${1:ReaProject project},${2:Int markerindex})$0"
    },
    "ENSURENOTCOMPLETELYOFFSCREEN c": {
        "prefix": "EnsureNotCompletelyOffscreen",
        "scope": "c",
        "description": "call with a saved window rect for your window and it'll correct any positioning info.\n",
        "body": "EnsureNotCompletelyOffscreen(${1:RECT* rInOut})$0"
    },
    "ENSURENOTCOMPLETELYOFFSCREEN eel2": {
        "prefix": "EnsureNotCompletelyOffscreen",
        "scope": "eel2",
        "description": "call with a saved window rect for your window and it'll correct any positioning info.\n",
        "body": "EnsureNotCompletelyOffscreen(${1:int &r.left},${2:int &r.top},${3:int &r.right},${4:int &r.bot})$0"
    },
    "REAPER.ENSURENOTCOMPLETELYOFFSCREEN lua": {
        "prefix": "reaper.EnsureNotCompletelyOffscreen",
        "scope": "lua",
        "description": "call with a saved window rect for your window and it'll correct any positioning info.\n",
        "body": "reaper.EnsureNotCompletelyOffscreen(${1:numberr.left},${2:numberr.top},${3:numberr.right},${4:numberr.bot})$0"
    },
    "RPR_ENSURENOTCOMPLETELYOFFSCREEN python": {
        "prefix": "RPR_EnsureNotCompletelyOffscreen",
        "scope": "python",
        "description": "call with a saved window rect for your window and it'll correct any positioning info.\n",
        "body": "RPR_EnsureNotCompletelyOffscreen(${1:RECT rInOut})$0"
    },
    "ENUMERATEFILES c": {
        "prefix": "EnumerateFiles",
        "scope": "c",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "EnumerateFiles(${1:const char* path},${2:int fileindex})$0"
    },
    "ENUMERATEFILES eel2": {
        "prefix": "EnumerateFiles",
        "scope": "eel2",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "EnumerateFiles(${1:#retval},${2:\"path\"},${3:int fileindex})$0"
    },
    "REAPER.ENUMERATEFILES lua": {
        "prefix": "reaper.EnumerateFiles",
        "scope": "lua",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "reaper.EnumerateFiles(${1:string path},${2:integer fileindex})$0"
    },
    "RPR_ENUMERATEFILES python": {
        "prefix": "RPR_EnumerateFiles",
        "scope": "python",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "RPR_EnumerateFiles(${1:String path},${2:Int fileindex})$0"
    },
    "ENUMERATESUBDIRECTORIES c": {
        "prefix": "EnumerateSubdirectories",
        "scope": "c",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "EnumerateSubdirectories(${1:const char* path},${2:int subdirindex})$0"
    },
    "ENUMERATESUBDIRECTORIES eel2": {
        "prefix": "EnumerateSubdirectories",
        "scope": "eel2",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "EnumerateSubdirectories(${1:#retval},${2:\"path\"},${3:int subdirindex})$0"
    },
    "REAPER.ENUMERATESUBDIRECTORIES lua": {
        "prefix": "reaper.EnumerateSubdirectories",
        "scope": "lua",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "reaper.EnumerateSubdirectories(${1:string path},${2:integer subdirindex})$0"
    },
    "RPR_ENUMERATESUBDIRECTORIES python": {
        "prefix": "RPR_EnumerateSubdirectories",
        "scope": "python",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "RPR_EnumerateSubdirectories(${1:String path},${2:Int subdirindex})$0"
    },
    "ENUMPITCHSHIFTMODES c": {
        "prefix": "EnumPitchShiftModes",
        "scope": "c",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "EnumPitchShiftModes(${1:int mode},${2:const char** strOut})$0"
    },
    "ENUMPITCHSHIFTMODES eel2": {
        "prefix": "EnumPitchShiftModes",
        "scope": "eel2",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "EnumPitchShiftModes(${1:int mode},${2:#str})$0"
    },
    "REAPER.ENUMPITCHSHIFTMODES lua": {
        "prefix": "reaper.EnumPitchShiftModes",
        "scope": "lua",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "reaper.EnumPitchShiftModes(${1:integer mode})$0"
    },
    "RPR_ENUMPITCHSHIFTMODES python": {
        "prefix": "RPR_EnumPitchShiftModes",
        "scope": "python",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "RPR_EnumPitchShiftModes(${1:Int mode},${2:String strOut})$0"
    },
    "ENUMPITCHSHIFTSUBMODES c": {
        "prefix": "EnumPitchShiftSubModes",
        "scope": "c",
        "description": "Returns submode name, or NULL\n",
        "body": "EnumPitchShiftSubModes(${1:int mode},${2:int submode})$0"
    },
    "ENUMPITCHSHIFTSUBMODES eel2": {
        "prefix": "EnumPitchShiftSubModes",
        "scope": "eel2",
        "description": "Returns submode name, or NULL\n",
        "body": "EnumPitchShiftSubModes(${1:#retval},${2:int mode},${3:int submode})$0"
    },
    "REAPER.ENUMPITCHSHIFTSUBMODES lua": {
        "prefix": "reaper.EnumPitchShiftSubModes",
        "scope": "lua",
        "description": "Returns submode name, or NULL\n",
        "body": "reaper.EnumPitchShiftSubModes(${1:integer mode},${2:integer submode})$0"
    },
    "RPR_ENUMPITCHSHIFTSUBMODES python": {
        "prefix": "RPR_EnumPitchShiftSubModes",
        "scope": "python",
        "description": "Returns submode name, or NULL\n",
        "body": "RPR_EnumPitchShiftSubModes(${1:Int mode},${2:Int submode})$0"
    },
    "ENUMPROJECTMARKERS c": {
        "prefix": "EnumProjectMarkers",
        "scope": "c",
        "description": "\n",
        "body": "EnumProjectMarkers(${1:int idx},${2:bool* isrgnOut},${3:double* posOut},${4:double* rgnendOut},${5:const char** nameOut},${6:int* markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS eel2": {
        "prefix": "EnumProjectMarkers",
        "scope": "eel2",
        "description": "\n",
        "body": "EnumProjectMarkers(${1:int idx},${2:bool &isrgn},${3:&pos},${4:&rgnend},${5:#name},${6:int &markrgnindexnumber})$0"
    },
    "REAPER.ENUMPROJECTMARKERS lua": {
        "prefix": "reaper.EnumProjectMarkers",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.EnumProjectMarkers(${1:integer idx})$0"
    },
    "RPR_ENUMPROJECTMARKERS python": {
        "prefix": "RPR_EnumProjectMarkers",
        "scope": "python",
        "description": "\n",
        "body": "RPR_EnumProjectMarkers(${1:idx},${2:isrgnOut},${3:posOut},${4:rgnendOut},${5:nameOut},${6:markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS2 c": {
        "prefix": "EnumProjectMarkers2",
        "scope": "c",
        "description": "\n",
        "body": "EnumProjectMarkers2(${1:ReaProject* proj},${2:int idx},${3:bool* isrgnOut},${4:double* posOut},${5:double* rgnendOut},${6:const char** nameOut},${7:int* markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS2 eel2": {
        "prefix": "EnumProjectMarkers2",
        "scope": "eel2",
        "description": "\n",
        "body": "EnumProjectMarkers2(${1:ReaProject proj},${2:int idx},${3:bool &isrgn},${4:&pos},${5:&rgnend},${6:#name},${7:int &markrgnindexnumber})$0"
    },
    "REAPER.ENUMPROJECTMARKERS2 lua": {
        "prefix": "reaper.EnumProjectMarkers2",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.EnumProjectMarkers2(${1:ReaProject proj},${2:integer idx})$0"
    },
    "RPR_ENUMPROJECTMARKERS2 python": {
        "prefix": "RPR_EnumProjectMarkers2",
        "scope": "python",
        "description": "\n",
        "body": "RPR_EnumProjectMarkers2(${1:proj},${2:idx},${3:isrgnOut},${4:posOut},${5:rgnendOut},${6:nameOut},${7:markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS3 c": {
        "prefix": "EnumProjectMarkers3",
        "scope": "c",
        "description": "\n",
        "body": "EnumProjectMarkers3(${1:ReaProject* proj},${2:int idx},${3:bool* isrgnOut},${4:double* posOut},${5:double* rgnendOut},${6:const char** nameOut},${7:int* markrgnindexnumberOut},${8:int* colorOut})$0"
    },
    "ENUMPROJECTMARKERS3 eel2": {
        "prefix": "EnumProjectMarkers3",
        "scope": "eel2",
        "description": "\n",
        "body": "EnumProjectMarkers3(${1:ReaProject proj},${2:int idx},${3:bool &isrgn},${4:&pos},${5:&rgnend},${6:#name},${7:int &markrgnindexnumber},${8:int &color})$0"
    },
    "REAPER.ENUMPROJECTMARKERS3 lua": {
        "prefix": "reaper.EnumProjectMarkers3",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.EnumProjectMarkers3(${1:ReaProject proj},${2:integer idx})$0"
    },
    "RPR_ENUMPROJECTMARKERS3 python": {
        "prefix": "RPR_EnumProjectMarkers3",
        "scope": "python",
        "description": "\n",
        "body": "RPR_EnumProjectMarkers3(${1:proj},${2:idx},${3:isrgnOut},${4:posOut},${5:rgnendOut},${6:nameOut},${7:markrgnindexnumberOut},${8:colorOut})$0"
    },
    "ENUMPROJECTS c": {
        "prefix": "EnumProjects",
        "scope": "c",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "EnumProjects(${1:int idx},${2:char* projfnOutOptional},${3:int projfnOutOptional_sz})$0"
    },
    "ENUMPROJECTS eel2": {
        "prefix": "EnumProjects",
        "scope": "eel2",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "EnumProjects(${1:int idx},${2:optional #projfn})$0"
    },
    "REAPER.ENUMPROJECTS lua": {
        "prefix": "reaper.EnumProjects",
        "scope": "lua",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "reaper.EnumProjects(${1:integer idx})$0"
    },
    "RPR_ENUMPROJECTS python": {
        "prefix": "RPR_EnumProjects",
        "scope": "python",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "RPR_EnumProjects(${1:idx},${2:projfnOutOptional},${3:projfnOutOptional_sz})$0"
    },
    "ENUMPROJEXTSTATE c": {
        "prefix": "EnumProjExtState",
        "scope": "c",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "EnumProjExtState(${1:ReaProject* proj},${2:const char* extname},${3:int idx},${4:char* keyOutOptional},${5:int keyOutOptional_sz},${6:char* valOutOptional},${7:int valOutOptional_sz})$0"
    },
    "ENUMPROJEXTSTATE eel2": {
        "prefix": "EnumProjExtState",
        "scope": "eel2",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "EnumProjExtState(${1:ReaProject proj},${2:\"extname\"},${3:int idx},${4:optional #key},${5:optional #val})$0"
    },
    "REAPER.ENUMPROJEXTSTATE lua": {
        "prefix": "reaper.EnumProjExtState",
        "scope": "lua",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "reaper.EnumProjExtState(${1:ReaProject proj},${2:string extname},${3:integer idx})$0"
    },
    "RPR_ENUMPROJEXTSTATE python": {
        "prefix": "RPR_EnumProjExtState",
        "scope": "python",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "RPR_EnumProjExtState(${1:proj},${2:extname},${3:idx},${4:keyOutOptional},${5:keyOutOptional_sz},${6:valOutOptional},${7:valOutOptional_sz})$0"
    },
    "ENUMREGIONRENDERMATRIX c": {
        "prefix": "EnumRegionRenderMatrix",
        "scope": "c",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "EnumRegionRenderMatrix(${1:ReaProject* proj},${2:int regionindex},${3:int rendertrack})$0"
    },
    "ENUMREGIONRENDERMATRIX eel2": {
        "prefix": "EnumRegionRenderMatrix",
        "scope": "eel2",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "EnumRegionRenderMatrix(${1:ReaProject proj},${2:int regionindex},${3:int rendertrack})$0"
    },
    "REAPER.ENUMREGIONRENDERMATRIX lua": {
        "prefix": "reaper.EnumRegionRenderMatrix",
        "scope": "lua",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "reaper.EnumRegionRenderMatrix(${1:ReaProject proj},${2:integer regionindex},${3:integer rendertrack})$0"
    },
    "RPR_ENUMREGIONRENDERMATRIX python": {
        "prefix": "RPR_EnumRegionRenderMatrix",
        "scope": "python",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "RPR_EnumRegionRenderMatrix(${1:ReaProject proj},${2:Int regionindex},${3:Int rendertrack})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMES c": {
        "prefix": "EnumTrackMIDIProgramNames",
        "scope": "c",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "EnumTrackMIDIProgramNames(${1:int track},${2:int programNumber},${3:char* programName},${4:int programName_sz})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMES eel2": {
        "prefix": "EnumTrackMIDIProgramNames",
        "scope": "eel2",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "EnumTrackMIDIProgramNames(${1:int track},${2:int programNumber},${3:#programName})$0"
    },
    "REAPER.ENUMTRACKMIDIPROGRAMNAMES lua": {
        "prefix": "reaper.EnumTrackMIDIProgramNames",
        "scope": "lua",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "reaper.EnumTrackMIDIProgramNames(${1:integer track},${2:integer programNumber},${3:string programName})$0"
    },
    "RPR_ENUMTRACKMIDIPROGRAMNAMES python": {
        "prefix": "RPR_EnumTrackMIDIProgramNames",
        "scope": "python",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "RPR_EnumTrackMIDIProgramNames(${1:track},${2:programNumber},${3:programName},${4:programName_sz})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMESEX c": {
        "prefix": "EnumTrackMIDIProgramNamesEx",
        "scope": "c",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "EnumTrackMIDIProgramNamesEx(${1:ReaProject* proj},${2:MediaTrack* track},${3:int programNumber},${4:char* programName},${5:int programName_sz})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMESEX eel2": {
        "prefix": "EnumTrackMIDIProgramNamesEx",
        "scope": "eel2",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "EnumTrackMIDIProgramNamesEx(${1:ReaProject proj},${2:MediaTrack track},${3:int programNumber},${4:#programName})$0"
    },
    "REAPER.ENUMTRACKMIDIPROGRAMNAMESEX lua": {
        "prefix": "reaper.EnumTrackMIDIProgramNamesEx",
        "scope": "lua",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "reaper.EnumTrackMIDIProgramNamesEx(${1:ReaProject proj},${2:MediaTrack track},${3:integer programNumber},${4:string programName})$0"
    },
    "RPR_ENUMTRACKMIDIPROGRAMNAMESEX python": {
        "prefix": "RPR_EnumTrackMIDIProgramNamesEx",
        "scope": "python",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "RPR_EnumTrackMIDIProgramNamesEx(${1:proj},${2:track},${3:programNumber},${4:programName},${5:programName_sz})$0"
    },
    "ENVELOPE_EVALUATE c": {
        "prefix": "Envelope_Evaluate",
        "scope": "c",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "Envelope_Evaluate(${1:TrackEnvelope* envelope},${2:double time},${3:double samplerate},${4:int samplesRequested},${5:double* valueOutOptional},${6:double* dVdSOutOptional},${7:double* ddVdSOutOptional},${8:double* dddVdSOutOptional})$0"
    },
    "ENVELOPE_EVALUATE eel2": {
        "prefix": "Envelope_Evaluate",
        "scope": "eel2",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "Envelope_Evaluate(${1:TrackEnvelope envelope},${2:time},${3:samplerate},${4:int samplesRequested},${5:optional &value},${6:optional &dVdS},${7:optional &ddVdS},${8:optional &dddVdS})$0"
    },
    "REAPER.ENVELOPE_EVALUATE lua": {
        "prefix": "reaper.Envelope_Evaluate",
        "scope": "lua",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "reaper.Envelope_Evaluate(${1:TrackEnvelope envelope},${2:number time},${3:number samplerate},${4:integer samplesRequested})$0"
    },
    "RPR_ENVELOPE_EVALUATE python": {
        "prefix": "RPR_Envelope_Evaluate",
        "scope": "python",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "RPR_Envelope_Evaluate(${1:envelope},${2:time},${3:samplerate},${4:samplesRequested},${5:valueOutOptional},${6:dVdSOutOptional},${7:ddVdSOutOptional},${8:dddVdSOutOptional})$0"
    },
    "ENVELOPE_FORMATVALUE c": {
        "prefix": "Envelope_FormatValue",
        "scope": "c",
        "description": "Formats the value of an envelope to a user-readable form\n",
        "body": "Envelope_FormatValue(${1:TrackEnvelope* env},${2:double value},${3:char* bufOut},${4:int bufOut_sz})$0"
    },
    "ENVELOPE_FORMATVALUE eel2": {
        "prefix": "Envelope_FormatValue",
        "scope": "eel2",
        "description": "Formats the value of an envelope to a user-readable form\n",
        "body": "Envelope_FormatValue(${1:TrackEnvelope env},${2:value},${3:#buf})$0"
    },
    "REAPER.ENVELOPE_FORMATVALUE lua": {
        "prefix": "reaper.Envelope_FormatValue",
        "scope": "lua",
        "description": "Formats the value of an envelope to a user-readable form\n",
        "body": "reaper.Envelope_FormatValue(${1:TrackEnvelope env},${2:number value})$0"
    },
    "RPR_ENVELOPE_FORMATVALUE python": {
        "prefix": "RPR_Envelope_FormatValue",
        "scope": "python",
        "description": "Formats the value of an envelope to a user-readable form\n",
        "body": "RPR_Envelope_FormatValue(${1:env},${2:value},${3:bufOut},${4:bufOut_sz})$0"
    },
    "ENVELOPE_GETPARENTTAKE c": {
        "prefix": "Envelope_GetParentTake",
        "scope": "c",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "Envelope_GetParentTake(${1:TrackEnvelope* env},${2:int* indexOutOptional},${3:int* index2OutOptional})$0"
    },
    "ENVELOPE_GETPARENTTAKE eel2": {
        "prefix": "Envelope_GetParentTake",
        "scope": "eel2",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "Envelope_GetParentTake(${1:TrackEnvelope env},${2:optional int &index},${3:optional int &index2})$0"
    },
    "REAPER.ENVELOPE_GETPARENTTAKE lua": {
        "prefix": "reaper.Envelope_GetParentTake",
        "scope": "lua",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "reaper.Envelope_GetParentTake(${1:TrackEnvelope env})$0"
    },
    "RPR_ENVELOPE_GETPARENTTAKE python": {
        "prefix": "RPR_Envelope_GetParentTake",
        "scope": "python",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "RPR_Envelope_GetParentTake(${1:env},${2:indexOutOptional},${3:index2OutOptional})$0"
    },
    "ENVELOPE_GETPARENTTRACK c": {
        "prefix": "Envelope_GetParentTrack",
        "scope": "c",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "Envelope_GetParentTrack(${1:TrackEnvelope* env},${2:int* indexOutOptional},${3:int* index2OutOptional})$0"
    },
    "ENVELOPE_GETPARENTTRACK eel2": {
        "prefix": "Envelope_GetParentTrack",
        "scope": "eel2",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "Envelope_GetParentTrack(${1:TrackEnvelope env},${2:optional int &index},${3:optional int &index2})$0"
    },
    "REAPER.ENVELOPE_GETPARENTTRACK lua": {
        "prefix": "reaper.Envelope_GetParentTrack",
        "scope": "lua",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "reaper.Envelope_GetParentTrack(${1:TrackEnvelope env})$0"
    },
    "RPR_ENVELOPE_GETPARENTTRACK python": {
        "prefix": "RPR_Envelope_GetParentTrack",
        "scope": "python",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "RPR_Envelope_GetParentTrack(${1:env},${2:indexOutOptional},${3:index2OutOptional})$0"
    },
    "ENVELOPE_SORTPOINTS c": {
        "prefix": "Envelope_SortPoints",
        "scope": "c",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "Envelope_SortPoints(${1:TrackEnvelope* envelope})$0"
    },
    "ENVELOPE_SORTPOINTS eel2": {
        "prefix": "Envelope_SortPoints",
        "scope": "eel2",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "Envelope_SortPoints(${1:TrackEnvelope envelope})$0"
    },
    "REAPER.ENVELOPE_SORTPOINTS lua": {
        "prefix": "reaper.Envelope_SortPoints",
        "scope": "lua",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "reaper.Envelope_SortPoints(${1:TrackEnvelope envelope})$0"
    },
    "RPR_ENVELOPE_SORTPOINTS python": {
        "prefix": "RPR_Envelope_SortPoints",
        "scope": "python",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "RPR_Envelope_SortPoints(${1:TrackEnvelope envelope})$0"
    },
    "ENVELOPE_SORTPOINTSEX c": {
        "prefix": "Envelope_SortPointsEx",
        "scope": "c",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "Envelope_SortPointsEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx})$0"
    },
    "ENVELOPE_SORTPOINTSEX eel2": {
        "prefix": "Envelope_SortPointsEx",
        "scope": "eel2",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "Envelope_SortPointsEx(${1:TrackEnvelope envelope},${2:int autoitem_idx})$0"
    },
    "REAPER.ENVELOPE_SORTPOINTSEX lua": {
        "prefix": "reaper.Envelope_SortPointsEx",
        "scope": "lua",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "reaper.Envelope_SortPointsEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx})$0"
    },
    "RPR_ENVELOPE_SORTPOINTSEX python": {
        "prefix": "RPR_Envelope_SortPointsEx",
        "scope": "python",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "RPR_Envelope_SortPointsEx(${1:TrackEnvelope envelope},${2:Int autoitem_idx})$0"
    },
    "EXECPROCESS c": {
        "prefix": "ExecProcess",
        "scope": "c",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "ExecProcess(${1:const char* cmdline},${2:int timeoutmsec})$0"
    },
    "EXECPROCESS eel2": {
        "prefix": "ExecProcess",
        "scope": "eel2",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "ExecProcess(${1:#retval},${2:\"cmdline\"},${3:int timeoutmsec})$0"
    },
    "REAPER.EXECPROCESS lua": {
        "prefix": "reaper.ExecProcess",
        "scope": "lua",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "reaper.ExecProcess(${1:string cmdline},${2:integer timeoutmsec})$0"
    },
    "RPR_EXECPROCESS python": {
        "prefix": "RPR_ExecProcess",
        "scope": "python",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "RPR_ExecProcess(${1:String cmdline},${2:Int timeoutmsec})$0"
    },
    "FILE_EXISTS c": {
        "prefix": "file_exists",
        "scope": "c",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "file_exists(${1:const char* path})$0"
    },
    "FILE_EXISTS eel2": {
        "prefix": "file_exists",
        "scope": "eel2",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "file_exists(${1:\"path\"})$0"
    },
    "REAPER.FILE_EXISTS lua": {
        "prefix": "reaper.file_exists",
        "scope": "lua",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "reaper.file_exists(${1:string path})$0"
    },
    "RPR_FILE_EXISTS python": {
        "prefix": "RPR_file_exists",
        "scope": "python",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "RPR_file_exists(${1:String path})$0"
    },
    "FINDTEMPOTIMESIGMARKER c": {
        "prefix": "FindTempoTimeSigMarker",
        "scope": "c",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "FindTempoTimeSigMarker(${1:ReaProject* project},${2:double time})$0"
    },
    "FINDTEMPOTIMESIGMARKER eel2": {
        "prefix": "FindTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "FindTempoTimeSigMarker(${1:ReaProject project},${2:time})$0"
    },
    "REAPER.FINDTEMPOTIMESIGMARKER lua": {
        "prefix": "reaper.FindTempoTimeSigMarker",
        "scope": "lua",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "reaper.FindTempoTimeSigMarker(${1:ReaProject project},${2:number time})$0"
    },
    "RPR_FINDTEMPOTIMESIGMARKER python": {
        "prefix": "RPR_FindTempoTimeSigMarker",
        "scope": "python",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "RPR_FindTempoTimeSigMarker(${1:ReaProject project},${2:Float time})$0"
    },
    "FORMAT_TIMESTR c": {
        "prefix": "format_timestr",
        "scope": "c",
        "description": "Format tpos (which is time in seconds) as hh:mm:ss.sss. See format_timestr_pos, format_timestr_len.\n",
        "body": "format_timestr(${1:double tpos},${2:char* buf},${3:int buf_sz})$0"
    },
    "FORMAT_TIMESTR eel2": {
        "prefix": "format_timestr",
        "scope": "eel2",
        "description": "Format tpos (which is time in seconds) as hh:mm:ss.sss. See format_timestr_pos, format_timestr_len.\n",
        "body": "format_timestr(${1:tpos},${2:#buf})$0"
    },
    "REAPER.FORMAT_TIMESTR lua": {
        "prefix": "reaper.format_timestr",
        "scope": "lua",
        "description": "Format tpos (which is time in seconds) as hh:mm:ss.sss. See format_timestr_pos, format_timestr_len.\n",
        "body": "reaper.format_timestr(${1:number tpos},${2:string buf})$0"
    },
    "RPR_FORMAT_TIMESTR python": {
        "prefix": "RPR_format_timestr",
        "scope": "python",
        "description": "Format tpos (which is time in seconds) as hh:mm:ss.sss. See format_timestr_pos, format_timestr_len.\n",
        "body": "RPR_format_timestr(${1:tpos},${2:buf},${3:buf_sz})$0"
    },
    "FORMAT_TIMESTR_LEN c": {
        "prefix": "format_timestr_len",
        "scope": "c",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\noffset is start of where the length will be calculated from\n",
        "body": "format_timestr_len(${1:double tpos},${2:char* buf},${3:int buf_sz},${4:double offset},${5:int modeoverride})$0"
    },
    "FORMAT_TIMESTR_LEN eel2": {
        "prefix": "format_timestr_len",
        "scope": "eel2",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\noffset is start of where the length will be calculated from\n",
        "body": "format_timestr_len(${1:tpos},${2:#buf},${3:offset},${4:int modeoverride})$0"
    },
    "REAPER.FORMAT_TIMESTR_LEN lua": {
        "prefix": "reaper.format_timestr_len",
        "scope": "lua",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\noffset is start of where the length will be calculated from\n",
        "body": "reaper.format_timestr_len(${1:number tpos},${2:string buf},${3:number offset},${4:integer modeoverride})$0"
    },
    "RPR_FORMAT_TIMESTR_LEN python": {
        "prefix": "RPR_format_timestr_len",
        "scope": "python",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\noffset is start of where the length will be calculated from\n",
        "body": "RPR_format_timestr_len(${1:tpos},${2:buf},${3:buf_sz},${4:offset},${5:modeoverride})$0"
    },
    "FORMAT_TIMESTR_POS c": {
        "prefix": "format_timestr_pos",
        "scope": "c",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "format_timestr_pos(${1:double tpos},${2:char* buf},${3:int buf_sz},${4:int modeoverride})$0"
    },
    "FORMAT_TIMESTR_POS eel2": {
        "prefix": "format_timestr_pos",
        "scope": "eel2",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "format_timestr_pos(${1:tpos},${2:#buf},${3:int modeoverride})$0"
    },
    "REAPER.FORMAT_TIMESTR_POS lua": {
        "prefix": "reaper.format_timestr_pos",
        "scope": "lua",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "reaper.format_timestr_pos(${1:number tpos},${2:string buf},${3:integer modeoverride})$0"
    },
    "RPR_FORMAT_TIMESTR_POS python": {
        "prefix": "RPR_format_timestr_pos",
        "scope": "python",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "RPR_format_timestr_pos(${1:tpos},${2:buf},${3:buf_sz},${4:modeoverride})$0"
    },
    "GENGUID c": {
        "prefix": "genGuid",
        "scope": "c",
        "description": "\n",
        "body": "genGuid(${1:GUID* g})$0"
    },
    "GENGUID eel2": {
        "prefix": "genGuid",
        "scope": "eel2",
        "description": "\n",
        "body": "genGuid(${1:#gGUID})$0"
    },
    "REAPER.GENGUID lua": {
        "prefix": "reaper.genGuid",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.genGuid(${1:string gGUID})$0"
    },
    "RPR_GENGUID python": {
        "prefix": "RPR_genGuid",
        "scope": "python",
        "description": "\n",
        "body": "RPR_genGuid(${1:GUID g})$0"
    },
    "GET_CONFIG_VAR_STRING c": {
        "prefix": "get_config_var_string",
        "scope": "c",
        "description": "gets ini configuration variable value as string\n",
        "body": "get_config_var_string(${1:const char* name},${2:char* bufOut},${3:int bufOut_sz})$0"
    },
    "GET_CONFIG_VAR_STRING eel2": {
        "prefix": "get_config_var_string",
        "scope": "eel2",
        "description": "gets ini configuration variable value as string\n",
        "body": "get_config_var_string(${1:\"name\"},${2:#buf})$0"
    },
    "REAPER.GET_CONFIG_VAR_STRING lua": {
        "prefix": "reaper.get_config_var_string",
        "scope": "lua",
        "description": "gets ini configuration variable value as string\n",
        "body": "reaper.get_config_var_string(${1:string name})$0"
    },
    "RPR_GET_CONFIG_VAR_STRING python": {
        "prefix": "RPR_get_config_var_string",
        "scope": "python",
        "description": "gets ini configuration variable value as string\n",
        "body": "RPR_get_config_var_string(${1:name},${2:bufOut},${3:bufOut_sz})$0"
    },
    "GET_INI_FILE c": {
        "prefix": "get_ini_file",
        "scope": "c",
        "description": "Get reaper.ini full filename.\n",
        "body": "get_ini_file()$0"
    },
    "GET_INI_FILE eel2": {
        "prefix": "get_ini_file",
        "scope": "eel2",
        "description": "Get reaper.ini full filename.\n",
        "body": "get_ini_file(${1:#retval})$0"
    },
    "REAPER.GET_INI_FILE lua": {
        "prefix": "reaper.get_ini_file",
        "scope": "lua",
        "description": "Get reaper.ini full filename.\n",
        "body": "reaper.get_ini_file()$0"
    },
    "RPR_GET_INI_FILE python": {
        "prefix": "RPR_get_ini_file",
        "scope": "python",
        "description": "Get reaper.ini full filename.\n",
        "body": "RPR_get_ini_file()$0"
    },
    "GETACTIVETAKE c": {
        "prefix": "GetActiveTake",
        "scope": "c",
        "description": "get the active take in this item\n",
        "body": "GetActiveTake(${1:MediaItem* item})$0"
    },
    "GETACTIVETAKE eel2": {
        "prefix": "GetActiveTake",
        "scope": "eel2",
        "description": "get the active take in this item\n",
        "body": "GetActiveTake(${1:MediaItem item})$0"
    },
    "REAPER.GETACTIVETAKE lua": {
        "prefix": "reaper.GetActiveTake",
        "scope": "lua",
        "description": "get the active take in this item\n",
        "body": "reaper.GetActiveTake(${1:MediaItem item})$0"
    },
    "RPR_GETACTIVETAKE python": {
        "prefix": "RPR_GetActiveTake",
        "scope": "python",
        "description": "get the active take in this item\n",
        "body": "RPR_GetActiveTake(${1:MediaItem item})$0"
    },
    "GETALLPROJECTPLAYSTATES c": {
        "prefix": "GetAllProjectPlayStates",
        "scope": "c",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "GetAllProjectPlayStates(${1:ReaProject* ignoreProject})$0"
    },
    "GETALLPROJECTPLAYSTATES eel2": {
        "prefix": "GetAllProjectPlayStates",
        "scope": "eel2",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "GetAllProjectPlayStates(${1:ReaProject ignoreProject})$0"
    },
    "REAPER.GETALLPROJECTPLAYSTATES lua": {
        "prefix": "reaper.GetAllProjectPlayStates",
        "scope": "lua",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "reaper.GetAllProjectPlayStates(${1:ReaProject ignoreProject})$0"
    },
    "RPR_GETALLPROJECTPLAYSTATES python": {
        "prefix": "RPR_GetAllProjectPlayStates",
        "scope": "python",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "RPR_GetAllProjectPlayStates(${1:ReaProject ignoreProject})$0"
    },
    "GETAPPVERSION c": {
        "prefix": "GetAppVersion",
        "scope": "c",
        "description": "\n",
        "body": "GetAppVersion()$0"
    },
    "GETAPPVERSION eel2": {
        "prefix": "GetAppVersion",
        "scope": "eel2",
        "description": "\n",
        "body": "GetAppVersion(${1:#retval})$0"
    },
    "REAPER.GETAPPVERSION lua": {
        "prefix": "reaper.GetAppVersion",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetAppVersion()$0"
    },
    "RPR_GETAPPVERSION python": {
        "prefix": "RPR_GetAppVersion",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetAppVersion()$0"
    },
    "GETARMEDCOMMAND c": {
        "prefix": "GetArmedCommand",
        "scope": "c",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "GetArmedCommand(${1:char* secOut},${2:int secOut_sz})$0"
    },
    "GETARMEDCOMMAND eel2": {
        "prefix": "GetArmedCommand",
        "scope": "eel2",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "GetArmedCommand(${1:#sec})$0"
    },
    "REAPER.GETARMEDCOMMAND lua": {
        "prefix": "reaper.GetArmedCommand",
        "scope": "lua",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "reaper.GetArmedCommand()$0"
    },
    "RPR_GETARMEDCOMMAND python": {
        "prefix": "RPR_GetArmedCommand",
        "scope": "python",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "RPR_GetArmedCommand(${1:secOut},${2:secOut_sz})$0"
    },
    "GETAUDIOACCESSORENDTIME c": {
        "prefix": "GetAudioAccessorEndTime",
        "scope": "c",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "GetAudioAccessorEndTime(${1:AudioAccessor* accessor})$0"
    },
    "GETAUDIOACCESSORENDTIME eel2": {
        "prefix": "GetAudioAccessorEndTime",
        "scope": "eel2",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "GetAudioAccessorEndTime(${1:AudioAccessor accessor})$0"
    },
    "REAPER.GETAUDIOACCESSORENDTIME lua": {
        "prefix": "reaper.GetAudioAccessorEndTime",
        "scope": "lua",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "reaper.GetAudioAccessorEndTime(${1:AudioAccessor accessor})$0"
    },
    "RPR_GETAUDIOACCESSORENDTIME python": {
        "prefix": "RPR_GetAudioAccessorEndTime",
        "scope": "python",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "RPR_GetAudioAccessorEndTime(${1:AudioAccessor accessor})$0"
    },
    "GETAUDIOACCESSORHASH c": {
        "prefix": "GetAudioAccessorHash",
        "scope": "c",
        "description": "Deprecated. See AudioAccessorStateChanged instead.\n",
        "body": "GetAudioAccessorHash(${1:AudioAccessor* accessor},${2:char* hashNeed128})$0"
    },
    "GETAUDIOACCESSORHASH eel2": {
        "prefix": "GetAudioAccessorHash",
        "scope": "eel2",
        "description": "Deprecated. See AudioAccessorStateChanged instead.\n",
        "body": "GetAudioAccessorHash(${1:AudioAccessor accessor},${2:#hashNeed128})$0"
    },
    "REAPER.GETAUDIOACCESSORHASH lua": {
        "prefix": "reaper.GetAudioAccessorHash",
        "scope": "lua",
        "description": "Deprecated. See AudioAccessorStateChanged instead.\n",
        "body": "reaper.GetAudioAccessorHash(${1:AudioAccessor accessor},${2:string hashNeed128})$0"
    },
    "RPR_GETAUDIOACCESSORHASH python": {
        "prefix": "RPR_GetAudioAccessorHash",
        "scope": "python",
        "description": "Deprecated. See AudioAccessorStateChanged instead.\n",
        "body": "RPR_GetAudioAccessorHash(${1:accessor},${2:hashNeed128})$0"
    },
    "GETAUDIOACCESSORSAMPLES c": {
        "prefix": "GetAudioAccessorSamples",
        "scope": "c",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "GetAudioAccessorSamples(${1:AudioAccessor* accessor},${2:int samplerate},${3:int numchannels},${4:double starttime_sec},${5:int numsamplesperchannel},${6:double* samplebuffer})$0"
    },
    "GETAUDIOACCESSORSAMPLES eel2": {
        "prefix": "GetAudioAccessorSamples",
        "scope": "eel2",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "GetAudioAccessorSamples(${1:AudioAccessor accessor},${2:int samplerate},${3:int numchannels},${4:starttime_sec},${5:int numsamplesperchannel},${6:buffer_ptr samplebuffer})$0"
    },
    "REAPER.GETAUDIOACCESSORSAMPLES lua": {
        "prefix": "reaper.GetAudioAccessorSamples",
        "scope": "lua",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "reaper.GetAudioAccessorSamples(${1:AudioAccessor accessor},${2:integer samplerate},${3:integer numchannels},${4:number starttime_sec},${5:integer numsamplesperchannel},${6:reaper_array samplebuffer})$0"
    },
    "RPR_GETAUDIOACCESSORSAMPLES python": {
        "prefix": "RPR_GetAudioAccessorSamples",
        "scope": "python",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "RPR_GetAudioAccessorSamples(${1:accessor},${2:samplerate},${3:numchannels},${4:starttime_sec},${5:numsamplesperchannel},${6:samplebuffer})$0"
    },
    "GETAUDIOACCESSORSTARTTIME c": {
        "prefix": "GetAudioAccessorStartTime",
        "scope": "c",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "GetAudioAccessorStartTime(${1:AudioAccessor* accessor})$0"
    },
    "GETAUDIOACCESSORSTARTTIME eel2": {
        "prefix": "GetAudioAccessorStartTime",
        "scope": "eel2",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "GetAudioAccessorStartTime(${1:AudioAccessor accessor})$0"
    },
    "REAPER.GETAUDIOACCESSORSTARTTIME lua": {
        "prefix": "reaper.GetAudioAccessorStartTime",
        "scope": "lua",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "reaper.GetAudioAccessorStartTime(${1:AudioAccessor accessor})$0"
    },
    "RPR_GETAUDIOACCESSORSTARTTIME python": {
        "prefix": "RPR_GetAudioAccessorStartTime",
        "scope": "python",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "RPR_GetAudioAccessorStartTime(${1:AudioAccessor accessor})$0"
    },
    "GETAUDIODEVICEINFO c": {
        "prefix": "GetAudioDeviceInfo",
        "scope": "c",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "GetAudioDeviceInfo(${1:const char* attribute},${2:char* desc},${3:int desc_sz})$0"
    },
    "GETAUDIODEVICEINFO eel2": {
        "prefix": "GetAudioDeviceInfo",
        "scope": "eel2",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "GetAudioDeviceInfo(${1:\"attribute\"},${2:#desc})$0"
    },
    "REAPER.GETAUDIODEVICEINFO lua": {
        "prefix": "reaper.GetAudioDeviceInfo",
        "scope": "lua",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "reaper.GetAudioDeviceInfo(${1:string attribute},${2:string desc})$0"
    },
    "RPR_GETAUDIODEVICEINFO python": {
        "prefix": "RPR_GetAudioDeviceInfo",
        "scope": "python",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "RPR_GetAudioDeviceInfo(${1:attribute},${2:desc},${3:desc_sz})$0"
    },
    "GETCONFIGWANTSDOCK c": {
        "prefix": "GetConfigWantsDock",
        "scope": "c",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "GetConfigWantsDock(${1:const char* ident_str})$0"
    },
    "GETCONFIGWANTSDOCK eel2": {
        "prefix": "GetConfigWantsDock",
        "scope": "eel2",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "GetConfigWantsDock(${1:\"ident_str\"})$0"
    },
    "REAPER.GETCONFIGWANTSDOCK lua": {
        "prefix": "reaper.GetConfigWantsDock",
        "scope": "lua",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "reaper.GetConfigWantsDock(${1:string ident_str})$0"
    },
    "RPR_GETCONFIGWANTSDOCK python": {
        "prefix": "RPR_GetConfigWantsDock",
        "scope": "python",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "RPR_GetConfigWantsDock(${1:String ident_str})$0"
    },
    "GETCURRENTPROJECTINLOADSAVE c": {
        "prefix": "GetCurrentProjectInLoadSave",
        "scope": "c",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "GetCurrentProjectInLoadSave()$0"
    },
    "GETCURRENTPROJECTINLOADSAVE eel2": {
        "prefix": "GetCurrentProjectInLoadSave",
        "scope": "eel2",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "GetCurrentProjectInLoadSave()$0"
    },
    "REAPER.GETCURRENTPROJECTINLOADSAVE lua": {
        "prefix": "reaper.GetCurrentProjectInLoadSave",
        "scope": "lua",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "reaper.GetCurrentProjectInLoadSave()$0"
    },
    "RPR_GETCURRENTPROJECTINLOADSAVE python": {
        "prefix": "RPR_GetCurrentProjectInLoadSave",
        "scope": "python",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "RPR_GetCurrentProjectInLoadSave()$0"
    },
    "GETCURSORCONTEXT c": {
        "prefix": "GetCursorContext",
        "scope": "c",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "GetCursorContext()$0"
    },
    "GETCURSORCONTEXT eel2": {
        "prefix": "GetCursorContext",
        "scope": "eel2",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "GetCursorContext()$0"
    },
    "REAPER.GETCURSORCONTEXT lua": {
        "prefix": "reaper.GetCursorContext",
        "scope": "lua",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "reaper.GetCursorContext()$0"
    },
    "RPR_GETCURSORCONTEXT python": {
        "prefix": "RPR_GetCursorContext",
        "scope": "python",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "RPR_GetCursorContext()$0"
    },
    "GETCURSORCONTEXT2 c": {
        "prefix": "GetCursorContext2",
        "scope": "c",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "GetCursorContext2(${1:bool want_last_valid})$0"
    },
    "GETCURSORCONTEXT2 eel2": {
        "prefix": "GetCursorContext2",
        "scope": "eel2",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "GetCursorContext2(${1:bool want_last_valid})$0"
    },
    "REAPER.GETCURSORCONTEXT2 lua": {
        "prefix": "reaper.GetCursorContext2",
        "scope": "lua",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "reaper.GetCursorContext2(${1:boolean want_last_valid})$0"
    },
    "RPR_GETCURSORCONTEXT2 python": {
        "prefix": "RPR_GetCursorContext2",
        "scope": "python",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "RPR_GetCursorContext2(${1:Boolean want_last_valid})$0"
    },
    "GETCURSORPOSITION c": {
        "prefix": "GetCursorPosition",
        "scope": "c",
        "description": "edit cursor position\n",
        "body": "GetCursorPosition()$0"
    },
    "GETCURSORPOSITION eel2": {
        "prefix": "GetCursorPosition",
        "scope": "eel2",
        "description": "edit cursor position\n",
        "body": "GetCursorPosition()$0"
    },
    "REAPER.GETCURSORPOSITION lua": {
        "prefix": "reaper.GetCursorPosition",
        "scope": "lua",
        "description": "edit cursor position\n",
        "body": "reaper.GetCursorPosition()$0"
    },
    "RPR_GETCURSORPOSITION python": {
        "prefix": "RPR_GetCursorPosition",
        "scope": "python",
        "description": "edit cursor position\n",
        "body": "RPR_GetCursorPosition()$0"
    },
    "GETCURSORPOSITIONEX c": {
        "prefix": "GetCursorPositionEx",
        "scope": "c",
        "description": "edit cursor position\n",
        "body": "GetCursorPositionEx(${1:ReaProject* proj})$0"
    },
    "GETCURSORPOSITIONEX eel2": {
        "prefix": "GetCursorPositionEx",
        "scope": "eel2",
        "description": "edit cursor position\n",
        "body": "GetCursorPositionEx(${1:ReaProject proj})$0"
    },
    "REAPER.GETCURSORPOSITIONEX lua": {
        "prefix": "reaper.GetCursorPositionEx",
        "scope": "lua",
        "description": "edit cursor position\n",
        "body": "reaper.GetCursorPositionEx(${1:ReaProject proj})$0"
    },
    "RPR_GETCURSORPOSITIONEX python": {
        "prefix": "RPR_GetCursorPositionEx",
        "scope": "python",
        "description": "edit cursor position\n",
        "body": "RPR_GetCursorPositionEx(${1:ReaProject proj})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR c": {
        "prefix": "GetDisplayedMediaItemColor",
        "scope": "c",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "GetDisplayedMediaItemColor(${1:MediaItem* item})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR eel2": {
        "prefix": "GetDisplayedMediaItemColor",
        "scope": "eel2",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "GetDisplayedMediaItemColor(${1:MediaItem item})$0"
    },
    "REAPER.GETDISPLAYEDMEDIAITEMCOLOR lua": {
        "prefix": "reaper.GetDisplayedMediaItemColor",
        "scope": "lua",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "reaper.GetDisplayedMediaItemColor(${1:MediaItem item})$0"
    },
    "RPR_GETDISPLAYEDMEDIAITEMCOLOR python": {
        "prefix": "RPR_GetDisplayedMediaItemColor",
        "scope": "python",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "RPR_GetDisplayedMediaItemColor(${1:MediaItem item})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR2 c": {
        "prefix": "GetDisplayedMediaItemColor2",
        "scope": "c",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "GetDisplayedMediaItemColor2(${1:MediaItem* item},${2:MediaItem_Take* take})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR2 eel2": {
        "prefix": "GetDisplayedMediaItemColor2",
        "scope": "eel2",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "GetDisplayedMediaItemColor2(${1:MediaItem item},${2:MediaItem_Take take})$0"
    },
    "REAPER.GETDISPLAYEDMEDIAITEMCOLOR2 lua": {
        "prefix": "reaper.GetDisplayedMediaItemColor2",
        "scope": "lua",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "reaper.GetDisplayedMediaItemColor2(${1:MediaItem item},${2:MediaItem_Take take})$0"
    },
    "RPR_GETDISPLAYEDMEDIAITEMCOLOR2 python": {
        "prefix": "RPR_GetDisplayedMediaItemColor2",
        "scope": "python",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "RPR_GetDisplayedMediaItemColor2(${1:MediaItem item},${2:MediaItem_Take take})$0"
    },
    "GETENVELOPEINFO_VALUE c": {
        "prefix": "GetEnvelopeInfo_Value",
        "scope": "c",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "GetEnvelopeInfo_Value(${1:TrackEnvelope* tr},${2|const char* parmname,\"I_TCPY\",\"I_TCPH\",\"I_TCPY_USED\",\"I_TCPH_USED\",\"P_TRACK\",\"P_ITEM\",\"P_TAKE\"|})$0"
    },
    "GETENVELOPEINFO_VALUE eel2": {
        "prefix": "GetEnvelopeInfo_Value",
        "scope": "eel2",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "GetEnvelopeInfo_Value(${1:TrackEnvelope tr},${2:\"parmname\"})$0"
    },
    "REAPER.GETENVELOPEINFO_VALUE lua": {
        "prefix": "reaper.GetEnvelopeInfo_Value",
        "scope": "lua",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "reaper.GetEnvelopeInfo_Value(${1:TrackEnvelope tr},${2|string parmname,\"I_TCPY\",\"I_TCPH\",\"I_TCPY_USED\",\"I_TCPH_USED\",\"P_TRACK\",\"P_ITEM\",\"P_TAKE\"|})$0"
    },
    "RPR_GETENVELOPEINFO_VALUE python": {
        "prefix": "RPR_GetEnvelopeInfo_Value",
        "scope": "python",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "RPR_GetEnvelopeInfo_Value(${1:TrackEnvelope tr},${2|String parmname,\"I_TCPY\",\"I_TCPH\",\"I_TCPY_USED\",\"I_TCPH_USED\",\"P_TRACK\",\"P_ITEM\",\"P_TAKE\"|})$0"
    },
    "GETENVELOPENAME c": {
        "prefix": "GetEnvelopeName",
        "scope": "c",
        "description": "\n",
        "body": "GetEnvelopeName(${1:TrackEnvelope* env},${2:char* bufOut},${3:int bufOut_sz})$0"
    },
    "GETENVELOPENAME eel2": {
        "prefix": "GetEnvelopeName",
        "scope": "eel2",
        "description": "\n",
        "body": "GetEnvelopeName(${1:TrackEnvelope env},${2:#buf})$0"
    },
    "REAPER.GETENVELOPENAME lua": {
        "prefix": "reaper.GetEnvelopeName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetEnvelopeName(${1:TrackEnvelope env})$0"
    },
    "RPR_GETENVELOPENAME python": {
        "prefix": "RPR_GetEnvelopeName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetEnvelopeName(${1:env},${2:bufOut},${3:bufOut_sz})$0"
    },
    "GETENVELOPEPOINT c": {
        "prefix": "GetEnvelopePoint",
        "scope": "c",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "GetEnvelopePoint(${1:TrackEnvelope* envelope},${2:int ptidx},${3:double* timeOutOptional},${4:double* valueOutOptional},${5:int* shapeOutOptional},${6:double* tensionOutOptional},${7:bool* selectedOutOptional})$0"
    },
    "GETENVELOPEPOINT eel2": {
        "prefix": "GetEnvelopePoint",
        "scope": "eel2",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "GetEnvelopePoint(${1:TrackEnvelope envelope},${2:int ptidx},${3:optional &time},${4:optional &value},${5:optional int &shape},${6:optional &tension},${7:optional bool &selected})$0"
    },
    "REAPER.GETENVELOPEPOINT lua": {
        "prefix": "reaper.GetEnvelopePoint",
        "scope": "lua",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "reaper.GetEnvelopePoint(${1:TrackEnvelope envelope},${2:integer ptidx})$0"
    },
    "RPR_GETENVELOPEPOINT python": {
        "prefix": "RPR_GetEnvelopePoint",
        "scope": "python",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "RPR_GetEnvelopePoint(${1:envelope},${2:ptidx},${3:timeOutOptional},${4:valueOutOptional},${5:shapeOutOptional},${6:tensionOutOptional},${7:selectedOutOptional})$0"
    },
    "GETENVELOPEPOINTBYTIME c": {
        "prefix": "GetEnvelopePointByTime",
        "scope": "c",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "GetEnvelopePointByTime(${1:TrackEnvelope* envelope},${2:double time})$0"
    },
    "GETENVELOPEPOINTBYTIME eel2": {
        "prefix": "GetEnvelopePointByTime",
        "scope": "eel2",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "GetEnvelopePointByTime(${1:TrackEnvelope envelope},${2:time})$0"
    },
    "REAPER.GETENVELOPEPOINTBYTIME lua": {
        "prefix": "reaper.GetEnvelopePointByTime",
        "scope": "lua",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "reaper.GetEnvelopePointByTime(${1:TrackEnvelope envelope},${2:number time})$0"
    },
    "RPR_GETENVELOPEPOINTBYTIME python": {
        "prefix": "RPR_GetEnvelopePointByTime",
        "scope": "python",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "RPR_GetEnvelopePointByTime(${1:TrackEnvelope envelope},${2:Float time})$0"
    },
    "GETENVELOPEPOINTBYTIMEEX c": {
        "prefix": "GetEnvelopePointByTimeEx",
        "scope": "c",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "GetEnvelopePointByTimeEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx},${3:double time})$0"
    },
    "GETENVELOPEPOINTBYTIMEEX eel2": {
        "prefix": "GetEnvelopePointByTimeEx",
        "scope": "eel2",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "GetEnvelopePointByTimeEx(${1:TrackEnvelope envelope},${2:int autoitem_idx},${3:time})$0"
    },
    "REAPER.GETENVELOPEPOINTBYTIMEEX lua": {
        "prefix": "reaper.GetEnvelopePointByTimeEx",
        "scope": "lua",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "reaper.GetEnvelopePointByTimeEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx},${3:number time})$0"
    },
    "RPR_GETENVELOPEPOINTBYTIMEEX python": {
        "prefix": "RPR_GetEnvelopePointByTimeEx",
        "scope": "python",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "RPR_GetEnvelopePointByTimeEx(${1:TrackEnvelope envelope},${2:Int autoitem_idx},${3:Float time})$0"
    },
    "GETENVELOPEPOINTEX c": {
        "prefix": "GetEnvelopePointEx",
        "scope": "c",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "GetEnvelopePointEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx},${3:int ptidx},${4:double* timeOutOptional},${5:double* valueOutOptional},${6:int* shapeOutOptional},${7:double* tensionOutOptional},${8:bool* selectedOutOptional})$0"
    },
    "GETENVELOPEPOINTEX eel2": {
        "prefix": "GetEnvelopePointEx",
        "scope": "eel2",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "GetEnvelopePointEx(${1:TrackEnvelope envelope},${2:int autoitem_idx},${3:int ptidx},${4:optional &time},${5:optional &value},${6:optional int &shape},${7:optional &tension},${8:optional bool &selected})$0"
    },
    "REAPER.GETENVELOPEPOINTEX lua": {
        "prefix": "reaper.GetEnvelopePointEx",
        "scope": "lua",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "reaper.GetEnvelopePointEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx},${3:integer ptidx})$0"
    },
    "RPR_GETENVELOPEPOINTEX python": {
        "prefix": "RPR_GetEnvelopePointEx",
        "scope": "python",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "RPR_GetEnvelopePointEx(${1:envelope},${2:autoitem_idx},${3:ptidx},${4:timeOutOptional},${5:valueOutOptional},${6:shapeOutOptional},${7:tensionOutOptional},${8:selectedOutOptional})$0"
    },
    "GETENVELOPESCALINGMODE c": {
        "prefix": "GetEnvelopeScalingMode",
        "scope": "c",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "GetEnvelopeScalingMode(${1:TrackEnvelope* env})$0"
    },
    "GETENVELOPESCALINGMODE eel2": {
        "prefix": "GetEnvelopeScalingMode",
        "scope": "eel2",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "GetEnvelopeScalingMode(${1:TrackEnvelope env})$0"
    },
    "REAPER.GETENVELOPESCALINGMODE lua": {
        "prefix": "reaper.GetEnvelopeScalingMode",
        "scope": "lua",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "reaper.GetEnvelopeScalingMode(${1:TrackEnvelope env})$0"
    },
    "RPR_GETENVELOPESCALINGMODE python": {
        "prefix": "RPR_GetEnvelopeScalingMode",
        "scope": "python",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "RPR_GetEnvelopeScalingMode(${1:TrackEnvelope env})$0"
    },
    "GETENVELOPESTATECHUNK c": {
        "prefix": "GetEnvelopeStateChunk",
        "scope": "c",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "GetEnvelopeStateChunk(${1:TrackEnvelope* env},${2:char* strNeedBig},${3:int strNeedBig_sz},${4:bool isundoOptional})$0"
    },
    "GETENVELOPESTATECHUNK eel2": {
        "prefix": "GetEnvelopeStateChunk",
        "scope": "eel2",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "GetEnvelopeStateChunk(${1:TrackEnvelope env},${2:#str},${3:bool isundo})$0"
    },
    "REAPER.GETENVELOPESTATECHUNK lua": {
        "prefix": "reaper.GetEnvelopeStateChunk",
        "scope": "lua",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "reaper.GetEnvelopeStateChunk(${1:TrackEnvelope env},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_GETENVELOPESTATECHUNK python": {
        "prefix": "RPR_GetEnvelopeStateChunk",
        "scope": "python",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "RPR_GetEnvelopeStateChunk(${1:env},${2:strNeedBig},${3:strNeedBig_sz},${4:isundoOptional})$0"
    },
    "GETEXEPATH c": {
        "prefix": "GetExePath",
        "scope": "c",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "GetExePath()$0"
    },
    "GETEXEPATH eel2": {
        "prefix": "GetExePath",
        "scope": "eel2",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "GetExePath(${1:#retval})$0"
    },
    "REAPER.GETEXEPATH lua": {
        "prefix": "reaper.GetExePath",
        "scope": "lua",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "reaper.GetExePath()$0"
    },
    "RPR_GETEXEPATH python": {
        "prefix": "RPR_GetExePath",
        "scope": "python",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "RPR_GetExePath()$0"
    },
    "GETEXTSTATE c": {
        "prefix": "GetExtState",
        "scope": "c",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "GetExtState(${1:const char* section},${2:const char* key})$0"
    },
    "GETEXTSTATE eel2": {
        "prefix": "GetExtState",
        "scope": "eel2",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "GetExtState(${1:#retval},${2:\"section\"},${3:\"key\"})$0"
    },
    "REAPER.GETEXTSTATE lua": {
        "prefix": "reaper.GetExtState",
        "scope": "lua",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "reaper.GetExtState(${1:string section},${2:string key})$0"
    },
    "RPR_GETEXTSTATE python": {
        "prefix": "RPR_GetExtState",
        "scope": "python",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "RPR_GetExtState(${1:String section},${2:String key})$0"
    },
    "GETFOCUSEDFX c": {
        "prefix": "GetFocusedFX",
        "scope": "c",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "GetFocusedFX(${1:int* tracknumberOut},${2:int* itemnumberOut},${3:int* fxnumberOut})$0"
    },
    "GETFOCUSEDFX eel2": {
        "prefix": "GetFocusedFX",
        "scope": "eel2",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "GetFocusedFX(${1:int &tracknumber},${2:int &itemnumber},${3:int &fxnumber})$0"
    },
    "REAPER.GETFOCUSEDFX lua": {
        "prefix": "reaper.GetFocusedFX",
        "scope": "lua",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "reaper.GetFocusedFX()$0"
    },
    "RPR_GETFOCUSEDFX python": {
        "prefix": "RPR_GetFocusedFX",
        "scope": "python",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "RPR_GetFocusedFX(${1:tracknumberOut},${2:itemnumberOut},${3:fxnumberOut})$0"
    },
    "GETFREEDISKSPACEFORRECORDPATH c": {
        "prefix": "GetFreeDiskSpaceForRecordPath",
        "scope": "c",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "GetFreeDiskSpaceForRecordPath(${1:ReaProject* proj},${2:int pathidx})$0"
    },
    "GETFREEDISKSPACEFORRECORDPATH eel2": {
        "prefix": "GetFreeDiskSpaceForRecordPath",
        "scope": "eel2",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "GetFreeDiskSpaceForRecordPath(${1:ReaProject proj},${2:int pathidx})$0"
    },
    "REAPER.GETFREEDISKSPACEFORRECORDPATH lua": {
        "prefix": "reaper.GetFreeDiskSpaceForRecordPath",
        "scope": "lua",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "reaper.GetFreeDiskSpaceForRecordPath(${1:ReaProject proj},${2:integer pathidx})$0"
    },
    "RPR_GETFREEDISKSPACEFORRECORDPATH python": {
        "prefix": "RPR_GetFreeDiskSpaceForRecordPath",
        "scope": "python",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "RPR_GetFreeDiskSpaceForRecordPath(${1:ReaProject proj},${2:Int pathidx})$0"
    },
    "GETFXENVELOPE c": {
        "prefix": "GetFXEnvelope",
        "scope": "c",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "GetFXEnvelope(${1:MediaTrack* track},${2:int fxindex},${3:int parameterindex},${4:bool create})$0"
    },
    "GETFXENVELOPE eel2": {
        "prefix": "GetFXEnvelope",
        "scope": "eel2",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "GetFXEnvelope(${1:MediaTrack track},${2:int fxindex},${3:int parameterindex},${4:bool create})$0"
    },
    "REAPER.GETFXENVELOPE lua": {
        "prefix": "reaper.GetFXEnvelope",
        "scope": "lua",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "reaper.GetFXEnvelope(${1:MediaTrack track},${2:integer fxindex},${3:integer parameterindex},${4:boolean create})$0"
    },
    "RPR_GETFXENVELOPE python": {
        "prefix": "RPR_GetFXEnvelope",
        "scope": "python",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "RPR_GetFXEnvelope(${1:MediaTrack track},${2:Int fxindex},${3:Int parameterindex},${4:Boolean create})$0"
    },
    "GETGLOBALAUTOMATIONOVERRIDE c": {
        "prefix": "GetGlobalAutomationOverride",
        "scope": "c",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "GetGlobalAutomationOverride()$0"
    },
    "GETGLOBALAUTOMATIONOVERRIDE eel2": {
        "prefix": "GetGlobalAutomationOverride",
        "scope": "eel2",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "GetGlobalAutomationOverride()$0"
    },
    "REAPER.GETGLOBALAUTOMATIONOVERRIDE lua": {
        "prefix": "reaper.GetGlobalAutomationOverride",
        "scope": "lua",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "reaper.GetGlobalAutomationOverride()$0"
    },
    "RPR_GETGLOBALAUTOMATIONOVERRIDE python": {
        "prefix": "RPR_GetGlobalAutomationOverride",
        "scope": "python",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "RPR_GetGlobalAutomationOverride()$0"
    },
    "GETHZOOMLEVEL c": {
        "prefix": "GetHZoomLevel",
        "scope": "c",
        "description": "returns pixels/second\n",
        "body": "GetHZoomLevel()$0"
    },
    "GETHZOOMLEVEL eel2": {
        "prefix": "GetHZoomLevel",
        "scope": "eel2",
        "description": "returns pixels/second\n",
        "body": "GetHZoomLevel()$0"
    },
    "REAPER.GETHZOOMLEVEL lua": {
        "prefix": "reaper.GetHZoomLevel",
        "scope": "lua",
        "description": "returns pixels/second\n",
        "body": "reaper.GetHZoomLevel()$0"
    },
    "RPR_GETHZOOMLEVEL python": {
        "prefix": "RPR_GetHZoomLevel",
        "scope": "python",
        "description": "returns pixels/second\n",
        "body": "RPR_GetHZoomLevel()$0"
    },
    "GETINPUTCHANNELNAME c": {
        "prefix": "GetInputChannelName",
        "scope": "c",
        "description": "\n",
        "body": "GetInputChannelName(${1:int channelIndex})$0"
    },
    "GETINPUTCHANNELNAME eel2": {
        "prefix": "GetInputChannelName",
        "scope": "eel2",
        "description": "\n",
        "body": "GetInputChannelName(${1:#retval},${2:int channelIndex})$0"
    },
    "REAPER.GETINPUTCHANNELNAME lua": {
        "prefix": "reaper.GetInputChannelName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetInputChannelName(${1:integer channelIndex})$0"
    },
    "RPR_GETINPUTCHANNELNAME python": {
        "prefix": "RPR_GetInputChannelName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetInputChannelName(${1:Int channelIndex})$0"
    },
    "GETINPUTOUTPUTLATENCY c": {
        "prefix": "GetInputOutputLatency",
        "scope": "c",
        "description": "Gets the audio device input/output latency in samples\n",
        "body": "GetInputOutputLatency(${1:int* inputlatencyOut},${2:int* outputLatencyOut})$0"
    },
    "GETINPUTOUTPUTLATENCY eel2": {
        "prefix": "GetInputOutputLatency",
        "scope": "eel2",
        "description": "Gets the audio device input/output latency in samples\n",
        "body": "GetInputOutputLatency(${1:int &inputlatency},${2:int &outputLatency})$0"
    },
    "REAPER.GETINPUTOUTPUTLATENCY lua": {
        "prefix": "reaper.GetInputOutputLatency",
        "scope": "lua",
        "description": "Gets the audio device input/output latency in samples\n",
        "body": "reaper.GetInputOutputLatency()$0"
    },
    "RPR_GETINPUTOUTPUTLATENCY python": {
        "prefix": "RPR_GetInputOutputLatency",
        "scope": "python",
        "description": "Gets the audio device input/output latency in samples\n",
        "body": "RPR_GetInputOutputLatency(${1:inputlatencyOut},${2:outputLatencyOut})$0"
    },
    "GETITEMEDITINGTIME2 c": {
        "prefix": "GetItemEditingTime2",
        "scope": "c",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "GetItemEditingTime2(${1:PCM_source** which_itemOut},${2:int* flagsOut})$0"
    },
    "GETITEMEDITINGTIME2 eel2": {
        "prefix": "GetItemEditingTime2",
        "scope": "eel2",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "GetItemEditingTime2(${1:PCM_source &which_item},${2:int &flags})$0"
    },
    "REAPER.GETITEMEDITINGTIME2 lua": {
        "prefix": "reaper.GetItemEditingTime2",
        "scope": "lua",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "reaper.GetItemEditingTime2()$0"
    },
    "RPR_GETITEMEDITINGTIME2 python": {
        "prefix": "RPR_GetItemEditingTime2",
        "scope": "python",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "RPR_GetItemEditingTime2(${1:which_itemOut},${2:flagsOut})$0"
    },
    "GETITEMFROMPOINT c": {
        "prefix": "GetItemFromPoint",
        "scope": "c",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "GetItemFromPoint(${1:int screen_x},${2:int screen_y},${3:bool allow_locked},${4:MediaItem_Take** takeOutOptional})$0"
    },
    "GETITEMFROMPOINT eel2": {
        "prefix": "GetItemFromPoint",
        "scope": "eel2",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "GetItemFromPoint(${1:int screen_x},${2:int screen_y},${3:bool allow_locked},${4:MediaItem_Take &take})$0"
    },
    "REAPER.GETITEMFROMPOINT lua": {
        "prefix": "reaper.GetItemFromPoint",
        "scope": "lua",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "reaper.GetItemFromPoint(${1:integer screen_x},${2:integer screen_y},${3:boolean allow_locked})$0"
    },
    "RPR_GETITEMFROMPOINT python": {
        "prefix": "RPR_GetItemFromPoint",
        "scope": "python",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "RPR_GetItemFromPoint(${1:Int screen_x},${2:Int screen_y},${3:Boolean allow_locked},${4:MediaItem_Take* takeOutOptional})$0"
    },
    "GETITEMPROJECTCONTEXT c": {
        "prefix": "GetItemProjectContext",
        "scope": "c",
        "description": "\n",
        "body": "GetItemProjectContext(${1:MediaItem* item})$0"
    },
    "GETITEMPROJECTCONTEXT eel2": {
        "prefix": "GetItemProjectContext",
        "scope": "eel2",
        "description": "\n",
        "body": "GetItemProjectContext(${1:MediaItem item})$0"
    },
    "REAPER.GETITEMPROJECTCONTEXT lua": {
        "prefix": "reaper.GetItemProjectContext",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetItemProjectContext(${1:MediaItem item})$0"
    },
    "RPR_GETITEMPROJECTCONTEXT python": {
        "prefix": "RPR_GetItemProjectContext",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetItemProjectContext(${1:MediaItem item})$0"
    },
    "GETITEMSTATECHUNK c": {
        "prefix": "GetItemStateChunk",
        "scope": "c",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "GetItemStateChunk(${1:MediaItem* item},${2:char* strNeedBig},${3:int strNeedBig_sz},${4:bool isundoOptional})$0"
    },
    "GETITEMSTATECHUNK eel2": {
        "prefix": "GetItemStateChunk",
        "scope": "eel2",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "GetItemStateChunk(${1:MediaItem item},${2:#str},${3:bool isundo})$0"
    },
    "REAPER.GETITEMSTATECHUNK lua": {
        "prefix": "reaper.GetItemStateChunk",
        "scope": "lua",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "reaper.GetItemStateChunk(${1:MediaItem item},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_GETITEMSTATECHUNK python": {
        "prefix": "RPR_GetItemStateChunk",
        "scope": "python",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "RPR_GetItemStateChunk(${1:item},${2:strNeedBig},${3:strNeedBig_sz},${4:isundoOptional})$0"
    },
    "GETLASTCOLORTHEMEFILE c": {
        "prefix": "GetLastColorThemeFile",
        "scope": "c",
        "description": "\n",
        "body": "GetLastColorThemeFile()$0"
    },
    "GETLASTCOLORTHEMEFILE eel2": {
        "prefix": "GetLastColorThemeFile",
        "scope": "eel2",
        "description": "\n",
        "body": "GetLastColorThemeFile(${1:#retval})$0"
    },
    "REAPER.GETLASTCOLORTHEMEFILE lua": {
        "prefix": "reaper.GetLastColorThemeFile",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetLastColorThemeFile()$0"
    },
    "RPR_GETLASTCOLORTHEMEFILE python": {
        "prefix": "RPR_GetLastColorThemeFile",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetLastColorThemeFile()$0"
    },
    "GETLASTMARKERANDCURREGION c": {
        "prefix": "GetLastMarkerAndCurRegion",
        "scope": "c",
        "description": "Get the last project marker before time, and/or the project region that\nincludes time. markeridx and regionidx are returned not necessarily as\nthe displayed marker/region index, but as the index that can be passed\nto EnumProjectMarkers. Either or both of markeridx and regionidx may be\nNULL. See EnumProjectMarkers.\n",
        "body": "GetLastMarkerAndCurRegion(${1:ReaProject* proj},${2:double time},${3:int* markeridxOut},${4:int* regionidxOut})$0"
    },
    "GETLASTMARKERANDCURREGION eel2": {
        "prefix": "GetLastMarkerAndCurRegion",
        "scope": "eel2",
        "description": "Get the last project marker before time, and/or the project region that\nincludes time. markeridx and regionidx are returned not necessarily as\nthe displayed marker/region index, but as the index that can be passed\nto EnumProjectMarkers. Either or both of markeridx and regionidx may be\nNULL. See EnumProjectMarkers.\n",
        "body": "GetLastMarkerAndCurRegion(${1:ReaProject proj},${2:time},${3:int &markeridx},${4:int &regionidx})$0"
    },
    "REAPER.GETLASTMARKERANDCURREGION lua": {
        "prefix": "reaper.GetLastMarkerAndCurRegion",
        "scope": "lua",
        "description": "Get the last project marker before time, and/or the project region that\nincludes time. markeridx and regionidx are returned not necessarily as\nthe displayed marker/region index, but as the index that can be passed\nto EnumProjectMarkers. Either or both of markeridx and regionidx may be\nNULL. See EnumProjectMarkers.\n",
        "body": "reaper.GetLastMarkerAndCurRegion(${1:ReaProject proj},${2:number time})$0"
    },
    "RPR_GETLASTMARKERANDCURREGION python": {
        "prefix": "RPR_GetLastMarkerAndCurRegion",
        "scope": "python",
        "description": "Get the last project marker before time, and/or the project region that\nincludes time. markeridx and regionidx are returned not necessarily as\nthe displayed marker/region index, but as the index that can be passed\nto EnumProjectMarkers. Either or both of markeridx and regionidx may be\nNULL. See EnumProjectMarkers.\n",
        "body": "RPR_GetLastMarkerAndCurRegion(${1:proj},${2:time},${3:markeridxOut},${4:regionidxOut})$0"
    },
    "GETLASTTOUCHEDFX c": {
        "prefix": "GetLastTouchedFX",
        "scope": "c",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "GetLastTouchedFX(${1:int* tracknumberOut},${2:int* fxnumberOut},${3:int* paramnumberOut})$0"
    },
    "GETLASTTOUCHEDFX eel2": {
        "prefix": "GetLastTouchedFX",
        "scope": "eel2",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "GetLastTouchedFX(${1:int &tracknumber},${2:int &fxnumber},${3:int &paramnumber})$0"
    },
    "REAPER.GETLASTTOUCHEDFX lua": {
        "prefix": "reaper.GetLastTouchedFX",
        "scope": "lua",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "reaper.GetLastTouchedFX()$0"
    },
    "RPR_GETLASTTOUCHEDFX python": {
        "prefix": "RPR_GetLastTouchedFX",
        "scope": "python",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "RPR_GetLastTouchedFX(${1:tracknumberOut},${2:fxnumberOut},${3:paramnumberOut})$0"
    },
    "GETLASTTOUCHEDTRACK c": {
        "prefix": "GetLastTouchedTrack",
        "scope": "c",
        "description": "\n",
        "body": "GetLastTouchedTrack()$0"
    },
    "GETLASTTOUCHEDTRACK eel2": {
        "prefix": "GetLastTouchedTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "GetLastTouchedTrack()$0"
    },
    "REAPER.GETLASTTOUCHEDTRACK lua": {
        "prefix": "reaper.GetLastTouchedTrack",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetLastTouchedTrack()$0"
    },
    "RPR_GETLASTTOUCHEDTRACK python": {
        "prefix": "RPR_GetLastTouchedTrack",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetLastTouchedTrack()$0"
    },
    "GETMAINHWND c": {
        "prefix": "GetMainHwnd",
        "scope": "c",
        "description": "\n",
        "body": "GetMainHwnd()$0"
    },
    "GETMAINHWND eel2": {
        "prefix": "GetMainHwnd",
        "scope": "eel2",
        "description": "\n",
        "body": "GetMainHwnd()$0"
    },
    "REAPER.GETMAINHWND lua": {
        "prefix": "reaper.GetMainHwnd",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetMainHwnd()$0"
    },
    "RPR_GETMAINHWND python": {
        "prefix": "RPR_GetMainHwnd",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetMainHwnd()$0"
    },
    "GETMASTERMUTESOLOFLAGS c": {
        "prefix": "GetMasterMuteSoloFlags",
        "scope": "c",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "GetMasterMuteSoloFlags()$0"
    },
    "GETMASTERMUTESOLOFLAGS eel2": {
        "prefix": "GetMasterMuteSoloFlags",
        "scope": "eel2",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "GetMasterMuteSoloFlags()$0"
    },
    "REAPER.GETMASTERMUTESOLOFLAGS lua": {
        "prefix": "reaper.GetMasterMuteSoloFlags",
        "scope": "lua",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "reaper.GetMasterMuteSoloFlags()$0"
    },
    "RPR_GETMASTERMUTESOLOFLAGS python": {
        "prefix": "RPR_GetMasterMuteSoloFlags",
        "scope": "python",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "RPR_GetMasterMuteSoloFlags()$0"
    },
    "GETMASTERTRACK c": {
        "prefix": "GetMasterTrack",
        "scope": "c",
        "description": "\n",
        "body": "GetMasterTrack(${1:ReaProject* proj})$0"
    },
    "GETMASTERTRACK eel2": {
        "prefix": "GetMasterTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "GetMasterTrack(${1:ReaProject proj})$0"
    },
    "REAPER.GETMASTERTRACK lua": {
        "prefix": "reaper.GetMasterTrack",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetMasterTrack(${1:ReaProject proj})$0"
    },
    "RPR_GETMASTERTRACK python": {
        "prefix": "RPR_GetMasterTrack",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetMasterTrack(${1:ReaProject proj})$0"
    },
    "GETMASTERTRACKVISIBILITY c": {
        "prefix": "GetMasterTrackVisibility",
        "scope": "c",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "GetMasterTrackVisibility()$0"
    },
    "GETMASTERTRACKVISIBILITY eel2": {
        "prefix": "GetMasterTrackVisibility",
        "scope": "eel2",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "GetMasterTrackVisibility()$0"
    },
    "REAPER.GETMASTERTRACKVISIBILITY lua": {
        "prefix": "reaper.GetMasterTrackVisibility",
        "scope": "lua",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "reaper.GetMasterTrackVisibility()$0"
    },
    "RPR_GETMASTERTRACKVISIBILITY python": {
        "prefix": "RPR_GetMasterTrackVisibility",
        "scope": "python",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "RPR_GetMasterTrackVisibility()$0"
    },
    "GETMAXMIDIINPUTS c": {
        "prefix": "GetMaxMidiInputs",
        "scope": "c",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "GetMaxMidiInputs()$0"
    },
    "GETMAXMIDIINPUTS eel2": {
        "prefix": "GetMaxMidiInputs",
        "scope": "eel2",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "GetMaxMidiInputs()$0"
    },
    "REAPER.GETMAXMIDIINPUTS lua": {
        "prefix": "reaper.GetMaxMidiInputs",
        "scope": "lua",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "reaper.GetMaxMidiInputs()$0"
    },
    "RPR_GETMAXMIDIINPUTS python": {
        "prefix": "RPR_GetMaxMidiInputs",
        "scope": "python",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "RPR_GetMaxMidiInputs()$0"
    },
    "GETMAXMIDIOUTPUTS c": {
        "prefix": "GetMaxMidiOutputs",
        "scope": "c",
        "description": "\n",
        "body": "GetMaxMidiOutputs()$0"
    },
    "GETMAXMIDIOUTPUTS eel2": {
        "prefix": "GetMaxMidiOutputs",
        "scope": "eel2",
        "description": "\n",
        "body": "GetMaxMidiOutputs()$0"
    },
    "REAPER.GETMAXMIDIOUTPUTS lua": {
        "prefix": "reaper.GetMaxMidiOutputs",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetMaxMidiOutputs()$0"
    },
    "RPR_GETMAXMIDIOUTPUTS python": {
        "prefix": "RPR_GetMaxMidiOutputs",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetMaxMidiOutputs()$0"
    },
    "GETMEDIAITEM c": {
        "prefix": "GetMediaItem",
        "scope": "c",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "GetMediaItem(${1:ReaProject* proj},${2:int itemidx})$0"
    },
    "GETMEDIAITEM eel2": {
        "prefix": "GetMediaItem",
        "scope": "eel2",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "GetMediaItem(${1:ReaProject proj},${2:int itemidx})$0"
    },
    "REAPER.GETMEDIAITEM lua": {
        "prefix": "reaper.GetMediaItem",
        "scope": "lua",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "reaper.GetMediaItem(${1:ReaProject proj},${2:integer itemidx})$0"
    },
    "RPR_GETMEDIAITEM python": {
        "prefix": "RPR_GetMediaItem",
        "scope": "python",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "RPR_GetMediaItem(${1:ReaProject proj},${2:Int itemidx})$0"
    },
    "GETMEDIAITEM_TRACK c": {
        "prefix": "GetMediaItem_Track",
        "scope": "c",
        "description": "Get parent track of media item\n",
        "body": "GetMediaItem_Track(${1:MediaItem* item})$0"
    },
    "GETMEDIAITEM_TRACK eel2": {
        "prefix": "GetMediaItem_Track",
        "scope": "eel2",
        "description": "Get parent track of media item\n",
        "body": "GetMediaItem_Track(${1:MediaItem item})$0"
    },
    "REAPER.GETMEDIAITEM_TRACK lua": {
        "prefix": "reaper.GetMediaItem_Track",
        "scope": "lua",
        "description": "Get parent track of media item\n",
        "body": "reaper.GetMediaItem_Track(${1:MediaItem item})$0"
    },
    "RPR_GETMEDIAITEM_TRACK python": {
        "prefix": "RPR_GetMediaItem_Track",
        "scope": "python",
        "description": "Get parent track of media item\n",
        "body": "RPR_GetMediaItem_Track(${1:MediaItem item})$0"
    },
    "GETMEDIAITEMINFO_VALUE c": {
        "prefix": "GetMediaItemInfo_Value",
        "scope": "c",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "GetMediaItemInfo_Value(${1:MediaItem* item},${2|const char* parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\",\"P_TRACK\"|})$0"
    },
    "GETMEDIAITEMINFO_VALUE eel2": {
        "prefix": "GetMediaItemInfo_Value",
        "scope": "eel2",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "GetMediaItemInfo_Value(${1:MediaItem item},${2:\"parmname\"})$0"
    },
    "REAPER.GETMEDIAITEMINFO_VALUE lua": {
        "prefix": "reaper.GetMediaItemInfo_Value",
        "scope": "lua",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "reaper.GetMediaItemInfo_Value(${1:MediaItem item},${2|string parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\",\"P_TRACK\"|})$0"
    },
    "RPR_GETMEDIAITEMINFO_VALUE python": {
        "prefix": "RPR_GetMediaItemInfo_Value",
        "scope": "python",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "RPR_GetMediaItemInfo_Value(${1:MediaItem item},${2|String parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\",\"P_TRACK\"|})$0"
    },
    "GETMEDIAITEMNUMTAKES c": {
        "prefix": "GetMediaItemNumTakes",
        "scope": "c",
        "description": "\n",
        "body": "GetMediaItemNumTakes(${1:MediaItem* item})$0"
    },
    "GETMEDIAITEMNUMTAKES eel2": {
        "prefix": "GetMediaItemNumTakes",
        "scope": "eel2",
        "description": "\n",
        "body": "GetMediaItemNumTakes(${1:MediaItem item})$0"
    },
    "REAPER.GETMEDIAITEMNUMTAKES lua": {
        "prefix": "reaper.GetMediaItemNumTakes",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetMediaItemNumTakes(${1:MediaItem item})$0"
    },
    "RPR_GETMEDIAITEMNUMTAKES python": {
        "prefix": "RPR_GetMediaItemNumTakes",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetMediaItemNumTakes(${1:MediaItem item})$0"
    },
    "GETMEDIAITEMTAKE c": {
        "prefix": "GetMediaItemTake",
        "scope": "c",
        "description": "\n",
        "body": "GetMediaItemTake(${1:MediaItem* item},${2:int tk})$0"
    },
    "GETMEDIAITEMTAKE eel2": {
        "prefix": "GetMediaItemTake",
        "scope": "eel2",
        "description": "\n",
        "body": "GetMediaItemTake(${1:MediaItem item},${2:int tk})$0"
    },
    "REAPER.GETMEDIAITEMTAKE lua": {
        "prefix": "reaper.GetMediaItemTake",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetMediaItemTake(${1:MediaItem item},${2:integer tk})$0"
    },
    "RPR_GETMEDIAITEMTAKE python": {
        "prefix": "RPR_GetMediaItemTake",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetMediaItemTake(${1:MediaItem item},${2:Int tk})$0"
    },
    "GETMEDIAITEMTAKE_ITEM c": {
        "prefix": "GetMediaItemTake_Item",
        "scope": "c",
        "description": "Get parent item of media item take\n",
        "body": "GetMediaItemTake_Item(${1:MediaItem_Take* take})$0"
    },
    "GETMEDIAITEMTAKE_ITEM eel2": {
        "prefix": "GetMediaItemTake_Item",
        "scope": "eel2",
        "description": "Get parent item of media item take\n",
        "body": "GetMediaItemTake_Item(${1:MediaItem_Take take})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_ITEM lua": {
        "prefix": "reaper.GetMediaItemTake_Item",
        "scope": "lua",
        "description": "Get parent item of media item take\n",
        "body": "reaper.GetMediaItemTake_Item(${1:MediaItem_Take take})$0"
    },
    "RPR_GETMEDIAITEMTAKE_ITEM python": {
        "prefix": "RPR_GetMediaItemTake_Item",
        "scope": "python",
        "description": "Get parent item of media item take\n",
        "body": "RPR_GetMediaItemTake_Item(${1:MediaItem_Take take})$0"
    },
    "GETMEDIAITEMTAKE_PEAKS c": {
        "prefix": "GetMediaItemTake_Peaks",
        "scope": "c",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "GetMediaItemTake_Peaks(${1:MediaItem_Take* take},${2:double peakrate},${3:double starttime},${4:int numchannels},${5:int numsamplesperchannel},${6:int want_extra_type},${7:double* buf})$0"
    },
    "GETMEDIAITEMTAKE_PEAKS eel2": {
        "prefix": "GetMediaItemTake_Peaks",
        "scope": "eel2",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "GetMediaItemTake_Peaks(${1:MediaItem_Take take},${2:peakrate},${3:starttime},${4:int numchannels},${5:int numsamplesperchannel},${6:int want_extra_type},${7:buffer_ptr buf})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_PEAKS lua": {
        "prefix": "reaper.GetMediaItemTake_Peaks",
        "scope": "lua",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "reaper.GetMediaItemTake_Peaks(${1:MediaItem_Take take},${2:number peakrate},${3:number starttime},${4:integer numchannels},${5:integer numsamplesperchannel},${6:integer want_extra_type},${7:reaper_array buf})$0"
    },
    "RPR_GETMEDIAITEMTAKE_PEAKS python": {
        "prefix": "RPR_GetMediaItemTake_Peaks",
        "scope": "python",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "RPR_GetMediaItemTake_Peaks(${1:take},${2:peakrate},${3:starttime},${4:numchannels},${5:numsamplesperchannel},${6:want_extra_type},${7:buf})$0"
    },
    "GETMEDIAITEMTAKE_SOURCE c": {
        "prefix": "GetMediaItemTake_Source",
        "scope": "c",
        "description": "Get media source of media item take\n",
        "body": "GetMediaItemTake_Source(${1:MediaItem_Take* take})$0"
    },
    "GETMEDIAITEMTAKE_SOURCE eel2": {
        "prefix": "GetMediaItemTake_Source",
        "scope": "eel2",
        "description": "Get media source of media item take\n",
        "body": "GetMediaItemTake_Source(${1:MediaItem_Take take})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_SOURCE lua": {
        "prefix": "reaper.GetMediaItemTake_Source",
        "scope": "lua",
        "description": "Get media source of media item take\n",
        "body": "reaper.GetMediaItemTake_Source(${1:MediaItem_Take take})$0"
    },
    "RPR_GETMEDIAITEMTAKE_SOURCE python": {
        "prefix": "RPR_GetMediaItemTake_Source",
        "scope": "python",
        "description": "Get media source of media item take\n",
        "body": "RPR_GetMediaItemTake_Source(${1:MediaItem_Take take})$0"
    },
    "GETMEDIAITEMTAKE_TRACK c": {
        "prefix": "GetMediaItemTake_Track",
        "scope": "c",
        "description": "Get parent track of media item take\n",
        "body": "GetMediaItemTake_Track(${1:MediaItem_Take* take})$0"
    },
    "GETMEDIAITEMTAKE_TRACK eel2": {
        "prefix": "GetMediaItemTake_Track",
        "scope": "eel2",
        "description": "Get parent track of media item take\n",
        "body": "GetMediaItemTake_Track(${1:MediaItem_Take take})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_TRACK lua": {
        "prefix": "reaper.GetMediaItemTake_Track",
        "scope": "lua",
        "description": "Get parent track of media item take\n",
        "body": "reaper.GetMediaItemTake_Track(${1:MediaItem_Take take})$0"
    },
    "RPR_GETMEDIAITEMTAKE_TRACK python": {
        "prefix": "RPR_GetMediaItemTake_Track",
        "scope": "python",
        "description": "Get parent track of media item take\n",
        "body": "RPR_GetMediaItemTake_Track(${1:MediaItem_Take take})$0"
    },
    "GETMEDIAITEMTAKEBYGUID c": {
        "prefix": "GetMediaItemTakeByGUID",
        "scope": "c",
        "description": "\n",
        "body": "GetMediaItemTakeByGUID(${1:ReaProject* project},${2:const GUID* guid})$0"
    },
    "GETMEDIAITEMTAKEBYGUID eel2": {
        "prefix": "GetMediaItemTakeByGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "GetMediaItemTakeByGUID(${1:ReaProject project},${2:\"guidGUID\"})$0"
    },
    "REAPER.GETMEDIAITEMTAKEBYGUID lua": {
        "prefix": "reaper.GetMediaItemTakeByGUID",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetMediaItemTakeByGUID(${1:ReaProject project},${2:string guidGUID})$0"
    },
    "RPR_GETMEDIAITEMTAKEBYGUID python": {
        "prefix": "RPR_GetMediaItemTakeByGUID",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetMediaItemTakeByGUID(${1:ReaProject project},${2:const GUID guid})$0"
    },
    "GETMEDIAITEMTAKEINFO_VALUE c": {
        "prefix": "GetMediaItemTakeInfo_Value",
        "scope": "c",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "GetMediaItemTakeInfo_Value(${1:MediaItem_Take* take},${2|const char* parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\",\"P_TRACK\",\"P_ITEM\",\"P_SOURCE\"|})$0"
    },
    "GETMEDIAITEMTAKEINFO_VALUE eel2": {
        "prefix": "GetMediaItemTakeInfo_Value",
        "scope": "eel2",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "GetMediaItemTakeInfo_Value(${1:MediaItem_Take take},${2:\"parmname\"})$0"
    },
    "REAPER.GETMEDIAITEMTAKEINFO_VALUE lua": {
        "prefix": "reaper.GetMediaItemTakeInfo_Value",
        "scope": "lua",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "reaper.GetMediaItemTakeInfo_Value(${1:MediaItem_Take take},${2|string parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\",\"P_TRACK\",\"P_ITEM\",\"P_SOURCE\"|})$0"
    },
    "RPR_GETMEDIAITEMTAKEINFO_VALUE python": {
        "prefix": "RPR_GetMediaItemTakeInfo_Value",
        "scope": "python",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "RPR_GetMediaItemTakeInfo_Value(${1:MediaItem_Take take},${2|String parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\",\"P_TRACK\",\"P_ITEM\",\"P_SOURCE\"|})$0"
    },
    "GETMEDIAITEMTRACK c": {
        "prefix": "GetMediaItemTrack",
        "scope": "c",
        "description": "\n",
        "body": "GetMediaItemTrack(${1:MediaItem* item})$0"
    },
    "GETMEDIAITEMTRACK eel2": {
        "prefix": "GetMediaItemTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "GetMediaItemTrack(${1:MediaItem item})$0"
    },
    "REAPER.GETMEDIAITEMTRACK lua": {
        "prefix": "reaper.GetMediaItemTrack",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetMediaItemTrack(${1:MediaItem item})$0"
    },
    "RPR_GETMEDIAITEMTRACK python": {
        "prefix": "RPR_GetMediaItemTrack",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetMediaItemTrack(${1:MediaItem item})$0"
    },
    "GETMEDIASOURCEFILENAME c": {
        "prefix": "GetMediaSourceFileName",
        "scope": "c",
        "description": "Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename. See GetMediaSourceParent.\n",
        "body": "GetMediaSourceFileName(${1:PCM_source* source},${2:char* filenamebuf},${3:int filenamebuf_sz})$0"
    },
    "GETMEDIASOURCEFILENAME eel2": {
        "prefix": "GetMediaSourceFileName",
        "scope": "eel2",
        "description": "Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename. See GetMediaSourceParent.\n",
        "body": "GetMediaSourceFileName(${1:PCM_source source},${2:#filenamebuf})$0"
    },
    "REAPER.GETMEDIASOURCEFILENAME lua": {
        "prefix": "reaper.GetMediaSourceFileName",
        "scope": "lua",
        "description": "Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename. See GetMediaSourceParent.\n",
        "body": "reaper.GetMediaSourceFileName(${1:PCM_source source},${2:string filenamebuf})$0"
    },
    "RPR_GETMEDIASOURCEFILENAME python": {
        "prefix": "RPR_GetMediaSourceFileName",
        "scope": "python",
        "description": "Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename. See GetMediaSourceParent.\n",
        "body": "RPR_GetMediaSourceFileName(${1:source},${2:filenamebuf},${3:filenamebuf_sz})$0"
    },
    "GETMEDIASOURCELENGTH c": {
        "prefix": "GetMediaSourceLength",
        "scope": "c",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "GetMediaSourceLength(${1:PCM_source* source},${2:bool* lengthIsQNOut})$0"
    },
    "GETMEDIASOURCELENGTH eel2": {
        "prefix": "GetMediaSourceLength",
        "scope": "eel2",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "GetMediaSourceLength(${1:PCM_source source},${2:bool &lengthIsQN})$0"
    },
    "REAPER.GETMEDIASOURCELENGTH lua": {
        "prefix": "reaper.GetMediaSourceLength",
        "scope": "lua",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "reaper.GetMediaSourceLength(${1:PCM_source source})$0"
    },
    "RPR_GETMEDIASOURCELENGTH python": {
        "prefix": "RPR_GetMediaSourceLength",
        "scope": "python",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "RPR_GetMediaSourceLength(${1:source},${2:lengthIsQNOut})$0"
    },
    "GETMEDIASOURCENUMCHANNELS c": {
        "prefix": "GetMediaSourceNumChannels",
        "scope": "c",
        "description": "Returns the number of channels in the source media.\n",
        "body": "GetMediaSourceNumChannels(${1:PCM_source* source})$0"
    },
    "GETMEDIASOURCENUMCHANNELS eel2": {
        "prefix": "GetMediaSourceNumChannels",
        "scope": "eel2",
        "description": "Returns the number of channels in the source media.\n",
        "body": "GetMediaSourceNumChannels(${1:PCM_source source})$0"
    },
    "REAPER.GETMEDIASOURCENUMCHANNELS lua": {
        "prefix": "reaper.GetMediaSourceNumChannels",
        "scope": "lua",
        "description": "Returns the number of channels in the source media.\n",
        "body": "reaper.GetMediaSourceNumChannels(${1:PCM_source source})$0"
    },
    "RPR_GETMEDIASOURCENUMCHANNELS python": {
        "prefix": "RPR_GetMediaSourceNumChannels",
        "scope": "python",
        "description": "Returns the number of channels in the source media.\n",
        "body": "RPR_GetMediaSourceNumChannels(${1:PCM_source source})$0"
    },
    "GETMEDIASOURCEPARENT c": {
        "prefix": "GetMediaSourceParent",
        "scope": "c",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "GetMediaSourceParent(${1:PCM_source* src})$0"
    },
    "GETMEDIASOURCEPARENT eel2": {
        "prefix": "GetMediaSourceParent",
        "scope": "eel2",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "GetMediaSourceParent(${1:PCM_source src})$0"
    },
    "REAPER.GETMEDIASOURCEPARENT lua": {
        "prefix": "reaper.GetMediaSourceParent",
        "scope": "lua",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "reaper.GetMediaSourceParent(${1:PCM_source src})$0"
    },
    "RPR_GETMEDIASOURCEPARENT python": {
        "prefix": "RPR_GetMediaSourceParent",
        "scope": "python",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "RPR_GetMediaSourceParent(${1:PCM_source src})$0"
    },
    "GETMEDIASOURCESAMPLERATE c": {
        "prefix": "GetMediaSourceSampleRate",
        "scope": "c",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "GetMediaSourceSampleRate(${1:PCM_source* source})$0"
    },
    "GETMEDIASOURCESAMPLERATE eel2": {
        "prefix": "GetMediaSourceSampleRate",
        "scope": "eel2",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "GetMediaSourceSampleRate(${1:PCM_source source})$0"
    },
    "REAPER.GETMEDIASOURCESAMPLERATE lua": {
        "prefix": "reaper.GetMediaSourceSampleRate",
        "scope": "lua",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "reaper.GetMediaSourceSampleRate(${1:PCM_source source})$0"
    },
    "RPR_GETMEDIASOURCESAMPLERATE python": {
        "prefix": "RPR_GetMediaSourceSampleRate",
        "scope": "python",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "RPR_GetMediaSourceSampleRate(${1:PCM_source source})$0"
    },
    "GETMEDIASOURCETYPE c": {
        "prefix": "GetMediaSourceType",
        "scope": "c",
        "description": "copies the media source type (\"WAV\", \"MIDI\", etc) to typebuf\n",
        "body": "GetMediaSourceType(${1:PCM_source* source},${2:char* typebuf},${3:int typebuf_sz})$0"
    },
    "GETMEDIASOURCETYPE eel2": {
        "prefix": "GetMediaSourceType",
        "scope": "eel2",
        "description": "copies the media source type (\"WAV\", \"MIDI\", etc) to typebuf\n",
        "body": "GetMediaSourceType(${1:PCM_source source},${2:#typebuf})$0"
    },
    "REAPER.GETMEDIASOURCETYPE lua": {
        "prefix": "reaper.GetMediaSourceType",
        "scope": "lua",
        "description": "copies the media source type (\"WAV\", \"MIDI\", etc) to typebuf\n",
        "body": "reaper.GetMediaSourceType(${1:PCM_source source},${2:string typebuf})$0"
    },
    "RPR_GETMEDIASOURCETYPE python": {
        "prefix": "RPR_GetMediaSourceType",
        "scope": "python",
        "description": "copies the media source type (\"WAV\", \"MIDI\", etc) to typebuf\n",
        "body": "RPR_GetMediaSourceType(${1:source},${2:typebuf},${3:typebuf_sz})$0"
    },
    "GETMEDIATRACKINFO_VALUE c": {
        "prefix": "GetMediaTrackInfo_Value",
        "scope": "c",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "GetMediaTrackInfo_Value(${1:MediaTrack* tr},${2|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\",\"P_PARTRACK\",\"P_PROJECT\"|})$0"
    },
    "GETMEDIATRACKINFO_VALUE eel2": {
        "prefix": "GetMediaTrackInfo_Value",
        "scope": "eel2",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "GetMediaTrackInfo_Value(${1:MediaTrack tr},${2:\"parmname\"})$0"
    },
    "REAPER.GETMEDIATRACKINFO_VALUE lua": {
        "prefix": "reaper.GetMediaTrackInfo_Value",
        "scope": "lua",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "reaper.GetMediaTrackInfo_Value(${1:MediaTrack tr},${2|string parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\",\"P_PARTRACK\",\"P_PROJECT\"|})$0"
    },
    "RPR_GETMEDIATRACKINFO_VALUE python": {
        "prefix": "RPR_GetMediaTrackInfo_Value",
        "scope": "python",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "RPR_GetMediaTrackInfo_Value(${1:MediaTrack tr},${2|String parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\",\"P_PARTRACK\",\"P_PROJECT\"|})$0"
    },
    "GETMIDIINPUTNAME c": {
        "prefix": "GetMIDIInputName",
        "scope": "c",
        "description": "returns true if device present\n",
        "body": "GetMIDIInputName(${1:int dev},${2:char* nameout},${3:int nameout_sz})$0"
    },
    "GETMIDIINPUTNAME eel2": {
        "prefix": "GetMIDIInputName",
        "scope": "eel2",
        "description": "returns true if device present\n",
        "body": "GetMIDIInputName(${1:int dev},${2:#nameout})$0"
    },
    "REAPER.GETMIDIINPUTNAME lua": {
        "prefix": "reaper.GetMIDIInputName",
        "scope": "lua",
        "description": "returns true if device present\n",
        "body": "reaper.GetMIDIInputName(${1:integer dev},${2:string nameout})$0"
    },
    "RPR_GETMIDIINPUTNAME python": {
        "prefix": "RPR_GetMIDIInputName",
        "scope": "python",
        "description": "returns true if device present\n",
        "body": "RPR_GetMIDIInputName(${1:dev},${2:nameout},${3:nameout_sz})$0"
    },
    "GETMIDIOUTPUTNAME c": {
        "prefix": "GetMIDIOutputName",
        "scope": "c",
        "description": "returns true if device present\n",
        "body": "GetMIDIOutputName(${1:int dev},${2:char* nameout},${3:int nameout_sz})$0"
    },
    "GETMIDIOUTPUTNAME eel2": {
        "prefix": "GetMIDIOutputName",
        "scope": "eel2",
        "description": "returns true if device present\n",
        "body": "GetMIDIOutputName(${1:int dev},${2:#nameout})$0"
    },
    "REAPER.GETMIDIOUTPUTNAME lua": {
        "prefix": "reaper.GetMIDIOutputName",
        "scope": "lua",
        "description": "returns true if device present\n",
        "body": "reaper.GetMIDIOutputName(${1:integer dev},${2:string nameout})$0"
    },
    "RPR_GETMIDIOUTPUTNAME python": {
        "prefix": "RPR_GetMIDIOutputName",
        "scope": "python",
        "description": "returns true if device present\n",
        "body": "RPR_GetMIDIOutputName(${1:dev},${2:nameout},${3:nameout_sz})$0"
    },
    "GETMIXERSCROLL c": {
        "prefix": "GetMixerScroll",
        "scope": "c",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "GetMixerScroll()$0"
    },
    "GETMIXERSCROLL eel2": {
        "prefix": "GetMixerScroll",
        "scope": "eel2",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "GetMixerScroll()$0"
    },
    "REAPER.GETMIXERSCROLL lua": {
        "prefix": "reaper.GetMixerScroll",
        "scope": "lua",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "reaper.GetMixerScroll()$0"
    },
    "RPR_GETMIXERSCROLL python": {
        "prefix": "RPR_GetMixerScroll",
        "scope": "python",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "RPR_GetMixerScroll()$0"
    },
    "GETMOUSEMODIFIER c": {
        "prefix": "GetMouseModifier",
        "scope": "c",
        "description": "Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.\naction will be filled in with the command ID number for a built-in mouse modifier\nor built-in REAPER command ID, or the custom action ID string.\nSee SetMouseModifier for more information.\n",
        "body": "GetMouseModifier(${1:const char* context},${2:int modifier_flag},${3:char* action},${4:int action_sz})$0"
    },
    "GETMOUSEMODIFIER eel2": {
        "prefix": "GetMouseModifier",
        "scope": "eel2",
        "description": "Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.\naction will be filled in with the command ID number for a built-in mouse modifier\nor built-in REAPER command ID, or the custom action ID string.\nSee SetMouseModifier for more information.\n",
        "body": "GetMouseModifier(${1:\"context\"},${2:int modifier_flag},${3:#action})$0"
    },
    "REAPER.GETMOUSEMODIFIER lua": {
        "prefix": "reaper.GetMouseModifier",
        "scope": "lua",
        "description": "Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.\naction will be filled in with the command ID number for a built-in mouse modifier\nor built-in REAPER command ID, or the custom action ID string.\nSee SetMouseModifier for more information.\n",
        "body": "reaper.GetMouseModifier(${1:string context},${2:integer modifier_flag},${3:string action})$0"
    },
    "RPR_GETMOUSEMODIFIER python": {
        "prefix": "RPR_GetMouseModifier",
        "scope": "python",
        "description": "Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.\naction will be filled in with the command ID number for a built-in mouse modifier\nor built-in REAPER command ID, or the custom action ID string.\nSee SetMouseModifier for more information.\n",
        "body": "RPR_GetMouseModifier(${1:context},${2:modifier_flag},${3:action},${4:action_sz})$0"
    },
    "GETMOUSEPOSITION c": {
        "prefix": "GetMousePosition",
        "scope": "c",
        "description": "get mouse position in screen coordinates\n",
        "body": "GetMousePosition(${1:int* xOut},${2:int* yOut})$0"
    },
    "GETMOUSEPOSITION eel2": {
        "prefix": "GetMousePosition",
        "scope": "eel2",
        "description": "get mouse position in screen coordinates\n",
        "body": "GetMousePosition(${1:int &x},${2:int &y})$0"
    },
    "REAPER.GETMOUSEPOSITION lua": {
        "prefix": "reaper.GetMousePosition",
        "scope": "lua",
        "description": "get mouse position in screen coordinates\n",
        "body": "reaper.GetMousePosition()$0"
    },
    "RPR_GETMOUSEPOSITION python": {
        "prefix": "RPR_GetMousePosition",
        "scope": "python",
        "description": "get mouse position in screen coordinates\n",
        "body": "RPR_GetMousePosition(${1:xOut},${2:yOut})$0"
    },
    "GETNUMAUDIOINPUTS c": {
        "prefix": "GetNumAudioInputs",
        "scope": "c",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "GetNumAudioInputs()$0"
    },
    "GETNUMAUDIOINPUTS eel2": {
        "prefix": "GetNumAudioInputs",
        "scope": "eel2",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "GetNumAudioInputs()$0"
    },
    "REAPER.GETNUMAUDIOINPUTS lua": {
        "prefix": "reaper.GetNumAudioInputs",
        "scope": "lua",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "reaper.GetNumAudioInputs()$0"
    },
    "RPR_GETNUMAUDIOINPUTS python": {
        "prefix": "RPR_GetNumAudioInputs",
        "scope": "python",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "RPR_GetNumAudioInputs()$0"
    },
    "GETNUMAUDIOOUTPUTS c": {
        "prefix": "GetNumAudioOutputs",
        "scope": "c",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "GetNumAudioOutputs()$0"
    },
    "GETNUMAUDIOOUTPUTS eel2": {
        "prefix": "GetNumAudioOutputs",
        "scope": "eel2",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "GetNumAudioOutputs()$0"
    },
    "REAPER.GETNUMAUDIOOUTPUTS lua": {
        "prefix": "reaper.GetNumAudioOutputs",
        "scope": "lua",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "reaper.GetNumAudioOutputs()$0"
    },
    "RPR_GETNUMAUDIOOUTPUTS python": {
        "prefix": "RPR_GetNumAudioOutputs",
        "scope": "python",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "RPR_GetNumAudioOutputs()$0"
    },
    "GETNUMMIDIINPUTS c": {
        "prefix": "GetNumMIDIInputs",
        "scope": "c",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "GetNumMIDIInputs()$0"
    },
    "GETNUMMIDIINPUTS eel2": {
        "prefix": "GetNumMIDIInputs",
        "scope": "eel2",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "GetNumMIDIInputs()$0"
    },
    "REAPER.GETNUMMIDIINPUTS lua": {
        "prefix": "reaper.GetNumMIDIInputs",
        "scope": "lua",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "reaper.GetNumMIDIInputs()$0"
    },
    "RPR_GETNUMMIDIINPUTS python": {
        "prefix": "RPR_GetNumMIDIInputs",
        "scope": "python",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "RPR_GetNumMIDIInputs()$0"
    },
    "GETNUMMIDIOUTPUTS c": {
        "prefix": "GetNumMIDIOutputs",
        "scope": "c",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "GetNumMIDIOutputs()$0"
    },
    "GETNUMMIDIOUTPUTS eel2": {
        "prefix": "GetNumMIDIOutputs",
        "scope": "eel2",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "GetNumMIDIOutputs()$0"
    },
    "REAPER.GETNUMMIDIOUTPUTS lua": {
        "prefix": "reaper.GetNumMIDIOutputs",
        "scope": "lua",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "reaper.GetNumMIDIOutputs()$0"
    },
    "RPR_GETNUMMIDIOUTPUTS python": {
        "prefix": "RPR_GetNumMIDIOutputs",
        "scope": "python",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "RPR_GetNumMIDIOutputs()$0"
    },
    "GETNUMTRACKS c": {
        "prefix": "GetNumTracks",
        "scope": "c",
        "description": "\n",
        "body": "GetNumTracks()$0"
    },
    "GETNUMTRACKS eel2": {
        "prefix": "GetNumTracks",
        "scope": "eel2",
        "description": "\n",
        "body": "GetNumTracks()$0"
    },
    "REAPER.GETNUMTRACKS lua": {
        "prefix": "reaper.GetNumTracks",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetNumTracks()$0"
    },
    "RPR_GETNUMTRACKS python": {
        "prefix": "RPR_GetNumTracks",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetNumTracks()$0"
    },
    "GETOS c": {
        "prefix": "GetOS",
        "scope": "c",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "GetOS()$0"
    },
    "GETOS eel2": {
        "prefix": "GetOS",
        "scope": "eel2",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "GetOS(${1:#retval})$0"
    },
    "REAPER.GETOS lua": {
        "prefix": "reaper.GetOS",
        "scope": "lua",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "reaper.GetOS()$0"
    },
    "RPR_GETOS python": {
        "prefix": "RPR_GetOS",
        "scope": "python",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "RPR_GetOS()$0"
    },
    "GETOUTPUTCHANNELNAME c": {
        "prefix": "GetOutputChannelName",
        "scope": "c",
        "description": "\n",
        "body": "GetOutputChannelName(${1:int channelIndex})$0"
    },
    "GETOUTPUTCHANNELNAME eel2": {
        "prefix": "GetOutputChannelName",
        "scope": "eel2",
        "description": "\n",
        "body": "GetOutputChannelName(${1:#retval},${2:int channelIndex})$0"
    },
    "REAPER.GETOUTPUTCHANNELNAME lua": {
        "prefix": "reaper.GetOutputChannelName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetOutputChannelName(${1:integer channelIndex})$0"
    },
    "RPR_GETOUTPUTCHANNELNAME python": {
        "prefix": "RPR_GetOutputChannelName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetOutputChannelName(${1:Int channelIndex})$0"
    },
    "GETOUTPUTLATENCY c": {
        "prefix": "GetOutputLatency",
        "scope": "c",
        "description": "returns output latency in seconds\n",
        "body": "GetOutputLatency()$0"
    },
    "GETOUTPUTLATENCY eel2": {
        "prefix": "GetOutputLatency",
        "scope": "eel2",
        "description": "returns output latency in seconds\n",
        "body": "GetOutputLatency()$0"
    },
    "REAPER.GETOUTPUTLATENCY lua": {
        "prefix": "reaper.GetOutputLatency",
        "scope": "lua",
        "description": "returns output latency in seconds\n",
        "body": "reaper.GetOutputLatency()$0"
    },
    "RPR_GETOUTPUTLATENCY python": {
        "prefix": "RPR_GetOutputLatency",
        "scope": "python",
        "description": "returns output latency in seconds\n",
        "body": "RPR_GetOutputLatency()$0"
    },
    "GETPARENTTRACK c": {
        "prefix": "GetParentTrack",
        "scope": "c",
        "description": "\n",
        "body": "GetParentTrack(${1:MediaTrack* track})$0"
    },
    "GETPARENTTRACK eel2": {
        "prefix": "GetParentTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "GetParentTrack(${1:MediaTrack track})$0"
    },
    "REAPER.GETPARENTTRACK lua": {
        "prefix": "reaper.GetParentTrack",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetParentTrack(${1:MediaTrack track})$0"
    },
    "RPR_GETPARENTTRACK python": {
        "prefix": "RPR_GetParentTrack",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetParentTrack(${1:MediaTrack track})$0"
    },
    "GETPEAKFILENAME c": {
        "prefix": "GetPeakFileName",
        "scope": "c",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "GetPeakFileName(${1:const char* fn},${2:char* buf},${3:int buf_sz})$0"
    },
    "GETPEAKFILENAME eel2": {
        "prefix": "GetPeakFileName",
        "scope": "eel2",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "GetPeakFileName(${1:\"fn\"},${2:#buf})$0"
    },
    "REAPER.GETPEAKFILENAME lua": {
        "prefix": "reaper.GetPeakFileName",
        "scope": "lua",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "reaper.GetPeakFileName(${1:string fn},${2:string buf})$0"
    },
    "RPR_GETPEAKFILENAME python": {
        "prefix": "RPR_GetPeakFileName",
        "scope": "python",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "RPR_GetPeakFileName(${1:fn},${2:buf},${3:buf_sz})$0"
    },
    "GETPEAKFILENAMEEX c": {
        "prefix": "GetPeakFileNameEx",
        "scope": "c",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "GetPeakFileNameEx(${1:const char* fn},${2:char* buf},${3:int buf_sz},${4:bool forWrite})$0"
    },
    "GETPEAKFILENAMEEX eel2": {
        "prefix": "GetPeakFileNameEx",
        "scope": "eel2",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "GetPeakFileNameEx(${1:\"fn\"},${2:#buf},${3:bool forWrite})$0"
    },
    "REAPER.GETPEAKFILENAMEEX lua": {
        "prefix": "reaper.GetPeakFileNameEx",
        "scope": "lua",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "reaper.GetPeakFileNameEx(${1:string fn},${2:string buf},${3:boolean forWrite})$0"
    },
    "RPR_GETPEAKFILENAMEEX python": {
        "prefix": "RPR_GetPeakFileNameEx",
        "scope": "python",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "RPR_GetPeakFileNameEx(${1:fn},${2:buf},${3:buf_sz},${4:forWrite})$0"
    },
    "GETPEAKFILENAMEEX2 c": {
        "prefix": "GetPeakFileNameEx2",
        "scope": "c",
        "description": "Like GetPeakFileNameEx, but you can specify peaksfileextension such as \".reapeaks\"\n",
        "body": "GetPeakFileNameEx2(${1:const char* fn},${2:char* buf},${3:int buf_sz},${4:bool forWrite},${5:const char* peaksfileextension})$0"
    },
    "GETPEAKFILENAMEEX2 eel2": {
        "prefix": "GetPeakFileNameEx2",
        "scope": "eel2",
        "description": "Like GetPeakFileNameEx, but you can specify peaksfileextension such as \".reapeaks\"\n",
        "body": "GetPeakFileNameEx2(${1:\"fn\"},${2:#buf},${3:bool forWrite},${4:\"peaksfileextension\"})$0"
    },
    "REAPER.GETPEAKFILENAMEEX2 lua": {
        "prefix": "reaper.GetPeakFileNameEx2",
        "scope": "lua",
        "description": "Like GetPeakFileNameEx, but you can specify peaksfileextension such as \".reapeaks\"\n",
        "body": "reaper.GetPeakFileNameEx2(${1:string fn},${2:string buf},${3:boolean forWrite},${4:string peaksfileextension})$0"
    },
    "RPR_GETPEAKFILENAMEEX2 python": {
        "prefix": "RPR_GetPeakFileNameEx2",
        "scope": "python",
        "description": "Like GetPeakFileNameEx, but you can specify peaksfileextension such as \".reapeaks\"\n",
        "body": "RPR_GetPeakFileNameEx2(${1:fn},${2:buf},${3:buf_sz},${4:forWrite},${5:peaksfileextension})$0"
    },
    "GETPLAYPOSITION c": {
        "prefix": "GetPlayPosition",
        "scope": "c",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "GetPlayPosition()$0"
    },
    "GETPLAYPOSITION eel2": {
        "prefix": "GetPlayPosition",
        "scope": "eel2",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "GetPlayPosition()$0"
    },
    "REAPER.GETPLAYPOSITION lua": {
        "prefix": "reaper.GetPlayPosition",
        "scope": "lua",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "reaper.GetPlayPosition()$0"
    },
    "RPR_GETPLAYPOSITION python": {
        "prefix": "RPR_GetPlayPosition",
        "scope": "python",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "RPR_GetPlayPosition()$0"
    },
    "GETPLAYPOSITION2 c": {
        "prefix": "GetPlayPosition2",
        "scope": "c",
        "description": "returns position of next audio block being processed\n",
        "body": "GetPlayPosition2()$0"
    },
    "GETPLAYPOSITION2 eel2": {
        "prefix": "GetPlayPosition2",
        "scope": "eel2",
        "description": "returns position of next audio block being processed\n",
        "body": "GetPlayPosition2()$0"
    },
    "REAPER.GETPLAYPOSITION2 lua": {
        "prefix": "reaper.GetPlayPosition2",
        "scope": "lua",
        "description": "returns position of next audio block being processed\n",
        "body": "reaper.GetPlayPosition2()$0"
    },
    "RPR_GETPLAYPOSITION2 python": {
        "prefix": "RPR_GetPlayPosition2",
        "scope": "python",
        "description": "returns position of next audio block being processed\n",
        "body": "RPR_GetPlayPosition2()$0"
    },
    "GETPLAYPOSITION2EX c": {
        "prefix": "GetPlayPosition2Ex",
        "scope": "c",
        "description": "returns position of next audio block being processed\n",
        "body": "GetPlayPosition2Ex(${1:ReaProject* proj})$0"
    },
    "GETPLAYPOSITION2EX eel2": {
        "prefix": "GetPlayPosition2Ex",
        "scope": "eel2",
        "description": "returns position of next audio block being processed\n",
        "body": "GetPlayPosition2Ex(${1:ReaProject proj})$0"
    },
    "REAPER.GETPLAYPOSITION2EX lua": {
        "prefix": "reaper.GetPlayPosition2Ex",
        "scope": "lua",
        "description": "returns position of next audio block being processed\n",
        "body": "reaper.GetPlayPosition2Ex(${1:ReaProject proj})$0"
    },
    "RPR_GETPLAYPOSITION2EX python": {
        "prefix": "RPR_GetPlayPosition2Ex",
        "scope": "python",
        "description": "returns position of next audio block being processed\n",
        "body": "RPR_GetPlayPosition2Ex(${1:ReaProject proj})$0"
    },
    "GETPLAYPOSITIONEX c": {
        "prefix": "GetPlayPositionEx",
        "scope": "c",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "GetPlayPositionEx(${1:ReaProject* proj})$0"
    },
    "GETPLAYPOSITIONEX eel2": {
        "prefix": "GetPlayPositionEx",
        "scope": "eel2",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "GetPlayPositionEx(${1:ReaProject proj})$0"
    },
    "REAPER.GETPLAYPOSITIONEX lua": {
        "prefix": "reaper.GetPlayPositionEx",
        "scope": "lua",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "reaper.GetPlayPositionEx(${1:ReaProject proj})$0"
    },
    "RPR_GETPLAYPOSITIONEX python": {
        "prefix": "RPR_GetPlayPositionEx",
        "scope": "python",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "RPR_GetPlayPositionEx(${1:ReaProject proj})$0"
    },
    "GETPLAYSTATE c": {
        "prefix": "GetPlayState",
        "scope": "c",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "GetPlayState()$0"
    },
    "GETPLAYSTATE eel2": {
        "prefix": "GetPlayState",
        "scope": "eel2",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "GetPlayState()$0"
    },
    "REAPER.GETPLAYSTATE lua": {
        "prefix": "reaper.GetPlayState",
        "scope": "lua",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "reaper.GetPlayState()$0"
    },
    "RPR_GETPLAYSTATE python": {
        "prefix": "RPR_GetPlayState",
        "scope": "python",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "RPR_GetPlayState()$0"
    },
    "GETPLAYSTATEEX c": {
        "prefix": "GetPlayStateEx",
        "scope": "c",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "GetPlayStateEx(${1:ReaProject* proj})$0"
    },
    "GETPLAYSTATEEX eel2": {
        "prefix": "GetPlayStateEx",
        "scope": "eel2",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "GetPlayStateEx(${1:ReaProject proj})$0"
    },
    "REAPER.GETPLAYSTATEEX lua": {
        "prefix": "reaper.GetPlayStateEx",
        "scope": "lua",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "reaper.GetPlayStateEx(${1:ReaProject proj})$0"
    },
    "RPR_GETPLAYSTATEEX python": {
        "prefix": "RPR_GetPlayStateEx",
        "scope": "python",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "RPR_GetPlayStateEx(${1:ReaProject proj})$0"
    },
    "GETPROJECTLENGTH c": {
        "prefix": "GetProjectLength",
        "scope": "c",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "GetProjectLength(${1:ReaProject* proj})$0"
    },
    "GETPROJECTLENGTH eel2": {
        "prefix": "GetProjectLength",
        "scope": "eel2",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "GetProjectLength(${1:ReaProject proj})$0"
    },
    "REAPER.GETPROJECTLENGTH lua": {
        "prefix": "reaper.GetProjectLength",
        "scope": "lua",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "reaper.GetProjectLength(${1:ReaProject proj})$0"
    },
    "RPR_GETPROJECTLENGTH python": {
        "prefix": "RPR_GetProjectLength",
        "scope": "python",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "RPR_GetProjectLength(${1:ReaProject proj})$0"
    },
    "GETPROJECTNAME c": {
        "prefix": "GetProjectName",
        "scope": "c",
        "description": "\n",
        "body": "GetProjectName(${1:ReaProject* proj},${2:char* buf},${3:int buf_sz})$0"
    },
    "GETPROJECTNAME eel2": {
        "prefix": "GetProjectName",
        "scope": "eel2",
        "description": "\n",
        "body": "GetProjectName(${1:ReaProject proj},${2:#buf})$0"
    },
    "REAPER.GETPROJECTNAME lua": {
        "prefix": "reaper.GetProjectName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetProjectName(${1:ReaProject proj},${2:string buf})$0"
    },
    "RPR_GETPROJECTNAME python": {
        "prefix": "RPR_GetProjectName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetProjectName(${1:proj},${2:buf},${3:buf_sz})$0"
    },
    "GETPROJECTPATH c": {
        "prefix": "GetProjectPath",
        "scope": "c",
        "description": "Get the project recording path.\n",
        "body": "GetProjectPath(${1:char* buf},${2:int buf_sz})$0"
    },
    "GETPROJECTPATH eel2": {
        "prefix": "GetProjectPath",
        "scope": "eel2",
        "description": "Get the project recording path.\n",
        "body": "GetProjectPath(${1:#buf})$0"
    },
    "REAPER.GETPROJECTPATH lua": {
        "prefix": "reaper.GetProjectPath",
        "scope": "lua",
        "description": "Get the project recording path.\n",
        "body": "reaper.GetProjectPath(${1:string buf})$0"
    },
    "RPR_GETPROJECTPATH python": {
        "prefix": "RPR_GetProjectPath",
        "scope": "python",
        "description": "Get the project recording path.\n",
        "body": "RPR_GetProjectPath(${1:buf},${2:buf_sz})$0"
    },
    "GETPROJECTPATHEX c": {
        "prefix": "GetProjectPathEx",
        "scope": "c",
        "description": "Get the project recording path.\n",
        "body": "GetProjectPathEx(${1:ReaProject* proj},${2:char* buf},${3:int buf_sz})$0"
    },
    "GETPROJECTPATHEX eel2": {
        "prefix": "GetProjectPathEx",
        "scope": "eel2",
        "description": "Get the project recording path.\n",
        "body": "GetProjectPathEx(${1:ReaProject proj},${2:#buf})$0"
    },
    "REAPER.GETPROJECTPATHEX lua": {
        "prefix": "reaper.GetProjectPathEx",
        "scope": "lua",
        "description": "Get the project recording path.\n",
        "body": "reaper.GetProjectPathEx(${1:ReaProject proj},${2:string buf})$0"
    },
    "RPR_GETPROJECTPATHEX python": {
        "prefix": "RPR_GetProjectPathEx",
        "scope": "python",
        "description": "Get the project recording path.\n",
        "body": "RPR_GetProjectPathEx(${1:proj},${2:buf},${3:buf_sz})$0"
    },
    "GETPROJECTSTATECHANGECOUNT c": {
        "prefix": "GetProjectStateChangeCount",
        "scope": "c",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "GetProjectStateChangeCount(${1:ReaProject* proj})$0"
    },
    "GETPROJECTSTATECHANGECOUNT eel2": {
        "prefix": "GetProjectStateChangeCount",
        "scope": "eel2",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "GetProjectStateChangeCount(${1:ReaProject proj})$0"
    },
    "REAPER.GETPROJECTSTATECHANGECOUNT lua": {
        "prefix": "reaper.GetProjectStateChangeCount",
        "scope": "lua",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "reaper.GetProjectStateChangeCount(${1:ReaProject proj})$0"
    },
    "RPR_GETPROJECTSTATECHANGECOUNT python": {
        "prefix": "RPR_GetProjectStateChangeCount",
        "scope": "python",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "RPR_GetProjectStateChangeCount(${1:ReaProject proj})$0"
    },
    "GETPROJECTTIMEOFFSET c": {
        "prefix": "GetProjectTimeOffset",
        "scope": "c",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "GetProjectTimeOffset(${1:ReaProject* proj},${2:bool rndframe})$0"
    },
    "GETPROJECTTIMEOFFSET eel2": {
        "prefix": "GetProjectTimeOffset",
        "scope": "eel2",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "GetProjectTimeOffset(${1:ReaProject proj},${2:bool rndframe})$0"
    },
    "REAPER.GETPROJECTTIMEOFFSET lua": {
        "prefix": "reaper.GetProjectTimeOffset",
        "scope": "lua",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "reaper.GetProjectTimeOffset(${1:ReaProject proj},${2:boolean rndframe})$0"
    },
    "RPR_GETPROJECTTIMEOFFSET python": {
        "prefix": "RPR_GetProjectTimeOffset",
        "scope": "python",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "RPR_GetProjectTimeOffset(${1:ReaProject proj},${2:Boolean rndframe})$0"
    },
    "GETPROJECTTIMESIGNATURE c": {
        "prefix": "GetProjectTimeSignature",
        "scope": "c",
        "description": "deprecated\n",
        "body": "GetProjectTimeSignature(${1:double* bpmOut},${2:double* bpiOut})$0"
    },
    "GETPROJECTTIMESIGNATURE eel2": {
        "prefix": "GetProjectTimeSignature",
        "scope": "eel2",
        "description": "deprecated\n",
        "body": "GetProjectTimeSignature(${1:&bpm},${2:&bpi})$0"
    },
    "REAPER.GETPROJECTTIMESIGNATURE lua": {
        "prefix": "reaper.GetProjectTimeSignature",
        "scope": "lua",
        "description": "deprecated\n",
        "body": "reaper.GetProjectTimeSignature()$0"
    },
    "RPR_GETPROJECTTIMESIGNATURE python": {
        "prefix": "RPR_GetProjectTimeSignature",
        "scope": "python",
        "description": "deprecated\n",
        "body": "RPR_GetProjectTimeSignature(${1:bpmOut},${2:bpiOut})$0"
    },
    "GETPROJECTTIMESIGNATURE2 c": {
        "prefix": "GetProjectTimeSignature2",
        "scope": "c",
        "description": "Gets basic time signature (beats per minute, numerator of time signature in bpi)\nthis does not reflect tempo envelopes but is purely what is set in the project settings.\n",
        "body": "GetProjectTimeSignature2(${1:ReaProject* proj},${2:double* bpmOut},${3:double* bpiOut})$0"
    },
    "GETPROJECTTIMESIGNATURE2 eel2": {
        "prefix": "GetProjectTimeSignature2",
        "scope": "eel2",
        "description": "Gets basic time signature (beats per minute, numerator of time signature in bpi)\nthis does not reflect tempo envelopes but is purely what is set in the project settings.\n",
        "body": "GetProjectTimeSignature2(${1:ReaProject proj},${2:&bpm},${3:&bpi})$0"
    },
    "REAPER.GETPROJECTTIMESIGNATURE2 lua": {
        "prefix": "reaper.GetProjectTimeSignature2",
        "scope": "lua",
        "description": "Gets basic time signature (beats per minute, numerator of time signature in bpi)\nthis does not reflect tempo envelopes but is purely what is set in the project settings.\n",
        "body": "reaper.GetProjectTimeSignature2(${1:ReaProject proj})$0"
    },
    "RPR_GETPROJECTTIMESIGNATURE2 python": {
        "prefix": "RPR_GetProjectTimeSignature2",
        "scope": "python",
        "description": "Gets basic time signature (beats per minute, numerator of time signature in bpi)\nthis does not reflect tempo envelopes but is purely what is set in the project settings.\n",
        "body": "RPR_GetProjectTimeSignature2(${1:proj},${2:bpmOut},${3:bpiOut})$0"
    },
    "GETPROJEXTSTATE c": {
        "prefix": "GetProjExtState",
        "scope": "c",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "GetProjExtState(${1:ReaProject* proj},${2:const char* extname},${3:const char* key},${4:char* valOutNeedBig},${5:int valOutNeedBig_sz})$0"
    },
    "GETPROJEXTSTATE eel2": {
        "prefix": "GetProjExtState",
        "scope": "eel2",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "GetProjExtState(${1:ReaProject proj},${2:\"extname\"},${3:\"key\"},${4:#val})$0"
    },
    "REAPER.GETPROJEXTSTATE lua": {
        "prefix": "reaper.GetProjExtState",
        "scope": "lua",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "reaper.GetProjExtState(${1:ReaProject proj},${2:string extname},${3:string key})$0"
    },
    "RPR_GETPROJEXTSTATE python": {
        "prefix": "RPR_GetProjExtState",
        "scope": "python",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "RPR_GetProjExtState(${1:proj},${2:extname},${3:key},${4:valOutNeedBig},${5:valOutNeedBig_sz})$0"
    },
    "GETRESOURCEPATH c": {
        "prefix": "GetResourcePath",
        "scope": "c",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "GetResourcePath()$0"
    },
    "GETRESOURCEPATH eel2": {
        "prefix": "GetResourcePath",
        "scope": "eel2",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "GetResourcePath(${1:#retval})$0"
    },
    "REAPER.GETRESOURCEPATH lua": {
        "prefix": "reaper.GetResourcePath",
        "scope": "lua",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "reaper.GetResourcePath()$0"
    },
    "RPR_GETRESOURCEPATH python": {
        "prefix": "RPR_GetResourcePath",
        "scope": "python",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "RPR_GetResourcePath()$0"
    },
    "GETSELECTEDENVELOPE c": {
        "prefix": "GetSelectedEnvelope",
        "scope": "c",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "GetSelectedEnvelope(${1:ReaProject* proj})$0"
    },
    "GETSELECTEDENVELOPE eel2": {
        "prefix": "GetSelectedEnvelope",
        "scope": "eel2",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "GetSelectedEnvelope(${1:ReaProject proj})$0"
    },
    "REAPER.GETSELECTEDENVELOPE lua": {
        "prefix": "reaper.GetSelectedEnvelope",
        "scope": "lua",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "reaper.GetSelectedEnvelope(${1:ReaProject proj})$0"
    },
    "RPR_GETSELECTEDENVELOPE python": {
        "prefix": "RPR_GetSelectedEnvelope",
        "scope": "python",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "RPR_GetSelectedEnvelope(${1:ReaProject proj})$0"
    },
    "GETSELECTEDMEDIAITEM c": {
        "prefix": "GetSelectedMediaItem",
        "scope": "c",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "GetSelectedMediaItem(${1:ReaProject* proj},${2:int selitem})$0"
    },
    "GETSELECTEDMEDIAITEM eel2": {
        "prefix": "GetSelectedMediaItem",
        "scope": "eel2",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "GetSelectedMediaItem(${1:ReaProject proj},${2:int selitem})$0"
    },
    "REAPER.GETSELECTEDMEDIAITEM lua": {
        "prefix": "reaper.GetSelectedMediaItem",
        "scope": "lua",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "reaper.GetSelectedMediaItem(${1:ReaProject proj},${2:integer selitem})$0"
    },
    "RPR_GETSELECTEDMEDIAITEM python": {
        "prefix": "RPR_GetSelectedMediaItem",
        "scope": "python",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "RPR_GetSelectedMediaItem(${1:ReaProject proj},${2:Int selitem})$0"
    },
    "GETSELECTEDTRACK c": {
        "prefix": "GetSelectedTrack",
        "scope": "c",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "GetSelectedTrack(${1:ReaProject* proj},${2:int seltrackidx})$0"
    },
    "GETSELECTEDTRACK eel2": {
        "prefix": "GetSelectedTrack",
        "scope": "eel2",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "GetSelectedTrack(${1:ReaProject proj},${2:int seltrackidx})$0"
    },
    "REAPER.GETSELECTEDTRACK lua": {
        "prefix": "reaper.GetSelectedTrack",
        "scope": "lua",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "reaper.GetSelectedTrack(${1:ReaProject proj},${2:integer seltrackidx})$0"
    },
    "RPR_GETSELECTEDTRACK python": {
        "prefix": "RPR_GetSelectedTrack",
        "scope": "python",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "RPR_GetSelectedTrack(${1:ReaProject proj},${2:Int seltrackidx})$0"
    },
    "GETSELECTEDTRACK2 c": {
        "prefix": "GetSelectedTrack2",
        "scope": "c",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "GetSelectedTrack2(${1:ReaProject* proj},${2:int seltrackidx},${3:bool wantmaster})$0"
    },
    "GETSELECTEDTRACK2 eel2": {
        "prefix": "GetSelectedTrack2",
        "scope": "eel2",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "GetSelectedTrack2(${1:ReaProject proj},${2:int seltrackidx},${3:bool wantmaster})$0"
    },
    "REAPER.GETSELECTEDTRACK2 lua": {
        "prefix": "reaper.GetSelectedTrack2",
        "scope": "lua",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "reaper.GetSelectedTrack2(${1:ReaProject proj},${2:integer seltrackidx},${3:boolean wantmaster})$0"
    },
    "RPR_GETSELECTEDTRACK2 python": {
        "prefix": "RPR_GetSelectedTrack2",
        "scope": "python",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "RPR_GetSelectedTrack2(${1:ReaProject proj},${2:Int seltrackidx},${3:Boolean wantmaster})$0"
    },
    "GETSELECTEDTRACKENVELOPE c": {
        "prefix": "GetSelectedTrackEnvelope",
        "scope": "c",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "GetSelectedTrackEnvelope(${1:ReaProject* proj})$0"
    },
    "GETSELECTEDTRACKENVELOPE eel2": {
        "prefix": "GetSelectedTrackEnvelope",
        "scope": "eel2",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "GetSelectedTrackEnvelope(${1:ReaProject proj})$0"
    },
    "REAPER.GETSELECTEDTRACKENVELOPE lua": {
        "prefix": "reaper.GetSelectedTrackEnvelope",
        "scope": "lua",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "reaper.GetSelectedTrackEnvelope(${1:ReaProject proj})$0"
    },
    "RPR_GETSELECTEDTRACKENVELOPE python": {
        "prefix": "RPR_GetSelectedTrackEnvelope",
        "scope": "python",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "RPR_GetSelectedTrackEnvelope(${1:ReaProject proj})$0"
    },
    "GETSET_ARRANGEVIEW2 c": {
        "prefix": "GetSet_ArrangeView2",
        "scope": "c",
        "description": "Gets or sets the arrange view start/end time for screen coordinates. use\nscreen_x_start=screen_x_end=0 to use the full arrange view's start/end\ntime\n",
        "body": "GetSet_ArrangeView2(${1:ReaProject* proj},${2:bool isSet},${3:int screen_x_start},${4:int screen_x_end},${5:double* start_timeOut},${6:double* end_timeOut})$0"
    },
    "GETSET_ARRANGEVIEW2 eel2": {
        "prefix": "GetSet_ArrangeView2",
        "scope": "eel2",
        "description": "Gets or sets the arrange view start/end time for screen coordinates. use\nscreen_x_start=screen_x_end=0 to use the full arrange view's start/end\ntime\n",
        "body": "GetSet_ArrangeView2(${1:ReaProject proj},${2:bool isSet},${3:int screen_x_start},${4:int screen_x_end},${5:&start_time},${6:&end_time})$0"
    },
    "REAPER.GETSET_ARRANGEVIEW2 lua": {
        "prefix": "reaper.GetSet_ArrangeView2",
        "scope": "lua",
        "description": "Gets or sets the arrange view start/end time for screen coordinates. use\nscreen_x_start=screen_x_end=0 to use the full arrange view's start/end\ntime\n",
        "body": "reaper.GetSet_ArrangeView2(${1:ReaProject proj},${2:boolean isSet},${3:integer screen_x_start},${4:integer screen_x_end})$0"
    },
    "RPR_GETSET_ARRANGEVIEW2 python": {
        "prefix": "RPR_GetSet_ArrangeView2",
        "scope": "python",
        "description": "Gets or sets the arrange view start/end time for screen coordinates. use\nscreen_x_start=screen_x_end=0 to use the full arrange view's start/end\ntime\n",
        "body": "RPR_GetSet_ArrangeView2(${1:proj},${2:isSet},${3:screen_x_start},${4:screen_x_end},${5:start_timeOut},${6:end_timeOut})$0"
    },
    "GETSET_LOOPTIMERANGE c": {
        "prefix": "GetSet_LoopTimeRange",
        "scope": "c",
        "description": "\n",
        "body": "GetSet_LoopTimeRange(${1:bool isSet},${2:bool isLoop},${3:double* startOut},${4:double* endOut},${5:bool allowautoseek})$0"
    },
    "GETSET_LOOPTIMERANGE eel2": {
        "prefix": "GetSet_LoopTimeRange",
        "scope": "eel2",
        "description": "\n",
        "body": "GetSet_LoopTimeRange(${1:bool isSet},${2:bool isLoop},${3:&start},${4:&end},${5:bool allowautoseek})$0"
    },
    "REAPER.GETSET_LOOPTIMERANGE lua": {
        "prefix": "reaper.GetSet_LoopTimeRange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetSet_LoopTimeRange(${1:boolean isSet},${2:boolean isLoop},${3:number start},${4:number end},${5:boolean allowautoseek})$0"
    },
    "RPR_GETSET_LOOPTIMERANGE python": {
        "prefix": "RPR_GetSet_LoopTimeRange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetSet_LoopTimeRange(${1:isSet},${2:isLoop},${3:startOut},${4:endOut},${5:allowautoseek})$0"
    },
    "GETSET_LOOPTIMERANGE2 c": {
        "prefix": "GetSet_LoopTimeRange2",
        "scope": "c",
        "description": "\n",
        "body": "GetSet_LoopTimeRange2(${1:ReaProject* proj},${2:bool isSet},${3:bool isLoop},${4:double* startOut},${5:double* endOut},${6:bool allowautoseek})$0"
    },
    "GETSET_LOOPTIMERANGE2 eel2": {
        "prefix": "GetSet_LoopTimeRange2",
        "scope": "eel2",
        "description": "\n",
        "body": "GetSet_LoopTimeRange2(${1:ReaProject proj},${2:bool isSet},${3:bool isLoop},${4:&start},${5:&end},${6:bool allowautoseek})$0"
    },
    "REAPER.GETSET_LOOPTIMERANGE2 lua": {
        "prefix": "reaper.GetSet_LoopTimeRange2",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetSet_LoopTimeRange2(${1:ReaProject proj},${2:boolean isSet},${3:boolean isLoop},${4:number start},${5:number end},${6:boolean allowautoseek})$0"
    },
    "RPR_GETSET_LOOPTIMERANGE2 python": {
        "prefix": "RPR_GetSet_LoopTimeRange2",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetSet_LoopTimeRange2(${1:proj},${2:isSet},${3:isLoop},${4:startOut},${5:endOut},${6:allowautoseek})$0"
    },
    "GETSETAUTOMATIONITEMINFO c": {
        "prefix": "GetSetAutomationItemInfo",
        "scope": "c",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "GetSetAutomationItemInfo(${1:TrackEnvelope* env},${2:int autoitem_idx},${3|const char* desc,\"D_POOL_ID\",\"D_POSITION\",\"D_LENGTH\",\"D_STARTOFFS\",\"D_PLAYRATE\",\"D_BASELINE\",\"D_AMPLITUDE\",\"D_LOOPSRC\",\"D_UISEL\",\"D_POOL_QNLEN\"|},${4:double value},${5:bool is_set})$0"
    },
    "GETSETAUTOMATIONITEMINFO eel2": {
        "prefix": "GetSetAutomationItemInfo",
        "scope": "eel2",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "GetSetAutomationItemInfo(${1:TrackEnvelope env},${2:int autoitem_idx},${3:\"desc\"},${4:value},${5:bool is_set})$0"
    },
    "REAPER.GETSETAUTOMATIONITEMINFO lua": {
        "prefix": "reaper.GetSetAutomationItemInfo",
        "scope": "lua",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "reaper.GetSetAutomationItemInfo(${1:TrackEnvelope env},${2:integer autoitem_idx},${3|string desc,\"D_POOL_ID\",\"D_POSITION\",\"D_LENGTH\",\"D_STARTOFFS\",\"D_PLAYRATE\",\"D_BASELINE\",\"D_AMPLITUDE\",\"D_LOOPSRC\",\"D_UISEL\",\"D_POOL_QNLEN\"|},${4:number value},${5:boolean is_set})$0"
    },
    "RPR_GETSETAUTOMATIONITEMINFO python": {
        "prefix": "RPR_GetSetAutomationItemInfo",
        "scope": "python",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "RPR_GetSetAutomationItemInfo(${1:TrackEnvelope env},${2:Int autoitem_idx},${3|String desc,\"D_POOL_ID\",\"D_POSITION\",\"D_LENGTH\",\"D_STARTOFFS\",\"D_PLAYRATE\",\"D_BASELINE\",\"D_AMPLITUDE\",\"D_LOOPSRC\",\"D_UISEL\",\"D_POOL_QNLEN\"|},${4:Float value},${5:Boolean is_set})$0"
    },
    "GETSETAUTOMATIONITEMINFO_STRING c": {
        "prefix": "GetSetAutomationItemInfo_String",
        "scope": "c",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "GetSetAutomationItemInfo_String(${1:TrackEnvelope* env},${2:int autoitem_idx},${3|const char* desc,\"P_POOL_NAME\",\"P_POOL_EXT:xyz\"|},${4:char* valuestrNeedBig},${5:bool is_set})$0"
    },
    "GETSETAUTOMATIONITEMINFO_STRING eel2": {
        "prefix": "GetSetAutomationItemInfo_String",
        "scope": "eel2",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "GetSetAutomationItemInfo_String(${1:TrackEnvelope env},${2:int autoitem_idx},${3:\"desc\"},${4:#valuestrNeedBig},${5:bool is_set})$0"
    },
    "REAPER.GETSETAUTOMATIONITEMINFO_STRING lua": {
        "prefix": "reaper.GetSetAutomationItemInfo_String",
        "scope": "lua",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "reaper.GetSetAutomationItemInfo_String(${1:TrackEnvelope env},${2:integer autoitem_idx},${3|string desc,\"P_POOL_NAME\",\"P_POOL_EXT:xyz\"|},${4:string valuestrNeedBig},${5:boolean is_set})$0"
    },
    "RPR_GETSETAUTOMATIONITEMINFO_STRING python": {
        "prefix": "RPR_GetSetAutomationItemInfo_String",
        "scope": "python",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "RPR_GetSetAutomationItemInfo_String(${1:env},${2:autoitem_idx},${3:desc},${4:valuestrNeedBig},${5:is_set})$0"
    },
    "GETSETENVELOPEINFO_STRING c": {
        "prefix": "GetSetEnvelopeInfo_String",
        "scope": "c",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "GetSetEnvelopeInfo_String(${1:TrackEnvelope* env},${2|const char* parmname,\"P_EXT:xyz\"|},${3:char* stringNeedBig},${4:bool setNewValue})$0"
    },
    "GETSETENVELOPEINFO_STRING eel2": {
        "prefix": "GetSetEnvelopeInfo_String",
        "scope": "eel2",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "GetSetEnvelopeInfo_String(${1:TrackEnvelope env},${2:\"parmname\"},${3:#stringNeedBig},${4:bool setNewValue})$0"
    },
    "REAPER.GETSETENVELOPEINFO_STRING lua": {
        "prefix": "reaper.GetSetEnvelopeInfo_String",
        "scope": "lua",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "reaper.GetSetEnvelopeInfo_String(${1:TrackEnvelope env},${2|string parmname,\"P_EXT:xyz\"|},${3:string stringNeedBig},${4:boolean setNewValue})$0"
    },
    "RPR_GETSETENVELOPEINFO_STRING python": {
        "prefix": "RPR_GetSetEnvelopeInfo_String",
        "scope": "python",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "RPR_GetSetEnvelopeInfo_String(${1:env},${2:parmname},${3:stringNeedBig},${4:setNewValue})$0"
    },
    "GETSETENVELOPESTATE c": {
        "prefix": "GetSetEnvelopeState",
        "scope": "c",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "GetSetEnvelopeState(${1:TrackEnvelope* env},${2:char* str},${3:int str_sz})$0"
    },
    "GETSETENVELOPESTATE eel2": {
        "prefix": "GetSetEnvelopeState",
        "scope": "eel2",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "GetSetEnvelopeState(${1:TrackEnvelope env},${2:#str})$0"
    },
    "REAPER.GETSETENVELOPESTATE lua": {
        "prefix": "reaper.GetSetEnvelopeState",
        "scope": "lua",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "reaper.GetSetEnvelopeState(${1:TrackEnvelope env},${2:string str})$0"
    },
    "RPR_GETSETENVELOPESTATE python": {
        "prefix": "RPR_GetSetEnvelopeState",
        "scope": "python",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "RPR_GetSetEnvelopeState(${1:env},${2:str},${3:str_sz})$0"
    },
    "GETSETENVELOPESTATE2 c": {
        "prefix": "GetSetEnvelopeState2",
        "scope": "c",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "GetSetEnvelopeState2(${1:TrackEnvelope* env},${2:char* str},${3:int str_sz},${4:bool isundo})$0"
    },
    "GETSETENVELOPESTATE2 eel2": {
        "prefix": "GetSetEnvelopeState2",
        "scope": "eel2",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "GetSetEnvelopeState2(${1:TrackEnvelope env},${2:#str},${3:bool isundo})$0"
    },
    "REAPER.GETSETENVELOPESTATE2 lua": {
        "prefix": "reaper.GetSetEnvelopeState2",
        "scope": "lua",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "reaper.GetSetEnvelopeState2(${1:TrackEnvelope env},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_GETSETENVELOPESTATE2 python": {
        "prefix": "RPR_GetSetEnvelopeState2",
        "scope": "python",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "RPR_GetSetEnvelopeState2(${1:env},${2:str},${3:str_sz},${4:isundo})$0"
    },
    "GETSETITEMSTATE c": {
        "prefix": "GetSetItemState",
        "scope": "c",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "GetSetItemState(${1:MediaItem* item},${2:char* str},${3:int str_sz})$0"
    },
    "GETSETITEMSTATE eel2": {
        "prefix": "GetSetItemState",
        "scope": "eel2",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "GetSetItemState(${1:MediaItem item},${2:#str})$0"
    },
    "REAPER.GETSETITEMSTATE lua": {
        "prefix": "reaper.GetSetItemState",
        "scope": "lua",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "reaper.GetSetItemState(${1:MediaItem item},${2:string str})$0"
    },
    "RPR_GETSETITEMSTATE python": {
        "prefix": "RPR_GetSetItemState",
        "scope": "python",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "RPR_GetSetItemState(${1:item},${2:str},${3:str_sz})$0"
    },
    "GETSETITEMSTATE2 c": {
        "prefix": "GetSetItemState2",
        "scope": "c",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "GetSetItemState2(${1:MediaItem* item},${2:char* str},${3:int str_sz},${4:bool isundo})$0"
    },
    "GETSETITEMSTATE2 eel2": {
        "prefix": "GetSetItemState2",
        "scope": "eel2",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "GetSetItemState2(${1:MediaItem item},${2:#str},${3:bool isundo})$0"
    },
    "REAPER.GETSETITEMSTATE2 lua": {
        "prefix": "reaper.GetSetItemState2",
        "scope": "lua",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "reaper.GetSetItemState2(${1:MediaItem item},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_GETSETITEMSTATE2 python": {
        "prefix": "RPR_GetSetItemState2",
        "scope": "python",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "RPR_GetSetItemState2(${1:item},${2:str},${3:str_sz},${4:isundo})$0"
    },
    "GETSETMEDIAITEMINFO_STRING c": {
        "prefix": "GetSetMediaItemInfo_String",
        "scope": "c",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "GetSetMediaItemInfo_String(${1:MediaItem* item},${2|const char* parmname,\"P_NOTES\",\"P_EXT:xyz\",\"GUID\"|},${3:char* stringNeedBig},${4:bool setNewValue})$0"
    },
    "GETSETMEDIAITEMINFO_STRING eel2": {
        "prefix": "GetSetMediaItemInfo_String",
        "scope": "eel2",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "GetSetMediaItemInfo_String(${1:MediaItem item},${2:\"parmname\"},${3:#stringNeedBig},${4:bool setNewValue})$0"
    },
    "REAPER.GETSETMEDIAITEMINFO_STRING lua": {
        "prefix": "reaper.GetSetMediaItemInfo_String",
        "scope": "lua",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "reaper.GetSetMediaItemInfo_String(${1:MediaItem item},${2|string parmname,\"P_NOTES\",\"P_EXT:xyz\",\"GUID\"|},${3:string stringNeedBig},${4:boolean setNewValue})$0"
    },
    "RPR_GETSETMEDIAITEMINFO_STRING python": {
        "prefix": "RPR_GetSetMediaItemInfo_String",
        "scope": "python",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "RPR_GetSetMediaItemInfo_String(${1:item},${2:parmname},${3:stringNeedBig},${4:setNewValue})$0"
    },
    "GETSETMEDIAITEMTAKEINFO_STRING c": {
        "prefix": "GetSetMediaItemTakeInfo_String",
        "scope": "c",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "GetSetMediaItemTakeInfo_String(${1:MediaItem_Take* tk},${2|const char* parmname,\"P_NAME\",\"P_EXT:xyz\",\"GUID\"|},${3:char* stringNeedBig},${4:bool setNewValue})$0"
    },
    "GETSETMEDIAITEMTAKEINFO_STRING eel2": {
        "prefix": "GetSetMediaItemTakeInfo_String",
        "scope": "eel2",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "GetSetMediaItemTakeInfo_String(${1:MediaItem_Take tk},${2:\"parmname\"},${3:#stringNeedBig},${4:bool setNewValue})$0"
    },
    "REAPER.GETSETMEDIAITEMTAKEINFO_STRING lua": {
        "prefix": "reaper.GetSetMediaItemTakeInfo_String",
        "scope": "lua",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "reaper.GetSetMediaItemTakeInfo_String(${1:MediaItem_Take tk},${2|string parmname,\"P_NAME\",\"P_EXT:xyz\",\"GUID\"|},${3:string stringNeedBig},${4:boolean setNewValue})$0"
    },
    "RPR_GETSETMEDIAITEMTAKEINFO_STRING python": {
        "prefix": "RPR_GetSetMediaItemTakeInfo_String",
        "scope": "python",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "RPR_GetSetMediaItemTakeInfo_String(${1:tk},${2:parmname},${3:stringNeedBig},${4:setNewValue})$0"
    },
    "GETSETMEDIATRACKINFO_STRING c": {
        "prefix": "GetSetMediaTrackInfo_String",
        "scope": "c",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "GetSetMediaTrackInfo_String(${1:MediaTrack* tr},${2|const char* parmname,\"P_NAME\",\"P_ICON\",\"P_MCP_LAYOUT\",\"P_TCP_LAYOUT\",\"P_EXT:xyz\",\"GUID\"|},${3:char* stringNeedBig},${4:bool setNewValue})$0"
    },
    "GETSETMEDIATRACKINFO_STRING eel2": {
        "prefix": "GetSetMediaTrackInfo_String",
        "scope": "eel2",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "GetSetMediaTrackInfo_String(${1:MediaTrack tr},${2:\"parmname\"},${3:#stringNeedBig},${4:bool setNewValue})$0"
    },
    "REAPER.GETSETMEDIATRACKINFO_STRING lua": {
        "prefix": "reaper.GetSetMediaTrackInfo_String",
        "scope": "lua",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "reaper.GetSetMediaTrackInfo_String(${1:MediaTrack tr},${2|string parmname,\"P_NAME\",\"P_ICON\",\"P_MCP_LAYOUT\",\"P_TCP_LAYOUT\",\"P_EXT:xyz\",\"GUID\"|},${3:string stringNeedBig},${4:boolean setNewValue})$0"
    },
    "RPR_GETSETMEDIATRACKINFO_STRING python": {
        "prefix": "RPR_GetSetMediaTrackInfo_String",
        "scope": "python",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "RPR_GetSetMediaTrackInfo_String(${1:tr},${2:parmname},${3:stringNeedBig},${4:setNewValue})$0"
    },
    "GETSETPROJECTAUTHOR c": {
        "prefix": "GetSetProjectAuthor",
        "scope": "c",
        "description": "gets or sets project author, author_sz is ignored when setting\n",
        "body": "GetSetProjectAuthor(${1:ReaProject* proj},${2:bool set},${3:char* author},${4:int author_sz})$0"
    },
    "GETSETPROJECTAUTHOR eel2": {
        "prefix": "GetSetProjectAuthor",
        "scope": "eel2",
        "description": "gets or sets project author, author_sz is ignored when setting\n",
        "body": "GetSetProjectAuthor(${1:ReaProject proj},${2:bool set},${3:#author})$0"
    },
    "REAPER.GETSETPROJECTAUTHOR lua": {
        "prefix": "reaper.GetSetProjectAuthor",
        "scope": "lua",
        "description": "gets or sets project author, author_sz is ignored when setting\n",
        "body": "reaper.GetSetProjectAuthor(${1:ReaProject proj},${2:boolean set},${3:string author})$0"
    },
    "RPR_GETSETPROJECTAUTHOR python": {
        "prefix": "RPR_GetSetProjectAuthor",
        "scope": "python",
        "description": "gets or sets project author, author_sz is ignored when setting\n",
        "body": "RPR_GetSetProjectAuthor(${1:proj},${2:set},${3:author},${4:author_sz})$0"
    },
    "GETSETPROJECTGRID c": {
        "prefix": "GetSetProjectGrid",
        "scope": "c",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "GetSetProjectGrid(${1:ReaProject* project},${2:bool set},${3:double* divisionInOutOptional},${4:int* swingmodeInOutOptional},${5:double* swingamtInOutOptional})$0"
    },
    "GETSETPROJECTGRID eel2": {
        "prefix": "GetSetProjectGrid",
        "scope": "eel2",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "GetSetProjectGrid(${1:ReaProject project},${2:bool set},${3:optional &division},${4:optional int &swingmode},${5:optional &swingamt})$0"
    },
    "REAPER.GETSETPROJECTGRID lua": {
        "prefix": "reaper.GetSetProjectGrid",
        "scope": "lua",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "reaper.GetSetProjectGrid(${1:ReaProject project},${2:boolean set},${3:optional number division},${4:optional number swingmode},${5:optional number swingamt})$0"
    },
    "RPR_GETSETPROJECTGRID python": {
        "prefix": "RPR_GetSetProjectGrid",
        "scope": "python",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "RPR_GetSetProjectGrid(${1:project},${2:set},${3:divisionInOutOptional},${4:swingmodeInOutOptional},${5:swingamtInOutOptional})$0"
    },
    "GETSETPROJECTINFO c": {
        "prefix": "GetSetProjectInfo",
        "scope": "c",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "GetSetProjectInfo(${1:ReaProject* project},${2|const char* desc,\"RENDER_SETTINGS\",\"RENDER_BOUNDSFLAG\",\"RENDER_CHANNELS\",\"RENDER_SRATE\",\"RENDER_STARTPOS\",\"RENDER_ENDPOS\",\"RENDER_TAILFLAG\",\"RENDER_TAILMS\",\"RENDER_ADDTOPROJ\",\"RENDER_DITHER\",\"PROJECT_SRATE\",\"PROJECT_SRATE_USE\"|},${3:double value},${4:bool is_set})$0"
    },
    "GETSETPROJECTINFO eel2": {
        "prefix": "GetSetProjectInfo",
        "scope": "eel2",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "GetSetProjectInfo(${1:ReaProject project},${2:\"desc\"},${3:value},${4:bool is_set})$0"
    },
    "REAPER.GETSETPROJECTINFO lua": {
        "prefix": "reaper.GetSetProjectInfo",
        "scope": "lua",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "reaper.GetSetProjectInfo(${1:ReaProject project},${2|string desc,\"RENDER_SETTINGS\",\"RENDER_BOUNDSFLAG\",\"RENDER_CHANNELS\",\"RENDER_SRATE\",\"RENDER_STARTPOS\",\"RENDER_ENDPOS\",\"RENDER_TAILFLAG\",\"RENDER_TAILMS\",\"RENDER_ADDTOPROJ\",\"RENDER_DITHER\",\"PROJECT_SRATE\",\"PROJECT_SRATE_USE\"|},${3:number value},${4:boolean is_set})$0"
    },
    "RPR_GETSETPROJECTINFO python": {
        "prefix": "RPR_GetSetProjectInfo",
        "scope": "python",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "RPR_GetSetProjectInfo(${1:ReaProject project},${2|String desc,\"RENDER_SETTINGS\",\"RENDER_BOUNDSFLAG\",\"RENDER_CHANNELS\",\"RENDER_SRATE\",\"RENDER_STARTPOS\",\"RENDER_ENDPOS\",\"RENDER_TAILFLAG\",\"RENDER_TAILMS\",\"RENDER_ADDTOPROJ\",\"RENDER_DITHER\",\"PROJECT_SRATE\",\"PROJECT_SRATE_USE\"|},${3:Float value},${4:Boolean is_set})$0"
    },
    "GETSETPROJECTINFO_STRING c": {
        "prefix": "GetSetProjectInfo_String",
        "scope": "c",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "GetSetProjectInfo_String(${1:ReaProject* project},${2|const char* desc,\"MARKER_GUID:X\",\"RECORD_PATH\",\"RENDER_FILE\",\"RENDER_PATTERN\",\"RENDER_FORMAT\",\"RENDER_FORMAT2\"|},${3:char* valuestrNeedBig},${4:bool is_set})$0"
    },
    "GETSETPROJECTINFO_STRING eel2": {
        "prefix": "GetSetProjectInfo_String",
        "scope": "eel2",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "GetSetProjectInfo_String(${1:ReaProject project},${2:\"desc\"},${3:#valuestrNeedBig},${4:bool is_set})$0"
    },
    "REAPER.GETSETPROJECTINFO_STRING lua": {
        "prefix": "reaper.GetSetProjectInfo_String",
        "scope": "lua",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "reaper.GetSetProjectInfo_String(${1:ReaProject project},${2|string desc,\"MARKER_GUID:X\",\"RECORD_PATH\",\"RENDER_FILE\",\"RENDER_PATTERN\",\"RENDER_FORMAT\",\"RENDER_FORMAT2\"|},${3:string valuestrNeedBig},${4:boolean is_set})$0"
    },
    "RPR_GETSETPROJECTINFO_STRING python": {
        "prefix": "RPR_GetSetProjectInfo_String",
        "scope": "python",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "RPR_GetSetProjectInfo_String(${1:project},${2:desc},${3:valuestrNeedBig},${4:is_set})$0"
    },
    "GETSETPROJECTNOTES c": {
        "prefix": "GetSetProjectNotes",
        "scope": "c",
        "description": "gets or sets project notes, notesNeedBig_sz is ignored when setting\n",
        "body": "GetSetProjectNotes(${1:ReaProject* proj},${2:bool set},${3:char* notesNeedBig},${4:int notesNeedBig_sz})$0"
    },
    "GETSETPROJECTNOTES eel2": {
        "prefix": "GetSetProjectNotes",
        "scope": "eel2",
        "description": "gets or sets project notes, notesNeedBig_sz is ignored when setting\n",
        "body": "GetSetProjectNotes(${1:ReaProject proj},${2:bool set},${3:#notes})$0"
    },
    "REAPER.GETSETPROJECTNOTES lua": {
        "prefix": "reaper.GetSetProjectNotes",
        "scope": "lua",
        "description": "gets or sets project notes, notesNeedBig_sz is ignored when setting\n",
        "body": "reaper.GetSetProjectNotes(${1:ReaProject proj},${2:boolean set},${3:string notes})$0"
    },
    "RPR_GETSETPROJECTNOTES python": {
        "prefix": "RPR_GetSetProjectNotes",
        "scope": "python",
        "description": "gets or sets project notes, notesNeedBig_sz is ignored when setting\n",
        "body": "RPR_GetSetProjectNotes(${1:proj},${2:set},${3:notesNeedBig},${4:notesNeedBig_sz})$0"
    },
    "GETSETREPEAT c": {
        "prefix": "GetSetRepeat",
        "scope": "c",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "GetSetRepeat(${1:int val})$0"
    },
    "GETSETREPEAT eel2": {
        "prefix": "GetSetRepeat",
        "scope": "eel2",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "GetSetRepeat(${1:int val})$0"
    },
    "REAPER.GETSETREPEAT lua": {
        "prefix": "reaper.GetSetRepeat",
        "scope": "lua",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "reaper.GetSetRepeat(${1:integer val})$0"
    },
    "RPR_GETSETREPEAT python": {
        "prefix": "RPR_GetSetRepeat",
        "scope": "python",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "RPR_GetSetRepeat(${1:Int val})$0"
    },
    "GETSETREPEATEX c": {
        "prefix": "GetSetRepeatEx",
        "scope": "c",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "GetSetRepeatEx(${1:ReaProject* proj},${2:int val})$0"
    },
    "GETSETREPEATEX eel2": {
        "prefix": "GetSetRepeatEx",
        "scope": "eel2",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "GetSetRepeatEx(${1:ReaProject proj},${2:int val})$0"
    },
    "REAPER.GETSETREPEATEX lua": {
        "prefix": "reaper.GetSetRepeatEx",
        "scope": "lua",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "reaper.GetSetRepeatEx(${1:ReaProject proj},${2:integer val})$0"
    },
    "RPR_GETSETREPEATEX python": {
        "prefix": "RPR_GetSetRepeatEx",
        "scope": "python",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "RPR_GetSetRepeatEx(${1:ReaProject proj},${2:Int val})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIP c": {
        "prefix": "GetSetTrackGroupMembership",
        "scope": "c",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "GetSetTrackGroupMembership(${1:MediaTrack* tr},${2:const char* groupname},${3:unsigned int setmask},${4:unsigned int setvalue})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIP eel2": {
        "prefix": "GetSetTrackGroupMembership",
        "scope": "eel2",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "GetSetTrackGroupMembership(${1:MediaTrack tr},${2:\"groupname\"},${3:uint setmask},${4:uint setvalue})$0"
    },
    "REAPER.GETSETTRACKGROUPMEMBERSHIP lua": {
        "prefix": "reaper.GetSetTrackGroupMembership",
        "scope": "lua",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "reaper.GetSetTrackGroupMembership(${1:MediaTrack tr},${2:string groupname},${3:integer setmask},${4:integer setvalue})$0"
    },
    "RPR_GETSETTRACKGROUPMEMBERSHIP python": {
        "prefix": "RPR_GetSetTrackGroupMembership",
        "scope": "python",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "RPR_GetSetTrackGroupMembership(${1:MediaTrack tr},${2:String groupname},${3:Unknown setmask},${4:Unknown setvalue})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIPHIGH c": {
        "prefix": "GetSetTrackGroupMembershipHigh",
        "scope": "c",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "GetSetTrackGroupMembershipHigh(${1:MediaTrack* tr},${2:const char* groupname},${3:unsigned int setmask},${4:unsigned int setvalue})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIPHIGH eel2": {
        "prefix": "GetSetTrackGroupMembershipHigh",
        "scope": "eel2",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "GetSetTrackGroupMembershipHigh(${1:MediaTrack tr},${2:\"groupname\"},${3:uint setmask},${4:uint setvalue})$0"
    },
    "REAPER.GETSETTRACKGROUPMEMBERSHIPHIGH lua": {
        "prefix": "reaper.GetSetTrackGroupMembershipHigh",
        "scope": "lua",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "reaper.GetSetTrackGroupMembershipHigh(${1:MediaTrack tr},${2:string groupname},${3:integer setmask},${4:integer setvalue})$0"
    },
    "RPR_GETSETTRACKGROUPMEMBERSHIPHIGH python": {
        "prefix": "RPR_GetSetTrackGroupMembershipHigh",
        "scope": "python",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "RPR_GetSetTrackGroupMembershipHigh(${1:MediaTrack tr},${2:String groupname},${3:Unknown setmask},${4:Unknown setvalue})$0"
    },
    "GETSETTRACKSENDINFO_STRING c": {
        "prefix": "GetSetTrackSendInfo_String",
        "scope": "c",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "GetSetTrackSendInfo_String(${1:MediaTrack* tr},${2:int category},${3:int sendidx},${4|const char* parmname,\"P_EXT:xyz\"|},${5:char* stringNeedBig},${6:bool setNewValue})$0"
    },
    "GETSETTRACKSENDINFO_STRING eel2": {
        "prefix": "GetSetTrackSendInfo_String",
        "scope": "eel2",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "GetSetTrackSendInfo_String(${1:MediaTrack tr},${2:int category},${3:int sendidx},${4:\"parmname\"},${5:#stringNeedBig},${6:bool setNewValue})$0"
    },
    "REAPER.GETSETTRACKSENDINFO_STRING lua": {
        "prefix": "reaper.GetSetTrackSendInfo_String",
        "scope": "lua",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "reaper.GetSetTrackSendInfo_String(${1:MediaTrack tr},${2:integer category},${3:integer sendidx},${4|string parmname,\"P_EXT:xyz\"|},${5:string stringNeedBig},${6:boolean setNewValue})$0"
    },
    "RPR_GETSETTRACKSENDINFO_STRING python": {
        "prefix": "RPR_GetSetTrackSendInfo_String",
        "scope": "python",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "RPR_GetSetTrackSendInfo_String(${1:tr},${2:category},${3:sendidx},${4:parmname},${5:stringNeedBig},${6:setNewValue})$0"
    },
    "GETSETTRACKSTATE c": {
        "prefix": "GetSetTrackState",
        "scope": "c",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "GetSetTrackState(${1:MediaTrack* track},${2:char* str},${3:int str_sz})$0"
    },
    "GETSETTRACKSTATE eel2": {
        "prefix": "GetSetTrackState",
        "scope": "eel2",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "GetSetTrackState(${1:MediaTrack track},${2:#str})$0"
    },
    "REAPER.GETSETTRACKSTATE lua": {
        "prefix": "reaper.GetSetTrackState",
        "scope": "lua",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "reaper.GetSetTrackState(${1:MediaTrack track},${2:string str})$0"
    },
    "RPR_GETSETTRACKSTATE python": {
        "prefix": "RPR_GetSetTrackState",
        "scope": "python",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "RPR_GetSetTrackState(${1:track},${2:str},${3:str_sz})$0"
    },
    "GETSETTRACKSTATE2 c": {
        "prefix": "GetSetTrackState2",
        "scope": "c",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "GetSetTrackState2(${1:MediaTrack* track},${2:char* str},${3:int str_sz},${4:bool isundo})$0"
    },
    "GETSETTRACKSTATE2 eel2": {
        "prefix": "GetSetTrackState2",
        "scope": "eel2",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "GetSetTrackState2(${1:MediaTrack track},${2:#str},${3:bool isundo})$0"
    },
    "REAPER.GETSETTRACKSTATE2 lua": {
        "prefix": "reaper.GetSetTrackState2",
        "scope": "lua",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "reaper.GetSetTrackState2(${1:MediaTrack track},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_GETSETTRACKSTATE2 python": {
        "prefix": "RPR_GetSetTrackState2",
        "scope": "python",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "RPR_GetSetTrackState2(${1:track},${2:str},${3:str_sz},${4:isundo})$0"
    },
    "GETSUBPROJECTFROMSOURCE c": {
        "prefix": "GetSubProjectFromSource",
        "scope": "c",
        "description": "\n",
        "body": "GetSubProjectFromSource(${1:PCM_source* src})$0"
    },
    "GETSUBPROJECTFROMSOURCE eel2": {
        "prefix": "GetSubProjectFromSource",
        "scope": "eel2",
        "description": "\n",
        "body": "GetSubProjectFromSource(${1:PCM_source src})$0"
    },
    "REAPER.GETSUBPROJECTFROMSOURCE lua": {
        "prefix": "reaper.GetSubProjectFromSource",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetSubProjectFromSource(${1:PCM_source src})$0"
    },
    "RPR_GETSUBPROJECTFROMSOURCE python": {
        "prefix": "RPR_GetSubProjectFromSource",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetSubProjectFromSource(${1:PCM_source src})$0"
    },
    "GETTAKE c": {
        "prefix": "GetTake",
        "scope": "c",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "GetTake(${1:MediaItem* item},${2:int takeidx})$0"
    },
    "GETTAKE eel2": {
        "prefix": "GetTake",
        "scope": "eel2",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "GetTake(${1:MediaItem item},${2:int takeidx})$0"
    },
    "REAPER.GETTAKE lua": {
        "prefix": "reaper.GetTake",
        "scope": "lua",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "reaper.GetTake(${1:MediaItem item},${2:integer takeidx})$0"
    },
    "RPR_GETTAKE python": {
        "prefix": "RPR_GetTake",
        "scope": "python",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "RPR_GetTake(${1:MediaItem item},${2:Int takeidx})$0"
    },
    "GETTAKEENVELOPE c": {
        "prefix": "GetTakeEnvelope",
        "scope": "c",
        "description": "\n",
        "body": "GetTakeEnvelope(${1:MediaItem_Take* take},${2:int envidx})$0"
    },
    "GETTAKEENVELOPE eel2": {
        "prefix": "GetTakeEnvelope",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTakeEnvelope(${1:MediaItem_Take take},${2:int envidx})$0"
    },
    "REAPER.GETTAKEENVELOPE lua": {
        "prefix": "reaper.GetTakeEnvelope",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTakeEnvelope(${1:MediaItem_Take take},${2:integer envidx})$0"
    },
    "RPR_GETTAKEENVELOPE python": {
        "prefix": "RPR_GetTakeEnvelope",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTakeEnvelope(${1:MediaItem_Take take},${2:Int envidx})$0"
    },
    "GETTAKEENVELOPEBYNAME c": {
        "prefix": "GetTakeEnvelopeByName",
        "scope": "c",
        "description": "\n",
        "body": "GetTakeEnvelopeByName(${1:MediaItem_Take* take},${2:const char* envname})$0"
    },
    "GETTAKEENVELOPEBYNAME eel2": {
        "prefix": "GetTakeEnvelopeByName",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTakeEnvelopeByName(${1:MediaItem_Take take},${2:\"envname\"})$0"
    },
    "REAPER.GETTAKEENVELOPEBYNAME lua": {
        "prefix": "reaper.GetTakeEnvelopeByName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTakeEnvelopeByName(${1:MediaItem_Take take},${2:string envname})$0"
    },
    "RPR_GETTAKEENVELOPEBYNAME python": {
        "prefix": "RPR_GetTakeEnvelopeByName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTakeEnvelopeByName(${1:MediaItem_Take take},${2:String envname})$0"
    },
    "GETTAKENAME c": {
        "prefix": "GetTakeName",
        "scope": "c",
        "description": "returns NULL if the take is not valid\n",
        "body": "GetTakeName(${1:MediaItem_Take* take})$0"
    },
    "GETTAKENAME eel2": {
        "prefix": "GetTakeName",
        "scope": "eel2",
        "description": "returns NULL if the take is not valid\n",
        "body": "GetTakeName(${1:#retval},${2:MediaItem_Take take})$0"
    },
    "REAPER.GETTAKENAME lua": {
        "prefix": "reaper.GetTakeName",
        "scope": "lua",
        "description": "returns NULL if the take is not valid\n",
        "body": "reaper.GetTakeName(${1:MediaItem_Take take})$0"
    },
    "RPR_GETTAKENAME python": {
        "prefix": "RPR_GetTakeName",
        "scope": "python",
        "description": "returns NULL if the take is not valid\n",
        "body": "RPR_GetTakeName(${1:MediaItem_Take take})$0"
    },
    "GETTAKENUMSTRETCHMARKERS c": {
        "prefix": "GetTakeNumStretchMarkers",
        "scope": "c",
        "description": "Returns number of stretch markers in take\n",
        "body": "GetTakeNumStretchMarkers(${1:MediaItem_Take* take})$0"
    },
    "GETTAKENUMSTRETCHMARKERS eel2": {
        "prefix": "GetTakeNumStretchMarkers",
        "scope": "eel2",
        "description": "Returns number of stretch markers in take\n",
        "body": "GetTakeNumStretchMarkers(${1:MediaItem_Take take})$0"
    },
    "REAPER.GETTAKENUMSTRETCHMARKERS lua": {
        "prefix": "reaper.GetTakeNumStretchMarkers",
        "scope": "lua",
        "description": "Returns number of stretch markers in take\n",
        "body": "reaper.GetTakeNumStretchMarkers(${1:MediaItem_Take take})$0"
    },
    "RPR_GETTAKENUMSTRETCHMARKERS python": {
        "prefix": "RPR_GetTakeNumStretchMarkers",
        "scope": "python",
        "description": "Returns number of stretch markers in take\n",
        "body": "RPR_GetTakeNumStretchMarkers(${1:MediaItem_Take take})$0"
    },
    "GETTAKESTRETCHMARKER c": {
        "prefix": "GetTakeStretchMarker",
        "scope": "c",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "GetTakeStretchMarker(${1:MediaItem_Take* take},${2:int idx},${3:double* posOut},${4:double* srcposOutOptional})$0"
    },
    "GETTAKESTRETCHMARKER eel2": {
        "prefix": "GetTakeStretchMarker",
        "scope": "eel2",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "GetTakeStretchMarker(${1:MediaItem_Take take},${2:int idx},${3:&pos},${4:optional &srcpos})$0"
    },
    "REAPER.GETTAKESTRETCHMARKER lua": {
        "prefix": "reaper.GetTakeStretchMarker",
        "scope": "lua",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "reaper.GetTakeStretchMarker(${1:MediaItem_Take take},${2:integer idx})$0"
    },
    "RPR_GETTAKESTRETCHMARKER python": {
        "prefix": "RPR_GetTakeStretchMarker",
        "scope": "python",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "RPR_GetTakeStretchMarker(${1:take},${2:idx},${3:posOut},${4:srcposOutOptional})$0"
    },
    "GETTAKESTRETCHMARKERSLOPE c": {
        "prefix": "GetTakeStretchMarkerSlope",
        "scope": "c",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "GetTakeStretchMarkerSlope(${1:MediaItem_Take* take},${2:int idx})$0"
    },
    "GETTAKESTRETCHMARKERSLOPE eel2": {
        "prefix": "GetTakeStretchMarkerSlope",
        "scope": "eel2",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "GetTakeStretchMarkerSlope(${1:MediaItem_Take take},${2:int idx})$0"
    },
    "REAPER.GETTAKESTRETCHMARKERSLOPE lua": {
        "prefix": "reaper.GetTakeStretchMarkerSlope",
        "scope": "lua",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "reaper.GetTakeStretchMarkerSlope(${1:MediaItem_Take take},${2:integer idx})$0"
    },
    "RPR_GETTAKESTRETCHMARKERSLOPE python": {
        "prefix": "RPR_GetTakeStretchMarkerSlope",
        "scope": "python",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "RPR_GetTakeStretchMarkerSlope(${1:MediaItem_Take take},${2:Int idx})$0"
    },
    "GETTCPFXPARM c": {
        "prefix": "GetTCPFXParm",
        "scope": "c",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "GetTCPFXParm(${1:ReaProject* project},${2:MediaTrack* track},${3:int index},${4:int* fxindexOut},${5:int* parmidxOut})$0"
    },
    "GETTCPFXPARM eel2": {
        "prefix": "GetTCPFXParm",
        "scope": "eel2",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "GetTCPFXParm(${1:ReaProject project},${2:MediaTrack track},${3:int index},${4:int &fxindex},${5:int &parmidx})$0"
    },
    "REAPER.GETTCPFXPARM lua": {
        "prefix": "reaper.GetTCPFXParm",
        "scope": "lua",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "reaper.GetTCPFXParm(${1:ReaProject project},${2:MediaTrack track},${3:integer index})$0"
    },
    "RPR_GETTCPFXPARM python": {
        "prefix": "RPR_GetTCPFXParm",
        "scope": "python",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "RPR_GetTCPFXParm(${1:project},${2:track},${3:index},${4:fxindexOut},${5:parmidxOut})$0"
    },
    "GETTEMPOMATCHPLAYRATE c": {
        "prefix": "GetTempoMatchPlayRate",
        "scope": "c",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "GetTempoMatchPlayRate(${1:PCM_source* source},${2:double srcscale},${3:double position},${4:double mult},${5:double* rateOut},${6:double* targetlenOut})$0"
    },
    "GETTEMPOMATCHPLAYRATE eel2": {
        "prefix": "GetTempoMatchPlayRate",
        "scope": "eel2",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "GetTempoMatchPlayRate(${1:PCM_source source},${2:srcscale},${3:position},${4:mult},${5:&rate},${6:&targetlen})$0"
    },
    "REAPER.GETTEMPOMATCHPLAYRATE lua": {
        "prefix": "reaper.GetTempoMatchPlayRate",
        "scope": "lua",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "reaper.GetTempoMatchPlayRate(${1:PCM_source source},${2:number srcscale},${3:number position},${4:number mult})$0"
    },
    "RPR_GETTEMPOMATCHPLAYRATE python": {
        "prefix": "RPR_GetTempoMatchPlayRate",
        "scope": "python",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "RPR_GetTempoMatchPlayRate(${1:source},${2:srcscale},${3:position},${4:mult},${5:rateOut},${6:targetlenOut})$0"
    },
    "GETTEMPOTIMESIGMARKER c": {
        "prefix": "GetTempoTimeSigMarker",
        "scope": "c",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "GetTempoTimeSigMarker(${1:ReaProject* proj},${2:int ptidx},${3:double* timeposOut},${4:int* measureposOut},${5:double* beatposOut},${6:double* bpmOut},${7:int* timesig_numOut},${8:int* timesig_denomOut},${9:bool* lineartempoOut})$0"
    },
    "GETTEMPOTIMESIGMARKER eel2": {
        "prefix": "GetTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "GetTempoTimeSigMarker(${1:ReaProject proj},${2:int ptidx},${3:&timepos},${4:int &measurepos},${5:&beatpos},${6:&bpm},${7:int &timesig_num},${8:int &timesig_denom},${9:bool &lineartempo})$0"
    },
    "REAPER.GETTEMPOTIMESIGMARKER lua": {
        "prefix": "reaper.GetTempoTimeSigMarker",
        "scope": "lua",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "reaper.GetTempoTimeSigMarker(${1:ReaProject proj},${2:integer ptidx})$0"
    },
    "RPR_GETTEMPOTIMESIGMARKER python": {
        "prefix": "RPR_GetTempoTimeSigMarker",
        "scope": "python",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "RPR_GetTempoTimeSigMarker(${1:proj},${2:ptidx},${3:timeposOut},${4:measureposOut},${5:beatposOut},${6:bpmOut},${7:timesig_numOut},${8:timesig_denomOut},${9:lineartempoOut})$0"
    },
    "GETTOGGLECOMMANDSTATE c": {
        "prefix": "GetToggleCommandState",
        "scope": "c",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "GetToggleCommandState(${1:int command_id})$0"
    },
    "GETTOGGLECOMMANDSTATE eel2": {
        "prefix": "GetToggleCommandState",
        "scope": "eel2",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "GetToggleCommandState(${1:int command_id})$0"
    },
    "REAPER.GETTOGGLECOMMANDSTATE lua": {
        "prefix": "reaper.GetToggleCommandState",
        "scope": "lua",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "reaper.GetToggleCommandState(${1:integer command_id})$0"
    },
    "RPR_GETTOGGLECOMMANDSTATE python": {
        "prefix": "RPR_GetToggleCommandState",
        "scope": "python",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "RPR_GetToggleCommandState(${1:Int command_id})$0"
    },
    "GETTOGGLECOMMANDSTATEEX c": {
        "prefix": "GetToggleCommandStateEx",
        "scope": "c",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "GetToggleCommandStateEx(${1:int section_id},${2:int command_id})$0"
    },
    "GETTOGGLECOMMANDSTATEEX eel2": {
        "prefix": "GetToggleCommandStateEx",
        "scope": "eel2",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "GetToggleCommandStateEx(${1:int section_id},${2:int command_id})$0"
    },
    "REAPER.GETTOGGLECOMMANDSTATEEX lua": {
        "prefix": "reaper.GetToggleCommandStateEx",
        "scope": "lua",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "reaper.GetToggleCommandStateEx(${1:integer section_id},${2:integer command_id})$0"
    },
    "RPR_GETTOGGLECOMMANDSTATEEX python": {
        "prefix": "RPR_GetToggleCommandStateEx",
        "scope": "python",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "RPR_GetToggleCommandStateEx(${1:Int section_id},${2:Int command_id})$0"
    },
    "GETTOOLTIPWINDOW c": {
        "prefix": "GetTooltipWindow",
        "scope": "c",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "GetTooltipWindow()$0"
    },
    "GETTOOLTIPWINDOW eel2": {
        "prefix": "GetTooltipWindow",
        "scope": "eel2",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "GetTooltipWindow()$0"
    },
    "REAPER.GETTOOLTIPWINDOW lua": {
        "prefix": "reaper.GetTooltipWindow",
        "scope": "lua",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "reaper.GetTooltipWindow()$0"
    },
    "RPR_GETTOOLTIPWINDOW python": {
        "prefix": "RPR_GetTooltipWindow",
        "scope": "python",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "RPR_GetTooltipWindow()$0"
    },
    "GETTRACK c": {
        "prefix": "GetTrack",
        "scope": "c",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "GetTrack(${1:ReaProject* proj},${2:int trackidx})$0"
    },
    "GETTRACK eel2": {
        "prefix": "GetTrack",
        "scope": "eel2",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "GetTrack(${1:ReaProject proj},${2:int trackidx})$0"
    },
    "REAPER.GETTRACK lua": {
        "prefix": "reaper.GetTrack",
        "scope": "lua",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "reaper.GetTrack(${1:ReaProject proj},${2:integer trackidx})$0"
    },
    "RPR_GETTRACK python": {
        "prefix": "RPR_GetTrack",
        "scope": "python",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "RPR_GetTrack(${1:ReaProject proj},${2:Int trackidx})$0"
    },
    "GETTRACKAUTOMATIONMODE c": {
        "prefix": "GetTrackAutomationMode",
        "scope": "c",
        "description": "return the track mode, regardless of global override\n",
        "body": "GetTrackAutomationMode(${1:MediaTrack* tr})$0"
    },
    "GETTRACKAUTOMATIONMODE eel2": {
        "prefix": "GetTrackAutomationMode",
        "scope": "eel2",
        "description": "return the track mode, regardless of global override\n",
        "body": "GetTrackAutomationMode(${1:MediaTrack tr})$0"
    },
    "REAPER.GETTRACKAUTOMATIONMODE lua": {
        "prefix": "reaper.GetTrackAutomationMode",
        "scope": "lua",
        "description": "return the track mode, regardless of global override\n",
        "body": "reaper.GetTrackAutomationMode(${1:MediaTrack tr})$0"
    },
    "RPR_GETTRACKAUTOMATIONMODE python": {
        "prefix": "RPR_GetTrackAutomationMode",
        "scope": "python",
        "description": "return the track mode, regardless of global override\n",
        "body": "RPR_GetTrackAutomationMode(${1:MediaTrack tr})$0"
    },
    "GETTRACKCOLOR c": {
        "prefix": "GetTrackColor",
        "scope": "c",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "GetTrackColor(${1:MediaTrack* track})$0"
    },
    "GETTRACKCOLOR eel2": {
        "prefix": "GetTrackColor",
        "scope": "eel2",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "GetTrackColor(${1:MediaTrack track})$0"
    },
    "REAPER.GETTRACKCOLOR lua": {
        "prefix": "reaper.GetTrackColor",
        "scope": "lua",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "reaper.GetTrackColor(${1:MediaTrack track})$0"
    },
    "RPR_GETTRACKCOLOR python": {
        "prefix": "RPR_GetTrackColor",
        "scope": "python",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "RPR_GetTrackColor(${1:MediaTrack track})$0"
    },
    "GETTRACKDEPTH c": {
        "prefix": "GetTrackDepth",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackDepth(${1:MediaTrack* track})$0"
    },
    "GETTRACKDEPTH eel2": {
        "prefix": "GetTrackDepth",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackDepth(${1:MediaTrack track})$0"
    },
    "REAPER.GETTRACKDEPTH lua": {
        "prefix": "reaper.GetTrackDepth",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackDepth(${1:MediaTrack track})$0"
    },
    "RPR_GETTRACKDEPTH python": {
        "prefix": "RPR_GetTrackDepth",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackDepth(${1:MediaTrack track})$0"
    },
    "GETTRACKENVELOPE c": {
        "prefix": "GetTrackEnvelope",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackEnvelope(${1:MediaTrack* track},${2:int envidx})$0"
    },
    "GETTRACKENVELOPE eel2": {
        "prefix": "GetTrackEnvelope",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackEnvelope(${1:MediaTrack track},${2:int envidx})$0"
    },
    "REAPER.GETTRACKENVELOPE lua": {
        "prefix": "reaper.GetTrackEnvelope",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackEnvelope(${1:MediaTrack track},${2:integer envidx})$0"
    },
    "RPR_GETTRACKENVELOPE python": {
        "prefix": "RPR_GetTrackEnvelope",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackEnvelope(${1:MediaTrack track},${2:Int envidx})$0"
    },
    "GETTRACKENVELOPEBYCHUNKNAME c": {
        "prefix": "GetTrackEnvelopeByChunkName",
        "scope": "c",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "GetTrackEnvelopeByChunkName(${1:MediaTrack* tr},${2:const char* cfgchunkname})$0"
    },
    "GETTRACKENVELOPEBYCHUNKNAME eel2": {
        "prefix": "GetTrackEnvelopeByChunkName",
        "scope": "eel2",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "GetTrackEnvelopeByChunkName(${1:MediaTrack tr},${2:\"cfgchunkname\"})$0"
    },
    "REAPER.GETTRACKENVELOPEBYCHUNKNAME lua": {
        "prefix": "reaper.GetTrackEnvelopeByChunkName",
        "scope": "lua",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "reaper.GetTrackEnvelopeByChunkName(${1:MediaTrack tr},${2:string cfgchunkname})$0"
    },
    "RPR_GETTRACKENVELOPEBYCHUNKNAME python": {
        "prefix": "RPR_GetTrackEnvelopeByChunkName",
        "scope": "python",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "RPR_GetTrackEnvelopeByChunkName(${1:MediaTrack tr},${2:String cfgchunkname})$0"
    },
    "GETTRACKENVELOPEBYNAME c": {
        "prefix": "GetTrackEnvelopeByName",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackEnvelopeByName(${1:MediaTrack* track},${2:const char* envname})$0"
    },
    "GETTRACKENVELOPEBYNAME eel2": {
        "prefix": "GetTrackEnvelopeByName",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackEnvelopeByName(${1:MediaTrack track},${2:\"envname\"})$0"
    },
    "REAPER.GETTRACKENVELOPEBYNAME lua": {
        "prefix": "reaper.GetTrackEnvelopeByName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackEnvelopeByName(${1:MediaTrack track},${2:string envname})$0"
    },
    "RPR_GETTRACKENVELOPEBYNAME python": {
        "prefix": "RPR_GetTrackEnvelopeByName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackEnvelopeByName(${1:MediaTrack track},${2:String envname})$0"
    },
    "GETTRACKFROMPOINT c": {
        "prefix": "GetTrackFromPoint",
        "scope": "c",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "GetTrackFromPoint(${1:int screen_x},${2:int screen_y},${3:int* infoOutOptional})$0"
    },
    "GETTRACKFROMPOINT eel2": {
        "prefix": "GetTrackFromPoint",
        "scope": "eel2",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "GetTrackFromPoint(${1:int screen_x},${2:int screen_y},${3:optional int &info})$0"
    },
    "REAPER.GETTRACKFROMPOINT lua": {
        "prefix": "reaper.GetTrackFromPoint",
        "scope": "lua",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "reaper.GetTrackFromPoint(${1:integer screen_x},${2:integer screen_y})$0"
    },
    "RPR_GETTRACKFROMPOINT python": {
        "prefix": "RPR_GetTrackFromPoint",
        "scope": "python",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "RPR_GetTrackFromPoint(${1:screen_x},${2:screen_y},${3:infoOutOptional})$0"
    },
    "GETTRACKGUID c": {
        "prefix": "GetTrackGUID",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackGUID(${1:MediaTrack* tr})$0"
    },
    "GETTRACKGUID eel2": {
        "prefix": "GetTrackGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackGUID(${1:#retguid},${2:MediaTrack tr})$0"
    },
    "REAPER.GETTRACKGUID lua": {
        "prefix": "reaper.GetTrackGUID",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackGUID(${1:MediaTrack tr})$0"
    },
    "RPR_GETTRACKGUID python": {
        "prefix": "RPR_GetTrackGUID",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackGUID(${1:MediaTrack tr})$0"
    },
    "GETTRACKMEDIAITEM c": {
        "prefix": "GetTrackMediaItem",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackMediaItem(${1:MediaTrack* tr},${2:int itemidx})$0"
    },
    "GETTRACKMEDIAITEM eel2": {
        "prefix": "GetTrackMediaItem",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackMediaItem(${1:MediaTrack tr},${2:int itemidx})$0"
    },
    "REAPER.GETTRACKMEDIAITEM lua": {
        "prefix": "reaper.GetTrackMediaItem",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackMediaItem(${1:MediaTrack tr},${2:integer itemidx})$0"
    },
    "RPR_GETTRACKMEDIAITEM python": {
        "prefix": "RPR_GetTrackMediaItem",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackMediaItem(${1:MediaTrack tr},${2:Int itemidx})$0"
    },
    "GETTRACKMIDILYRICS c": {
        "prefix": "GetTrackMIDILyrics",
        "scope": "c",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "GetTrackMIDILyrics(${1:MediaTrack* track},${2:int flag},${3:char* bufWantNeedBig},${4:int* bufWantNeedBig_sz})$0"
    },
    "GETTRACKMIDILYRICS eel2": {
        "prefix": "GetTrackMIDILyrics",
        "scope": "eel2",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "GetTrackMIDILyrics(${1:MediaTrack track},${2:int flag},${3:#bufWant})$0"
    },
    "REAPER.GETTRACKMIDILYRICS lua": {
        "prefix": "reaper.GetTrackMIDILyrics",
        "scope": "lua",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "reaper.GetTrackMIDILyrics(${1:MediaTrack track},${2:integer flag},${3:string bufWant})$0"
    },
    "RPR_GETTRACKMIDILYRICS python": {
        "prefix": "RPR_GetTrackMIDILyrics",
        "scope": "python",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "RPR_GetTrackMIDILyrics(${1:track},${2:flag},${3:bufWantNeedBig},${4:bufWantNeedBig_sz})$0"
    },
    "GETTRACKMIDINOTENAME c": {
        "prefix": "GetTrackMIDINoteName",
        "scope": "c",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "GetTrackMIDINoteName(${1:int track},${2:int pitch},${3:int chan})$0"
    },
    "GETTRACKMIDINOTENAME eel2": {
        "prefix": "GetTrackMIDINoteName",
        "scope": "eel2",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "GetTrackMIDINoteName(${1:#retval},${2:int track},${3:int pitch},${4:int chan})$0"
    },
    "REAPER.GETTRACKMIDINOTENAME lua": {
        "prefix": "reaper.GetTrackMIDINoteName",
        "scope": "lua",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "reaper.GetTrackMIDINoteName(${1:integer track},${2:integer pitch},${3:integer chan})$0"
    },
    "RPR_GETTRACKMIDINOTENAME python": {
        "prefix": "RPR_GetTrackMIDINoteName",
        "scope": "python",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "RPR_GetTrackMIDINoteName(${1:Int track},${2:Int pitch},${3:Int chan})$0"
    },
    "GETTRACKMIDINOTENAMEEX c": {
        "prefix": "GetTrackMIDINoteNameEx",
        "scope": "c",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "GetTrackMIDINoteNameEx(${1:ReaProject* proj},${2:MediaTrack* track},${3:int pitch},${4:int chan})$0"
    },
    "GETTRACKMIDINOTENAMEEX eel2": {
        "prefix": "GetTrackMIDINoteNameEx",
        "scope": "eel2",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "GetTrackMIDINoteNameEx(${1:#retval},${2:ReaProject proj},${3:MediaTrack track},${4:int pitch},${5:int chan})$0"
    },
    "REAPER.GETTRACKMIDINOTENAMEEX lua": {
        "prefix": "reaper.GetTrackMIDINoteNameEx",
        "scope": "lua",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "reaper.GetTrackMIDINoteNameEx(${1:ReaProject proj},${2:MediaTrack track},${3:integer pitch},${4:integer chan})$0"
    },
    "RPR_GETTRACKMIDINOTENAMEEX python": {
        "prefix": "RPR_GetTrackMIDINoteNameEx",
        "scope": "python",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "RPR_GetTrackMIDINoteNameEx(${1:ReaProject proj},${2:MediaTrack track},${3:Int pitch},${4:Int chan})$0"
    },
    "GETTRACKMIDINOTERANGE c": {
        "prefix": "GetTrackMIDINoteRange",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackMIDINoteRange(${1:ReaProject* proj},${2:MediaTrack* track},${3:int* note_loOut},${4:int* note_hiOut})$0"
    },
    "GETTRACKMIDINOTERANGE eel2": {
        "prefix": "GetTrackMIDINoteRange",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackMIDINoteRange(${1:ReaProject proj},${2:MediaTrack track},${3:int &note_lo},${4:int &note_hi})$0"
    },
    "REAPER.GETTRACKMIDINOTERANGE lua": {
        "prefix": "reaper.GetTrackMIDINoteRange",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackMIDINoteRange(${1:ReaProject proj},${2:MediaTrack track})$0"
    },
    "RPR_GETTRACKMIDINOTERANGE python": {
        "prefix": "RPR_GetTrackMIDINoteRange",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackMIDINoteRange(${1:proj},${2:track},${3:note_loOut},${4:note_hiOut})$0"
    },
    "GETTRACKNAME c": {
        "prefix": "GetTrackName",
        "scope": "c",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "GetTrackName(${1:MediaTrack* track},${2:char* bufOut},${3:int bufOut_sz})$0"
    },
    "GETTRACKNAME eel2": {
        "prefix": "GetTrackName",
        "scope": "eel2",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "GetTrackName(${1:MediaTrack track},${2:#buf})$0"
    },
    "REAPER.GETTRACKNAME lua": {
        "prefix": "reaper.GetTrackName",
        "scope": "lua",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "reaper.GetTrackName(${1:MediaTrack track})$0"
    },
    "RPR_GETTRACKNAME python": {
        "prefix": "RPR_GetTrackName",
        "scope": "python",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "RPR_GetTrackName(${1:track},${2:bufOut},${3:bufOut_sz})$0"
    },
    "GETTRACKNUMMEDIAITEMS c": {
        "prefix": "GetTrackNumMediaItems",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackNumMediaItems(${1:MediaTrack* tr})$0"
    },
    "GETTRACKNUMMEDIAITEMS eel2": {
        "prefix": "GetTrackNumMediaItems",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackNumMediaItems(${1:MediaTrack tr})$0"
    },
    "REAPER.GETTRACKNUMMEDIAITEMS lua": {
        "prefix": "reaper.GetTrackNumMediaItems",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackNumMediaItems(${1:MediaTrack tr})$0"
    },
    "RPR_GETTRACKNUMMEDIAITEMS python": {
        "prefix": "RPR_GetTrackNumMediaItems",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackNumMediaItems(${1:MediaTrack tr})$0"
    },
    "GETTRACKNUMSENDS c": {
        "prefix": "GetTrackNumSends",
        "scope": "c",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "GetTrackNumSends(${1:MediaTrack* tr},${2:int category})$0"
    },
    "GETTRACKNUMSENDS eel2": {
        "prefix": "GetTrackNumSends",
        "scope": "eel2",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "GetTrackNumSends(${1:MediaTrack tr},${2:int category})$0"
    },
    "REAPER.GETTRACKNUMSENDS lua": {
        "prefix": "reaper.GetTrackNumSends",
        "scope": "lua",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "reaper.GetTrackNumSends(${1:MediaTrack tr},${2:integer category})$0"
    },
    "RPR_GETTRACKNUMSENDS python": {
        "prefix": "RPR_GetTrackNumSends",
        "scope": "python",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "RPR_GetTrackNumSends(${1:MediaTrack tr},${2:Int category})$0"
    },
    "GETTRACKRECEIVENAME c": {
        "prefix": "GetTrackReceiveName",
        "scope": "c",
        "description": "See GetTrackSendName.\n",
        "body": "GetTrackReceiveName(${1:MediaTrack* track},${2:int recv_index},${3:char* buf},${4:int buf_sz})$0"
    },
    "GETTRACKRECEIVENAME eel2": {
        "prefix": "GetTrackReceiveName",
        "scope": "eel2",
        "description": "See GetTrackSendName.\n",
        "body": "GetTrackReceiveName(${1:MediaTrack track},${2:int recv_index},${3:#buf})$0"
    },
    "REAPER.GETTRACKRECEIVENAME lua": {
        "prefix": "reaper.GetTrackReceiveName",
        "scope": "lua",
        "description": "See GetTrackSendName.\n",
        "body": "reaper.GetTrackReceiveName(${1:MediaTrack track},${2:integer recv_index},${3:string buf})$0"
    },
    "RPR_GETTRACKRECEIVENAME python": {
        "prefix": "RPR_GetTrackReceiveName",
        "scope": "python",
        "description": "See GetTrackSendName.\n",
        "body": "RPR_GetTrackReceiveName(${1:track},${2:recv_index},${3:buf},${4:buf_sz})$0"
    },
    "GETTRACKRECEIVEUIMUTE c": {
        "prefix": "GetTrackReceiveUIMute",
        "scope": "c",
        "description": "See GetTrackSendUIMute.\n",
        "body": "GetTrackReceiveUIMute(${1:MediaTrack* track},${2:int recv_index},${3:bool* muteOut})$0"
    },
    "GETTRACKRECEIVEUIMUTE eel2": {
        "prefix": "GetTrackReceiveUIMute",
        "scope": "eel2",
        "description": "See GetTrackSendUIMute.\n",
        "body": "GetTrackReceiveUIMute(${1:MediaTrack track},${2:int recv_index},${3:bool &mute})$0"
    },
    "REAPER.GETTRACKRECEIVEUIMUTE lua": {
        "prefix": "reaper.GetTrackReceiveUIMute",
        "scope": "lua",
        "description": "See GetTrackSendUIMute.\n",
        "body": "reaper.GetTrackReceiveUIMute(${1:MediaTrack track},${2:integer recv_index})$0"
    },
    "RPR_GETTRACKRECEIVEUIMUTE python": {
        "prefix": "RPR_GetTrackReceiveUIMute",
        "scope": "python",
        "description": "See GetTrackSendUIMute.\n",
        "body": "RPR_GetTrackReceiveUIMute(${1:track},${2:recv_index},${3:muteOut})$0"
    },
    "GETTRACKRECEIVEUIVOLPAN c": {
        "prefix": "GetTrackReceiveUIVolPan",
        "scope": "c",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "GetTrackReceiveUIVolPan(${1:MediaTrack* track},${2:int recv_index},${3:double* volumeOut},${4:double* panOut})$0"
    },
    "GETTRACKRECEIVEUIVOLPAN eel2": {
        "prefix": "GetTrackReceiveUIVolPan",
        "scope": "eel2",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "GetTrackReceiveUIVolPan(${1:MediaTrack track},${2:int recv_index},${3:&volume},${4:&pan})$0"
    },
    "REAPER.GETTRACKRECEIVEUIVOLPAN lua": {
        "prefix": "reaper.GetTrackReceiveUIVolPan",
        "scope": "lua",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "reaper.GetTrackReceiveUIVolPan(${1:MediaTrack track},${2:integer recv_index})$0"
    },
    "RPR_GETTRACKRECEIVEUIVOLPAN python": {
        "prefix": "RPR_GetTrackReceiveUIVolPan",
        "scope": "python",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "RPR_GetTrackReceiveUIVolPan(${1:track},${2:recv_index},${3:volumeOut},${4:panOut})$0"
    },
    "GETTRACKSENDINFO_VALUE c": {
        "prefix": "GetTrackSendInfo_Value",
        "scope": "c",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "GetTrackSendInfo_Value(${1:MediaTrack* tr},${2:int category},${3:int sendidx},${4|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\",\"P_DESTTRACK\",\"P_SRCTRACK\",\"P_ENV:<envchunkname\"|})$0"
    },
    "GETTRACKSENDINFO_VALUE eel2": {
        "prefix": "GetTrackSendInfo_Value",
        "scope": "eel2",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "GetTrackSendInfo_Value(${1:MediaTrack tr},${2:int category},${3:int sendidx},${4:\"parmname\"})$0"
    },
    "REAPER.GETTRACKSENDINFO_VALUE lua": {
        "prefix": "reaper.GetTrackSendInfo_Value",
        "scope": "lua",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "reaper.GetTrackSendInfo_Value(${1:MediaTrack tr},${2:integer category},${3:integer sendidx},${4|string parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\",\"P_DESTTRACK\",\"P_SRCTRACK\",\"P_ENV:<envchunkname\"|})$0"
    },
    "RPR_GETTRACKSENDINFO_VALUE python": {
        "prefix": "RPR_GetTrackSendInfo_Value",
        "scope": "python",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "RPR_GetTrackSendInfo_Value(${1:MediaTrack tr},${2:Int category},${3:Int sendidx},${4|String parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\",\"P_DESTTRACK\",\"P_SRCTRACK\",\"P_ENV:<envchunkname\"|})$0"
    },
    "GETTRACKSENDNAME c": {
        "prefix": "GetTrackSendName",
        "scope": "c",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "GetTrackSendName(${1:MediaTrack* track},${2:int send_index},${3:char* buf},${4:int buf_sz})$0"
    },
    "GETTRACKSENDNAME eel2": {
        "prefix": "GetTrackSendName",
        "scope": "eel2",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "GetTrackSendName(${1:MediaTrack track},${2:int send_index},${3:#buf})$0"
    },
    "REAPER.GETTRACKSENDNAME lua": {
        "prefix": "reaper.GetTrackSendName",
        "scope": "lua",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "reaper.GetTrackSendName(${1:MediaTrack track},${2:integer send_index},${3:string buf})$0"
    },
    "RPR_GETTRACKSENDNAME python": {
        "prefix": "RPR_GetTrackSendName",
        "scope": "python",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "RPR_GetTrackSendName(${1:track},${2:send_index},${3:buf},${4:buf_sz})$0"
    },
    "GETTRACKSENDUIMUTE c": {
        "prefix": "GetTrackSendUIMute",
        "scope": "c",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "GetTrackSendUIMute(${1:MediaTrack* track},${2:int send_index},${3:bool* muteOut})$0"
    },
    "GETTRACKSENDUIMUTE eel2": {
        "prefix": "GetTrackSendUIMute",
        "scope": "eel2",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "GetTrackSendUIMute(${1:MediaTrack track},${2:int send_index},${3:bool &mute})$0"
    },
    "REAPER.GETTRACKSENDUIMUTE lua": {
        "prefix": "reaper.GetTrackSendUIMute",
        "scope": "lua",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "reaper.GetTrackSendUIMute(${1:MediaTrack track},${2:integer send_index})$0"
    },
    "RPR_GETTRACKSENDUIMUTE python": {
        "prefix": "RPR_GetTrackSendUIMute",
        "scope": "python",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "RPR_GetTrackSendUIMute(${1:track},${2:send_index},${3:muteOut})$0"
    },
    "GETTRACKSENDUIVOLPAN c": {
        "prefix": "GetTrackSendUIVolPan",
        "scope": "c",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "GetTrackSendUIVolPan(${1:MediaTrack* track},${2:int send_index},${3:double* volumeOut},${4:double* panOut})$0"
    },
    "GETTRACKSENDUIVOLPAN eel2": {
        "prefix": "GetTrackSendUIVolPan",
        "scope": "eel2",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "GetTrackSendUIVolPan(${1:MediaTrack track},${2:int send_index},${3:&volume},${4:&pan})$0"
    },
    "REAPER.GETTRACKSENDUIVOLPAN lua": {
        "prefix": "reaper.GetTrackSendUIVolPan",
        "scope": "lua",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "reaper.GetTrackSendUIVolPan(${1:MediaTrack track},${2:integer send_index})$0"
    },
    "RPR_GETTRACKSENDUIVOLPAN python": {
        "prefix": "RPR_GetTrackSendUIVolPan",
        "scope": "python",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "RPR_GetTrackSendUIVolPan(${1:track},${2:send_index},${3:volumeOut},${4:panOut})$0"
    },
    "GETTRACKSTATE c": {
        "prefix": "GetTrackState",
        "scope": "c",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "GetTrackState(${1:MediaTrack* track},${2:int* flagsOut})$0"
    },
    "GETTRACKSTATE eel2": {
        "prefix": "GetTrackState",
        "scope": "eel2",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "GetTrackState(${1:#retval},${2:MediaTrack track},${3:int &flags})$0"
    },
    "REAPER.GETTRACKSTATE lua": {
        "prefix": "reaper.GetTrackState",
        "scope": "lua",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "reaper.GetTrackState(${1:MediaTrack track})$0"
    },
    "RPR_GETTRACKSTATE python": {
        "prefix": "RPR_GetTrackState",
        "scope": "python",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "RPR_GetTrackState(${1:track},${2:flagsOut})$0"
    },
    "GETTRACKSTATECHUNK c": {
        "prefix": "GetTrackStateChunk",
        "scope": "c",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "GetTrackStateChunk(${1:MediaTrack* track},${2:char* strNeedBig},${3:int strNeedBig_sz},${4:bool isundoOptional})$0"
    },
    "GETTRACKSTATECHUNK eel2": {
        "prefix": "GetTrackStateChunk",
        "scope": "eel2",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "GetTrackStateChunk(${1:MediaTrack track},${2:#str},${3:bool isundo})$0"
    },
    "REAPER.GETTRACKSTATECHUNK lua": {
        "prefix": "reaper.GetTrackStateChunk",
        "scope": "lua",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "reaper.GetTrackStateChunk(${1:MediaTrack track},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_GETTRACKSTATECHUNK python": {
        "prefix": "RPR_GetTrackStateChunk",
        "scope": "python",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "RPR_GetTrackStateChunk(${1:track},${2:strNeedBig},${3:strNeedBig_sz},${4:isundoOptional})$0"
    },
    "GETTRACKUIMUTE c": {
        "prefix": "GetTrackUIMute",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackUIMute(${1:MediaTrack* track},${2:bool* muteOut})$0"
    },
    "GETTRACKUIMUTE eel2": {
        "prefix": "GetTrackUIMute",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackUIMute(${1:MediaTrack track},${2:bool &mute})$0"
    },
    "REAPER.GETTRACKUIMUTE lua": {
        "prefix": "reaper.GetTrackUIMute",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackUIMute(${1:MediaTrack track})$0"
    },
    "RPR_GETTRACKUIMUTE python": {
        "prefix": "RPR_GetTrackUIMute",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackUIMute(${1:track},${2:muteOut})$0"
    },
    "GETTRACKUIPAN c": {
        "prefix": "GetTrackUIPan",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackUIPan(${1:MediaTrack* track},${2:double* pan1Out},${3:double* pan2Out},${4:int* panmodeOut})$0"
    },
    "GETTRACKUIPAN eel2": {
        "prefix": "GetTrackUIPan",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackUIPan(${1:MediaTrack track},${2:&pan1},${3:&pan2},${4:int &panmode})$0"
    },
    "REAPER.GETTRACKUIPAN lua": {
        "prefix": "reaper.GetTrackUIPan",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackUIPan(${1:MediaTrack track})$0"
    },
    "RPR_GETTRACKUIPAN python": {
        "prefix": "RPR_GetTrackUIPan",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackUIPan(${1:track},${2:pan1Out},${3:pan2Out},${4:panmodeOut})$0"
    },
    "GETTRACKUIVOLPAN c": {
        "prefix": "GetTrackUIVolPan",
        "scope": "c",
        "description": "\n",
        "body": "GetTrackUIVolPan(${1:MediaTrack* track},${2:double* volumeOut},${3:double* panOut})$0"
    },
    "GETTRACKUIVOLPAN eel2": {
        "prefix": "GetTrackUIVolPan",
        "scope": "eel2",
        "description": "\n",
        "body": "GetTrackUIVolPan(${1:MediaTrack track},${2:&volume},${3:&pan})$0"
    },
    "REAPER.GETTRACKUIVOLPAN lua": {
        "prefix": "reaper.GetTrackUIVolPan",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.GetTrackUIVolPan(${1:MediaTrack track})$0"
    },
    "RPR_GETTRACKUIVOLPAN python": {
        "prefix": "RPR_GetTrackUIVolPan",
        "scope": "python",
        "description": "\n",
        "body": "RPR_GetTrackUIVolPan(${1:track},${2:volumeOut},${3:panOut})$0"
    },
    "GETUNDERRUNTIME c": {
        "prefix": "GetUnderrunTime",
        "scope": "c",
        "description": "retrieves the last timestamps of audio xrun (yellow-flash, if\navailable), media xrun (red-flash), and the current time stamp (all\nmilliseconds)\n",
        "body": "GetUnderrunTime(${1:unsigned int* audio_xrunOutOptional},${2:unsigned int* media_xrunOutOptional},${3:unsigned int* curtimeOutOptional})$0"
    },
    "GETUNDERRUNTIME eel2": {
        "prefix": "GetUnderrunTime",
        "scope": "eel2",
        "description": "retrieves the last timestamps of audio xrun (yellow-flash, if\navailable), media xrun (red-flash), and the current time stamp (all\nmilliseconds)\n",
        "body": "GetUnderrunTime(${1:optional unsigned int &audio_xrun},${2:optional unsigned int &media_xrun},${3:optional unsigned int &curtime})$0"
    },
    "REAPER.GETUNDERRUNTIME lua": {
        "prefix": "reaper.GetUnderrunTime",
        "scope": "lua",
        "description": "retrieves the last timestamps of audio xrun (yellow-flash, if\navailable), media xrun (red-flash), and the current time stamp (all\nmilliseconds)\n",
        "body": "reaper.GetUnderrunTime()$0"
    },
    "RPR_GETUNDERRUNTIME python": {
        "prefix": "RPR_GetUnderrunTime",
        "scope": "python",
        "description": "retrieves the last timestamps of audio xrun (yellow-flash, if\navailable), media xrun (red-flash), and the current time stamp (all\nmilliseconds)\n",
        "body": "RPR_GetUnderrunTime(${1:unsigned int audio_xrunOutOptional},${2:unsigned int media_xrunOutOptional},${3:unsigned int curtimeOutOptional})$0"
    },
    "GETUSERFILENAMEFORREAD c": {
        "prefix": "GetUserFileNameForRead",
        "scope": "c",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "GetUserFileNameForRead(${1:char* filenameNeed4096},${2:const char* title},${3:const char* defext})$0"
    },
    "GETUSERFILENAMEFORREAD eel2": {
        "prefix": "GetUserFileNameForRead",
        "scope": "eel2",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "GetUserFileNameForRead(${1:#filenameNeed4096},${2:\"title\"},${3:\"defext\"})$0"
    },
    "REAPER.GETUSERFILENAMEFORREAD lua": {
        "prefix": "reaper.GetUserFileNameForRead",
        "scope": "lua",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "reaper.GetUserFileNameForRead(${1:string filenameNeed4096},${2:string title},${3:string defext})$0"
    },
    "RPR_GETUSERFILENAMEFORREAD python": {
        "prefix": "RPR_GetUserFileNameForRead",
        "scope": "python",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "RPR_GetUserFileNameForRead(${1:filenameNeed4096},${2:title},${3:defext})$0"
    },
    "GETUSERINPUTS c": {
        "prefix": "GetUserInputs",
        "scope": "c",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "GetUserInputs(${1:const char* title},${2:int num_inputs},${3:const char* captions_csv},${4:char* retvals_csv},${5:int retvals_csv_sz})$0"
    },
    "GETUSERINPUTS eel2": {
        "prefix": "GetUserInputs",
        "scope": "eel2",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "GetUserInputs(${1:\"title\"},${2:int num_inputs},${3:\"captions_csv\"},${4:#retvals_csv})$0"
    },
    "REAPER.GETUSERINPUTS lua": {
        "prefix": "reaper.GetUserInputs",
        "scope": "lua",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "reaper.GetUserInputs(${1:string title},${2:integer num_inputs},${3:string captions_csv},${4:string retvals_csv})$0"
    },
    "RPR_GETUSERINPUTS python": {
        "prefix": "RPR_GetUserInputs",
        "scope": "python",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "RPR_GetUserInputs(${1:title},${2:num_inputs},${3:captions_csv},${4:retvals_csv},${5:retvals_csv_sz})$0"
    },
    "GOTOMARKER c": {
        "prefix": "GoToMarker",
        "scope": "c",
        "description": "Go to marker. If use_timeline_order==true, marker_index 1 refers to the\nfirst marker on the timeline.  If use_timeline_order==false,\nmarker_index 1 refers to the first marker with the user-editable index\nof 1.\n",
        "body": "GoToMarker(${1:ReaProject* proj},${2:int marker_index},${3:bool use_timeline_order})$0"
    },
    "GOTOMARKER eel2": {
        "prefix": "GoToMarker",
        "scope": "eel2",
        "description": "Go to marker. If use_timeline_order==true, marker_index 1 refers to the\nfirst marker on the timeline.  If use_timeline_order==false,\nmarker_index 1 refers to the first marker with the user-editable index\nof 1.\n",
        "body": "GoToMarker(${1:ReaProject proj},${2:int marker_index},${3:bool use_timeline_order})$0"
    },
    "REAPER.GOTOMARKER lua": {
        "prefix": "reaper.GoToMarker",
        "scope": "lua",
        "description": "Go to marker. If use_timeline_order==true, marker_index 1 refers to the\nfirst marker on the timeline.  If use_timeline_order==false,\nmarker_index 1 refers to the first marker with the user-editable index\nof 1.\n",
        "body": "reaper.GoToMarker(${1:ReaProject proj},${2:integer marker_index},${3:boolean use_timeline_order})$0"
    },
    "RPR_GOTOMARKER python": {
        "prefix": "RPR_GoToMarker",
        "scope": "python",
        "description": "Go to marker. If use_timeline_order==true, marker_index 1 refers to the\nfirst marker on the timeline.  If use_timeline_order==false,\nmarker_index 1 refers to the first marker with the user-editable index\nof 1.\n",
        "body": "RPR_GoToMarker(${1:ReaProject proj},${2:Int marker_index},${3:Boolean use_timeline_order})$0"
    },
    "GOTOREGION c": {
        "prefix": "GoToRegion",
        "scope": "c",
        "description": "Seek to region after current region finishes playing (smooth seek). If\nuse_timeline_order==true, region_index 1 refers to the first region on\nthe timeline.  If use_timeline_order==false, region_index 1 refers to\nthe first region with the user-editable index of 1.\n",
        "body": "GoToRegion(${1:ReaProject* proj},${2:int region_index},${3:bool use_timeline_order})$0"
    },
    "GOTOREGION eel2": {
        "prefix": "GoToRegion",
        "scope": "eel2",
        "description": "Seek to region after current region finishes playing (smooth seek). If\nuse_timeline_order==true, region_index 1 refers to the first region on\nthe timeline.  If use_timeline_order==false, region_index 1 refers to\nthe first region with the user-editable index of 1.\n",
        "body": "GoToRegion(${1:ReaProject proj},${2:int region_index},${3:bool use_timeline_order})$0"
    },
    "REAPER.GOTOREGION lua": {
        "prefix": "reaper.GoToRegion",
        "scope": "lua",
        "description": "Seek to region after current region finishes playing (smooth seek). If\nuse_timeline_order==true, region_index 1 refers to the first region on\nthe timeline.  If use_timeline_order==false, region_index 1 refers to\nthe first region with the user-editable index of 1.\n",
        "body": "reaper.GoToRegion(${1:ReaProject proj},${2:integer region_index},${3:boolean use_timeline_order})$0"
    },
    "RPR_GOTOREGION python": {
        "prefix": "RPR_GoToRegion",
        "scope": "python",
        "description": "Seek to region after current region finishes playing (smooth seek). If\nuse_timeline_order==true, region_index 1 refers to the first region on\nthe timeline.  If use_timeline_order==false, region_index 1 refers to\nthe first region with the user-editable index of 1.\n",
        "body": "RPR_GoToRegion(${1:ReaProject proj},${2:Int region_index},${3:Boolean use_timeline_order})$0"
    },
    "GR_SELECTCOLOR c": {
        "prefix": "GR_SelectColor",
        "scope": "c",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "GR_SelectColor(${1:HWND hwnd},${2:int* colorOut})$0"
    },
    "GR_SELECTCOLOR eel2": {
        "prefix": "GR_SelectColor",
        "scope": "eel2",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "GR_SelectColor(${1:HWND hwnd},${2:int &color})$0"
    },
    "REAPER.GR_SELECTCOLOR lua": {
        "prefix": "reaper.GR_SelectColor",
        "scope": "lua",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "reaper.GR_SelectColor(${1:HWND hwnd})$0"
    },
    "RPR_GR_SELECTCOLOR python": {
        "prefix": "RPR_GR_SelectColor",
        "scope": "python",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "RPR_GR_SelectColor(${1:hwnd},${2:colorOut})$0"
    },
    "GSC_MAINWND c": {
        "prefix": "GSC_mainwnd",
        "scope": "c",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "GSC_mainwnd(${1:int t})$0"
    },
    "GSC_MAINWND eel2": {
        "prefix": "GSC_mainwnd",
        "scope": "eel2",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "GSC_mainwnd(${1:int t})$0"
    },
    "REAPER.GSC_MAINWND lua": {
        "prefix": "reaper.GSC_mainwnd",
        "scope": "lua",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "reaper.GSC_mainwnd(${1:integer t})$0"
    },
    "RPR_GSC_MAINWND python": {
        "prefix": "RPR_GSC_mainwnd",
        "scope": "python",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "RPR_GSC_mainwnd(${1:Int t})$0"
    },
    "GUIDTOSTRING c": {
        "prefix": "guidToString",
        "scope": "c",
        "description": "dest should be at least 64 chars long to be safe\n",
        "body": "guidToString(${1:const GUID* g},${2:char* destNeed64})$0"
    },
    "GUIDTOSTRING eel2": {
        "prefix": "guidToString",
        "scope": "eel2",
        "description": "dest should be at least 64 chars long to be safe\n",
        "body": "guidToString(${1:\"gGUID\"},${2:#destNeed64})$0"
    },
    "REAPER.GUIDTOSTRING lua": {
        "prefix": "reaper.guidToString",
        "scope": "lua",
        "description": "dest should be at least 64 chars long to be safe\n",
        "body": "reaper.guidToString(${1:string gGUID},${2:string destNeed64})$0"
    },
    "RPR_GUIDTOSTRING python": {
        "prefix": "RPR_guidToString",
        "scope": "python",
        "description": "dest should be at least 64 chars long to be safe\n",
        "body": "RPR_guidToString(${1:g},${2:destNeed64})$0"
    },
    "HASEXTSTATE c": {
        "prefix": "HasExtState",
        "scope": "c",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "HasExtState(${1:const char* section},${2:const char* key})$0"
    },
    "HASEXTSTATE eel2": {
        "prefix": "HasExtState",
        "scope": "eel2",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "HasExtState(${1:\"section\"},${2:\"key\"})$0"
    },
    "REAPER.HASEXTSTATE lua": {
        "prefix": "reaper.HasExtState",
        "scope": "lua",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "reaper.HasExtState(${1:string section},${2:string key})$0"
    },
    "RPR_HASEXTSTATE python": {
        "prefix": "RPR_HasExtState",
        "scope": "python",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "RPR_HasExtState(${1:String section},${2:String key})$0"
    },
    "HASTRACKMIDIPROGRAMS c": {
        "prefix": "HasTrackMIDIPrograms",
        "scope": "c",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "HasTrackMIDIPrograms(${1:int track})$0"
    },
    "HASTRACKMIDIPROGRAMS eel2": {
        "prefix": "HasTrackMIDIPrograms",
        "scope": "eel2",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "HasTrackMIDIPrograms(${1:#retval},${2:int track})$0"
    },
    "REAPER.HASTRACKMIDIPROGRAMS lua": {
        "prefix": "reaper.HasTrackMIDIPrograms",
        "scope": "lua",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "reaper.HasTrackMIDIPrograms(${1:integer track})$0"
    },
    "RPR_HASTRACKMIDIPROGRAMS python": {
        "prefix": "RPR_HasTrackMIDIPrograms",
        "scope": "python",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "RPR_HasTrackMIDIPrograms(${1:Int track})$0"
    },
    "HASTRACKMIDIPROGRAMSEX c": {
        "prefix": "HasTrackMIDIProgramsEx",
        "scope": "c",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "HasTrackMIDIProgramsEx(${1:ReaProject* proj},${2:MediaTrack* track})$0"
    },
    "HASTRACKMIDIPROGRAMSEX eel2": {
        "prefix": "HasTrackMIDIProgramsEx",
        "scope": "eel2",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "HasTrackMIDIProgramsEx(${1:#retval},${2:ReaProject proj},${3:MediaTrack track})$0"
    },
    "REAPER.HASTRACKMIDIPROGRAMSEX lua": {
        "prefix": "reaper.HasTrackMIDIProgramsEx",
        "scope": "lua",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "reaper.HasTrackMIDIProgramsEx(${1:ReaProject proj},${2:MediaTrack track})$0"
    },
    "RPR_HASTRACKMIDIPROGRAMSEX python": {
        "prefix": "RPR_HasTrackMIDIProgramsEx",
        "scope": "python",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "RPR_HasTrackMIDIProgramsEx(${1:ReaProject proj},${2:MediaTrack track})$0"
    },
    "HELP_SET c": {
        "prefix": "Help_Set",
        "scope": "c",
        "description": "\n",
        "body": "Help_Set(${1:const char* helpstring},${2:bool is_temporary_help})$0"
    },
    "HELP_SET eel2": {
        "prefix": "Help_Set",
        "scope": "eel2",
        "description": "\n",
        "body": "Help_Set(${1:\"helpstring\"},${2:bool is_temporary_help})$0"
    },
    "REAPER.HELP_SET lua": {
        "prefix": "reaper.Help_Set",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Help_Set(${1:string helpstring},${2:boolean is_temporary_help})$0"
    },
    "RPR_HELP_SET python": {
        "prefix": "RPR_Help_Set",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Help_Set(${1:String helpstring},${2:Boolean is_temporary_help})$0"
    },
    "IMAGE_RESOLVE_FN c": {
        "prefix": "image_resolve_fn",
        "scope": "c",
        "description": "\n",
        "body": "image_resolve_fn(${1:const char* in},${2:char* out},${3:int out_sz})$0"
    },
    "IMAGE_RESOLVE_FN eel2": {
        "prefix": "image_resolve_fn",
        "scope": "eel2",
        "description": "\n",
        "body": "image_resolve_fn(${1:\"in\"},${2:#out})$0"
    },
    "REAPER.IMAGE_RESOLVE_FN lua": {
        "prefix": "reaper.image_resolve_fn",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.image_resolve_fn(${1:string in},${2:string out})$0"
    },
    "RPR_IMAGE_RESOLVE_FN python": {
        "prefix": "RPR_image_resolve_fn",
        "scope": "python",
        "description": "\n",
        "body": "RPR_image_resolve_fn(${1:in},${2:out},${3:out_sz})$0"
    },
    "INSERTAUTOMATIONITEM c": {
        "prefix": "InsertAutomationItem",
        "scope": "c",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "InsertAutomationItem(${1:TrackEnvelope* env},${2:int pool_id},${3:double position},${4:double length})$0"
    },
    "INSERTAUTOMATIONITEM eel2": {
        "prefix": "InsertAutomationItem",
        "scope": "eel2",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "InsertAutomationItem(${1:TrackEnvelope env},${2:int pool_id},${3:position},${4:length})$0"
    },
    "REAPER.INSERTAUTOMATIONITEM lua": {
        "prefix": "reaper.InsertAutomationItem",
        "scope": "lua",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "reaper.InsertAutomationItem(${1:TrackEnvelope env},${2:integer pool_id},${3:number position},${4:number length})$0"
    },
    "RPR_INSERTAUTOMATIONITEM python": {
        "prefix": "RPR_InsertAutomationItem",
        "scope": "python",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "RPR_InsertAutomationItem(${1:TrackEnvelope env},${2:Int pool_id},${3:Float position},${4:Float length})$0"
    },
    "INSERTENVELOPEPOINT c": {
        "prefix": "InsertEnvelopePoint",
        "scope": "c",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "InsertEnvelopePoint(${1:TrackEnvelope* envelope},${2:double time},${3:double value},${4:int shape},${5:double tension},${6:bool selected},${7:bool* noSortInOptional})$0"
    },
    "INSERTENVELOPEPOINT eel2": {
        "prefix": "InsertEnvelopePoint",
        "scope": "eel2",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "InsertEnvelopePoint(${1:TrackEnvelope envelope},${2:time},${3:value},${4:int shape},${5:tension},${6:bool selected},${7:optional bool noSortIn})$0"
    },
    "REAPER.INSERTENVELOPEPOINT lua": {
        "prefix": "reaper.InsertEnvelopePoint",
        "scope": "lua",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "reaper.InsertEnvelopePoint(${1:TrackEnvelope envelope},${2:number time},${3:number value},${4:integer shape},${5:number tension},${6:boolean selected},${7:optional boolean noSortIn})$0"
    },
    "RPR_INSERTENVELOPEPOINT python": {
        "prefix": "RPR_InsertEnvelopePoint",
        "scope": "python",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "RPR_InsertEnvelopePoint(${1:envelope},${2:time},${3:value},${4:shape},${5:tension},${6:selected},${7:noSortInOptional})$0"
    },
    "INSERTENVELOPEPOINTEX c": {
        "prefix": "InsertEnvelopePointEx",
        "scope": "c",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "InsertEnvelopePointEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx},${3:double time},${4:double value},${5:int shape},${6:double tension},${7:bool selected},${8:bool* noSortInOptional})$0"
    },
    "INSERTENVELOPEPOINTEX eel2": {
        "prefix": "InsertEnvelopePointEx",
        "scope": "eel2",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "InsertEnvelopePointEx(${1:TrackEnvelope envelope},${2:int autoitem_idx},${3:time},${4:value},${5:int shape},${6:tension},${7:bool selected},${8:optional bool noSortIn})$0"
    },
    "REAPER.INSERTENVELOPEPOINTEX lua": {
        "prefix": "reaper.InsertEnvelopePointEx",
        "scope": "lua",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "reaper.InsertEnvelopePointEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx},${3:number time},${4:number value},${5:integer shape},${6:number tension},${7:boolean selected},${8:optional boolean noSortIn})$0"
    },
    "RPR_INSERTENVELOPEPOINTEX python": {
        "prefix": "RPR_InsertEnvelopePointEx",
        "scope": "python",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "RPR_InsertEnvelopePointEx(${1:envelope},${2:autoitem_idx},${3:time},${4:value},${5:shape},${6:tension},${7:selected},${8:noSortInOptional})$0"
    },
    "INSERTMEDIA c": {
        "prefix": "InsertMedia",
        "scope": "c",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "InsertMedia(${1:const char* file},${2:int mode})$0"
    },
    "INSERTMEDIA eel2": {
        "prefix": "InsertMedia",
        "scope": "eel2",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "InsertMedia(${1:\"file\"},${2:int mode})$0"
    },
    "REAPER.INSERTMEDIA lua": {
        "prefix": "reaper.InsertMedia",
        "scope": "lua",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "reaper.InsertMedia(${1:string file},${2:integer mode})$0"
    },
    "RPR_INSERTMEDIA python": {
        "prefix": "RPR_InsertMedia",
        "scope": "python",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "RPR_InsertMedia(${1:String file},${2:Int mode})$0"
    },
    "INSERTMEDIASECTION c": {
        "prefix": "InsertMediaSection",
        "scope": "c",
        "description": "\n",
        "body": "InsertMediaSection(${1:const char* file},${2:int mode},${3:double startpct},${4:double endpct},${5:double pitchshift})$0"
    },
    "INSERTMEDIASECTION eel2": {
        "prefix": "InsertMediaSection",
        "scope": "eel2",
        "description": "\n",
        "body": "InsertMediaSection(${1:\"file\"},${2:int mode},${3:startpct},${4:endpct},${5:pitchshift})$0"
    },
    "REAPER.INSERTMEDIASECTION lua": {
        "prefix": "reaper.InsertMediaSection",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.InsertMediaSection(${1:string file},${2:integer mode},${3:number startpct},${4:number endpct},${5:number pitchshift})$0"
    },
    "RPR_INSERTMEDIASECTION python": {
        "prefix": "RPR_InsertMediaSection",
        "scope": "python",
        "description": "\n",
        "body": "RPR_InsertMediaSection(${1:String file},${2:Int mode},${3:Float startpct},${4:Float endpct},${5:Float pitchshift})$0"
    },
    "INSERTTRACKATINDEX c": {
        "prefix": "InsertTrackAtIndex",
        "scope": "c",
        "description": "inserts a track at idx,of course this will be clamped to\n0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise\nno enabled fx/env\n",
        "body": "InsertTrackAtIndex(${1:int idx},${2:bool wantDefaults})$0"
    },
    "INSERTTRACKATINDEX eel2": {
        "prefix": "InsertTrackAtIndex",
        "scope": "eel2",
        "description": "inserts a track at idx,of course this will be clamped to\n0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise\nno enabled fx/env\n",
        "body": "InsertTrackAtIndex(${1:int idx},${2:bool wantDefaults})$0"
    },
    "REAPER.INSERTTRACKATINDEX lua": {
        "prefix": "reaper.InsertTrackAtIndex",
        "scope": "lua",
        "description": "inserts a track at idx,of course this will be clamped to\n0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise\nno enabled fx/env\n",
        "body": "reaper.InsertTrackAtIndex(${1:integer idx},${2:boolean wantDefaults})$0"
    },
    "RPR_INSERTTRACKATINDEX python": {
        "prefix": "RPR_InsertTrackAtIndex",
        "scope": "python",
        "description": "inserts a track at idx,of course this will be clamped to\n0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise\nno enabled fx/env\n",
        "body": "RPR_InsertTrackAtIndex(${1:Int idx},${2:Boolean wantDefaults})$0"
    },
    "ISMEDIAEXTENSION c": {
        "prefix": "IsMediaExtension",
        "scope": "c",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "IsMediaExtension(${1:const char* ext},${2:bool wantOthers})$0"
    },
    "ISMEDIAEXTENSION eel2": {
        "prefix": "IsMediaExtension",
        "scope": "eel2",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "IsMediaExtension(${1:\"ext\"},${2:bool wantOthers})$0"
    },
    "REAPER.ISMEDIAEXTENSION lua": {
        "prefix": "reaper.IsMediaExtension",
        "scope": "lua",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "reaper.IsMediaExtension(${1:string ext},${2:boolean wantOthers})$0"
    },
    "RPR_ISMEDIAEXTENSION python": {
        "prefix": "RPR_IsMediaExtension",
        "scope": "python",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "RPR_IsMediaExtension(${1:String ext},${2:Boolean wantOthers})$0"
    },
    "ISMEDIAITEMSELECTED c": {
        "prefix": "IsMediaItemSelected",
        "scope": "c",
        "description": "\n",
        "body": "IsMediaItemSelected(${1:MediaItem* item})$0"
    },
    "ISMEDIAITEMSELECTED eel2": {
        "prefix": "IsMediaItemSelected",
        "scope": "eel2",
        "description": "\n",
        "body": "IsMediaItemSelected(${1:MediaItem item})$0"
    },
    "REAPER.ISMEDIAITEMSELECTED lua": {
        "prefix": "reaper.IsMediaItemSelected",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.IsMediaItemSelected(${1:MediaItem item})$0"
    },
    "RPR_ISMEDIAITEMSELECTED python": {
        "prefix": "RPR_IsMediaItemSelected",
        "scope": "python",
        "description": "\n",
        "body": "RPR_IsMediaItemSelected(${1:MediaItem item})$0"
    },
    "ISPROJECTDIRTY c": {
        "prefix": "IsProjectDirty",
        "scope": "c",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "IsProjectDirty(${1:ReaProject* proj})$0"
    },
    "ISPROJECTDIRTY eel2": {
        "prefix": "IsProjectDirty",
        "scope": "eel2",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "IsProjectDirty(${1:ReaProject proj})$0"
    },
    "REAPER.ISPROJECTDIRTY lua": {
        "prefix": "reaper.IsProjectDirty",
        "scope": "lua",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "reaper.IsProjectDirty(${1:ReaProject proj})$0"
    },
    "RPR_ISPROJECTDIRTY python": {
        "prefix": "RPR_IsProjectDirty",
        "scope": "python",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "RPR_IsProjectDirty(${1:ReaProject proj})$0"
    },
    "ISTRACKSELECTED c": {
        "prefix": "IsTrackSelected",
        "scope": "c",
        "description": "\n",
        "body": "IsTrackSelected(${1:MediaTrack* track})$0"
    },
    "ISTRACKSELECTED eel2": {
        "prefix": "IsTrackSelected",
        "scope": "eel2",
        "description": "\n",
        "body": "IsTrackSelected(${1:MediaTrack track})$0"
    },
    "REAPER.ISTRACKSELECTED lua": {
        "prefix": "reaper.IsTrackSelected",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.IsTrackSelected(${1:MediaTrack track})$0"
    },
    "RPR_ISTRACKSELECTED python": {
        "prefix": "RPR_IsTrackSelected",
        "scope": "python",
        "description": "\n",
        "body": "RPR_IsTrackSelected(${1:MediaTrack track})$0"
    },
    "ISTRACKVISIBLE c": {
        "prefix": "IsTrackVisible",
        "scope": "c",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "IsTrackVisible(${1:MediaTrack* track},${2:bool mixer})$0"
    },
    "ISTRACKVISIBLE eel2": {
        "prefix": "IsTrackVisible",
        "scope": "eel2",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "IsTrackVisible(${1:MediaTrack track},${2:bool mixer})$0"
    },
    "REAPER.ISTRACKVISIBLE lua": {
        "prefix": "reaper.IsTrackVisible",
        "scope": "lua",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "reaper.IsTrackVisible(${1:MediaTrack track},${2:boolean mixer})$0"
    },
    "RPR_ISTRACKVISIBLE python": {
        "prefix": "RPR_IsTrackVisible",
        "scope": "python",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "RPR_IsTrackVisible(${1:MediaTrack track},${2:Boolean mixer})$0"
    },
    "JOYSTICK_CREATE c": {
        "prefix": "joystick_create",
        "scope": "c",
        "description": "creates a joystick device\n",
        "body": "joystick_create(${1:const GUID* guid})$0"
    },
    "JOYSTICK_CREATE eel2": {
        "prefix": "joystick_create",
        "scope": "eel2",
        "description": "creates a joystick device\n",
        "body": "joystick_create(${1:\"guidGUID\"})$0"
    },
    "REAPER.JOYSTICK_CREATE lua": {
        "prefix": "reaper.joystick_create",
        "scope": "lua",
        "description": "creates a joystick device\n",
        "body": "reaper.joystick_create(${1:string guidGUID})$0"
    },
    "RPR_JOYSTICK_CREATE python": {
        "prefix": "RPR_joystick_create",
        "scope": "python",
        "description": "creates a joystick device\n",
        "body": "RPR_joystick_create(${1:const GUID guid})$0"
    },
    "JOYSTICK_DESTROY c": {
        "prefix": "joystick_destroy",
        "scope": "c",
        "description": "destroys a joystick device\n",
        "body": "joystick_destroy(${1:joystick_device* device})$0"
    },
    "JOYSTICK_DESTROY eel2": {
        "prefix": "joystick_destroy",
        "scope": "eel2",
        "description": "destroys a joystick device\n",
        "body": "joystick_destroy(${1:joystick_device device})$0"
    },
    "REAPER.JOYSTICK_DESTROY lua": {
        "prefix": "reaper.joystick_destroy",
        "scope": "lua",
        "description": "destroys a joystick device\n",
        "body": "reaper.joystick_destroy(${1:joystick_device device})$0"
    },
    "RPR_JOYSTICK_DESTROY python": {
        "prefix": "RPR_joystick_destroy",
        "scope": "python",
        "description": "destroys a joystick device\n",
        "body": "RPR_joystick_destroy(${1:joystick_device device})$0"
    },
    "JOYSTICK_ENUM c": {
        "prefix": "joystick_enum",
        "scope": "c",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "joystick_enum(${1:int index},${2:const char** namestrOutOptional})$0"
    },
    "JOYSTICK_ENUM eel2": {
        "prefix": "joystick_enum",
        "scope": "eel2",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "joystick_enum(${1:#retval},${2:int index},${3:optional #namestr})$0"
    },
    "REAPER.JOYSTICK_ENUM lua": {
        "prefix": "reaper.joystick_enum",
        "scope": "lua",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "reaper.joystick_enum(${1:integer index})$0"
    },
    "RPR_JOYSTICK_ENUM python": {
        "prefix": "RPR_joystick_enum",
        "scope": "python",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "RPR_joystick_enum(${1:Int index},${2:String namestrOutOptional})$0"
    },
    "JOYSTICK_GETAXIS c": {
        "prefix": "joystick_getaxis",
        "scope": "c",
        "description": "returns axis value (-1..1)\n",
        "body": "joystick_getaxis(${1:joystick_device* dev},${2:int axis})$0"
    },
    "JOYSTICK_GETAXIS eel2": {
        "prefix": "joystick_getaxis",
        "scope": "eel2",
        "description": "returns axis value (-1..1)\n",
        "body": "joystick_getaxis(${1:joystick_device dev},${2:int axis})$0"
    },
    "REAPER.JOYSTICK_GETAXIS lua": {
        "prefix": "reaper.joystick_getaxis",
        "scope": "lua",
        "description": "returns axis value (-1..1)\n",
        "body": "reaper.joystick_getaxis(${1:joystick_device dev},${2:integer axis})$0"
    },
    "RPR_JOYSTICK_GETAXIS python": {
        "prefix": "RPR_joystick_getaxis",
        "scope": "python",
        "description": "returns axis value (-1..1)\n",
        "body": "RPR_joystick_getaxis(${1:joystick_device dev},${2:Int axis})$0"
    },
    "JOYSTICK_GETBUTTONMASK c": {
        "prefix": "joystick_getbuttonmask",
        "scope": "c",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "joystick_getbuttonmask(${1:joystick_device* dev})$0"
    },
    "JOYSTICK_GETBUTTONMASK eel2": {
        "prefix": "joystick_getbuttonmask",
        "scope": "eel2",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "joystick_getbuttonmask(${1:joystick_device dev})$0"
    },
    "REAPER.JOYSTICK_GETBUTTONMASK lua": {
        "prefix": "reaper.joystick_getbuttonmask",
        "scope": "lua",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "reaper.joystick_getbuttonmask(${1:joystick_device dev})$0"
    },
    "RPR_JOYSTICK_GETBUTTONMASK python": {
        "prefix": "RPR_joystick_getbuttonmask",
        "scope": "python",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "RPR_joystick_getbuttonmask(${1:joystick_device dev})$0"
    },
    "JOYSTICK_GETINFO c": {
        "prefix": "joystick_getinfo",
        "scope": "c",
        "description": "returns button count\n",
        "body": "joystick_getinfo(${1:joystick_device* dev},${2:int* axesOutOptional},${3:int* povsOutOptional})$0"
    },
    "JOYSTICK_GETINFO eel2": {
        "prefix": "joystick_getinfo",
        "scope": "eel2",
        "description": "returns button count\n",
        "body": "joystick_getinfo(${1:joystick_device dev},${2:optional int &axes},${3:optional int &povs})$0"
    },
    "REAPER.JOYSTICK_GETINFO lua": {
        "prefix": "reaper.joystick_getinfo",
        "scope": "lua",
        "description": "returns button count\n",
        "body": "reaper.joystick_getinfo(${1:joystick_device dev})$0"
    },
    "RPR_JOYSTICK_GETINFO python": {
        "prefix": "RPR_joystick_getinfo",
        "scope": "python",
        "description": "returns button count\n",
        "body": "RPR_joystick_getinfo(${1:dev},${2:axesOutOptional},${3:povsOutOptional})$0"
    },
    "JOYSTICK_GETPOV c": {
        "prefix": "joystick_getpov",
        "scope": "c",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "joystick_getpov(${1:joystick_device* dev},${2:int pov})$0"
    },
    "JOYSTICK_GETPOV eel2": {
        "prefix": "joystick_getpov",
        "scope": "eel2",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "joystick_getpov(${1:joystick_device dev},${2:int pov})$0"
    },
    "REAPER.JOYSTICK_GETPOV lua": {
        "prefix": "reaper.joystick_getpov",
        "scope": "lua",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "reaper.joystick_getpov(${1:joystick_device dev},${2:integer pov})$0"
    },
    "RPR_JOYSTICK_GETPOV python": {
        "prefix": "RPR_joystick_getpov",
        "scope": "python",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "RPR_joystick_getpov(${1:joystick_device dev},${2:Int pov})$0"
    },
    "JOYSTICK_UPDATE c": {
        "prefix": "joystick_update",
        "scope": "c",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "joystick_update(${1:joystick_device* dev})$0"
    },
    "JOYSTICK_UPDATE eel2": {
        "prefix": "joystick_update",
        "scope": "eel2",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "joystick_update(${1:joystick_device dev})$0"
    },
    "REAPER.JOYSTICK_UPDATE lua": {
        "prefix": "reaper.joystick_update",
        "scope": "lua",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "reaper.joystick_update(${1:joystick_device dev})$0"
    },
    "RPR_JOYSTICK_UPDATE python": {
        "prefix": "RPR_joystick_update",
        "scope": "python",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "RPR_joystick_update(${1:joystick_device dev})$0"
    },
    "LICE_CLIPLINE c": {
        "prefix": "LICE_ClipLine",
        "scope": "c",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "LICE_ClipLine(${1:int* pX1Out},${2:int* pY1Out},${3:int* pX2Out},${4:int* pY2Out},${5:int xLo},${6:int yLo},${7:int xHi},${8:int yHi})$0"
    },
    "LICE_CLIPLINE eel2": {
        "prefix": "LICE_ClipLine",
        "scope": "eel2",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "LICE_ClipLine(${1:int &pX1},${2:int &pY1},${3:int &pX2},${4:int &pY2},${5:int xLo},${6:int yLo},${7:int xHi},${8:int yHi})$0"
    },
    "REAPER.LICE_CLIPLINE lua": {
        "prefix": "reaper.LICE_ClipLine",
        "scope": "lua",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "reaper.LICE_ClipLine(${1:number pX1},${2:number pY1},${3:number pX2},${4:number pY2},${5:integer xLo},${6:integer yLo},${7:integer xHi},${8:integer yHi})$0"
    },
    "RPR_LICE_CLIPLINE python": {
        "prefix": "RPR_LICE_ClipLine",
        "scope": "python",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "RPR_LICE_ClipLine(${1:pX1Out},${2:pY1Out},${3:pX2Out},${4:pY2Out},${5:xLo},${6:yLo},${7:xHi},${8:yHi})$0"
    },
    "LOOP_ONARROW c": {
        "prefix": "Loop_OnArrow",
        "scope": "c",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "Loop_OnArrow(${1:ReaProject* project},${2:int direction})$0"
    },
    "LOOP_ONARROW eel2": {
        "prefix": "Loop_OnArrow",
        "scope": "eel2",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "Loop_OnArrow(${1:ReaProject project},${2:int direction})$0"
    },
    "REAPER.LOOP_ONARROW lua": {
        "prefix": "reaper.Loop_OnArrow",
        "scope": "lua",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "reaper.Loop_OnArrow(${1:ReaProject project},${2:integer direction})$0"
    },
    "RPR_LOOP_ONARROW python": {
        "prefix": "RPR_Loop_OnArrow",
        "scope": "python",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "RPR_Loop_OnArrow(${1:ReaProject project},${2:Int direction})$0"
    },
    "MAIN_ONCOMMAND c": {
        "prefix": "Main_OnCommand",
        "scope": "c",
        "description": "See Main_OnCommandEx.\n",
        "body": "Main_OnCommand(${1:int command},${2:int flag})$0"
    },
    "MAIN_ONCOMMAND eel2": {
        "prefix": "Main_OnCommand",
        "scope": "eel2",
        "description": "See Main_OnCommandEx.\n",
        "body": "Main_OnCommand(${1:int command},${2:int flag})$0"
    },
    "REAPER.MAIN_ONCOMMAND lua": {
        "prefix": "reaper.Main_OnCommand",
        "scope": "lua",
        "description": "See Main_OnCommandEx.\n",
        "body": "reaper.Main_OnCommand(${1:integer command},${2:integer flag})$0"
    },
    "RPR_MAIN_ONCOMMAND python": {
        "prefix": "RPR_Main_OnCommand",
        "scope": "python",
        "description": "See Main_OnCommandEx.\n",
        "body": "RPR_Main_OnCommand(${1:Int command},${2:Int flag})$0"
    },
    "MAIN_ONCOMMANDEX c": {
        "prefix": "Main_OnCommandEx",
        "scope": "c",
        "description": "Performs an action belonging to the main action section. To perform\nnon-native actions (ReaScripts, custom or extension plugins' actions)\nsafely, see NamedCommandLookup().\n",
        "body": "Main_OnCommandEx(${1:int command},${2:int flag},${3:ReaProject* proj})$0"
    },
    "MAIN_ONCOMMANDEX eel2": {
        "prefix": "Main_OnCommandEx",
        "scope": "eel2",
        "description": "Performs an action belonging to the main action section. To perform\nnon-native actions (ReaScripts, custom or extension plugins' actions)\nsafely, see NamedCommandLookup().\n",
        "body": "Main_OnCommandEx(${1:int command},${2:int flag},${3:ReaProject proj})$0"
    },
    "REAPER.MAIN_ONCOMMANDEX lua": {
        "prefix": "reaper.Main_OnCommandEx",
        "scope": "lua",
        "description": "Performs an action belonging to the main action section. To perform\nnon-native actions (ReaScripts, custom or extension plugins' actions)\nsafely, see NamedCommandLookup().\n",
        "body": "reaper.Main_OnCommandEx(${1:integer command},${2:integer flag},${3:ReaProject proj})$0"
    },
    "RPR_MAIN_ONCOMMANDEX python": {
        "prefix": "RPR_Main_OnCommandEx",
        "scope": "python",
        "description": "Performs an action belonging to the main action section. To perform\nnon-native actions (ReaScripts, custom or extension plugins' actions)\nsafely, see NamedCommandLookup().\n",
        "body": "RPR_Main_OnCommandEx(${1:Int command},${2:Int flag},${3:ReaProject proj})$0"
    },
    "MAIN_OPENPROJECT c": {
        "prefix": "Main_openProject",
        "scope": "c",
        "description": "opens a project. will prompt the user to save unless name is prefixed\nwith 'noprompt:'. If name is prefixed with 'template:', project file\nwill be loaded as a template.\nIf passed a .RTrackTemplate file, adds the template to the existing project.\n",
        "body": "Main_openProject(${1:const char* name})$0"
    },
    "MAIN_OPENPROJECT eel2": {
        "prefix": "Main_openProject",
        "scope": "eel2",
        "description": "opens a project. will prompt the user to save unless name is prefixed\nwith 'noprompt:'. If name is prefixed with 'template:', project file\nwill be loaded as a template.\nIf passed a .RTrackTemplate file, adds the template to the existing project.\n",
        "body": "Main_openProject(${1:\"name\"})$0"
    },
    "REAPER.MAIN_OPENPROJECT lua": {
        "prefix": "reaper.Main_openProject",
        "scope": "lua",
        "description": "opens a project. will prompt the user to save unless name is prefixed\nwith 'noprompt:'. If name is prefixed with 'template:', project file\nwill be loaded as a template.\nIf passed a .RTrackTemplate file, adds the template to the existing project.\n",
        "body": "reaper.Main_openProject(${1:string name})$0"
    },
    "RPR_MAIN_OPENPROJECT python": {
        "prefix": "RPR_Main_openProject",
        "scope": "python",
        "description": "opens a project. will prompt the user to save unless name is prefixed\nwith 'noprompt:'. If name is prefixed with 'template:', project file\nwill be loaded as a template.\nIf passed a .RTrackTemplate file, adds the template to the existing project.\n",
        "body": "RPR_Main_openProject(${1:String name})$0"
    },
    "MAIN_SAVEPROJECT c": {
        "prefix": "Main_SaveProject",
        "scope": "c",
        "description": "Save the project.\n",
        "body": "Main_SaveProject(${1:ReaProject* proj},${2:bool forceSaveAsInOptional})$0"
    },
    "MAIN_SAVEPROJECT eel2": {
        "prefix": "Main_SaveProject",
        "scope": "eel2",
        "description": "Save the project.\n",
        "body": "Main_SaveProject(${1:ReaProject proj},${2:bool forceSaveAsIn})$0"
    },
    "REAPER.MAIN_SAVEPROJECT lua": {
        "prefix": "reaper.Main_SaveProject",
        "scope": "lua",
        "description": "Save the project.\n",
        "body": "reaper.Main_SaveProject(${1:ReaProject proj},${2:boolean forceSaveAsIn})$0"
    },
    "RPR_MAIN_SAVEPROJECT python": {
        "prefix": "RPR_Main_SaveProject",
        "scope": "python",
        "description": "Save the project.\n",
        "body": "RPR_Main_SaveProject(${1:ReaProject proj},${2:Boolean forceSaveAsInOptional})$0"
    },
    "MAIN_UPDATELOOPINFO c": {
        "prefix": "Main_UpdateLoopInfo",
        "scope": "c",
        "description": "\n",
        "body": "Main_UpdateLoopInfo(${1:int ignoremask})$0"
    },
    "MAIN_UPDATELOOPINFO eel2": {
        "prefix": "Main_UpdateLoopInfo",
        "scope": "eel2",
        "description": "\n",
        "body": "Main_UpdateLoopInfo(${1:int ignoremask})$0"
    },
    "REAPER.MAIN_UPDATELOOPINFO lua": {
        "prefix": "reaper.Main_UpdateLoopInfo",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Main_UpdateLoopInfo(${1:integer ignoremask})$0"
    },
    "RPR_MAIN_UPDATELOOPINFO python": {
        "prefix": "RPR_Main_UpdateLoopInfo",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Main_UpdateLoopInfo(${1:Int ignoremask})$0"
    },
    "MARKPROJECTDIRTY c": {
        "prefix": "MarkProjectDirty",
        "scope": "c",
        "description": "Marks project as dirty (needing save) if 'undo/prompt to save' is enabled in preferences.\n",
        "body": "MarkProjectDirty(${1:ReaProject* proj})$0"
    },
    "MARKPROJECTDIRTY eel2": {
        "prefix": "MarkProjectDirty",
        "scope": "eel2",
        "description": "Marks project as dirty (needing save) if 'undo/prompt to save' is enabled in preferences.\n",
        "body": "MarkProjectDirty(${1:ReaProject proj})$0"
    },
    "REAPER.MARKPROJECTDIRTY lua": {
        "prefix": "reaper.MarkProjectDirty",
        "scope": "lua",
        "description": "Marks project as dirty (needing save) if 'undo/prompt to save' is enabled in preferences.\n",
        "body": "reaper.MarkProjectDirty(${1:ReaProject proj})$0"
    },
    "RPR_MARKPROJECTDIRTY python": {
        "prefix": "RPR_MarkProjectDirty",
        "scope": "python",
        "description": "Marks project as dirty (needing save) if 'undo/prompt to save' is enabled in preferences.\n",
        "body": "RPR_MarkProjectDirty(${1:ReaProject proj})$0"
    },
    "MARKTRACKITEMSDIRTY c": {
        "prefix": "MarkTrackItemsDirty",
        "scope": "c",
        "description": "If track is supplied, item is ignored\n",
        "body": "MarkTrackItemsDirty(${1:MediaTrack* track},${2:MediaItem* item})$0"
    },
    "MARKTRACKITEMSDIRTY eel2": {
        "prefix": "MarkTrackItemsDirty",
        "scope": "eel2",
        "description": "If track is supplied, item is ignored\n",
        "body": "MarkTrackItemsDirty(${1:MediaTrack track},${2:MediaItem item})$0"
    },
    "REAPER.MARKTRACKITEMSDIRTY lua": {
        "prefix": "reaper.MarkTrackItemsDirty",
        "scope": "lua",
        "description": "If track is supplied, item is ignored\n",
        "body": "reaper.MarkTrackItemsDirty(${1:MediaTrack track},${2:MediaItem item})$0"
    },
    "RPR_MARKTRACKITEMSDIRTY python": {
        "prefix": "RPR_MarkTrackItemsDirty",
        "scope": "python",
        "description": "If track is supplied, item is ignored\n",
        "body": "RPR_MarkTrackItemsDirty(${1:MediaTrack track},${2:MediaItem item})$0"
    },
    "MASTER_GETPLAYRATE c": {
        "prefix": "Master_GetPlayRate",
        "scope": "c",
        "description": "\n",
        "body": "Master_GetPlayRate(${1:ReaProject* project})$0"
    },
    "MASTER_GETPLAYRATE eel2": {
        "prefix": "Master_GetPlayRate",
        "scope": "eel2",
        "description": "\n",
        "body": "Master_GetPlayRate(${1:ReaProject project})$0"
    },
    "REAPER.MASTER_GETPLAYRATE lua": {
        "prefix": "reaper.Master_GetPlayRate",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Master_GetPlayRate(${1:ReaProject project})$0"
    },
    "RPR_MASTER_GETPLAYRATE python": {
        "prefix": "RPR_Master_GetPlayRate",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Master_GetPlayRate(${1:ReaProject project})$0"
    },
    "MASTER_GETPLAYRATEATTIME c": {
        "prefix": "Master_GetPlayRateAtTime",
        "scope": "c",
        "description": "\n",
        "body": "Master_GetPlayRateAtTime(${1:double time_s},${2:ReaProject* proj})$0"
    },
    "MASTER_GETPLAYRATEATTIME eel2": {
        "prefix": "Master_GetPlayRateAtTime",
        "scope": "eel2",
        "description": "\n",
        "body": "Master_GetPlayRateAtTime(${1:time_s},${2:ReaProject proj})$0"
    },
    "REAPER.MASTER_GETPLAYRATEATTIME lua": {
        "prefix": "reaper.Master_GetPlayRateAtTime",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Master_GetPlayRateAtTime(${1:number time_s},${2:ReaProject proj})$0"
    },
    "RPR_MASTER_GETPLAYRATEATTIME python": {
        "prefix": "RPR_Master_GetPlayRateAtTime",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Master_GetPlayRateAtTime(${1:Float time_s},${2:ReaProject proj})$0"
    },
    "MASTER_GETTEMPO c": {
        "prefix": "Master_GetTempo",
        "scope": "c",
        "description": "\n",
        "body": "Master_GetTempo()$0"
    },
    "MASTER_GETTEMPO eel2": {
        "prefix": "Master_GetTempo",
        "scope": "eel2",
        "description": "\n",
        "body": "Master_GetTempo()$0"
    },
    "REAPER.MASTER_GETTEMPO lua": {
        "prefix": "reaper.Master_GetTempo",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Master_GetTempo()$0"
    },
    "RPR_MASTER_GETTEMPO python": {
        "prefix": "RPR_Master_GetTempo",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Master_GetTempo()$0"
    },
    "MASTER_NORMALIZEPLAYRATE c": {
        "prefix": "Master_NormalizePlayRate",
        "scope": "c",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "Master_NormalizePlayRate(${1:double playrate},${2:bool isnormalized})$0"
    },
    "MASTER_NORMALIZEPLAYRATE eel2": {
        "prefix": "Master_NormalizePlayRate",
        "scope": "eel2",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "Master_NormalizePlayRate(${1:playrate},${2:bool isnormalized})$0"
    },
    "REAPER.MASTER_NORMALIZEPLAYRATE lua": {
        "prefix": "reaper.Master_NormalizePlayRate",
        "scope": "lua",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "reaper.Master_NormalizePlayRate(${1:number playrate},${2:boolean isnormalized})$0"
    },
    "RPR_MASTER_NORMALIZEPLAYRATE python": {
        "prefix": "RPR_Master_NormalizePlayRate",
        "scope": "python",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "RPR_Master_NormalizePlayRate(${1:Float playrate},${2:Boolean isnormalized})$0"
    },
    "MASTER_NORMALIZETEMPO c": {
        "prefix": "Master_NormalizeTempo",
        "scope": "c",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "Master_NormalizeTempo(${1:double bpm},${2:bool isnormalized})$0"
    },
    "MASTER_NORMALIZETEMPO eel2": {
        "prefix": "Master_NormalizeTempo",
        "scope": "eel2",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "Master_NormalizeTempo(${1:bpm},${2:bool isnormalized})$0"
    },
    "REAPER.MASTER_NORMALIZETEMPO lua": {
        "prefix": "reaper.Master_NormalizeTempo",
        "scope": "lua",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "reaper.Master_NormalizeTempo(${1:number bpm},${2:boolean isnormalized})$0"
    },
    "RPR_MASTER_NORMALIZETEMPO python": {
        "prefix": "RPR_Master_NormalizeTempo",
        "scope": "python",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "RPR_Master_NormalizeTempo(${1:Float bpm},${2:Boolean isnormalized})$0"
    },
    "MB c": {
        "prefix": "MB",
        "scope": "c",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "MB(${1:const char* msg},${2:const char* title},${3:int type})$0"
    },
    "MB eel2": {
        "prefix": "MB",
        "scope": "eel2",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "MB(${1:\"msg\"},${2:\"title\"},${3:int type})$0"
    },
    "REAPER.MB lua": {
        "prefix": "reaper.MB",
        "scope": "lua",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "reaper.MB(${1:string msg},${2:string title},${3:integer type})$0"
    },
    "RPR_MB python": {
        "prefix": "RPR_MB",
        "scope": "python",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "RPR_MB(${1:String msg},${2:String title},${3:Int type})$0"
    },
    "MEDIAITEMDESCENDSFROMTRACK c": {
        "prefix": "MediaItemDescendsFromTrack",
        "scope": "c",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "MediaItemDescendsFromTrack(${1:MediaItem* item},${2:MediaTrack* track})$0"
    },
    "MEDIAITEMDESCENDSFROMTRACK eel2": {
        "prefix": "MediaItemDescendsFromTrack",
        "scope": "eel2",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "MediaItemDescendsFromTrack(${1:MediaItem item},${2:MediaTrack track})$0"
    },
    "REAPER.MEDIAITEMDESCENDSFROMTRACK lua": {
        "prefix": "reaper.MediaItemDescendsFromTrack",
        "scope": "lua",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "reaper.MediaItemDescendsFromTrack(${1:MediaItem item},${2:MediaTrack track})$0"
    },
    "RPR_MEDIAITEMDESCENDSFROMTRACK python": {
        "prefix": "RPR_MediaItemDescendsFromTrack",
        "scope": "python",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "RPR_MediaItemDescendsFromTrack(${1:MediaItem item},${2:MediaTrack track})$0"
    },
    "MIDI_COUNTEVTS c": {
        "prefix": "MIDI_CountEvts",
        "scope": "c",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "MIDI_CountEvts(${1:MediaItem_Take* take},${2:int* notecntOut},${3:int* ccevtcntOut},${4:int* textsyxevtcntOut})$0"
    },
    "MIDI_COUNTEVTS eel2": {
        "prefix": "MIDI_CountEvts",
        "scope": "eel2",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "MIDI_CountEvts(${1:MediaItem_Take take},${2:int &notecnt},${3:int &ccevtcnt},${4:int &textsyxevtcnt})$0"
    },
    "REAPER.MIDI_COUNTEVTS lua": {
        "prefix": "reaper.MIDI_CountEvts",
        "scope": "lua",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "reaper.MIDI_CountEvts(${1:MediaItem_Take take})$0"
    },
    "RPR_MIDI_COUNTEVTS python": {
        "prefix": "RPR_MIDI_CountEvts",
        "scope": "python",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "RPR_MIDI_CountEvts(${1:take},${2:notecntOut},${3:ccevtcntOut},${4:textsyxevtcntOut})$0"
    },
    "MIDI_DELETECC c": {
        "prefix": "MIDI_DeleteCC",
        "scope": "c",
        "description": "Delete a MIDI CC event.\n",
        "body": "MIDI_DeleteCC(${1:MediaItem_Take* take},${2:int ccidx})$0"
    },
    "MIDI_DELETECC eel2": {
        "prefix": "MIDI_DeleteCC",
        "scope": "eel2",
        "description": "Delete a MIDI CC event.\n",
        "body": "MIDI_DeleteCC(${1:MediaItem_Take take},${2:int ccidx})$0"
    },
    "REAPER.MIDI_DELETECC lua": {
        "prefix": "reaper.MIDI_DeleteCC",
        "scope": "lua",
        "description": "Delete a MIDI CC event.\n",
        "body": "reaper.MIDI_DeleteCC(${1:MediaItem_Take take},${2:integer ccidx})$0"
    },
    "RPR_MIDI_DELETECC python": {
        "prefix": "RPR_MIDI_DeleteCC",
        "scope": "python",
        "description": "Delete a MIDI CC event.\n",
        "body": "RPR_MIDI_DeleteCC(${1:MediaItem_Take take},${2:Int ccidx})$0"
    },
    "MIDI_DELETEEVT c": {
        "prefix": "MIDI_DeleteEvt",
        "scope": "c",
        "description": "Delete a MIDI event.\n",
        "body": "MIDI_DeleteEvt(${1:MediaItem_Take* take},${2:int evtidx})$0"
    },
    "MIDI_DELETEEVT eel2": {
        "prefix": "MIDI_DeleteEvt",
        "scope": "eel2",
        "description": "Delete a MIDI event.\n",
        "body": "MIDI_DeleteEvt(${1:MediaItem_Take take},${2:int evtidx})$0"
    },
    "REAPER.MIDI_DELETEEVT lua": {
        "prefix": "reaper.MIDI_DeleteEvt",
        "scope": "lua",
        "description": "Delete a MIDI event.\n",
        "body": "reaper.MIDI_DeleteEvt(${1:MediaItem_Take take},${2:integer evtidx})$0"
    },
    "RPR_MIDI_DELETEEVT python": {
        "prefix": "RPR_MIDI_DeleteEvt",
        "scope": "python",
        "description": "Delete a MIDI event.\n",
        "body": "RPR_MIDI_DeleteEvt(${1:MediaItem_Take take},${2:Int evtidx})$0"
    },
    "MIDI_DELETENOTE c": {
        "prefix": "MIDI_DeleteNote",
        "scope": "c",
        "description": "Delete a MIDI note.\n",
        "body": "MIDI_DeleteNote(${1:MediaItem_Take* take},${2:int noteidx})$0"
    },
    "MIDI_DELETENOTE eel2": {
        "prefix": "MIDI_DeleteNote",
        "scope": "eel2",
        "description": "Delete a MIDI note.\n",
        "body": "MIDI_DeleteNote(${1:MediaItem_Take take},${2:int noteidx})$0"
    },
    "REAPER.MIDI_DELETENOTE lua": {
        "prefix": "reaper.MIDI_DeleteNote",
        "scope": "lua",
        "description": "Delete a MIDI note.\n",
        "body": "reaper.MIDI_DeleteNote(${1:MediaItem_Take take},${2:integer noteidx})$0"
    },
    "RPR_MIDI_DELETENOTE python": {
        "prefix": "RPR_MIDI_DeleteNote",
        "scope": "python",
        "description": "Delete a MIDI note.\n",
        "body": "RPR_MIDI_DeleteNote(${1:MediaItem_Take take},${2:Int noteidx})$0"
    },
    "MIDI_DELETETEXTSYSEXEVT c": {
        "prefix": "MIDI_DeleteTextSysexEvt",
        "scope": "c",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "MIDI_DeleteTextSysexEvt(${1:MediaItem_Take* take},${2:int textsyxevtidx})$0"
    },
    "MIDI_DELETETEXTSYSEXEVT eel2": {
        "prefix": "MIDI_DeleteTextSysexEvt",
        "scope": "eel2",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "MIDI_DeleteTextSysexEvt(${1:MediaItem_Take take},${2:int textsyxevtidx})$0"
    },
    "REAPER.MIDI_DELETETEXTSYSEXEVT lua": {
        "prefix": "reaper.MIDI_DeleteTextSysexEvt",
        "scope": "lua",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "reaper.MIDI_DeleteTextSysexEvt(${1:MediaItem_Take take},${2:integer textsyxevtidx})$0"
    },
    "RPR_MIDI_DELETETEXTSYSEXEVT python": {
        "prefix": "RPR_MIDI_DeleteTextSysexEvt",
        "scope": "python",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "RPR_MIDI_DeleteTextSysexEvt(${1:MediaItem_Take take},${2:Int textsyxevtidx})$0"
    },
    "MIDI_DISABLESORT c": {
        "prefix": "MIDI_DisableSort",
        "scope": "c",
        "description": "Disable sorting for all MIDI insert, delete, get and set functions, until MIDI_Sort is called.\n",
        "body": "MIDI_DisableSort(${1:MediaItem_Take* take})$0"
    },
    "MIDI_DISABLESORT eel2": {
        "prefix": "MIDI_DisableSort",
        "scope": "eel2",
        "description": "Disable sorting for all MIDI insert, delete, get and set functions, until MIDI_Sort is called.\n",
        "body": "MIDI_DisableSort(${1:MediaItem_Take take})$0"
    },
    "REAPER.MIDI_DISABLESORT lua": {
        "prefix": "reaper.MIDI_DisableSort",
        "scope": "lua",
        "description": "Disable sorting for all MIDI insert, delete, get and set functions, until MIDI_Sort is called.\n",
        "body": "reaper.MIDI_DisableSort(${1:MediaItem_Take take})$0"
    },
    "RPR_MIDI_DISABLESORT python": {
        "prefix": "RPR_MIDI_DisableSort",
        "scope": "python",
        "description": "Disable sorting for all MIDI insert, delete, get and set functions, until MIDI_Sort is called.\n",
        "body": "RPR_MIDI_DisableSort(${1:MediaItem_Take take})$0"
    },
    "MIDI_ENUMSELCC c": {
        "prefix": "MIDI_EnumSelCC",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelCC(${1:MediaItem_Take* take},${2:int ccidx})$0"
    },
    "MIDI_ENUMSELCC eel2": {
        "prefix": "MIDI_EnumSelCC",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelCC(${1:MediaItem_Take take},${2:int ccidx})$0"
    },
    "REAPER.MIDI_ENUMSELCC lua": {
        "prefix": "reaper.MIDI_EnumSelCC",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "reaper.MIDI_EnumSelCC(${1:MediaItem_Take take},${2:integer ccidx})$0"
    },
    "RPR_MIDI_ENUMSELCC python": {
        "prefix": "RPR_MIDI_EnumSelCC",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "RPR_MIDI_EnumSelCC(${1:MediaItem_Take take},${2:Int ccidx})$0"
    },
    "MIDI_ENUMSELEVTS c": {
        "prefix": "MIDI_EnumSelEvts",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelEvts(${1:MediaItem_Take* take},${2:int evtidx})$0"
    },
    "MIDI_ENUMSELEVTS eel2": {
        "prefix": "MIDI_EnumSelEvts",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelEvts(${1:MediaItem_Take take},${2:int evtidx})$0"
    },
    "REAPER.MIDI_ENUMSELEVTS lua": {
        "prefix": "reaper.MIDI_EnumSelEvts",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "reaper.MIDI_EnumSelEvts(${1:MediaItem_Take take},${2:integer evtidx})$0"
    },
    "RPR_MIDI_ENUMSELEVTS python": {
        "prefix": "RPR_MIDI_EnumSelEvts",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "RPR_MIDI_EnumSelEvts(${1:MediaItem_Take take},${2:Int evtidx})$0"
    },
    "MIDI_ENUMSELNOTES c": {
        "prefix": "MIDI_EnumSelNotes",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelNotes(${1:MediaItem_Take* take},${2:int noteidx})$0"
    },
    "MIDI_ENUMSELNOTES eel2": {
        "prefix": "MIDI_EnumSelNotes",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelNotes(${1:MediaItem_Take take},${2:int noteidx})$0"
    },
    "REAPER.MIDI_ENUMSELNOTES lua": {
        "prefix": "reaper.MIDI_EnumSelNotes",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "reaper.MIDI_EnumSelNotes(${1:MediaItem_Take take},${2:integer noteidx})$0"
    },
    "RPR_MIDI_ENUMSELNOTES python": {
        "prefix": "RPR_MIDI_EnumSelNotes",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "RPR_MIDI_EnumSelNotes(${1:MediaItem_Take take},${2:Int noteidx})$0"
    },
    "MIDI_ENUMSELTEXTSYSEXEVTS c": {
        "prefix": "MIDI_EnumSelTextSysexEvts",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelTextSysexEvts(${1:MediaItem_Take* take},${2:int textsyxidx})$0"
    },
    "MIDI_ENUMSELTEXTSYSEXEVTS eel2": {
        "prefix": "MIDI_EnumSelTextSysexEvts",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "MIDI_EnumSelTextSysexEvts(${1:MediaItem_Take take},${2:int textsyxidx})$0"
    },
    "REAPER.MIDI_ENUMSELTEXTSYSEXEVTS lua": {
        "prefix": "reaper.MIDI_EnumSelTextSysexEvts",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "reaper.MIDI_EnumSelTextSysexEvts(${1:MediaItem_Take take},${2:integer textsyxidx})$0"
    },
    "RPR_MIDI_ENUMSELTEXTSYSEXEVTS python": {
        "prefix": "RPR_MIDI_EnumSelTextSysexEvts",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "RPR_MIDI_EnumSelTextSysexEvts(${1:MediaItem_Take take},${2:Int textsyxidx})$0"
    },
    "MIDI_GETALLEVTS c": {
        "prefix": "MIDI_GetAllEvts",
        "scope": "c",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "MIDI_GetAllEvts(${1:MediaItem_Take* take},${2:char* bufNeedBig},${3:int* bufNeedBig_sz})$0"
    },
    "MIDI_GETALLEVTS eel2": {
        "prefix": "MIDI_GetAllEvts",
        "scope": "eel2",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "MIDI_GetAllEvts(${1:MediaItem_Take take},${2:#buf})$0"
    },
    "REAPER.MIDI_GETALLEVTS lua": {
        "prefix": "reaper.MIDI_GetAllEvts",
        "scope": "lua",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "reaper.MIDI_GetAllEvts(${1:MediaItem_Take take},${2:string buf})$0"
    },
    "RPR_MIDI_GETALLEVTS python": {
        "prefix": "RPR_MIDI_GetAllEvts",
        "scope": "python",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "RPR_MIDI_GetAllEvts(${1:take},${2:bufNeedBig},${3:bufNeedBig_sz})$0"
    },
    "MIDI_GETCC c": {
        "prefix": "MIDI_GetCC",
        "scope": "c",
        "description": "Get MIDI CC event properties.\n",
        "body": "MIDI_GetCC(${1:MediaItem_Take* take},${2:int ccidx},${3:bool* selectedOut},${4:bool* mutedOut},${5:double* ppqposOut},${6:int* chanmsgOut},${7:int* chanOut},${8:int* msg2Out},${9:int* msg3Out})$0"
    },
    "MIDI_GETCC eel2": {
        "prefix": "MIDI_GetCC",
        "scope": "eel2",
        "description": "Get MIDI CC event properties.\n",
        "body": "MIDI_GetCC(${1:MediaItem_Take take},${2:int ccidx},${3:bool &selected},${4:bool &muted},${5:&ppqpos},${6:int &chanmsg},${7:int &chan},${8:int &msg2},${9:int &msg3})$0"
    },
    "REAPER.MIDI_GETCC lua": {
        "prefix": "reaper.MIDI_GetCC",
        "scope": "lua",
        "description": "Get MIDI CC event properties.\n",
        "body": "reaper.MIDI_GetCC(${1:MediaItem_Take take},${2:integer ccidx})$0"
    },
    "RPR_MIDI_GETCC python": {
        "prefix": "RPR_MIDI_GetCC",
        "scope": "python",
        "description": "Get MIDI CC event properties.\n",
        "body": "RPR_MIDI_GetCC(${1:take},${2:ccidx},${3:selectedOut},${4:mutedOut},${5:ppqposOut},${6:chanmsgOut},${7:chanOut},${8:msg2Out},${9:msg3Out})$0"
    },
    "MIDI_GETCCSHAPE c": {
        "prefix": "MIDI_GetCCShape",
        "scope": "c",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "MIDI_GetCCShape(${1:MediaItem_Take* take},${2:int ccidx},${3:int* shapeOut},${4:double* beztensionOut})$0"
    },
    "MIDI_GETCCSHAPE eel2": {
        "prefix": "MIDI_GetCCShape",
        "scope": "eel2",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "MIDI_GetCCShape(${1:MediaItem_Take take},${2:int ccidx},${3:int &shape},${4:&beztension})$0"
    },
    "REAPER.MIDI_GETCCSHAPE lua": {
        "prefix": "reaper.MIDI_GetCCShape",
        "scope": "lua",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "reaper.MIDI_GetCCShape(${1:MediaItem_Take take},${2:integer ccidx})$0"
    },
    "RPR_MIDI_GETCCSHAPE python": {
        "prefix": "RPR_MIDI_GetCCShape",
        "scope": "python",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "RPR_MIDI_GetCCShape(${1:take},${2:ccidx},${3:shapeOut},${4:beztensionOut})$0"
    },
    "MIDI_GETEVT c": {
        "prefix": "MIDI_GetEvt",
        "scope": "c",
        "description": "Get MIDI event properties.\n",
        "body": "MIDI_GetEvt(${1:MediaItem_Take* take},${2:int evtidx},${3:bool* selectedOut},${4:bool* mutedOut},${5:double* ppqposOut},${6:char* msg},${7:int* msg_sz})$0"
    },
    "MIDI_GETEVT eel2": {
        "prefix": "MIDI_GetEvt",
        "scope": "eel2",
        "description": "Get MIDI event properties.\n",
        "body": "MIDI_GetEvt(${1:MediaItem_Take take},${2:int evtidx},${3:bool &selected},${4:bool &muted},${5:&ppqpos},${6:#msg})$0"
    },
    "REAPER.MIDI_GETEVT lua": {
        "prefix": "reaper.MIDI_GetEvt",
        "scope": "lua",
        "description": "Get MIDI event properties.\n",
        "body": "reaper.MIDI_GetEvt(${1:MediaItem_Take take},${2:integer evtidx},${3:boolean selected},${4:boolean muted},${5:number ppqpos},${6:string msg})$0"
    },
    "RPR_MIDI_GETEVT python": {
        "prefix": "RPR_MIDI_GetEvt",
        "scope": "python",
        "description": "Get MIDI event properties.\n",
        "body": "RPR_MIDI_GetEvt(${1:take},${2:evtidx},${3:selectedOut},${4:mutedOut},${5:ppqposOut},${6:msg},${7:msg_sz})$0"
    },
    "MIDI_GETGRID c": {
        "prefix": "MIDI_GetGrid",
        "scope": "c",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "MIDI_GetGrid(${1:MediaItem_Take* take},${2:double* swingOutOptional},${3:double* noteLenOutOptional})$0"
    },
    "MIDI_GETGRID eel2": {
        "prefix": "MIDI_GetGrid",
        "scope": "eel2",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "MIDI_GetGrid(${1:MediaItem_Take take},${2:optional &swing},${3:optional &noteLen})$0"
    },
    "REAPER.MIDI_GETGRID lua": {
        "prefix": "reaper.MIDI_GetGrid",
        "scope": "lua",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "reaper.MIDI_GetGrid(${1:MediaItem_Take take})$0"
    },
    "RPR_MIDI_GETGRID python": {
        "prefix": "RPR_MIDI_GetGrid",
        "scope": "python",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "RPR_MIDI_GetGrid(${1:take},${2:swingOutOptional},${3:noteLenOutOptional})$0"
    },
    "MIDI_GETHASH c": {
        "prefix": "MIDI_GetHash",
        "scope": "c",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "MIDI_GetHash(${1:MediaItem_Take* take},${2:bool notesonly},${3:char* hash},${4:int hash_sz})$0"
    },
    "MIDI_GETHASH eel2": {
        "prefix": "MIDI_GetHash",
        "scope": "eel2",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "MIDI_GetHash(${1:MediaItem_Take take},${2:bool notesonly},${3:#hash})$0"
    },
    "REAPER.MIDI_GETHASH lua": {
        "prefix": "reaper.MIDI_GetHash",
        "scope": "lua",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "reaper.MIDI_GetHash(${1:MediaItem_Take take},${2:boolean notesonly},${3:string hash})$0"
    },
    "RPR_MIDI_GETHASH python": {
        "prefix": "RPR_MIDI_GetHash",
        "scope": "python",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "RPR_MIDI_GetHash(${1:take},${2:notesonly},${3:hash},${4:hash_sz})$0"
    },
    "MIDI_GETNOTE c": {
        "prefix": "MIDI_GetNote",
        "scope": "c",
        "description": "Get MIDI note properties.\n",
        "body": "MIDI_GetNote(${1:MediaItem_Take* take},${2:int noteidx},${3:bool* selectedOut},${4:bool* mutedOut},${5:double* startppqposOut},${6:double* endppqposOut},${7:int* chanOut},${8:int* pitchOut},${9:int* velOut})$0"
    },
    "MIDI_GETNOTE eel2": {
        "prefix": "MIDI_GetNote",
        "scope": "eel2",
        "description": "Get MIDI note properties.\n",
        "body": "MIDI_GetNote(${1:MediaItem_Take take},${2:int noteidx},${3:bool &selected},${4:bool &muted},${5:&startppqpos},${6:&endppqpos},${7:int &chan},${8:int &pitch},${9:int &vel})$0"
    },
    "REAPER.MIDI_GETNOTE lua": {
        "prefix": "reaper.MIDI_GetNote",
        "scope": "lua",
        "description": "Get MIDI note properties.\n",
        "body": "reaper.MIDI_GetNote(${1:MediaItem_Take take},${2:integer noteidx})$0"
    },
    "RPR_MIDI_GETNOTE python": {
        "prefix": "RPR_MIDI_GetNote",
        "scope": "python",
        "description": "Get MIDI note properties.\n",
        "body": "RPR_MIDI_GetNote(${1:take},${2:noteidx},${3:selectedOut},${4:mutedOut},${5:startppqposOut},${6:endppqposOut},${7:chanOut},${8:pitchOut},${9:velOut})$0"
    },
    "MIDI_GETPPQPOS_ENDOFMEASURE c": {
        "prefix": "MIDI_GetPPQPos_EndOfMeasure",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "MIDI_GetPPQPos_EndOfMeasure(${1:MediaItem_Take* take},${2:double ppqpos})$0"
    },
    "MIDI_GETPPQPOS_ENDOFMEASURE eel2": {
        "prefix": "MIDI_GetPPQPos_EndOfMeasure",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "MIDI_GetPPQPos_EndOfMeasure(${1:MediaItem_Take take},${2:ppqpos})$0"
    },
    "REAPER.MIDI_GETPPQPOS_ENDOFMEASURE lua": {
        "prefix": "reaper.MIDI_GetPPQPos_EndOfMeasure",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "reaper.MIDI_GetPPQPos_EndOfMeasure(${1:MediaItem_Take take},${2:number ppqpos})$0"
    },
    "RPR_MIDI_GETPPQPOS_ENDOFMEASURE python": {
        "prefix": "RPR_MIDI_GetPPQPos_EndOfMeasure",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "RPR_MIDI_GetPPQPos_EndOfMeasure(${1:MediaItem_Take take},${2:Float ppqpos})$0"
    },
    "MIDI_GETPPQPOS_STARTOFMEASURE c": {
        "prefix": "MIDI_GetPPQPos_StartOfMeasure",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "MIDI_GetPPQPos_StartOfMeasure(${1:MediaItem_Take* take},${2:double ppqpos})$0"
    },
    "MIDI_GETPPQPOS_STARTOFMEASURE eel2": {
        "prefix": "MIDI_GetPPQPos_StartOfMeasure",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "MIDI_GetPPQPos_StartOfMeasure(${1:MediaItem_Take take},${2:ppqpos})$0"
    },
    "REAPER.MIDI_GETPPQPOS_STARTOFMEASURE lua": {
        "prefix": "reaper.MIDI_GetPPQPos_StartOfMeasure",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "reaper.MIDI_GetPPQPos_StartOfMeasure(${1:MediaItem_Take take},${2:number ppqpos})$0"
    },
    "RPR_MIDI_GETPPQPOS_STARTOFMEASURE python": {
        "prefix": "RPR_MIDI_GetPPQPos_StartOfMeasure",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "RPR_MIDI_GetPPQPos_StartOfMeasure(${1:MediaItem_Take take},${2:Float ppqpos})$0"
    },
    "MIDI_GETPPQPOSFROMPROJQN c": {
        "prefix": "MIDI_GetPPQPosFromProjQN",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "MIDI_GetPPQPosFromProjQN(${1:MediaItem_Take* take},${2:double projqn})$0"
    },
    "MIDI_GETPPQPOSFROMPROJQN eel2": {
        "prefix": "MIDI_GetPPQPosFromProjQN",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "MIDI_GetPPQPosFromProjQN(${1:MediaItem_Take take},${2:projqn})$0"
    },
    "REAPER.MIDI_GETPPQPOSFROMPROJQN lua": {
        "prefix": "reaper.MIDI_GetPPQPosFromProjQN",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "reaper.MIDI_GetPPQPosFromProjQN(${1:MediaItem_Take take},${2:number projqn})$0"
    },
    "RPR_MIDI_GETPPQPOSFROMPROJQN python": {
        "prefix": "RPR_MIDI_GetPPQPosFromProjQN",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "RPR_MIDI_GetPPQPosFromProjQN(${1:MediaItem_Take take},${2:Float projqn})$0"
    },
    "MIDI_GETPPQPOSFROMPROJTIME c": {
        "prefix": "MIDI_GetPPQPosFromProjTime",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "MIDI_GetPPQPosFromProjTime(${1:MediaItem_Take* take},${2:double projtime})$0"
    },
    "MIDI_GETPPQPOSFROMPROJTIME eel2": {
        "prefix": "MIDI_GetPPQPosFromProjTime",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "MIDI_GetPPQPosFromProjTime(${1:MediaItem_Take take},${2:projtime})$0"
    },
    "REAPER.MIDI_GETPPQPOSFROMPROJTIME lua": {
        "prefix": "reaper.MIDI_GetPPQPosFromProjTime",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "reaper.MIDI_GetPPQPosFromProjTime(${1:MediaItem_Take take},${2:number projtime})$0"
    },
    "RPR_MIDI_GETPPQPOSFROMPROJTIME python": {
        "prefix": "RPR_MIDI_GetPPQPosFromProjTime",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "RPR_MIDI_GetPPQPosFromProjTime(${1:MediaItem_Take take},${2:Float projtime})$0"
    },
    "MIDI_GETPROJQNFROMPPQPOS c": {
        "prefix": "MIDI_GetProjQNFromPPQPos",
        "scope": "c",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "MIDI_GetProjQNFromPPQPos(${1:MediaItem_Take* take},${2:double ppqpos})$0"
    },
    "MIDI_GETPROJQNFROMPPQPOS eel2": {
        "prefix": "MIDI_GetProjQNFromPPQPos",
        "scope": "eel2",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "MIDI_GetProjQNFromPPQPos(${1:MediaItem_Take take},${2:ppqpos})$0"
    },
    "REAPER.MIDI_GETPROJQNFROMPPQPOS lua": {
        "prefix": "reaper.MIDI_GetProjQNFromPPQPos",
        "scope": "lua",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "reaper.MIDI_GetProjQNFromPPQPos(${1:MediaItem_Take take},${2:number ppqpos})$0"
    },
    "RPR_MIDI_GETPROJQNFROMPPQPOS python": {
        "prefix": "RPR_MIDI_GetProjQNFromPPQPos",
        "scope": "python",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "RPR_MIDI_GetProjQNFromPPQPos(${1:MediaItem_Take take},${2:Float ppqpos})$0"
    },
    "MIDI_GETPROJTIMEFROMPPQPOS c": {
        "prefix": "MIDI_GetProjTimeFromPPQPos",
        "scope": "c",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "MIDI_GetProjTimeFromPPQPos(${1:MediaItem_Take* take},${2:double ppqpos})$0"
    },
    "MIDI_GETPROJTIMEFROMPPQPOS eel2": {
        "prefix": "MIDI_GetProjTimeFromPPQPos",
        "scope": "eel2",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "MIDI_GetProjTimeFromPPQPos(${1:MediaItem_Take take},${2:ppqpos})$0"
    },
    "REAPER.MIDI_GETPROJTIMEFROMPPQPOS lua": {
        "prefix": "reaper.MIDI_GetProjTimeFromPPQPos",
        "scope": "lua",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "reaper.MIDI_GetProjTimeFromPPQPos(${1:MediaItem_Take take},${2:number ppqpos})$0"
    },
    "RPR_MIDI_GETPROJTIMEFROMPPQPOS python": {
        "prefix": "RPR_MIDI_GetProjTimeFromPPQPos",
        "scope": "python",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "RPR_MIDI_GetProjTimeFromPPQPos(${1:MediaItem_Take take},${2:Float ppqpos})$0"
    },
    "MIDI_GETSCALE c": {
        "prefix": "MIDI_GetScale",
        "scope": "c",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "MIDI_GetScale(${1:MediaItem_Take* take},${2:int* rootOut},${3:int* scaleOut},${4:char* name},${5:int name_sz})$0"
    },
    "MIDI_GETSCALE eel2": {
        "prefix": "MIDI_GetScale",
        "scope": "eel2",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "MIDI_GetScale(${1:MediaItem_Take take},${2:int &root},${3:int &scale},${4:#name})$0"
    },
    "REAPER.MIDI_GETSCALE lua": {
        "prefix": "reaper.MIDI_GetScale",
        "scope": "lua",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "reaper.MIDI_GetScale(${1:MediaItem_Take take},${2:number root},${3:number scale},${4:string name})$0"
    },
    "RPR_MIDI_GETSCALE python": {
        "prefix": "RPR_MIDI_GetScale",
        "scope": "python",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "RPR_MIDI_GetScale(${1:take},${2:rootOut},${3:scaleOut},${4:name},${5:name_sz})$0"
    },
    "MIDI_GETTEXTSYSEXEVT c": {
        "prefix": "MIDI_GetTextSysexEvt",
        "scope": "c",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "MIDI_GetTextSysexEvt(${1:MediaItem_Take* take},${2:int textsyxevtidx},${3:bool* selectedOutOptional},${4:bool* mutedOutOptional},${5:double* ppqposOutOptional},${6:int* typeOutOptional},${7:char* msgOptional},${8:int* msgOptional_sz})$0"
    },
    "MIDI_GETTEXTSYSEXEVT eel2": {
        "prefix": "MIDI_GetTextSysexEvt",
        "scope": "eel2",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "MIDI_GetTextSysexEvt(${1:MediaItem_Take take},${2:int textsyxevtidx},${3:optional bool &selected},${4:optional bool &muted},${5:optional &ppqpos},${6:optional int &type},${7:optional #msg})$0"
    },
    "REAPER.MIDI_GETTEXTSYSEXEVT lua": {
        "prefix": "reaper.MIDI_GetTextSysexEvt",
        "scope": "lua",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "reaper.MIDI_GetTextSysexEvt(${1:MediaItem_Take take},${2:integer textsyxevtidx},${3:optional boolean selected},${4:optional boolean muted},${5:optional number ppqpos},${6:optional number type},${7:optional string msg})$0"
    },
    "RPR_MIDI_GETTEXTSYSEXEVT python": {
        "prefix": "RPR_MIDI_GetTextSysexEvt",
        "scope": "python",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "RPR_MIDI_GetTextSysexEvt(${1:take},${2:textsyxevtidx},${3:selectedOutOptional},${4:mutedOutOptional},${5:ppqposOutOptional},${6:typeOutOptional},${7:msgOptional},${8:msgOptional_sz})$0"
    },
    "MIDI_GETTRACKHASH c": {
        "prefix": "MIDI_GetTrackHash",
        "scope": "c",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "MIDI_GetTrackHash(${1:MediaTrack* track},${2:bool notesonly},${3:char* hash},${4:int hash_sz})$0"
    },
    "MIDI_GETTRACKHASH eel2": {
        "prefix": "MIDI_GetTrackHash",
        "scope": "eel2",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "MIDI_GetTrackHash(${1:MediaTrack track},${2:bool notesonly},${3:#hash})$0"
    },
    "REAPER.MIDI_GETTRACKHASH lua": {
        "prefix": "reaper.MIDI_GetTrackHash",
        "scope": "lua",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "reaper.MIDI_GetTrackHash(${1:MediaTrack track},${2:boolean notesonly},${3:string hash})$0"
    },
    "RPR_MIDI_GETTRACKHASH python": {
        "prefix": "RPR_MIDI_GetTrackHash",
        "scope": "python",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "RPR_MIDI_GetTrackHash(${1:track},${2:notesonly},${3:hash},${4:hash_sz})$0"
    },
    "MIDI_INSERTCC c": {
        "prefix": "MIDI_InsertCC",
        "scope": "c",
        "description": "Insert a new MIDI CC event.\n",
        "body": "MIDI_InsertCC(${1:MediaItem_Take* take},${2:bool selected},${3:bool muted},${4:double ppqpos},${5:int chanmsg},${6:int chan},${7:int msg2},${8:int msg3})$0"
    },
    "MIDI_INSERTCC eel2": {
        "prefix": "MIDI_InsertCC",
        "scope": "eel2",
        "description": "Insert a new MIDI CC event.\n",
        "body": "MIDI_InsertCC(${1:MediaItem_Take take},${2:bool selected},${3:bool muted},${4:ppqpos},${5:int chanmsg},${6:int chan},${7:int msg2},${8:int msg3})$0"
    },
    "REAPER.MIDI_INSERTCC lua": {
        "prefix": "reaper.MIDI_InsertCC",
        "scope": "lua",
        "description": "Insert a new MIDI CC event.\n",
        "body": "reaper.MIDI_InsertCC(${1:MediaItem_Take take},${2:boolean selected},${3:boolean muted},${4:number ppqpos},${5:integer chanmsg},${6:integer chan},${7:integer msg2},${8:integer msg3})$0"
    },
    "RPR_MIDI_INSERTCC python": {
        "prefix": "RPR_MIDI_InsertCC",
        "scope": "python",
        "description": "Insert a new MIDI CC event.\n",
        "body": "RPR_MIDI_InsertCC(${1:MediaItem_Take take},${2:Boolean selected},${3:Boolean muted},${4:Float ppqpos},${5:Int chanmsg},${6:Int chan},${7:Int msg2},${8:Int msg3})$0"
    },
    "MIDI_INSERTEVT c": {
        "prefix": "MIDI_InsertEvt",
        "scope": "c",
        "description": "Insert a new MIDI event.\n",
        "body": "MIDI_InsertEvt(${1:MediaItem_Take* take},${2:bool selected},${3:bool muted},${4:double ppqpos},${5:const char* bytestr},${6:int bytestr_sz})$0"
    },
    "MIDI_INSERTEVT eel2": {
        "prefix": "MIDI_InsertEvt",
        "scope": "eel2",
        "description": "Insert a new MIDI event.\n",
        "body": "MIDI_InsertEvt(${1:MediaItem_Take take},${2:bool selected},${3:bool muted},${4:ppqpos},${5:\"bytestr\"})$0"
    },
    "REAPER.MIDI_INSERTEVT lua": {
        "prefix": "reaper.MIDI_InsertEvt",
        "scope": "lua",
        "description": "Insert a new MIDI event.\n",
        "body": "reaper.MIDI_InsertEvt(${1:MediaItem_Take take},${2:boolean selected},${3:boolean muted},${4:number ppqpos},${5:string bytestr})$0"
    },
    "RPR_MIDI_INSERTEVT python": {
        "prefix": "RPR_MIDI_InsertEvt",
        "scope": "python",
        "description": "Insert a new MIDI event.\n",
        "body": "RPR_MIDI_InsertEvt(${1:MediaItem_Take take},${2:Boolean selected},${3:Boolean muted},${4:Float ppqpos},${5:String bytestr},${6:Int bytestr_sz})$0"
    },
    "MIDI_INSERTNOTE c": {
        "prefix": "MIDI_InsertNote",
        "scope": "c",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_InsertNote(${1:MediaItem_Take* take},${2:bool selected},${3:bool muted},${4:double startppqpos},${5:double endppqpos},${6:int chan},${7:int pitch},${8:int vel},${9:const bool* noSortInOptional})$0"
    },
    "MIDI_INSERTNOTE eel2": {
        "prefix": "MIDI_InsertNote",
        "scope": "eel2",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_InsertNote(${1:MediaItem_Take take},${2:bool selected},${3:bool muted},${4:startppqpos},${5:endppqpos},${6:int chan},${7:int pitch},${8:int vel},${9:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_INSERTNOTE lua": {
        "prefix": "reaper.MIDI_InsertNote",
        "scope": "lua",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "reaper.MIDI_InsertNote(${1:MediaItem_Take take},${2:boolean selected},${3:boolean muted},${4:number startppqpos},${5:number endppqpos},${6:integer chan},${7:integer pitch},${8:integer vel},${9:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_INSERTNOTE python": {
        "prefix": "RPR_MIDI_InsertNote",
        "scope": "python",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "RPR_MIDI_InsertNote(${1:MediaItem_Take take},${2:Boolean selected},${3:Boolean muted},${4:Float startppqpos},${5:Float endppqpos},${6:Int chan},${7:Int pitch},${8:Int vel},${9:const bool noSortInOptional})$0"
    },
    "MIDI_INSERTTEXTSYSEXEVT c": {
        "prefix": "MIDI_InsertTextSysexEvt",
        "scope": "c",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "MIDI_InsertTextSysexEvt(${1:MediaItem_Take* take},${2:bool selected},${3:bool muted},${4:double ppqpos},${5:int type},${6:const char* bytestr},${7:int bytestr_sz})$0"
    },
    "MIDI_INSERTTEXTSYSEXEVT eel2": {
        "prefix": "MIDI_InsertTextSysexEvt",
        "scope": "eel2",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "MIDI_InsertTextSysexEvt(${1:MediaItem_Take take},${2:bool selected},${3:bool muted},${4:ppqpos},${5:int type},${6:\"bytestr\"})$0"
    },
    "REAPER.MIDI_INSERTTEXTSYSEXEVT lua": {
        "prefix": "reaper.MIDI_InsertTextSysexEvt",
        "scope": "lua",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "reaper.MIDI_InsertTextSysexEvt(${1:MediaItem_Take take},${2:boolean selected},${3:boolean muted},${4:number ppqpos},${5:integer type},${6:string bytestr})$0"
    },
    "RPR_MIDI_INSERTTEXTSYSEXEVT python": {
        "prefix": "RPR_MIDI_InsertTextSysexEvt",
        "scope": "python",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "RPR_MIDI_InsertTextSysexEvt(${1:MediaItem_Take take},${2:Boolean selected},${3:Boolean muted},${4:Float ppqpos},${5:Int type},${6:String bytestr},${7:Int bytestr_sz})$0"
    },
    "MIDI_REINIT c": {
        "prefix": "midi_reinit",
        "scope": "c",
        "description": "Reset all MIDI devices\n",
        "body": "midi_reinit()$0"
    },
    "MIDI_REINIT eel2": {
        "prefix": "midi_reinit",
        "scope": "eel2",
        "description": "Reset all MIDI devices\n",
        "body": "midi_reinit()$0"
    },
    "REAPER.MIDI_REINIT lua": {
        "prefix": "reaper.midi_reinit",
        "scope": "lua",
        "description": "Reset all MIDI devices\n",
        "body": "reaper.midi_reinit()$0"
    },
    "RPR_MIDI_REINIT python": {
        "prefix": "RPR_midi_reinit",
        "scope": "python",
        "description": "Reset all MIDI devices\n",
        "body": "RPR_midi_reinit()$0"
    },
    "MIDI_SELECTALL c": {
        "prefix": "MIDI_SelectAll",
        "scope": "c",
        "description": "Select or deselect all MIDI content.\n",
        "body": "MIDI_SelectAll(${1:MediaItem_Take* take},${2:bool select})$0"
    },
    "MIDI_SELECTALL eel2": {
        "prefix": "MIDI_SelectAll",
        "scope": "eel2",
        "description": "Select or deselect all MIDI content.\n",
        "body": "MIDI_SelectAll(${1:MediaItem_Take take},${2:bool select})$0"
    },
    "REAPER.MIDI_SELECTALL lua": {
        "prefix": "reaper.MIDI_SelectAll",
        "scope": "lua",
        "description": "Select or deselect all MIDI content.\n",
        "body": "reaper.MIDI_SelectAll(${1:MediaItem_Take take},${2:boolean select})$0"
    },
    "RPR_MIDI_SELECTALL python": {
        "prefix": "RPR_MIDI_SelectAll",
        "scope": "python",
        "description": "Select or deselect all MIDI content.\n",
        "body": "RPR_MIDI_SelectAll(${1:MediaItem_Take take},${2:Boolean select})$0"
    },
    "MIDI_SETALLEVTS c": {
        "prefix": "MIDI_SetAllEvts",
        "scope": "c",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "MIDI_SetAllEvts(${1:MediaItem_Take* take},${2:const char* buf},${3:int buf_sz})$0"
    },
    "MIDI_SETALLEVTS eel2": {
        "prefix": "MIDI_SetAllEvts",
        "scope": "eel2",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "MIDI_SetAllEvts(${1:MediaItem_Take take},${2:\"buf\"})$0"
    },
    "REAPER.MIDI_SETALLEVTS lua": {
        "prefix": "reaper.MIDI_SetAllEvts",
        "scope": "lua",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "reaper.MIDI_SetAllEvts(${1:MediaItem_Take take},${2:string buf})$0"
    },
    "RPR_MIDI_SETALLEVTS python": {
        "prefix": "RPR_MIDI_SetAllEvts",
        "scope": "python",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "RPR_MIDI_SetAllEvts(${1:MediaItem_Take take},${2:String buf},${3:Int buf_sz})$0"
    },
    "MIDI_SETCC c": {
        "prefix": "MIDI_SetCC",
        "scope": "c",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_SetCC(${1:MediaItem_Take* take},${2:int ccidx},${3:const bool* selectedInOptional},${4:const bool* mutedInOptional},${5:const double* ppqposInOptional},${6:const int* chanmsgInOptional},${7:const int* chanInOptional},${8:const int* msg2InOptional},${9:const int* msg3InOptional},${10:const bool* noSortInOptional})$0"
    },
    "MIDI_SETCC eel2": {
        "prefix": "MIDI_SetCC",
        "scope": "eel2",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_SetCC(${1:MediaItem_Take take},${2:int ccidx},${3:optional bool selectedIn},${4:optional bool mutedIn},${5:optional ppqposIn},${6:optional int chanmsgIn},${7:optional int chanIn},${8:optional int msg2In},${9:optional int msg3In},${10:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETCC lua": {
        "prefix": "reaper.MIDI_SetCC",
        "scope": "lua",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "reaper.MIDI_SetCC(${1:MediaItem_Take take},${2:integer ccidx},${3:optional boolean selectedIn},${4:optional boolean mutedIn},${5:optional number ppqposIn},${6:optional number chanmsgIn},${7:optional number chanIn},${8:optional number msg2In},${9:optional number msg3In},${10:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETCC python": {
        "prefix": "RPR_MIDI_SetCC",
        "scope": "python",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "RPR_MIDI_SetCC(${1:MediaItem_Take take},${2:Int ccidx},${3:const bool selectedInOptional},${4:const bool mutedInOptional},${5:const double ppqposInOptional},${6:const int chanmsgInOptional},${7:const int chanInOptional},${8:const int msg2InOptional},${9:const int msg3InOptional},${10:const bool noSortInOptional})$0"
    },
    "MIDI_SETCCSHAPE c": {
        "prefix": "MIDI_SetCCShape",
        "scope": "c",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "MIDI_SetCCShape(${1:MediaItem_Take* take},${2:int ccidx},${3:int shape},${4:double beztension},${5:const bool* noSortInOptional})$0"
    },
    "MIDI_SETCCSHAPE eel2": {
        "prefix": "MIDI_SetCCShape",
        "scope": "eel2",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "MIDI_SetCCShape(${1:MediaItem_Take take},${2:int ccidx},${3:int shape},${4:beztension},${5:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETCCSHAPE lua": {
        "prefix": "reaper.MIDI_SetCCShape",
        "scope": "lua",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "reaper.MIDI_SetCCShape(${1:MediaItem_Take take},${2:integer ccidx},${3:integer shape},${4:number beztension},${5:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETCCSHAPE python": {
        "prefix": "RPR_MIDI_SetCCShape",
        "scope": "python",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "RPR_MIDI_SetCCShape(${1:MediaItem_Take take},${2:Int ccidx},${3:Int shape},${4:Float beztension},${5:const bool noSortInOptional})$0"
    },
    "MIDI_SETEVT c": {
        "prefix": "MIDI_SetEvt",
        "scope": "c",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_SetEvt(${1:MediaItem_Take* take},${2:int evtidx},${3:const bool* selectedInOptional},${4:const bool* mutedInOptional},${5:const double* ppqposInOptional},${6:const char* msgOptional},${7:int msgOptional_sz},${8:const bool* noSortInOptional})$0"
    },
    "MIDI_SETEVT eel2": {
        "prefix": "MIDI_SetEvt",
        "scope": "eel2",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_SetEvt(${1:MediaItem_Take take},${2:int evtidx},${3:optional bool selectedIn},${4:optional bool mutedIn},${5:optional ppqposIn},${6:optional \"msg\"},${7:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETEVT lua": {
        "prefix": "reaper.MIDI_SetEvt",
        "scope": "lua",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "reaper.MIDI_SetEvt(${1:MediaItem_Take take},${2:integer evtidx},${3:optional boolean selectedIn},${4:optional boolean mutedIn},${5:optional number ppqposIn},${6:optional string msg},${7:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETEVT python": {
        "prefix": "RPR_MIDI_SetEvt",
        "scope": "python",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "RPR_MIDI_SetEvt(${1:MediaItem_Take take},${2:Int evtidx},${3:const bool selectedInOptional},${4:const bool mutedInOptional},${5:const double ppqposInOptional},${6:String msgOptional},${7:Int msgOptional_sz},${8:const bool noSortInOptional})$0"
    },
    "MIDI_SETITEMEXTENTS c": {
        "prefix": "MIDI_SetItemExtents",
        "scope": "c",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "MIDI_SetItemExtents(${1:MediaItem* item},${2:double startQN},${3:double endQN})$0"
    },
    "MIDI_SETITEMEXTENTS eel2": {
        "prefix": "MIDI_SetItemExtents",
        "scope": "eel2",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "MIDI_SetItemExtents(${1:MediaItem item},${2:startQN},${3:endQN})$0"
    },
    "REAPER.MIDI_SETITEMEXTENTS lua": {
        "prefix": "reaper.MIDI_SetItemExtents",
        "scope": "lua",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "reaper.MIDI_SetItemExtents(${1:MediaItem item},${2:number startQN},${3:number endQN})$0"
    },
    "RPR_MIDI_SETITEMEXTENTS python": {
        "prefix": "RPR_MIDI_SetItemExtents",
        "scope": "python",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "RPR_MIDI_SetItemExtents(${1:MediaItem item},${2:Float startQN},${3:Float endQN})$0"
    },
    "MIDI_SETNOTE c": {
        "prefix": "MIDI_SetNote",
        "scope": "c",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "MIDI_SetNote(${1:MediaItem_Take* take},${2:int noteidx},${3:const bool* selectedInOptional},${4:const bool* mutedInOptional},${5:const double* startppqposInOptional},${6:const double* endppqposInOptional},${7:const int* chanInOptional},${8:const int* pitchInOptional},${9:const int* velInOptional},${10:const bool* noSortInOptional})$0"
    },
    "MIDI_SETNOTE eel2": {
        "prefix": "MIDI_SetNote",
        "scope": "eel2",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "MIDI_SetNote(${1:MediaItem_Take take},${2:int noteidx},${3:optional bool selectedIn},${4:optional bool mutedIn},${5:optional startppqposIn},${6:optional endppqposIn},${7:optional int chanIn},${8:optional int pitchIn},${9:optional int velIn},${10:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETNOTE lua": {
        "prefix": "reaper.MIDI_SetNote",
        "scope": "lua",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "reaper.MIDI_SetNote(${1:MediaItem_Take take},${2:integer noteidx},${3:optional boolean selectedIn},${4:optional boolean mutedIn},${5:optional number startppqposIn},${6:optional number endppqposIn},${7:optional number chanIn},${8:optional number pitchIn},${9:optional number velIn},${10:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETNOTE python": {
        "prefix": "RPR_MIDI_SetNote",
        "scope": "python",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "RPR_MIDI_SetNote(${1:MediaItem_Take take},${2:Int noteidx},${3:const bool selectedInOptional},${4:const bool mutedInOptional},${5:const double startppqposInOptional},${6:const double endppqposInOptional},${7:const int chanInOptional},${8:const int pitchInOptional},${9:const int velInOptional},${10:const bool noSortInOptional})$0"
    },
    "MIDI_SETTEXTSYSEXEVT c": {
        "prefix": "MIDI_SetTextSysexEvt",
        "scope": "c",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_SetTextSysexEvt(${1:MediaItem_Take* take},${2:int textsyxevtidx},${3:const bool* selectedInOptional},${4:const bool* mutedInOptional},${5:const double* ppqposInOptional},${6:const int* typeInOptional},${7:const char* msgOptional},${8:int msgOptional_sz},${9:const bool* noSortInOptional})$0"
    },
    "MIDI_SETTEXTSYSEXEVT eel2": {
        "prefix": "MIDI_SetTextSysexEvt",
        "scope": "eel2",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "MIDI_SetTextSysexEvt(${1:MediaItem_Take take},${2:int textsyxevtidx},${3:optional bool selectedIn},${4:optional bool mutedIn},${5:optional ppqposIn},${6:optional int typeIn},${7:optional \"msg\"},${8:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETTEXTSYSEXEVT lua": {
        "prefix": "reaper.MIDI_SetTextSysexEvt",
        "scope": "lua",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "reaper.MIDI_SetTextSysexEvt(${1:MediaItem_Take take},${2:integer textsyxevtidx},${3:optional boolean selectedIn},${4:optional boolean mutedIn},${5:optional number ppqposIn},${6:optional number typeIn},${7:optional string msg},${8:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETTEXTSYSEXEVT python": {
        "prefix": "RPR_MIDI_SetTextSysexEvt",
        "scope": "python",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "RPR_MIDI_SetTextSysexEvt(${1:MediaItem_Take take},${2:Int textsyxevtidx},${3:const bool selectedInOptional},${4:const bool mutedInOptional},${5:const double ppqposInOptional},${6:const int typeInOptional},${7:String msgOptional},${8:Int msgOptional_sz},${9:const bool noSortInOptional})$0"
    },
    "MIDI_SORT c": {
        "prefix": "MIDI_Sort",
        "scope": "c",
        "description": "Sort MIDI events after multiple calls to MIDI_SetNote, MIDI_SetCC, etc.\n",
        "body": "MIDI_Sort(${1:MediaItem_Take* take})$0"
    },
    "MIDI_SORT eel2": {
        "prefix": "MIDI_Sort",
        "scope": "eel2",
        "description": "Sort MIDI events after multiple calls to MIDI_SetNote, MIDI_SetCC, etc.\n",
        "body": "MIDI_Sort(${1:MediaItem_Take take})$0"
    },
    "REAPER.MIDI_SORT lua": {
        "prefix": "reaper.MIDI_Sort",
        "scope": "lua",
        "description": "Sort MIDI events after multiple calls to MIDI_SetNote, MIDI_SetCC, etc.\n",
        "body": "reaper.MIDI_Sort(${1:MediaItem_Take take})$0"
    },
    "RPR_MIDI_SORT python": {
        "prefix": "RPR_MIDI_Sort",
        "scope": "python",
        "description": "Sort MIDI events after multiple calls to MIDI_SetNote, MIDI_SetCC, etc.\n",
        "body": "RPR_MIDI_Sort(${1:MediaItem_Take take})$0"
    },
    "MIDIEDITOR_GETACTIVE c": {
        "prefix": "MIDIEditor_GetActive",
        "scope": "c",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "MIDIEditor_GetActive()$0"
    },
    "MIDIEDITOR_GETACTIVE eel2": {
        "prefix": "MIDIEditor_GetActive",
        "scope": "eel2",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "MIDIEditor_GetActive()$0"
    },
    "REAPER.MIDIEDITOR_GETACTIVE lua": {
        "prefix": "reaper.MIDIEditor_GetActive",
        "scope": "lua",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "reaper.MIDIEditor_GetActive()$0"
    },
    "RPR_MIDIEDITOR_GETACTIVE python": {
        "prefix": "RPR_MIDIEditor_GetActive",
        "scope": "python",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "RPR_MIDIEditor_GetActive()$0"
    },
    "MIDIEDITOR_GETMODE c": {
        "prefix": "MIDIEditor_GetMode",
        "scope": "c",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "MIDIEditor_GetMode(${1:HWND midieditor})$0"
    },
    "MIDIEDITOR_GETMODE eel2": {
        "prefix": "MIDIEditor_GetMode",
        "scope": "eel2",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "MIDIEditor_GetMode(${1:HWND midieditor})$0"
    },
    "REAPER.MIDIEDITOR_GETMODE lua": {
        "prefix": "reaper.MIDIEditor_GetMode",
        "scope": "lua",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "reaper.MIDIEditor_GetMode(${1:HWND midieditor})$0"
    },
    "RPR_MIDIEDITOR_GETMODE python": {
        "prefix": "RPR_MIDIEditor_GetMode",
        "scope": "python",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "RPR_MIDIEditor_GetMode(${1:HWND midieditor})$0"
    },
    "MIDIEDITOR_GETSETTING_INT c": {
        "prefix": "MIDIEditor_GetSetting_int",
        "scope": "c",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "MIDIEditor_GetSetting_int(${1:HWND midieditor},${2:const char* setting_desc})$0"
    },
    "MIDIEDITOR_GETSETTING_INT eel2": {
        "prefix": "MIDIEditor_GetSetting_int",
        "scope": "eel2",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "MIDIEditor_GetSetting_int(${1:HWND midieditor},${2:\"setting_desc\"})$0"
    },
    "REAPER.MIDIEDITOR_GETSETTING_INT lua": {
        "prefix": "reaper.MIDIEditor_GetSetting_int",
        "scope": "lua",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "reaper.MIDIEditor_GetSetting_int(${1:HWND midieditor},${2:string setting_desc})$0"
    },
    "RPR_MIDIEDITOR_GETSETTING_INT python": {
        "prefix": "RPR_MIDIEditor_GetSetting_int",
        "scope": "python",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "RPR_MIDIEditor_GetSetting_int(${1:HWND midieditor},${2:String setting_desc})$0"
    },
    "MIDIEDITOR_GETSETTING_STR c": {
        "prefix": "MIDIEditor_GetSetting_str",
        "scope": "c",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "MIDIEditor_GetSetting_str(${1:HWND midieditor},${2:const char* setting_desc},${3:char* buf},${4:int buf_sz})$0"
    },
    "MIDIEDITOR_GETSETTING_STR eel2": {
        "prefix": "MIDIEditor_GetSetting_str",
        "scope": "eel2",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "MIDIEditor_GetSetting_str(${1:HWND midieditor},${2:\"setting_desc\"},${3:#buf})$0"
    },
    "REAPER.MIDIEDITOR_GETSETTING_STR lua": {
        "prefix": "reaper.MIDIEditor_GetSetting_str",
        "scope": "lua",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "reaper.MIDIEditor_GetSetting_str(${1:HWND midieditor},${2:string setting_desc},${3:string buf})$0"
    },
    "RPR_MIDIEDITOR_GETSETTING_STR python": {
        "prefix": "RPR_MIDIEditor_GetSetting_str",
        "scope": "python",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "RPR_MIDIEditor_GetSetting_str(${1:midieditor},${2:setting_desc},${3:buf},${4:buf_sz})$0"
    },
    "MIDIEDITOR_GETTAKE c": {
        "prefix": "MIDIEditor_GetTake",
        "scope": "c",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "MIDIEditor_GetTake(${1:HWND midieditor})$0"
    },
    "MIDIEDITOR_GETTAKE eel2": {
        "prefix": "MIDIEditor_GetTake",
        "scope": "eel2",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "MIDIEditor_GetTake(${1:HWND midieditor})$0"
    },
    "REAPER.MIDIEDITOR_GETTAKE lua": {
        "prefix": "reaper.MIDIEditor_GetTake",
        "scope": "lua",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "reaper.MIDIEditor_GetTake(${1:HWND midieditor})$0"
    },
    "RPR_MIDIEDITOR_GETTAKE python": {
        "prefix": "RPR_MIDIEditor_GetTake",
        "scope": "python",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "RPR_MIDIEditor_GetTake(${1:HWND midieditor})$0"
    },
    "MIDIEDITOR_LASTFOCUSED_ONCOMMAND c": {
        "prefix": "MIDIEditor_LastFocused_OnCommand",
        "scope": "c",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "MIDIEditor_LastFocused_OnCommand(${1:int command_id},${2:bool islistviewcommand})$0"
    },
    "MIDIEDITOR_LASTFOCUSED_ONCOMMAND eel2": {
        "prefix": "MIDIEditor_LastFocused_OnCommand",
        "scope": "eel2",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "MIDIEditor_LastFocused_OnCommand(${1:int command_id},${2:bool islistviewcommand})$0"
    },
    "REAPER.MIDIEDITOR_LASTFOCUSED_ONCOMMAND lua": {
        "prefix": "reaper.MIDIEditor_LastFocused_OnCommand",
        "scope": "lua",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "reaper.MIDIEditor_LastFocused_OnCommand(${1:integer command_id},${2:boolean islistviewcommand})$0"
    },
    "RPR_MIDIEDITOR_LASTFOCUSED_ONCOMMAND python": {
        "prefix": "RPR_MIDIEditor_LastFocused_OnCommand",
        "scope": "python",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "RPR_MIDIEditor_LastFocused_OnCommand(${1:Int command_id},${2:Boolean islistviewcommand})$0"
    },
    "MIDIEDITOR_ONCOMMAND c": {
        "prefix": "MIDIEditor_OnCommand",
        "scope": "c",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "MIDIEditor_OnCommand(${1:HWND midieditor},${2:int command_id})$0"
    },
    "MIDIEDITOR_ONCOMMAND eel2": {
        "prefix": "MIDIEditor_OnCommand",
        "scope": "eel2",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "MIDIEditor_OnCommand(${1:HWND midieditor},${2:int command_id})$0"
    },
    "REAPER.MIDIEDITOR_ONCOMMAND lua": {
        "prefix": "reaper.MIDIEditor_OnCommand",
        "scope": "lua",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "reaper.MIDIEditor_OnCommand(${1:HWND midieditor},${2:integer command_id})$0"
    },
    "RPR_MIDIEDITOR_ONCOMMAND python": {
        "prefix": "RPR_MIDIEditor_OnCommand",
        "scope": "python",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "RPR_MIDIEditor_OnCommand(${1:HWND midieditor},${2:Int command_id})$0"
    },
    "MIDIEDITOR_SETSETTING_INT c": {
        "prefix": "MIDIEditor_SetSetting_int",
        "scope": "c",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "MIDIEditor_SetSetting_int(${1:HWND midieditor},${2:const char* setting_desc},${3:int setting})$0"
    },
    "MIDIEDITOR_SETSETTING_INT eel2": {
        "prefix": "MIDIEditor_SetSetting_int",
        "scope": "eel2",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "MIDIEditor_SetSetting_int(${1:HWND midieditor},${2:\"setting_desc\"},${3:int setting})$0"
    },
    "REAPER.MIDIEDITOR_SETSETTING_INT lua": {
        "prefix": "reaper.MIDIEditor_SetSetting_int",
        "scope": "lua",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "reaper.MIDIEditor_SetSetting_int(${1:HWND midieditor},${2:string setting_desc},${3:integer setting})$0"
    },
    "RPR_MIDIEDITOR_SETSETTING_INT python": {
        "prefix": "RPR_MIDIEditor_SetSetting_int",
        "scope": "python",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "RPR_MIDIEditor_SetSetting_int(${1:HWND midieditor},${2:String setting_desc},${3:Int setting})$0"
    },
    "MKPANSTR c": {
        "prefix": "mkpanstr",
        "scope": "c",
        "description": "\n",
        "body": "mkpanstr(${1:char* strNeed64},${2:double pan})$0"
    },
    "MKPANSTR eel2": {
        "prefix": "mkpanstr",
        "scope": "eel2",
        "description": "\n",
        "body": "mkpanstr(${1:#strNeed64},${2:pan})$0"
    },
    "REAPER.MKPANSTR lua": {
        "prefix": "reaper.mkpanstr",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.mkpanstr(${1:string strNeed64},${2:number pan})$0"
    },
    "RPR_MKPANSTR python": {
        "prefix": "RPR_mkpanstr",
        "scope": "python",
        "description": "\n",
        "body": "RPR_mkpanstr(${1:strNeed64},${2:pan})$0"
    },
    "MKVOLPANSTR c": {
        "prefix": "mkvolpanstr",
        "scope": "c",
        "description": "\n",
        "body": "mkvolpanstr(${1:char* strNeed64},${2:double vol},${3:double pan})$0"
    },
    "MKVOLPANSTR eel2": {
        "prefix": "mkvolpanstr",
        "scope": "eel2",
        "description": "\n",
        "body": "mkvolpanstr(${1:#strNeed64},${2:vol},${3:pan})$0"
    },
    "REAPER.MKVOLPANSTR lua": {
        "prefix": "reaper.mkvolpanstr",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.mkvolpanstr(${1:string strNeed64},${2:number vol},${3:number pan})$0"
    },
    "RPR_MKVOLPANSTR python": {
        "prefix": "RPR_mkvolpanstr",
        "scope": "python",
        "description": "\n",
        "body": "RPR_mkvolpanstr(${1:strNeed64},${2:vol},${3:pan})$0"
    },
    "MKVOLSTR c": {
        "prefix": "mkvolstr",
        "scope": "c",
        "description": "\n",
        "body": "mkvolstr(${1:char* strNeed64},${2:double vol})$0"
    },
    "MKVOLSTR eel2": {
        "prefix": "mkvolstr",
        "scope": "eel2",
        "description": "\n",
        "body": "mkvolstr(${1:#strNeed64},${2:vol})$0"
    },
    "REAPER.MKVOLSTR lua": {
        "prefix": "reaper.mkvolstr",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.mkvolstr(${1:string strNeed64},${2:number vol})$0"
    },
    "RPR_MKVOLSTR python": {
        "prefix": "RPR_mkvolstr",
        "scope": "python",
        "description": "\n",
        "body": "RPR_mkvolstr(${1:strNeed64},${2:vol})$0"
    },
    "MOVEEDITCURSOR c": {
        "prefix": "MoveEditCursor",
        "scope": "c",
        "description": "\n",
        "body": "MoveEditCursor(${1:double adjamt},${2:bool dosel})$0"
    },
    "MOVEEDITCURSOR eel2": {
        "prefix": "MoveEditCursor",
        "scope": "eel2",
        "description": "\n",
        "body": "MoveEditCursor(${1:adjamt},${2:bool dosel})$0"
    },
    "REAPER.MOVEEDITCURSOR lua": {
        "prefix": "reaper.MoveEditCursor",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.MoveEditCursor(${1:number adjamt},${2:boolean dosel})$0"
    },
    "RPR_MOVEEDITCURSOR python": {
        "prefix": "RPR_MoveEditCursor",
        "scope": "python",
        "description": "\n",
        "body": "RPR_MoveEditCursor(${1:Float adjamt},${2:Boolean dosel})$0"
    },
    "MOVEMEDIAITEMTOTRACK c": {
        "prefix": "MoveMediaItemToTrack",
        "scope": "c",
        "description": "returns TRUE if move succeeded\n",
        "body": "MoveMediaItemToTrack(${1:MediaItem* item},${2:MediaTrack* desttr})$0"
    },
    "MOVEMEDIAITEMTOTRACK eel2": {
        "prefix": "MoveMediaItemToTrack",
        "scope": "eel2",
        "description": "returns TRUE if move succeeded\n",
        "body": "MoveMediaItemToTrack(${1:MediaItem item},${2:MediaTrack desttr})$0"
    },
    "REAPER.MOVEMEDIAITEMTOTRACK lua": {
        "prefix": "reaper.MoveMediaItemToTrack",
        "scope": "lua",
        "description": "returns TRUE if move succeeded\n",
        "body": "reaper.MoveMediaItemToTrack(${1:MediaItem item},${2:MediaTrack desttr})$0"
    },
    "RPR_MOVEMEDIAITEMTOTRACK python": {
        "prefix": "RPR_MoveMediaItemToTrack",
        "scope": "python",
        "description": "returns TRUE if move succeeded\n",
        "body": "RPR_MoveMediaItemToTrack(${1:MediaItem item},${2:MediaTrack desttr})$0"
    },
    "MUTEALLTRACKS c": {
        "prefix": "MuteAllTracks",
        "scope": "c",
        "description": "\n",
        "body": "MuteAllTracks(${1:bool mute})$0"
    },
    "MUTEALLTRACKS eel2": {
        "prefix": "MuteAllTracks",
        "scope": "eel2",
        "description": "\n",
        "body": "MuteAllTracks(${1:bool mute})$0"
    },
    "REAPER.MUTEALLTRACKS lua": {
        "prefix": "reaper.MuteAllTracks",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.MuteAllTracks(${1:boolean mute})$0"
    },
    "RPR_MUTEALLTRACKS python": {
        "prefix": "RPR_MuteAllTracks",
        "scope": "python",
        "description": "\n",
        "body": "RPR_MuteAllTracks(${1:Boolean mute})$0"
    },
    "MY_GETVIEWPORT c": {
        "prefix": "my_getViewport",
        "scope": "c",
        "description": "\n",
        "body": "my_getViewport(${1:RECT* r},${2:const RECT* sr},${3:bool wantWorkArea})$0"
    },
    "MY_GETVIEWPORT eel2": {
        "prefix": "my_getViewport",
        "scope": "eel2",
        "description": "\n",
        "body": "my_getViewport(${1:int &r.left},${2:int &r.top},${3:int &r.right},${4:int &r.bot},${5:int sr.left},${6:int sr.top},${7:int sr.right},${8:int sr.bot},${9:bool wantWorkArea})$0"
    },
    "REAPER.MY_GETVIEWPORT lua": {
        "prefix": "reaper.my_getViewport",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.my_getViewport(${1:numberr.left},${2:numberr.top},${3:numberr.right},${4:numberr.bot},${5:number sr.left},${6:number sr.top},${7:number sr.right},${8:number sr.bot},${9:boolean wantWorkArea})$0"
    },
    "RPR_MY_GETVIEWPORT python": {
        "prefix": "RPR_my_getViewport",
        "scope": "python",
        "description": "\n",
        "body": "RPR_my_getViewport(${1:RECT r},${2:const RECT sr},${3:Boolean wantWorkArea})$0"
    },
    "NAMEDCOMMANDLOOKUP c": {
        "prefix": "NamedCommandLookup",
        "scope": "c",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "NamedCommandLookup(${1:const char* command_name})$0"
    },
    "NAMEDCOMMANDLOOKUP eel2": {
        "prefix": "NamedCommandLookup",
        "scope": "eel2",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "NamedCommandLookup(${1:\"command_name\"})$0"
    },
    "REAPER.NAMEDCOMMANDLOOKUP lua": {
        "prefix": "reaper.NamedCommandLookup",
        "scope": "lua",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "reaper.NamedCommandLookup(${1:string command_name})$0"
    },
    "RPR_NAMEDCOMMANDLOOKUP python": {
        "prefix": "RPR_NamedCommandLookup",
        "scope": "python",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "RPR_NamedCommandLookup(${1:String command_name})$0"
    },
    "ONPAUSEBUTTON c": {
        "prefix": "OnPauseButton",
        "scope": "c",
        "description": "direct way to simulate pause button hit\n",
        "body": "OnPauseButton()$0"
    },
    "ONPAUSEBUTTON eel2": {
        "prefix": "OnPauseButton",
        "scope": "eel2",
        "description": "direct way to simulate pause button hit\n",
        "body": "OnPauseButton()$0"
    },
    "REAPER.ONPAUSEBUTTON lua": {
        "prefix": "reaper.OnPauseButton",
        "scope": "lua",
        "description": "direct way to simulate pause button hit\n",
        "body": "reaper.OnPauseButton()$0"
    },
    "RPR_ONPAUSEBUTTON python": {
        "prefix": "RPR_OnPauseButton",
        "scope": "python",
        "description": "direct way to simulate pause button hit\n",
        "body": "RPR_OnPauseButton()$0"
    },
    "ONPAUSEBUTTONEX c": {
        "prefix": "OnPauseButtonEx",
        "scope": "c",
        "description": "direct way to simulate pause button hit\n",
        "body": "OnPauseButtonEx(${1:ReaProject* proj})$0"
    },
    "ONPAUSEBUTTONEX eel2": {
        "prefix": "OnPauseButtonEx",
        "scope": "eel2",
        "description": "direct way to simulate pause button hit\n",
        "body": "OnPauseButtonEx(${1:ReaProject proj})$0"
    },
    "REAPER.ONPAUSEBUTTONEX lua": {
        "prefix": "reaper.OnPauseButtonEx",
        "scope": "lua",
        "description": "direct way to simulate pause button hit\n",
        "body": "reaper.OnPauseButtonEx(${1:ReaProject proj})$0"
    },
    "RPR_ONPAUSEBUTTONEX python": {
        "prefix": "RPR_OnPauseButtonEx",
        "scope": "python",
        "description": "direct way to simulate pause button hit\n",
        "body": "RPR_OnPauseButtonEx(${1:ReaProject proj})$0"
    },
    "ONPLAYBUTTON c": {
        "prefix": "OnPlayButton",
        "scope": "c",
        "description": "direct way to simulate play button hit\n",
        "body": "OnPlayButton()$0"
    },
    "ONPLAYBUTTON eel2": {
        "prefix": "OnPlayButton",
        "scope": "eel2",
        "description": "direct way to simulate play button hit\n",
        "body": "OnPlayButton()$0"
    },
    "REAPER.ONPLAYBUTTON lua": {
        "prefix": "reaper.OnPlayButton",
        "scope": "lua",
        "description": "direct way to simulate play button hit\n",
        "body": "reaper.OnPlayButton()$0"
    },
    "RPR_ONPLAYBUTTON python": {
        "prefix": "RPR_OnPlayButton",
        "scope": "python",
        "description": "direct way to simulate play button hit\n",
        "body": "RPR_OnPlayButton()$0"
    },
    "ONPLAYBUTTONEX c": {
        "prefix": "OnPlayButtonEx",
        "scope": "c",
        "description": "direct way to simulate play button hit\n",
        "body": "OnPlayButtonEx(${1:ReaProject* proj})$0"
    },
    "ONPLAYBUTTONEX eel2": {
        "prefix": "OnPlayButtonEx",
        "scope": "eel2",
        "description": "direct way to simulate play button hit\n",
        "body": "OnPlayButtonEx(${1:ReaProject proj})$0"
    },
    "REAPER.ONPLAYBUTTONEX lua": {
        "prefix": "reaper.OnPlayButtonEx",
        "scope": "lua",
        "description": "direct way to simulate play button hit\n",
        "body": "reaper.OnPlayButtonEx(${1:ReaProject proj})$0"
    },
    "RPR_ONPLAYBUTTONEX python": {
        "prefix": "RPR_OnPlayButtonEx",
        "scope": "python",
        "description": "direct way to simulate play button hit\n",
        "body": "RPR_OnPlayButtonEx(${1:ReaProject proj})$0"
    },
    "ONSTOPBUTTON c": {
        "prefix": "OnStopButton",
        "scope": "c",
        "description": "direct way to simulate stop button hit\n",
        "body": "OnStopButton()$0"
    },
    "ONSTOPBUTTON eel2": {
        "prefix": "OnStopButton",
        "scope": "eel2",
        "description": "direct way to simulate stop button hit\n",
        "body": "OnStopButton()$0"
    },
    "REAPER.ONSTOPBUTTON lua": {
        "prefix": "reaper.OnStopButton",
        "scope": "lua",
        "description": "direct way to simulate stop button hit\n",
        "body": "reaper.OnStopButton()$0"
    },
    "RPR_ONSTOPBUTTON python": {
        "prefix": "RPR_OnStopButton",
        "scope": "python",
        "description": "direct way to simulate stop button hit\n",
        "body": "RPR_OnStopButton()$0"
    },
    "ONSTOPBUTTONEX c": {
        "prefix": "OnStopButtonEx",
        "scope": "c",
        "description": "direct way to simulate stop button hit\n",
        "body": "OnStopButtonEx(${1:ReaProject* proj})$0"
    },
    "ONSTOPBUTTONEX eel2": {
        "prefix": "OnStopButtonEx",
        "scope": "eel2",
        "description": "direct way to simulate stop button hit\n",
        "body": "OnStopButtonEx(${1:ReaProject proj})$0"
    },
    "REAPER.ONSTOPBUTTONEX lua": {
        "prefix": "reaper.OnStopButtonEx",
        "scope": "lua",
        "description": "direct way to simulate stop button hit\n",
        "body": "reaper.OnStopButtonEx(${1:ReaProject proj})$0"
    },
    "RPR_ONSTOPBUTTONEX python": {
        "prefix": "RPR_OnStopButtonEx",
        "scope": "python",
        "description": "direct way to simulate stop button hit\n",
        "body": "RPR_OnStopButtonEx(${1:ReaProject proj})$0"
    },
    "OPENCOLORTHEMEFILE c": {
        "prefix": "OpenColorThemeFile",
        "scope": "c",
        "description": "\n",
        "body": "OpenColorThemeFile(${1:const char* fn})$0"
    },
    "OPENCOLORTHEMEFILE eel2": {
        "prefix": "OpenColorThemeFile",
        "scope": "eel2",
        "description": "\n",
        "body": "OpenColorThemeFile(${1:\"fn\"})$0"
    },
    "REAPER.OPENCOLORTHEMEFILE lua": {
        "prefix": "reaper.OpenColorThemeFile",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.OpenColorThemeFile(${1:string fn})$0"
    },
    "RPR_OPENCOLORTHEMEFILE python": {
        "prefix": "RPR_OpenColorThemeFile",
        "scope": "python",
        "description": "\n",
        "body": "RPR_OpenColorThemeFile(${1:String fn})$0"
    },
    "OPENMEDIAEXPLORER c": {
        "prefix": "OpenMediaExplorer",
        "scope": "c",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "OpenMediaExplorer(${1:const char* mediafn},${2:bool play})$0"
    },
    "OPENMEDIAEXPLORER eel2": {
        "prefix": "OpenMediaExplorer",
        "scope": "eel2",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "OpenMediaExplorer(${1:\"mediafn\"},${2:bool play})$0"
    },
    "REAPER.OPENMEDIAEXPLORER lua": {
        "prefix": "reaper.OpenMediaExplorer",
        "scope": "lua",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "reaper.OpenMediaExplorer(${1:string mediafn},${2:boolean play})$0"
    },
    "RPR_OPENMEDIAEXPLORER python": {
        "prefix": "RPR_OpenMediaExplorer",
        "scope": "python",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "RPR_OpenMediaExplorer(${1:String mediafn},${2:Boolean play})$0"
    },
    "OSCLOCALMESSAGETOHOST c": {
        "prefix": "OscLocalMessageToHost",
        "scope": "c",
        "description": "Send an OSC message directly to REAPER. The value argument may be NULL.\nThe message will be matched against the default OSC patterns. Only\nsupported if control surface support was enabled when installing REAPER.\n",
        "body": "OscLocalMessageToHost(${1:const char* message},${2:const double* valueInOptional})$0"
    },
    "OSCLOCALMESSAGETOHOST eel2": {
        "prefix": "OscLocalMessageToHost",
        "scope": "eel2",
        "description": "Send an OSC message directly to REAPER. The value argument may be NULL.\nThe message will be matched against the default OSC patterns. Only\nsupported if control surface support was enabled when installing REAPER.\n",
        "body": "OscLocalMessageToHost(${1:\"message\"},${2:optional valueIn})$0"
    },
    "REAPER.OSCLOCALMESSAGETOHOST lua": {
        "prefix": "reaper.OscLocalMessageToHost",
        "scope": "lua",
        "description": "Send an OSC message directly to REAPER. The value argument may be NULL.\nThe message will be matched against the default OSC patterns. Only\nsupported if control surface support was enabled when installing REAPER.\n",
        "body": "reaper.OscLocalMessageToHost(${1:string message},${2:optional number valueIn})$0"
    },
    "RPR_OSCLOCALMESSAGETOHOST python": {
        "prefix": "RPR_OscLocalMessageToHost",
        "scope": "python",
        "description": "Send an OSC message directly to REAPER. The value argument may be NULL.\nThe message will be matched against the default OSC patterns. Only\nsupported if control surface support was enabled when installing REAPER.\n",
        "body": "RPR_OscLocalMessageToHost(${1:String message},${2:const double valueInOptional})$0"
    },
    "PARSE_TIMESTR c": {
        "prefix": "parse_timestr",
        "scope": "c",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "parse_timestr(${1:const char* buf})$0"
    },
    "PARSE_TIMESTR eel2": {
        "prefix": "parse_timestr",
        "scope": "eel2",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "parse_timestr(${1:\"buf\"})$0"
    },
    "REAPER.PARSE_TIMESTR lua": {
        "prefix": "reaper.parse_timestr",
        "scope": "lua",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "reaper.parse_timestr(${1:string buf})$0"
    },
    "RPR_PARSE_TIMESTR python": {
        "prefix": "RPR_parse_timestr",
        "scope": "python",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "RPR_parse_timestr(${1:String buf})$0"
    },
    "PARSE_TIMESTR_LEN c": {
        "prefix": "parse_timestr_len",
        "scope": "c",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "parse_timestr_len(${1:const char* buf},${2:double offset},${3:int modeoverride})$0"
    },
    "PARSE_TIMESTR_LEN eel2": {
        "prefix": "parse_timestr_len",
        "scope": "eel2",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "parse_timestr_len(${1:\"buf\"},${2:offset},${3:int modeoverride})$0"
    },
    "REAPER.PARSE_TIMESTR_LEN lua": {
        "prefix": "reaper.parse_timestr_len",
        "scope": "lua",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "reaper.parse_timestr_len(${1:string buf},${2:number offset},${3:integer modeoverride})$0"
    },
    "RPR_PARSE_TIMESTR_LEN python": {
        "prefix": "RPR_parse_timestr_len",
        "scope": "python",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "RPR_parse_timestr_len(${1:String buf},${2:Float offset},${3:Int modeoverride})$0"
    },
    "PARSE_TIMESTR_POS c": {
        "prefix": "parse_timestr_pos",
        "scope": "c",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "parse_timestr_pos(${1:const char* buf},${2:int modeoverride})$0"
    },
    "PARSE_TIMESTR_POS eel2": {
        "prefix": "parse_timestr_pos",
        "scope": "eel2",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "parse_timestr_pos(${1:\"buf\"},${2:int modeoverride})$0"
    },
    "REAPER.PARSE_TIMESTR_POS lua": {
        "prefix": "reaper.parse_timestr_pos",
        "scope": "lua",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "reaper.parse_timestr_pos(${1:string buf},${2:integer modeoverride})$0"
    },
    "RPR_PARSE_TIMESTR_POS python": {
        "prefix": "RPR_parse_timestr_pos",
        "scope": "python",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "RPR_parse_timestr_pos(${1:String buf},${2:Int modeoverride})$0"
    },
    "PARSEPANSTR c": {
        "prefix": "parsepanstr",
        "scope": "c",
        "description": "\n",
        "body": "parsepanstr(${1:const char* str})$0"
    },
    "PARSEPANSTR eel2": {
        "prefix": "parsepanstr",
        "scope": "eel2",
        "description": "\n",
        "body": "parsepanstr(${1:\"str\"})$0"
    },
    "REAPER.PARSEPANSTR lua": {
        "prefix": "reaper.parsepanstr",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.parsepanstr(${1:string str})$0"
    },
    "RPR_PARSEPANSTR python": {
        "prefix": "RPR_parsepanstr",
        "scope": "python",
        "description": "\n",
        "body": "RPR_parsepanstr(${1:String str})$0"
    },
    "PCM_SINK_ENUM c": {
        "prefix": "PCM_Sink_Enum",
        "scope": "c",
        "description": "\n",
        "body": "PCM_Sink_Enum(${1:int idx},${2:const char** descstrOut})$0"
    },
    "PCM_SINK_ENUM eel2": {
        "prefix": "PCM_Sink_Enum",
        "scope": "eel2",
        "description": "\n",
        "body": "PCM_Sink_Enum(${1:int idx},${2:#descstr})$0"
    },
    "REAPER.PCM_SINK_ENUM lua": {
        "prefix": "reaper.PCM_Sink_Enum",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.PCM_Sink_Enum(${1:integer idx})$0"
    },
    "RPR_PCM_SINK_ENUM python": {
        "prefix": "RPR_PCM_Sink_Enum",
        "scope": "python",
        "description": "\n",
        "body": "RPR_PCM_Sink_Enum(${1:Int idx},${2:String descstrOut})$0"
    },
    "PCM_SINK_GETEXTENSION c": {
        "prefix": "PCM_Sink_GetExtension",
        "scope": "c",
        "description": "\n",
        "body": "PCM_Sink_GetExtension(${1:const char* data},${2:int data_sz})$0"
    },
    "PCM_SINK_GETEXTENSION eel2": {
        "prefix": "PCM_Sink_GetExtension",
        "scope": "eel2",
        "description": "\n",
        "body": "PCM_Sink_GetExtension(${1:#retval},${2:\"data\"})$0"
    },
    "REAPER.PCM_SINK_GETEXTENSION lua": {
        "prefix": "reaper.PCM_Sink_GetExtension",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.PCM_Sink_GetExtension(${1:string data})$0"
    },
    "RPR_PCM_SINK_GETEXTENSION python": {
        "prefix": "RPR_PCM_Sink_GetExtension",
        "scope": "python",
        "description": "\n",
        "body": "RPR_PCM_Sink_GetExtension(${1:String data},${2:Int data_sz})$0"
    },
    "PCM_SINK_SHOWCONFIG c": {
        "prefix": "PCM_Sink_ShowConfig",
        "scope": "c",
        "description": "\n",
        "body": "PCM_Sink_ShowConfig(${1:const char* cfg},${2:int cfg_sz},${3:HWND hwndParent})$0"
    },
    "PCM_SINK_SHOWCONFIG eel2": {
        "prefix": "PCM_Sink_ShowConfig",
        "scope": "eel2",
        "description": "\n",
        "body": "PCM_Sink_ShowConfig(${1:\"cfg\"},${2:HWND hwndParent})$0"
    },
    "REAPER.PCM_SINK_SHOWCONFIG lua": {
        "prefix": "reaper.PCM_Sink_ShowConfig",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.PCM_Sink_ShowConfig(${1:string cfg},${2:HWND hwndParent})$0"
    },
    "RPR_PCM_SINK_SHOWCONFIG python": {
        "prefix": "RPR_PCM_Sink_ShowConfig",
        "scope": "python",
        "description": "\n",
        "body": "RPR_PCM_Sink_ShowConfig(${1:String cfg},${2:Int cfg_sz},${3:HWND hwndParent})$0"
    },
    "PCM_SOURCE_CREATEFROMFILE c": {
        "prefix": "PCM_Source_CreateFromFile",
        "scope": "c",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "PCM_Source_CreateFromFile(${1:const char* filename})$0"
    },
    "PCM_SOURCE_CREATEFROMFILE eel2": {
        "prefix": "PCM_Source_CreateFromFile",
        "scope": "eel2",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "PCM_Source_CreateFromFile(${1:\"filename\"})$0"
    },
    "REAPER.PCM_SOURCE_CREATEFROMFILE lua": {
        "prefix": "reaper.PCM_Source_CreateFromFile",
        "scope": "lua",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "reaper.PCM_Source_CreateFromFile(${1:string filename})$0"
    },
    "RPR_PCM_SOURCE_CREATEFROMFILE python": {
        "prefix": "RPR_PCM_Source_CreateFromFile",
        "scope": "python",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "RPR_PCM_Source_CreateFromFile(${1:String filename})$0"
    },
    "PCM_SOURCE_CREATEFROMFILEEX c": {
        "prefix": "PCM_Source_CreateFromFileEx",
        "scope": "c",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "PCM_Source_CreateFromFileEx(${1:const char* filename},${2:bool forcenoMidiImp})$0"
    },
    "PCM_SOURCE_CREATEFROMFILEEX eel2": {
        "prefix": "PCM_Source_CreateFromFileEx",
        "scope": "eel2",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "PCM_Source_CreateFromFileEx(${1:\"filename\"},${2:bool forcenoMidiImp})$0"
    },
    "REAPER.PCM_SOURCE_CREATEFROMFILEEX lua": {
        "prefix": "reaper.PCM_Source_CreateFromFileEx",
        "scope": "lua",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "reaper.PCM_Source_CreateFromFileEx(${1:string filename},${2:boolean forcenoMidiImp})$0"
    },
    "RPR_PCM_SOURCE_CREATEFROMFILEEX python": {
        "prefix": "RPR_PCM_Source_CreateFromFileEx",
        "scope": "python",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "RPR_PCM_Source_CreateFromFileEx(${1:String filename},${2:Boolean forcenoMidiImp})$0"
    },
    "PCM_SOURCE_CREATEFROMTYPE c": {
        "prefix": "PCM_Source_CreateFromType",
        "scope": "c",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "PCM_Source_CreateFromType(${1:const char* sourcetype})$0"
    },
    "PCM_SOURCE_CREATEFROMTYPE eel2": {
        "prefix": "PCM_Source_CreateFromType",
        "scope": "eel2",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "PCM_Source_CreateFromType(${1:\"sourcetype\"})$0"
    },
    "REAPER.PCM_SOURCE_CREATEFROMTYPE lua": {
        "prefix": "reaper.PCM_Source_CreateFromType",
        "scope": "lua",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "reaper.PCM_Source_CreateFromType(${1:string sourcetype})$0"
    },
    "RPR_PCM_SOURCE_CREATEFROMTYPE python": {
        "prefix": "RPR_PCM_Source_CreateFromType",
        "scope": "python",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "RPR_PCM_Source_CreateFromType(${1:String sourcetype})$0"
    },
    "PCM_SOURCE_DESTROY c": {
        "prefix": "PCM_Source_Destroy",
        "scope": "c",
        "description": "Deletes a PCM_source -- be sure that you remove any project reference before deleting a source\n",
        "body": "PCM_Source_Destroy(${1:PCM_source* src})$0"
    },
    "PCM_SOURCE_DESTROY eel2": {
        "prefix": "PCM_Source_Destroy",
        "scope": "eel2",
        "description": "Deletes a PCM_source -- be sure that you remove any project reference before deleting a source\n",
        "body": "PCM_Source_Destroy(${1:PCM_source src})$0"
    },
    "REAPER.PCM_SOURCE_DESTROY lua": {
        "prefix": "reaper.PCM_Source_Destroy",
        "scope": "lua",
        "description": "Deletes a PCM_source -- be sure that you remove any project reference before deleting a source\n",
        "body": "reaper.PCM_Source_Destroy(${1:PCM_source src})$0"
    },
    "RPR_PCM_SOURCE_DESTROY python": {
        "prefix": "RPR_PCM_Source_Destroy",
        "scope": "python",
        "description": "Deletes a PCM_source -- be sure that you remove any project reference before deleting a source\n",
        "body": "RPR_PCM_Source_Destroy(${1:PCM_source src})$0"
    },
    "PCM_SOURCE_GETPEAKS c": {
        "prefix": "PCM_Source_GetPeaks",
        "scope": "c",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "PCM_Source_GetPeaks(${1:PCM_source* src},${2:double peakrate},${3:double starttime},${4:int numchannels},${5:int numsamplesperchannel},${6:int want_extra_type},${7:double* buf})$0"
    },
    "PCM_SOURCE_GETPEAKS eel2": {
        "prefix": "PCM_Source_GetPeaks",
        "scope": "eel2",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "PCM_Source_GetPeaks(${1:PCM_source src},${2:peakrate},${3:starttime},${4:int numchannels},${5:int numsamplesperchannel},${6:int want_extra_type},${7:buffer_ptr buf})$0"
    },
    "REAPER.PCM_SOURCE_GETPEAKS lua": {
        "prefix": "reaper.PCM_Source_GetPeaks",
        "scope": "lua",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "reaper.PCM_Source_GetPeaks(${1:PCM_source src},${2:number peakrate},${3:number starttime},${4:integer numchannels},${5:integer numsamplesperchannel},${6:integer want_extra_type},${7:reaper_array buf})$0"
    },
    "RPR_PCM_SOURCE_GETPEAKS python": {
        "prefix": "RPR_PCM_Source_GetPeaks",
        "scope": "python",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "RPR_PCM_Source_GetPeaks(${1:src},${2:peakrate},${3:starttime},${4:numchannels},${5:numsamplesperchannel},${6:want_extra_type},${7:buf})$0"
    },
    "PCM_SOURCE_GETSECTIONINFO c": {
        "prefix": "PCM_Source_GetSectionInfo",
        "scope": "c",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "PCM_Source_GetSectionInfo(${1:PCM_source* src},${2:double* offsOut},${3:double* lenOut},${4:bool* revOut})$0"
    },
    "PCM_SOURCE_GETSECTIONINFO eel2": {
        "prefix": "PCM_Source_GetSectionInfo",
        "scope": "eel2",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "PCM_Source_GetSectionInfo(${1:PCM_source src},${2:&offs},${3:&len},${4:bool &rev})$0"
    },
    "REAPER.PCM_SOURCE_GETSECTIONINFO lua": {
        "prefix": "reaper.PCM_Source_GetSectionInfo",
        "scope": "lua",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "reaper.PCM_Source_GetSectionInfo(${1:PCM_source src})$0"
    },
    "RPR_PCM_SOURCE_GETSECTIONINFO python": {
        "prefix": "RPR_PCM_Source_GetSectionInfo",
        "scope": "python",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "RPR_PCM_Source_GetSectionInfo(${1:src},${2:offsOut},${3:lenOut},${4:revOut})$0"
    },
    "PLUGINWANTSALWAYSRUNFX c": {
        "prefix": "PluginWantsAlwaysRunFx",
        "scope": "c",
        "description": "\n",
        "body": "PluginWantsAlwaysRunFx(${1:int amt})$0"
    },
    "PLUGINWANTSALWAYSRUNFX eel2": {
        "prefix": "PluginWantsAlwaysRunFx",
        "scope": "eel2",
        "description": "\n",
        "body": "PluginWantsAlwaysRunFx(${1:int amt})$0"
    },
    "REAPER.PLUGINWANTSALWAYSRUNFX lua": {
        "prefix": "reaper.PluginWantsAlwaysRunFx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.PluginWantsAlwaysRunFx(${1:integer amt})$0"
    },
    "RPR_PLUGINWANTSALWAYSRUNFX python": {
        "prefix": "RPR_PluginWantsAlwaysRunFx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_PluginWantsAlwaysRunFx(${1:Int amt})$0"
    },
    "PREVENTUIREFRESH c": {
        "prefix": "PreventUIRefresh",
        "scope": "c",
        "description": "adds prevent_count to the UI refresh prevention state; always add then remove the same amount, or major disfunction will occur\n",
        "body": "PreventUIRefresh(${1:int prevent_count})$0"
    },
    "PREVENTUIREFRESH eel2": {
        "prefix": "PreventUIRefresh",
        "scope": "eel2",
        "description": "adds prevent_count to the UI refresh prevention state; always add then remove the same amount, or major disfunction will occur\n",
        "body": "PreventUIRefresh(${1:int prevent_count})$0"
    },
    "REAPER.PREVENTUIREFRESH lua": {
        "prefix": "reaper.PreventUIRefresh",
        "scope": "lua",
        "description": "adds prevent_count to the UI refresh prevention state; always add then remove the same amount, or major disfunction will occur\n",
        "body": "reaper.PreventUIRefresh(${1:integer prevent_count})$0"
    },
    "RPR_PREVENTUIREFRESH python": {
        "prefix": "RPR_PreventUIRefresh",
        "scope": "python",
        "description": "adds prevent_count to the UI refresh prevention state; always add then remove the same amount, or major disfunction will occur\n",
        "body": "RPR_PreventUIRefresh(${1:Int prevent_count})$0"
    },
    "REASCRIPTERROR c": {
        "prefix": "ReaScriptError",
        "scope": "c",
        "description": "Causes REAPER to display the error message after the current ReaScript finishes.\n",
        "body": "ReaScriptError(${1:const char* errmsg})$0"
    },
    "REASCRIPTERROR eel2": {
        "prefix": "ReaScriptError",
        "scope": "eel2",
        "description": "Causes REAPER to display the error message after the current ReaScript finishes.\n",
        "body": "ReaScriptError(${1:\"errmsg\"})$0"
    },
    "REAPER.REASCRIPTERROR lua": {
        "prefix": "reaper.ReaScriptError",
        "scope": "lua",
        "description": "Causes REAPER to display the error message after the current ReaScript finishes.\n",
        "body": "reaper.ReaScriptError(${1:string errmsg})$0"
    },
    "RPR_REASCRIPTERROR python": {
        "prefix": "RPR_ReaScriptError",
        "scope": "python",
        "description": "Causes REAPER to display the error message after the current ReaScript finishes.\n",
        "body": "RPR_ReaScriptError(${1:String errmsg})$0"
    },
    "RECURSIVECREATEDIRECTORY c": {
        "prefix": "RecursiveCreateDirectory",
        "scope": "c",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "RecursiveCreateDirectory(${1:const char* path},${2:size_t ignored})$0"
    },
    "RECURSIVECREATEDIRECTORY eel2": {
        "prefix": "RecursiveCreateDirectory",
        "scope": "eel2",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "RecursiveCreateDirectory(${1:\"path\"},${2:size_t ignored})$0"
    },
    "REAPER.RECURSIVECREATEDIRECTORY lua": {
        "prefix": "reaper.RecursiveCreateDirectory",
        "scope": "lua",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "reaper.RecursiveCreateDirectory(${1:string path},${2:integer ignored})$0"
    },
    "RPR_RECURSIVECREATEDIRECTORY python": {
        "prefix": "RPR_RecursiveCreateDirectory",
        "scope": "python",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "RPR_RecursiveCreateDirectory(${1:String path},${2:Unknown ignored})$0"
    },
    "REDUCE_OPEN_FILES c": {
        "prefix": "reduce_open_files",
        "scope": "c",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "reduce_open_files(${1:int flags})$0"
    },
    "REDUCE_OPEN_FILES eel2": {
        "prefix": "reduce_open_files",
        "scope": "eel2",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "reduce_open_files(${1:int flags})$0"
    },
    "REAPER.REDUCE_OPEN_FILES lua": {
        "prefix": "reaper.reduce_open_files",
        "scope": "lua",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "reaper.reduce_open_files(${1:integer flags})$0"
    },
    "RPR_REDUCE_OPEN_FILES python": {
        "prefix": "RPR_reduce_open_files",
        "scope": "python",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "RPR_reduce_open_files(${1:Int flags})$0"
    },
    "REFRESHTOOLBAR c": {
        "prefix": "RefreshToolbar",
        "scope": "c",
        "description": "See RefreshToolbar2.\n",
        "body": "RefreshToolbar(${1:int command_id})$0"
    },
    "REFRESHTOOLBAR eel2": {
        "prefix": "RefreshToolbar",
        "scope": "eel2",
        "description": "See RefreshToolbar2.\n",
        "body": "RefreshToolbar(${1:int command_id})$0"
    },
    "REAPER.REFRESHTOOLBAR lua": {
        "prefix": "reaper.RefreshToolbar",
        "scope": "lua",
        "description": "See RefreshToolbar2.\n",
        "body": "reaper.RefreshToolbar(${1:integer command_id})$0"
    },
    "RPR_REFRESHTOOLBAR python": {
        "prefix": "RPR_RefreshToolbar",
        "scope": "python",
        "description": "See RefreshToolbar2.\n",
        "body": "RPR_RefreshToolbar(${1:Int command_id})$0"
    },
    "REFRESHTOOLBAR2 c": {
        "prefix": "RefreshToolbar2",
        "scope": "c",
        "description": "Refresh the toolbar button states of a toggle action.\n",
        "body": "RefreshToolbar2(${1:int section_id},${2:int command_id})$0"
    },
    "REFRESHTOOLBAR2 eel2": {
        "prefix": "RefreshToolbar2",
        "scope": "eel2",
        "description": "Refresh the toolbar button states of a toggle action.\n",
        "body": "RefreshToolbar2(${1:int section_id},${2:int command_id})$0"
    },
    "REAPER.REFRESHTOOLBAR2 lua": {
        "prefix": "reaper.RefreshToolbar2",
        "scope": "lua",
        "description": "Refresh the toolbar button states of a toggle action.\n",
        "body": "reaper.RefreshToolbar2(${1:integer section_id},${2:integer command_id})$0"
    },
    "RPR_REFRESHTOOLBAR2 python": {
        "prefix": "RPR_RefreshToolbar2",
        "scope": "python",
        "description": "Refresh the toolbar button states of a toggle action.\n",
        "body": "RPR_RefreshToolbar2(${1:Int section_id},${2:Int command_id})$0"
    },
    "RELATIVE_FN c": {
        "prefix": "relative_fn",
        "scope": "c",
        "description": "Makes a filename \"in\" relative to the current project, if any.\n",
        "body": "relative_fn(${1:const char* in},${2:char* out},${3:int out_sz})$0"
    },
    "RELATIVE_FN eel2": {
        "prefix": "relative_fn",
        "scope": "eel2",
        "description": "Makes a filename \"in\" relative to the current project, if any.\n",
        "body": "relative_fn(${1:\"in\"},${2:#out})$0"
    },
    "REAPER.RELATIVE_FN lua": {
        "prefix": "reaper.relative_fn",
        "scope": "lua",
        "description": "Makes a filename \"in\" relative to the current project, if any.\n",
        "body": "reaper.relative_fn(${1:string in},${2:string out})$0"
    },
    "RPR_RELATIVE_FN python": {
        "prefix": "RPR_relative_fn",
        "scope": "python",
        "description": "Makes a filename \"in\" relative to the current project, if any.\n",
        "body": "RPR_relative_fn(${1:in},${2:out},${3:out_sz})$0"
    },
    "REMOVETRACKSEND c": {
        "prefix": "RemoveTrackSend",
        "scope": "c",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "RemoveTrackSend(${1:MediaTrack* tr},${2:int category},${3:int sendidx})$0"
    },
    "REMOVETRACKSEND eel2": {
        "prefix": "RemoveTrackSend",
        "scope": "eel2",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "RemoveTrackSend(${1:MediaTrack tr},${2:int category},${3:int sendidx})$0"
    },
    "REAPER.REMOVETRACKSEND lua": {
        "prefix": "reaper.RemoveTrackSend",
        "scope": "lua",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "reaper.RemoveTrackSend(${1:MediaTrack tr},${2:integer category},${3:integer sendidx})$0"
    },
    "RPR_REMOVETRACKSEND python": {
        "prefix": "RPR_RemoveTrackSend",
        "scope": "python",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "RPR_RemoveTrackSend(${1:MediaTrack tr},${2:Int category},${3:Int sendidx})$0"
    },
    "RENDERFILESECTION c": {
        "prefix": "RenderFileSection",
        "scope": "c",
        "description": "Not available while playing back.\n",
        "body": "RenderFileSection(${1:const char* source_filename},${2:const char* target_filename},${3:double start_percent},${4:double end_percent},${5:double playrate})$0"
    },
    "RENDERFILESECTION eel2": {
        "prefix": "RenderFileSection",
        "scope": "eel2",
        "description": "Not available while playing back.\n",
        "body": "RenderFileSection(${1:\"source_filename\"},${2:\"target_filename\"},${3:start_percent},${4:end_percent},${5:playrate})$0"
    },
    "REAPER.RENDERFILESECTION lua": {
        "prefix": "reaper.RenderFileSection",
        "scope": "lua",
        "description": "Not available while playing back.\n",
        "body": "reaper.RenderFileSection(${1:string source_filename},${2:string target_filename},${3:number start_percent},${4:number end_percent},${5:number playrate})$0"
    },
    "RPR_RENDERFILESECTION python": {
        "prefix": "RPR_RenderFileSection",
        "scope": "python",
        "description": "Not available while playing back.\n",
        "body": "RPR_RenderFileSection(${1:String source_filename},${2:String target_filename},${3:Float start_percent},${4:Float end_percent},${5:Float playrate})$0"
    },
    "REORDERSELECTEDTRACKS c": {
        "prefix": "ReorderSelectedTracks",
        "scope": "c",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "ReorderSelectedTracks(${1:int beforeTrackIdx},${2:int makePrevFolder})$0"
    },
    "REORDERSELECTEDTRACKS eel2": {
        "prefix": "ReorderSelectedTracks",
        "scope": "eel2",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "ReorderSelectedTracks(${1:int beforeTrackIdx},${2:int makePrevFolder})$0"
    },
    "REAPER.REORDERSELECTEDTRACKS lua": {
        "prefix": "reaper.ReorderSelectedTracks",
        "scope": "lua",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "reaper.ReorderSelectedTracks(${1:integer beforeTrackIdx},${2:integer makePrevFolder})$0"
    },
    "RPR_REORDERSELECTEDTRACKS python": {
        "prefix": "RPR_ReorderSelectedTracks",
        "scope": "python",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "RPR_ReorderSelectedTracks(${1:Int beforeTrackIdx},${2:Int makePrevFolder})$0"
    },
    "RESAMPLE_ENUMMODES c": {
        "prefix": "Resample_EnumModes",
        "scope": "c",
        "description": "\n",
        "body": "Resample_EnumModes(${1:int mode})$0"
    },
    "RESAMPLE_ENUMMODES eel2": {
        "prefix": "Resample_EnumModes",
        "scope": "eel2",
        "description": "\n",
        "body": "Resample_EnumModes(${1:#retval},${2:int mode})$0"
    },
    "REAPER.RESAMPLE_ENUMMODES lua": {
        "prefix": "reaper.Resample_EnumModes",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Resample_EnumModes(${1:integer mode})$0"
    },
    "RPR_RESAMPLE_ENUMMODES python": {
        "prefix": "RPR_Resample_EnumModes",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Resample_EnumModes(${1:Int mode})$0"
    },
    "RESOLVE_FN c": {
        "prefix": "resolve_fn",
        "scope": "c",
        "description": "See resolve_fn2.\n",
        "body": "resolve_fn(${1:const char* in},${2:char* out},${3:int out_sz})$0"
    },
    "RESOLVE_FN eel2": {
        "prefix": "resolve_fn",
        "scope": "eel2",
        "description": "See resolve_fn2.\n",
        "body": "resolve_fn(${1:\"in\"},${2:#out})$0"
    },
    "REAPER.RESOLVE_FN lua": {
        "prefix": "reaper.resolve_fn",
        "scope": "lua",
        "description": "See resolve_fn2.\n",
        "body": "reaper.resolve_fn(${1:string in},${2:string out})$0"
    },
    "RPR_RESOLVE_FN python": {
        "prefix": "RPR_resolve_fn",
        "scope": "python",
        "description": "See resolve_fn2.\n",
        "body": "RPR_resolve_fn(${1:in},${2:out},${3:out_sz})$0"
    },
    "RESOLVE_FN2 c": {
        "prefix": "resolve_fn2",
        "scope": "c",
        "description": "Resolves a filename \"in\" by using project settings etc. If no file found, out will be a copy of in.\n",
        "body": "resolve_fn2(${1:const char* in},${2:char* out},${3:int out_sz},${4:const char* checkSubDirOptional})$0"
    },
    "RESOLVE_FN2 eel2": {
        "prefix": "resolve_fn2",
        "scope": "eel2",
        "description": "Resolves a filename \"in\" by using project settings etc. If no file found, out will be a copy of in.\n",
        "body": "resolve_fn2(${1:\"in\"},${2:#out},${3:optional \"checkSubDir\"})$0"
    },
    "REAPER.RESOLVE_FN2 lua": {
        "prefix": "reaper.resolve_fn2",
        "scope": "lua",
        "description": "Resolves a filename \"in\" by using project settings etc. If no file found, out will be a copy of in.\n",
        "body": "reaper.resolve_fn2(${1:string in},${2:string out},${3:optional string checkSubDir})$0"
    },
    "RPR_RESOLVE_FN2 python": {
        "prefix": "RPR_resolve_fn2",
        "scope": "python",
        "description": "Resolves a filename \"in\" by using project settings etc. If no file found, out will be a copy of in.\n",
        "body": "RPR_resolve_fn2(${1:in},${2:out},${3:out_sz},${4:checkSubDirOptional})$0"
    },
    "REVERSENAMEDCOMMANDLOOKUP c": {
        "prefix": "ReverseNamedCommandLookup",
        "scope": "c",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "ReverseNamedCommandLookup(${1:int command_id})$0"
    },
    "REVERSENAMEDCOMMANDLOOKUP eel2": {
        "prefix": "ReverseNamedCommandLookup",
        "scope": "eel2",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "ReverseNamedCommandLookup(${1:#retval},${2:int command_id})$0"
    },
    "REAPER.REVERSENAMEDCOMMANDLOOKUP lua": {
        "prefix": "reaper.ReverseNamedCommandLookup",
        "scope": "lua",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "reaper.ReverseNamedCommandLookup(${1:integer command_id})$0"
    },
    "RPR_REVERSENAMEDCOMMANDLOOKUP python": {
        "prefix": "RPR_ReverseNamedCommandLookup",
        "scope": "python",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "RPR_ReverseNamedCommandLookup(${1:Int command_id})$0"
    },
    "SCALEFROMENVELOPEMODE c": {
        "prefix": "ScaleFromEnvelopeMode",
        "scope": "c",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "ScaleFromEnvelopeMode(${1:int scaling_mode},${2:double val})$0"
    },
    "SCALEFROMENVELOPEMODE eel2": {
        "prefix": "ScaleFromEnvelopeMode",
        "scope": "eel2",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "ScaleFromEnvelopeMode(${1:int scaling_mode},${2:val})$0"
    },
    "REAPER.SCALEFROMENVELOPEMODE lua": {
        "prefix": "reaper.ScaleFromEnvelopeMode",
        "scope": "lua",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "reaper.ScaleFromEnvelopeMode(${1:integer scaling_mode},${2:number val})$0"
    },
    "RPR_SCALEFROMENVELOPEMODE python": {
        "prefix": "RPR_ScaleFromEnvelopeMode",
        "scope": "python",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "RPR_ScaleFromEnvelopeMode(${1:Int scaling_mode},${2:Float val})$0"
    },
    "SCALETOENVELOPEMODE c": {
        "prefix": "ScaleToEnvelopeMode",
        "scope": "c",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "ScaleToEnvelopeMode(${1:int scaling_mode},${2:double val})$0"
    },
    "SCALETOENVELOPEMODE eel2": {
        "prefix": "ScaleToEnvelopeMode",
        "scope": "eel2",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "ScaleToEnvelopeMode(${1:int scaling_mode},${2:val})$0"
    },
    "REAPER.SCALETOENVELOPEMODE lua": {
        "prefix": "reaper.ScaleToEnvelopeMode",
        "scope": "lua",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "reaper.ScaleToEnvelopeMode(${1:integer scaling_mode},${2:number val})$0"
    },
    "RPR_SCALETOENVELOPEMODE python": {
        "prefix": "RPR_ScaleToEnvelopeMode",
        "scope": "python",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "RPR_ScaleToEnvelopeMode(${1:Int scaling_mode},${2:Float val})$0"
    },
    "SELECTALLMEDIAITEMS c": {
        "prefix": "SelectAllMediaItems",
        "scope": "c",
        "description": "\n",
        "body": "SelectAllMediaItems(${1:ReaProject* proj},${2:bool selected})$0"
    },
    "SELECTALLMEDIAITEMS eel2": {
        "prefix": "SelectAllMediaItems",
        "scope": "eel2",
        "description": "\n",
        "body": "SelectAllMediaItems(${1:ReaProject proj},${2:bool selected})$0"
    },
    "REAPER.SELECTALLMEDIAITEMS lua": {
        "prefix": "reaper.SelectAllMediaItems",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SelectAllMediaItems(${1:ReaProject proj},${2:boolean selected})$0"
    },
    "RPR_SELECTALLMEDIAITEMS python": {
        "prefix": "RPR_SelectAllMediaItems",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SelectAllMediaItems(${1:ReaProject proj},${2:Boolean selected})$0"
    },
    "SELECTPROJECTINSTANCE c": {
        "prefix": "SelectProjectInstance",
        "scope": "c",
        "description": "\n",
        "body": "SelectProjectInstance(${1:ReaProject* proj})$0"
    },
    "SELECTPROJECTINSTANCE eel2": {
        "prefix": "SelectProjectInstance",
        "scope": "eel2",
        "description": "\n",
        "body": "SelectProjectInstance(${1:ReaProject proj})$0"
    },
    "REAPER.SELECTPROJECTINSTANCE lua": {
        "prefix": "reaper.SelectProjectInstance",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SelectProjectInstance(${1:ReaProject proj})$0"
    },
    "RPR_SELECTPROJECTINSTANCE python": {
        "prefix": "RPR_SelectProjectInstance",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SelectProjectInstance(${1:ReaProject proj})$0"
    },
    "SETACTIVETAKE c": {
        "prefix": "SetActiveTake",
        "scope": "c",
        "description": "set this take active in this media item\n",
        "body": "SetActiveTake(${1:MediaItem_Take* take})$0"
    },
    "SETACTIVETAKE eel2": {
        "prefix": "SetActiveTake",
        "scope": "eel2",
        "description": "set this take active in this media item\n",
        "body": "SetActiveTake(${1:MediaItem_Take take})$0"
    },
    "REAPER.SETACTIVETAKE lua": {
        "prefix": "reaper.SetActiveTake",
        "scope": "lua",
        "description": "set this take active in this media item\n",
        "body": "reaper.SetActiveTake(${1:MediaItem_Take take})$0"
    },
    "RPR_SETACTIVETAKE python": {
        "prefix": "RPR_SetActiveTake",
        "scope": "python",
        "description": "set this take active in this media item\n",
        "body": "RPR_SetActiveTake(${1:MediaItem_Take take})$0"
    },
    "SETAUTOMATIONMODE c": {
        "prefix": "SetAutomationMode",
        "scope": "c",
        "description": "sets all or selected tracks to mode.\n",
        "body": "SetAutomationMode(${1:int mode},${2:bool onlySel})$0"
    },
    "SETAUTOMATIONMODE eel2": {
        "prefix": "SetAutomationMode",
        "scope": "eel2",
        "description": "sets all or selected tracks to mode.\n",
        "body": "SetAutomationMode(${1:int mode},${2:bool onlySel})$0"
    },
    "REAPER.SETAUTOMATIONMODE lua": {
        "prefix": "reaper.SetAutomationMode",
        "scope": "lua",
        "description": "sets all or selected tracks to mode.\n",
        "body": "reaper.SetAutomationMode(${1:integer mode},${2:boolean onlySel})$0"
    },
    "RPR_SETAUTOMATIONMODE python": {
        "prefix": "RPR_SetAutomationMode",
        "scope": "python",
        "description": "sets all or selected tracks to mode.\n",
        "body": "RPR_SetAutomationMode(${1:Int mode},${2:Boolean onlySel})$0"
    },
    "SETCURRENTBPM c": {
        "prefix": "SetCurrentBPM",
        "scope": "c",
        "description": "set current BPM in project, set wantUndo=true to add undo point\n",
        "body": "SetCurrentBPM(${1:ReaProject* __proj},${2:double bpm},${3:bool wantUndo})$0"
    },
    "SETCURRENTBPM eel2": {
        "prefix": "SetCurrentBPM",
        "scope": "eel2",
        "description": "set current BPM in project, set wantUndo=true to add undo point\n",
        "body": "SetCurrentBPM(${1:ReaProject __proj},${2:bpm},${3:bool wantUndo})$0"
    },
    "REAPER.SETCURRENTBPM lua": {
        "prefix": "reaper.SetCurrentBPM",
        "scope": "lua",
        "description": "set current BPM in project, set wantUndo=true to add undo point\n",
        "body": "reaper.SetCurrentBPM(${1:ReaProject __proj},${2:number bpm},${3:boolean wantUndo})$0"
    },
    "RPR_SETCURRENTBPM python": {
        "prefix": "RPR_SetCurrentBPM",
        "scope": "python",
        "description": "set current BPM in project, set wantUndo=true to add undo point\n",
        "body": "RPR_SetCurrentBPM(${1:ReaProject __proj},${2:Float bpm},${3:Boolean wantUndo})$0"
    },
    "SETCURSORCONTEXT c": {
        "prefix": "SetCursorContext",
        "scope": "c",
        "description": "You must use this to change the focus programmatically. mode=0 to focus\ntrack panels, 1 to focus the arrange window, 2 to focus the arrange\nwindow and select env (or env==NULL to clear the current track/take\nenvelope selection)\n",
        "body": "SetCursorContext(${1:int mode},${2:TrackEnvelope* envInOptional})$0"
    },
    "SETCURSORCONTEXT eel2": {
        "prefix": "SetCursorContext",
        "scope": "eel2",
        "description": "You must use this to change the focus programmatically. mode=0 to focus\ntrack panels, 1 to focus the arrange window, 2 to focus the arrange\nwindow and select env (or env==NULL to clear the current track/take\nenvelope selection)\n",
        "body": "SetCursorContext(${1:int mode},${2:TrackEnvelope envIn})$0"
    },
    "REAPER.SETCURSORCONTEXT lua": {
        "prefix": "reaper.SetCursorContext",
        "scope": "lua",
        "description": "You must use this to change the focus programmatically. mode=0 to focus\ntrack panels, 1 to focus the arrange window, 2 to focus the arrange\nwindow and select env (or env==NULL to clear the current track/take\nenvelope selection)\n",
        "body": "reaper.SetCursorContext(${1:integer mode},${2:TrackEnvelope envIn})$0"
    },
    "RPR_SETCURSORCONTEXT python": {
        "prefix": "RPR_SetCursorContext",
        "scope": "python",
        "description": "You must use this to change the focus programmatically. mode=0 to focus\ntrack panels, 1 to focus the arrange window, 2 to focus the arrange\nwindow and select env (or env==NULL to clear the current track/take\nenvelope selection)\n",
        "body": "RPR_SetCursorContext(${1:Int mode},${2:TrackEnvelope envInOptional})$0"
    },
    "SETEDITCURPOS c": {
        "prefix": "SetEditCurPos",
        "scope": "c",
        "description": "\n",
        "body": "SetEditCurPos(${1:double time},${2:bool moveview},${3:bool seekplay})$0"
    },
    "SETEDITCURPOS eel2": {
        "prefix": "SetEditCurPos",
        "scope": "eel2",
        "description": "\n",
        "body": "SetEditCurPos(${1:time},${2:bool moveview},${3:bool seekplay})$0"
    },
    "REAPER.SETEDITCURPOS lua": {
        "prefix": "reaper.SetEditCurPos",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetEditCurPos(${1:number time},${2:boolean moveview},${3:boolean seekplay})$0"
    },
    "RPR_SETEDITCURPOS python": {
        "prefix": "RPR_SetEditCurPos",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetEditCurPos(${1:Float time},${2:Boolean moveview},${3:Boolean seekplay})$0"
    },
    "SETEDITCURPOS2 c": {
        "prefix": "SetEditCurPos2",
        "scope": "c",
        "description": "\n",
        "body": "SetEditCurPos2(${1:ReaProject* proj},${2:double time},${3:bool moveview},${4:bool seekplay})$0"
    },
    "SETEDITCURPOS2 eel2": {
        "prefix": "SetEditCurPos2",
        "scope": "eel2",
        "description": "\n",
        "body": "SetEditCurPos2(${1:ReaProject proj},${2:time},${3:bool moveview},${4:bool seekplay})$0"
    },
    "REAPER.SETEDITCURPOS2 lua": {
        "prefix": "reaper.SetEditCurPos2",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetEditCurPos2(${1:ReaProject proj},${2:number time},${3:boolean moveview},${4:boolean seekplay})$0"
    },
    "RPR_SETEDITCURPOS2 python": {
        "prefix": "RPR_SetEditCurPos2",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetEditCurPos2(${1:ReaProject proj},${2:Float time},${3:Boolean moveview},${4:Boolean seekplay})$0"
    },
    "SETENVELOPEPOINT c": {
        "prefix": "SetEnvelopePoint",
        "scope": "c",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "SetEnvelopePoint(${1:TrackEnvelope* envelope},${2:int ptidx},${3:double* timeInOptional},${4:double* valueInOptional},${5:int* shapeInOptional},${6:double* tensionInOptional},${7:bool* selectedInOptional},${8:bool* noSortInOptional})$0"
    },
    "SETENVELOPEPOINT eel2": {
        "prefix": "SetEnvelopePoint",
        "scope": "eel2",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "SetEnvelopePoint(${1:TrackEnvelope envelope},${2:int ptidx},${3:optional timeIn},${4:optional valueIn},${5:optional int shapeIn},${6:optional tensionIn},${7:optional bool selectedIn},${8:optional bool noSortIn})$0"
    },
    "REAPER.SETENVELOPEPOINT lua": {
        "prefix": "reaper.SetEnvelopePoint",
        "scope": "lua",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "reaper.SetEnvelopePoint(${1:TrackEnvelope envelope},${2:integer ptidx},${3:optional number timeIn},${4:optional number valueIn},${5:optional number shapeIn},${6:optional number tensionIn},${7:optional boolean selectedIn},${8:optional boolean noSortIn})$0"
    },
    "RPR_SETENVELOPEPOINT python": {
        "prefix": "RPR_SetEnvelopePoint",
        "scope": "python",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "RPR_SetEnvelopePoint(${1:envelope},${2:ptidx},${3:timeInOptional},${4:valueInOptional},${5:shapeInOptional},${6:tensionInOptional},${7:selectedInOptional},${8:noSortInOptional})$0"
    },
    "SETENVELOPEPOINTEX c": {
        "prefix": "SetEnvelopePointEx",
        "scope": "c",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "SetEnvelopePointEx(${1:TrackEnvelope* envelope},${2:int autoitem_idx},${3:int ptidx},${4:double* timeInOptional},${5:double* valueInOptional},${6:int* shapeInOptional},${7:double* tensionInOptional},${8:bool* selectedInOptional},${9:bool* noSortInOptional})$0"
    },
    "SETENVELOPEPOINTEX eel2": {
        "prefix": "SetEnvelopePointEx",
        "scope": "eel2",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "SetEnvelopePointEx(${1:TrackEnvelope envelope},${2:int autoitem_idx},${3:int ptidx},${4:optional timeIn},${5:optional valueIn},${6:optional int shapeIn},${7:optional tensionIn},${8:optional bool selectedIn},${9:optional bool noSortIn})$0"
    },
    "REAPER.SETENVELOPEPOINTEX lua": {
        "prefix": "reaper.SetEnvelopePointEx",
        "scope": "lua",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "reaper.SetEnvelopePointEx(${1:TrackEnvelope envelope},${2:integer autoitem_idx},${3:integer ptidx},${4:optional number timeIn},${5:optional number valueIn},${6:optional number shapeIn},${7:optional number tensionIn},${8:optional boolean selectedIn},${9:optional boolean noSortIn})$0"
    },
    "RPR_SETENVELOPEPOINTEX python": {
        "prefix": "RPR_SetEnvelopePointEx",
        "scope": "python",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "RPR_SetEnvelopePointEx(${1:envelope},${2:autoitem_idx},${3:ptidx},${4:timeInOptional},${5:valueInOptional},${6:shapeInOptional},${7:tensionInOptional},${8:selectedInOptional},${9:noSortInOptional})$0"
    },
    "SETENVELOPESTATECHUNK c": {
        "prefix": "SetEnvelopeStateChunk",
        "scope": "c",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "SetEnvelopeStateChunk(${1:TrackEnvelope* env},${2:const char* str},${3:bool isundoOptional})$0"
    },
    "SETENVELOPESTATECHUNK eel2": {
        "prefix": "SetEnvelopeStateChunk",
        "scope": "eel2",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "SetEnvelopeStateChunk(${1:TrackEnvelope env},${2:\"str\"},${3:bool isundo})$0"
    },
    "REAPER.SETENVELOPESTATECHUNK lua": {
        "prefix": "reaper.SetEnvelopeStateChunk",
        "scope": "lua",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "reaper.SetEnvelopeStateChunk(${1:TrackEnvelope env},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_SETENVELOPESTATECHUNK python": {
        "prefix": "RPR_SetEnvelopeStateChunk",
        "scope": "python",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "RPR_SetEnvelopeStateChunk(${1:TrackEnvelope env},${2:String str},${3:Boolean isundoOptional})$0"
    },
    "SETEXTSTATE c": {
        "prefix": "SetExtState",
        "scope": "c",
        "description": "Set the extended state value for a specific section and key.\npersist=true means the value should be stored and reloaded the next time\nREAPER is opened. See GetExtState, DeleteExtState, HasExtState.\n",
        "body": "SetExtState(${1:const char* section},${2:const char* key},${3:const char* value},${4:bool persist})$0"
    },
    "SETEXTSTATE eel2": {
        "prefix": "SetExtState",
        "scope": "eel2",
        "description": "Set the extended state value for a specific section and key.\npersist=true means the value should be stored and reloaded the next time\nREAPER is opened. See GetExtState, DeleteExtState, HasExtState.\n",
        "body": "SetExtState(${1:\"section\"},${2:\"key\"},${3:\"value\"},${4:bool persist})$0"
    },
    "REAPER.SETEXTSTATE lua": {
        "prefix": "reaper.SetExtState",
        "scope": "lua",
        "description": "Set the extended state value for a specific section and key.\npersist=true means the value should be stored and reloaded the next time\nREAPER is opened. See GetExtState, DeleteExtState, HasExtState.\n",
        "body": "reaper.SetExtState(${1:string section},${2:string key},${3:string value},${4:boolean persist})$0"
    },
    "RPR_SETEXTSTATE python": {
        "prefix": "RPR_SetExtState",
        "scope": "python",
        "description": "Set the extended state value for a specific section and key.\npersist=true means the value should be stored and reloaded the next time\nREAPER is opened. See GetExtState, DeleteExtState, HasExtState.\n",
        "body": "RPR_SetExtState(${1:String section},${2:String key},${3:String value},${4:Boolean persist})$0"
    },
    "SETGLOBALAUTOMATIONOVERRIDE c": {
        "prefix": "SetGlobalAutomationOverride",
        "scope": "c",
        "description": "mode: see GetGlobalAutomationOverride\n",
        "body": "SetGlobalAutomationOverride(${1:int mode})$0"
    },
    "SETGLOBALAUTOMATIONOVERRIDE eel2": {
        "prefix": "SetGlobalAutomationOverride",
        "scope": "eel2",
        "description": "mode: see GetGlobalAutomationOverride\n",
        "body": "SetGlobalAutomationOverride(${1:int mode})$0"
    },
    "REAPER.SETGLOBALAUTOMATIONOVERRIDE lua": {
        "prefix": "reaper.SetGlobalAutomationOverride",
        "scope": "lua",
        "description": "mode: see GetGlobalAutomationOverride\n",
        "body": "reaper.SetGlobalAutomationOverride(${1:integer mode})$0"
    },
    "RPR_SETGLOBALAUTOMATIONOVERRIDE python": {
        "prefix": "RPR_SetGlobalAutomationOverride",
        "scope": "python",
        "description": "mode: see GetGlobalAutomationOverride\n",
        "body": "RPR_SetGlobalAutomationOverride(${1:Int mode})$0"
    },
    "SETITEMSTATECHUNK c": {
        "prefix": "SetItemStateChunk",
        "scope": "c",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "SetItemStateChunk(${1:MediaItem* item},${2:const char* str},${3:bool isundoOptional})$0"
    },
    "SETITEMSTATECHUNK eel2": {
        "prefix": "SetItemStateChunk",
        "scope": "eel2",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "SetItemStateChunk(${1:MediaItem item},${2:\"str\"},${3:bool isundo})$0"
    },
    "REAPER.SETITEMSTATECHUNK lua": {
        "prefix": "reaper.SetItemStateChunk",
        "scope": "lua",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "reaper.SetItemStateChunk(${1:MediaItem item},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_SETITEMSTATECHUNK python": {
        "prefix": "RPR_SetItemStateChunk",
        "scope": "python",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "RPR_SetItemStateChunk(${1:MediaItem item},${2:String str},${3:Boolean isundoOptional})$0"
    },
    "SETMASTERTRACKVISIBILITY c": {
        "prefix": "SetMasterTrackVisibility",
        "scope": "c",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "SetMasterTrackVisibility(${1:int flag})$0"
    },
    "SETMASTERTRACKVISIBILITY eel2": {
        "prefix": "SetMasterTrackVisibility",
        "scope": "eel2",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "SetMasterTrackVisibility(${1:int flag})$0"
    },
    "REAPER.SETMASTERTRACKVISIBILITY lua": {
        "prefix": "reaper.SetMasterTrackVisibility",
        "scope": "lua",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "reaper.SetMasterTrackVisibility(${1:integer flag})$0"
    },
    "RPR_SETMASTERTRACKVISIBILITY python": {
        "prefix": "RPR_SetMasterTrackVisibility",
        "scope": "python",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "RPR_SetMasterTrackVisibility(${1:Int flag})$0"
    },
    "SETMEDIAITEMINFO_VALUE c": {
        "prefix": "SetMediaItemInfo_Value",
        "scope": "c",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "SetMediaItemInfo_Value(${1:MediaItem* item},${2|const char* parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\"|},${3:double newvalue})$0"
    },
    "SETMEDIAITEMINFO_VALUE eel2": {
        "prefix": "SetMediaItemInfo_Value",
        "scope": "eel2",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "SetMediaItemInfo_Value(${1:MediaItem item},${2:\"parmname\"},${3:newvalue})$0"
    },
    "REAPER.SETMEDIAITEMINFO_VALUE lua": {
        "prefix": "reaper.SetMediaItemInfo_Value",
        "scope": "lua",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "reaper.SetMediaItemInfo_Value(${1:MediaItem item},${2|string parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\"|},${3:number newvalue})$0"
    },
    "RPR_SETMEDIAITEMINFO_VALUE python": {
        "prefix": "RPR_SetMediaItemInfo_Value",
        "scope": "python",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "RPR_SetMediaItemInfo_Value(${1:MediaItem item},${2|String parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\"|},${3:Float newvalue})$0"
    },
    "SETMEDIAITEMLENGTH c": {
        "prefix": "SetMediaItemLength",
        "scope": "c",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "SetMediaItemLength(${1:MediaItem* item},${2:double length},${3:bool refreshUI})$0"
    },
    "SETMEDIAITEMLENGTH eel2": {
        "prefix": "SetMediaItemLength",
        "scope": "eel2",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "SetMediaItemLength(${1:MediaItem item},${2:length},${3:bool refreshUI})$0"
    },
    "REAPER.SETMEDIAITEMLENGTH lua": {
        "prefix": "reaper.SetMediaItemLength",
        "scope": "lua",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "reaper.SetMediaItemLength(${1:MediaItem item},${2:number length},${3:boolean refreshUI})$0"
    },
    "RPR_SETMEDIAITEMLENGTH python": {
        "prefix": "RPR_SetMediaItemLength",
        "scope": "python",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "RPR_SetMediaItemLength(${1:MediaItem item},${2:Float length},${3:Boolean refreshUI})$0"
    },
    "SETMEDIAITEMPOSITION c": {
        "prefix": "SetMediaItemPosition",
        "scope": "c",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "SetMediaItemPosition(${1:MediaItem* item},${2:double position},${3:bool refreshUI})$0"
    },
    "SETMEDIAITEMPOSITION eel2": {
        "prefix": "SetMediaItemPosition",
        "scope": "eel2",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "SetMediaItemPosition(${1:MediaItem item},${2:position},${3:bool refreshUI})$0"
    },
    "REAPER.SETMEDIAITEMPOSITION lua": {
        "prefix": "reaper.SetMediaItemPosition",
        "scope": "lua",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "reaper.SetMediaItemPosition(${1:MediaItem item},${2:number position},${3:boolean refreshUI})$0"
    },
    "RPR_SETMEDIAITEMPOSITION python": {
        "prefix": "RPR_SetMediaItemPosition",
        "scope": "python",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "RPR_SetMediaItemPosition(${1:MediaItem item},${2:Float position},${3:Boolean refreshUI})$0"
    },
    "SETMEDIAITEMSELECTED c": {
        "prefix": "SetMediaItemSelected",
        "scope": "c",
        "description": "\n",
        "body": "SetMediaItemSelected(${1:MediaItem* item},${2:bool selected})$0"
    },
    "SETMEDIAITEMSELECTED eel2": {
        "prefix": "SetMediaItemSelected",
        "scope": "eel2",
        "description": "\n",
        "body": "SetMediaItemSelected(${1:MediaItem item},${2:bool selected})$0"
    },
    "REAPER.SETMEDIAITEMSELECTED lua": {
        "prefix": "reaper.SetMediaItemSelected",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetMediaItemSelected(${1:MediaItem item},${2:boolean selected})$0"
    },
    "RPR_SETMEDIAITEMSELECTED python": {
        "prefix": "RPR_SetMediaItemSelected",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetMediaItemSelected(${1:MediaItem item},${2:Boolean selected})$0"
    },
    "SETMEDIAITEMTAKE_SOURCE c": {
        "prefix": "SetMediaItemTake_Source",
        "scope": "c",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "SetMediaItemTake_Source(${1:MediaItem_Take* take},${2:PCM_source* source})$0"
    },
    "SETMEDIAITEMTAKE_SOURCE eel2": {
        "prefix": "SetMediaItemTake_Source",
        "scope": "eel2",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "SetMediaItemTake_Source(${1:MediaItem_Take take},${2:PCM_source source})$0"
    },
    "REAPER.SETMEDIAITEMTAKE_SOURCE lua": {
        "prefix": "reaper.SetMediaItemTake_Source",
        "scope": "lua",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "reaper.SetMediaItemTake_Source(${1:MediaItem_Take take},${2:PCM_source source})$0"
    },
    "RPR_SETMEDIAITEMTAKE_SOURCE python": {
        "prefix": "RPR_SetMediaItemTake_Source",
        "scope": "python",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "RPR_SetMediaItemTake_Source(${1:MediaItem_Take take},${2:PCM_source source})$0"
    },
    "SETMEDIAITEMTAKEINFO_VALUE c": {
        "prefix": "SetMediaItemTakeInfo_Value",
        "scope": "c",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "SetMediaItemTakeInfo_Value(${1:MediaItem_Take* take},${2|const char* parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\"|},${3:double newvalue})$0"
    },
    "SETMEDIAITEMTAKEINFO_VALUE eel2": {
        "prefix": "SetMediaItemTakeInfo_Value",
        "scope": "eel2",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "SetMediaItemTakeInfo_Value(${1:MediaItem_Take take},${2:\"parmname\"},${3:newvalue})$0"
    },
    "REAPER.SETMEDIAITEMTAKEINFO_VALUE lua": {
        "prefix": "reaper.SetMediaItemTakeInfo_Value",
        "scope": "lua",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "reaper.SetMediaItemTakeInfo_Value(${1:MediaItem_Take take},${2|string parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\"|},${3:number newvalue})$0"
    },
    "RPR_SETMEDIAITEMTAKEINFO_VALUE python": {
        "prefix": "RPR_SetMediaItemTakeInfo_Value",
        "scope": "python",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "RPR_SetMediaItemTakeInfo_Value(${1:MediaItem_Take take},${2|String parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\"|},${3:Float newvalue})$0"
    },
    "SETMEDIATRACKINFO_VALUE c": {
        "prefix": "SetMediaTrackInfo_Value",
        "scope": "c",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "SetMediaTrackInfo_Value(${1:MediaTrack* tr},${2|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\"|},${3:double newvalue})$0"
    },
    "SETMEDIATRACKINFO_VALUE eel2": {
        "prefix": "SetMediaTrackInfo_Value",
        "scope": "eel2",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "SetMediaTrackInfo_Value(${1:MediaTrack tr},${2:\"parmname\"},${3:newvalue})$0"
    },
    "REAPER.SETMEDIATRACKINFO_VALUE lua": {
        "prefix": "reaper.SetMediaTrackInfo_Value",
        "scope": "lua",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "reaper.SetMediaTrackInfo_Value(${1:MediaTrack tr},${2|string parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\"|},${3:number newvalue})$0"
    },
    "RPR_SETMEDIATRACKINFO_VALUE python": {
        "prefix": "RPR_SetMediaTrackInfo_Value",
        "scope": "python",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "RPR_SetMediaTrackInfo_Value(${1:MediaTrack tr},${2|String parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\"|},${3:Float newvalue})$0"
    },
    "SETMIDIEDITORGRID c": {
        "prefix": "SetMIDIEditorGrid",
        "scope": "c",
        "description": "Set the MIDI editor grid division. 0.25=quarter note, 1.0/3.0=half note tripet, etc.\n",
        "body": "SetMIDIEditorGrid(${1:ReaProject* project},${2:double division})$0"
    },
    "SETMIDIEDITORGRID eel2": {
        "prefix": "SetMIDIEditorGrid",
        "scope": "eel2",
        "description": "Set the MIDI editor grid division. 0.25=quarter note, 1.0/3.0=half note tripet, etc.\n",
        "body": "SetMIDIEditorGrid(${1:ReaProject project},${2:division})$0"
    },
    "REAPER.SETMIDIEDITORGRID lua": {
        "prefix": "reaper.SetMIDIEditorGrid",
        "scope": "lua",
        "description": "Set the MIDI editor grid division. 0.25=quarter note, 1.0/3.0=half note tripet, etc.\n",
        "body": "reaper.SetMIDIEditorGrid(${1:ReaProject project},${2:number division})$0"
    },
    "RPR_SETMIDIEDITORGRID python": {
        "prefix": "RPR_SetMIDIEditorGrid",
        "scope": "python",
        "description": "Set the MIDI editor grid division. 0.25=quarter note, 1.0/3.0=half note tripet, etc.\n",
        "body": "RPR_SetMIDIEditorGrid(${1:ReaProject project},${2:Float division})$0"
    },
    "SETMIXERSCROLL c": {
        "prefix": "SetMixerScroll",
        "scope": "c",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "SetMixerScroll(${1:MediaTrack* leftmosttrack})$0"
    },
    "SETMIXERSCROLL eel2": {
        "prefix": "SetMixerScroll",
        "scope": "eel2",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "SetMixerScroll(${1:MediaTrack leftmosttrack})$0"
    },
    "REAPER.SETMIXERSCROLL lua": {
        "prefix": "reaper.SetMixerScroll",
        "scope": "lua",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "reaper.SetMixerScroll(${1:MediaTrack leftmosttrack})$0"
    },
    "RPR_SETMIXERSCROLL python": {
        "prefix": "RPR_SetMixerScroll",
        "scope": "python",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "RPR_SetMixerScroll(${1:MediaTrack leftmosttrack})$0"
    },
    "SETMOUSEMODIFIER c": {
        "prefix": "SetMouseModifier",
        "scope": "c",
        "description": "Set the mouse modifier assignment for a specific modifier key assignment, in a specific context.\nContext is a string like \"MM_CTX_ITEM\". Find these strings by modifying an assignment in\nPreferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nModifier flag is a number from 0 to 15: add 1 for shift, 2 for control, 4 for alt, 8 for win.\n(macOS: add 1 for shift, 2 for command, 4 for opt, 8 for control.)\nFor left-click and double-click contexts, the action can be any built-in command ID number\nor any custom action ID string. Find built-in command IDs in the REAPER actions window\n(enable \"show action IDs\" in the context menu), and find custom action ID strings in reaper-kb.ini.\nFor built-in mouse modifier behaviors, find action IDs (which will be low numbers)\nby modifying an assignment in Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nAssigning an action of -1 will reset that mouse modifier behavior to factory default.\nSee GetMouseModifier.\n",
        "body": "SetMouseModifier(${1:const char* context},${2:int modifier_flag},${3:const char* action})$0"
    },
    "SETMOUSEMODIFIER eel2": {
        "prefix": "SetMouseModifier",
        "scope": "eel2",
        "description": "Set the mouse modifier assignment for a specific modifier key assignment, in a specific context.\nContext is a string like \"MM_CTX_ITEM\". Find these strings by modifying an assignment in\nPreferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nModifier flag is a number from 0 to 15: add 1 for shift, 2 for control, 4 for alt, 8 for win.\n(macOS: add 1 for shift, 2 for command, 4 for opt, 8 for control.)\nFor left-click and double-click contexts, the action can be any built-in command ID number\nor any custom action ID string. Find built-in command IDs in the REAPER actions window\n(enable \"show action IDs\" in the context menu), and find custom action ID strings in reaper-kb.ini.\nFor built-in mouse modifier behaviors, find action IDs (which will be low numbers)\nby modifying an assignment in Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nAssigning an action of -1 will reset that mouse modifier behavior to factory default.\nSee GetMouseModifier.\n",
        "body": "SetMouseModifier(${1:\"context\"},${2:int modifier_flag},${3:\"action\"})$0"
    },
    "REAPER.SETMOUSEMODIFIER lua": {
        "prefix": "reaper.SetMouseModifier",
        "scope": "lua",
        "description": "Set the mouse modifier assignment for a specific modifier key assignment, in a specific context.\nContext is a string like \"MM_CTX_ITEM\". Find these strings by modifying an assignment in\nPreferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nModifier flag is a number from 0 to 15: add 1 for shift, 2 for control, 4 for alt, 8 for win.\n(macOS: add 1 for shift, 2 for command, 4 for opt, 8 for control.)\nFor left-click and double-click contexts, the action can be any built-in command ID number\nor any custom action ID string. Find built-in command IDs in the REAPER actions window\n(enable \"show action IDs\" in the context menu), and find custom action ID strings in reaper-kb.ini.\nFor built-in mouse modifier behaviors, find action IDs (which will be low numbers)\nby modifying an assignment in Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nAssigning an action of -1 will reset that mouse modifier behavior to factory default.\nSee GetMouseModifier.\n",
        "body": "reaper.SetMouseModifier(${1:string context},${2:integer modifier_flag},${3:string action})$0"
    },
    "RPR_SETMOUSEMODIFIER python": {
        "prefix": "RPR_SetMouseModifier",
        "scope": "python",
        "description": "Set the mouse modifier assignment for a specific modifier key assignment, in a specific context.\nContext is a string like \"MM_CTX_ITEM\". Find these strings by modifying an assignment in\nPreferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nModifier flag is a number from 0 to 15: add 1 for shift, 2 for control, 4 for alt, 8 for win.\n(macOS: add 1 for shift, 2 for command, 4 for opt, 8 for control.)\nFor left-click and double-click contexts, the action can be any built-in command ID number\nor any custom action ID string. Find built-in command IDs in the REAPER actions window\n(enable \"show action IDs\" in the context menu), and find custom action ID strings in reaper-kb.ini.\nFor built-in mouse modifier behaviors, find action IDs (which will be low numbers)\nby modifying an assignment in Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nAssigning an action of -1 will reset that mouse modifier behavior to factory default.\nSee GetMouseModifier.\n",
        "body": "RPR_SetMouseModifier(${1:String context},${2:Int modifier_flag},${3:String action})$0"
    },
    "SETONLYTRACKSELECTED c": {
        "prefix": "SetOnlyTrackSelected",
        "scope": "c",
        "description": "Set exactly one track selected, deselect all others\n",
        "body": "SetOnlyTrackSelected(${1:MediaTrack* track})$0"
    },
    "SETONLYTRACKSELECTED eel2": {
        "prefix": "SetOnlyTrackSelected",
        "scope": "eel2",
        "description": "Set exactly one track selected, deselect all others\n",
        "body": "SetOnlyTrackSelected(${1:MediaTrack track})$0"
    },
    "REAPER.SETONLYTRACKSELECTED lua": {
        "prefix": "reaper.SetOnlyTrackSelected",
        "scope": "lua",
        "description": "Set exactly one track selected, deselect all others\n",
        "body": "reaper.SetOnlyTrackSelected(${1:MediaTrack track})$0"
    },
    "RPR_SETONLYTRACKSELECTED python": {
        "prefix": "RPR_SetOnlyTrackSelected",
        "scope": "python",
        "description": "Set exactly one track selected, deselect all others\n",
        "body": "RPR_SetOnlyTrackSelected(${1:MediaTrack track})$0"
    },
    "SETPROJECTGRID c": {
        "prefix": "SetProjectGrid",
        "scope": "c",
        "description": "Set the arrange view grid division. 0.25=quarter note, 1.0/3.0=half note triplet, etc.\n",
        "body": "SetProjectGrid(${1:ReaProject* project},${2:double division})$0"
    },
    "SETPROJECTGRID eel2": {
        "prefix": "SetProjectGrid",
        "scope": "eel2",
        "description": "Set the arrange view grid division. 0.25=quarter note, 1.0/3.0=half note triplet, etc.\n",
        "body": "SetProjectGrid(${1:ReaProject project},${2:division})$0"
    },
    "REAPER.SETPROJECTGRID lua": {
        "prefix": "reaper.SetProjectGrid",
        "scope": "lua",
        "description": "Set the arrange view grid division. 0.25=quarter note, 1.0/3.0=half note triplet, etc.\n",
        "body": "reaper.SetProjectGrid(${1:ReaProject project},${2:number division})$0"
    },
    "RPR_SETPROJECTGRID python": {
        "prefix": "RPR_SetProjectGrid",
        "scope": "python",
        "description": "Set the arrange view grid division. 0.25=quarter note, 1.0/3.0=half note triplet, etc.\n",
        "body": "RPR_SetProjectGrid(${1:ReaProject project},${2:Float division})$0"
    },
    "SETPROJECTMARKER c": {
        "prefix": "SetProjectMarker",
        "scope": "c",
        "description": "\n",
        "body": "SetProjectMarker(${1:int markrgnindexnumber},${2:bool isrgn},${3:double pos},${4:double rgnend},${5:const char* name})$0"
    },
    "SETPROJECTMARKER eel2": {
        "prefix": "SetProjectMarker",
        "scope": "eel2",
        "description": "\n",
        "body": "SetProjectMarker(${1:int markrgnindexnumber},${2:bool isrgn},${3:pos},${4:rgnend},${5:\"name\"})$0"
    },
    "REAPER.SETPROJECTMARKER lua": {
        "prefix": "reaper.SetProjectMarker",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetProjectMarker(${1:integer markrgnindexnumber},${2:boolean isrgn},${3:number pos},${4:number rgnend},${5:string name})$0"
    },
    "RPR_SETPROJECTMARKER python": {
        "prefix": "RPR_SetProjectMarker",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetProjectMarker(${1:Int markrgnindexnumber},${2:Boolean isrgn},${3:Float pos},${4:Float rgnend},${5:String name})$0"
    },
    "SETPROJECTMARKER2 c": {
        "prefix": "SetProjectMarker2",
        "scope": "c",
        "description": "\n",
        "body": "SetProjectMarker2(${1:ReaProject* proj},${2:int markrgnindexnumber},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:const char* name})$0"
    },
    "SETPROJECTMARKER2 eel2": {
        "prefix": "SetProjectMarker2",
        "scope": "eel2",
        "description": "\n",
        "body": "SetProjectMarker2(${1:ReaProject proj},${2:int markrgnindexnumber},${3:bool isrgn},${4:pos},${5:rgnend},${6:\"name\"})$0"
    },
    "REAPER.SETPROJECTMARKER2 lua": {
        "prefix": "reaper.SetProjectMarker2",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetProjectMarker2(${1:ReaProject proj},${2:integer markrgnindexnumber},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:string name})$0"
    },
    "RPR_SETPROJECTMARKER2 python": {
        "prefix": "RPR_SetProjectMarker2",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetProjectMarker2(${1:ReaProject proj},${2:Int markrgnindexnumber},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:String name})$0"
    },
    "SETPROJECTMARKER3 c": {
        "prefix": "SetProjectMarker3",
        "scope": "c",
        "description": "\n",
        "body": "SetProjectMarker3(${1:ReaProject* proj},${2:int markrgnindexnumber},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:const char* name},${7:int color})$0"
    },
    "SETPROJECTMARKER3 eel2": {
        "prefix": "SetProjectMarker3",
        "scope": "eel2",
        "description": "\n",
        "body": "SetProjectMarker3(${1:ReaProject proj},${2:int markrgnindexnumber},${3:bool isrgn},${4:pos},${5:rgnend},${6:\"name\"},${7:int color})$0"
    },
    "REAPER.SETPROJECTMARKER3 lua": {
        "prefix": "reaper.SetProjectMarker3",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetProjectMarker3(${1:ReaProject proj},${2:integer markrgnindexnumber},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:string name},${7:integer color})$0"
    },
    "RPR_SETPROJECTMARKER3 python": {
        "prefix": "RPR_SetProjectMarker3",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetProjectMarker3(${1:ReaProject proj},${2:Int markrgnindexnumber},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:String name},${7:Int color})$0"
    },
    "SETPROJECTMARKER4 c": {
        "prefix": "SetProjectMarker4",
        "scope": "c",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "SetProjectMarker4(${1:ReaProject* proj},${2:int markrgnindexnumber},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:const char* name},${7:int color},${8:int flags})$0"
    },
    "SETPROJECTMARKER4 eel2": {
        "prefix": "SetProjectMarker4",
        "scope": "eel2",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "SetProjectMarker4(${1:ReaProject proj},${2:int markrgnindexnumber},${3:bool isrgn},${4:pos},${5:rgnend},${6:\"name\"},${7:int color},${8:int flags})$0"
    },
    "REAPER.SETPROJECTMARKER4 lua": {
        "prefix": "reaper.SetProjectMarker4",
        "scope": "lua",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "reaper.SetProjectMarker4(${1:ReaProject proj},${2:integer markrgnindexnumber},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:string name},${7:integer color},${8:integer flags})$0"
    },
    "RPR_SETPROJECTMARKER4 python": {
        "prefix": "RPR_SetProjectMarker4",
        "scope": "python",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "RPR_SetProjectMarker4(${1:ReaProject proj},${2:Int markrgnindexnumber},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:String name},${7:Int color},${8:Int flags})$0"
    },
    "SETPROJECTMARKERBYINDEX c": {
        "prefix": "SetProjectMarkerByIndex",
        "scope": "c",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "SetProjectMarkerByIndex(${1:ReaProject* proj},${2:int markrgnidx},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:int IDnumber},${7:const char* name},${8:int color})$0"
    },
    "SETPROJECTMARKERBYINDEX eel2": {
        "prefix": "SetProjectMarkerByIndex",
        "scope": "eel2",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "SetProjectMarkerByIndex(${1:ReaProject proj},${2:int markrgnidx},${3:bool isrgn},${4:pos},${5:rgnend},${6:int IDnumber},${7:\"name\"},${8:int color})$0"
    },
    "REAPER.SETPROJECTMARKERBYINDEX lua": {
        "prefix": "reaper.SetProjectMarkerByIndex",
        "scope": "lua",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "reaper.SetProjectMarkerByIndex(${1:ReaProject proj},${2:integer markrgnidx},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:integer IDnumber},${7:string name},${8:integer color})$0"
    },
    "RPR_SETPROJECTMARKERBYINDEX python": {
        "prefix": "RPR_SetProjectMarkerByIndex",
        "scope": "python",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "RPR_SetProjectMarkerByIndex(${1:ReaProject proj},${2:Int markrgnidx},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:Int IDnumber},${7:String name},${8:Int color})$0"
    },
    "SETPROJECTMARKERBYINDEX2 c": {
        "prefix": "SetProjectMarkerByIndex2",
        "scope": "c",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "SetProjectMarkerByIndex2(${1:ReaProject* proj},${2:int markrgnidx},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:int IDnumber},${7:const char* name},${8:int color},${9:int flags})$0"
    },
    "SETPROJECTMARKERBYINDEX2 eel2": {
        "prefix": "SetProjectMarkerByIndex2",
        "scope": "eel2",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "SetProjectMarkerByIndex2(${1:ReaProject proj},${2:int markrgnidx},${3:bool isrgn},${4:pos},${5:rgnend},${6:int IDnumber},${7:\"name\"},${8:int color},${9:int flags})$0"
    },
    "REAPER.SETPROJECTMARKERBYINDEX2 lua": {
        "prefix": "reaper.SetProjectMarkerByIndex2",
        "scope": "lua",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "reaper.SetProjectMarkerByIndex2(${1:ReaProject proj},${2:integer markrgnidx},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:integer IDnumber},${7:string name},${8:integer color},${9:integer flags})$0"
    },
    "RPR_SETPROJECTMARKERBYINDEX2 python": {
        "prefix": "RPR_SetProjectMarkerByIndex2",
        "scope": "python",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "RPR_SetProjectMarkerByIndex2(${1:ReaProject proj},${2:Int markrgnidx},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:Int IDnumber},${7:String name},${8:Int color},${9:Int flags})$0"
    },
    "SETPROJEXTSTATE c": {
        "prefix": "SetProjExtState",
        "scope": "c",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "SetProjExtState(${1:ReaProject* proj},${2:const char* extname},${3:const char* key},${4:const char* value})$0"
    },
    "SETPROJEXTSTATE eel2": {
        "prefix": "SetProjExtState",
        "scope": "eel2",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "SetProjExtState(${1:ReaProject proj},${2:\"extname\"},${3:\"key\"},${4:\"value\"})$0"
    },
    "REAPER.SETPROJEXTSTATE lua": {
        "prefix": "reaper.SetProjExtState",
        "scope": "lua",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "reaper.SetProjExtState(${1:ReaProject proj},${2:string extname},${3:string key},${4:string value})$0"
    },
    "RPR_SETPROJEXTSTATE python": {
        "prefix": "RPR_SetProjExtState",
        "scope": "python",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "RPR_SetProjExtState(${1:ReaProject proj},${2:String extname},${3:String key},${4:String value})$0"
    },
    "SETREGIONRENDERMATRIX c": {
        "prefix": "SetRegionRenderMatrix",
        "scope": "c",
        "description": "Add (addorremove > 0) or remove (addorremove < 0) a track from this region when using the region render matrix.\n",
        "body": "SetRegionRenderMatrix(${1:ReaProject* proj},${2:int regionindex},${3:MediaTrack* track},${4:int addorremove})$0"
    },
    "SETREGIONRENDERMATRIX eel2": {
        "prefix": "SetRegionRenderMatrix",
        "scope": "eel2",
        "description": "Add (addorremove > 0) or remove (addorremove < 0) a track from this region when using the region render matrix.\n",
        "body": "SetRegionRenderMatrix(${1:ReaProject proj},${2:int regionindex},${3:MediaTrack track},${4:int addorremove})$0"
    },
    "REAPER.SETREGIONRENDERMATRIX lua": {
        "prefix": "reaper.SetRegionRenderMatrix",
        "scope": "lua",
        "description": "Add (addorremove > 0) or remove (addorremove < 0) a track from this region when using the region render matrix.\n",
        "body": "reaper.SetRegionRenderMatrix(${1:ReaProject proj},${2:integer regionindex},${3:MediaTrack track},${4:integer addorremove})$0"
    },
    "RPR_SETREGIONRENDERMATRIX python": {
        "prefix": "RPR_SetRegionRenderMatrix",
        "scope": "python",
        "description": "Add (addorremove > 0) or remove (addorremove < 0) a track from this region when using the region render matrix.\n",
        "body": "RPR_SetRegionRenderMatrix(${1:ReaProject proj},${2:Int regionindex},${3:MediaTrack track},${4:Int addorremove})$0"
    },
    "SETTAKESTRETCHMARKER c": {
        "prefix": "SetTakeStretchMarker",
        "scope": "c",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "SetTakeStretchMarker(${1:MediaItem_Take* take},${2:int idx},${3:double pos},${4:const double* srcposInOptional})$0"
    },
    "SETTAKESTRETCHMARKER eel2": {
        "prefix": "SetTakeStretchMarker",
        "scope": "eel2",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "SetTakeStretchMarker(${1:MediaItem_Take take},${2:int idx},${3:pos},${4:optional srcposIn})$0"
    },
    "REAPER.SETTAKESTRETCHMARKER lua": {
        "prefix": "reaper.SetTakeStretchMarker",
        "scope": "lua",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "reaper.SetTakeStretchMarker(${1:MediaItem_Take take},${2:integer idx},${3:number pos},${4:optional number srcposIn})$0"
    },
    "RPR_SETTAKESTRETCHMARKER python": {
        "prefix": "RPR_SetTakeStretchMarker",
        "scope": "python",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "RPR_SetTakeStretchMarker(${1:MediaItem_Take take},${2:Int idx},${3:Float pos},${4:const double srcposInOptional})$0"
    },
    "SETTAKESTRETCHMARKERSLOPE c": {
        "prefix": "SetTakeStretchMarkerSlope",
        "scope": "c",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "SetTakeStretchMarkerSlope(${1:MediaItem_Take* take},${2:int idx},${3:double slope})$0"
    },
    "SETTAKESTRETCHMARKERSLOPE eel2": {
        "prefix": "SetTakeStretchMarkerSlope",
        "scope": "eel2",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "SetTakeStretchMarkerSlope(${1:MediaItem_Take take},${2:int idx},${3:slope})$0"
    },
    "REAPER.SETTAKESTRETCHMARKERSLOPE lua": {
        "prefix": "reaper.SetTakeStretchMarkerSlope",
        "scope": "lua",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "reaper.SetTakeStretchMarkerSlope(${1:MediaItem_Take take},${2:integer idx},${3:number slope})$0"
    },
    "RPR_SETTAKESTRETCHMARKERSLOPE python": {
        "prefix": "RPR_SetTakeStretchMarkerSlope",
        "scope": "python",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "RPR_SetTakeStretchMarkerSlope(${1:MediaItem_Take take},${2:Int idx},${3:Float slope})$0"
    },
    "SETTEMPOTIMESIGMARKER c": {
        "prefix": "SetTempoTimeSigMarker",
        "scope": "c",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "SetTempoTimeSigMarker(${1:ReaProject* proj},${2:int ptidx},${3:double timepos},${4:int measurepos},${5:double beatpos},${6:double bpm},${7:int timesig_num},${8:int timesig_denom},${9:bool lineartempo})$0"
    },
    "SETTEMPOTIMESIGMARKER eel2": {
        "prefix": "SetTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "SetTempoTimeSigMarker(${1:ReaProject proj},${2:int ptidx},${3:timepos},${4:int measurepos},${5:beatpos},${6:bpm},${7:int timesig_num},${8:int timesig_denom},${9:bool lineartempo})$0"
    },
    "REAPER.SETTEMPOTIMESIGMARKER lua": {
        "prefix": "reaper.SetTempoTimeSigMarker",
        "scope": "lua",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "reaper.SetTempoTimeSigMarker(${1:ReaProject proj},${2:integer ptidx},${3:number timepos},${4:integer measurepos},${5:number beatpos},${6:number bpm},${7:integer timesig_num},${8:integer timesig_denom},${9:boolean lineartempo})$0"
    },
    "RPR_SETTEMPOTIMESIGMARKER python": {
        "prefix": "RPR_SetTempoTimeSigMarker",
        "scope": "python",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "RPR_SetTempoTimeSigMarker(${1:ReaProject proj},${2:Int ptidx},${3:Float timepos},${4:Int measurepos},${5:Float beatpos},${6:Float bpm},${7:Int timesig_num},${8:Int timesig_denom},${9:Boolean lineartempo})$0"
    },
    "SETTOGGLECOMMANDSTATE c": {
        "prefix": "SetToggleCommandState",
        "scope": "c",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "SetToggleCommandState(${1:int section_id},${2:int command_id},${3:int state})$0"
    },
    "SETTOGGLECOMMANDSTATE eel2": {
        "prefix": "SetToggleCommandState",
        "scope": "eel2",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "SetToggleCommandState(${1:int section_id},${2:int command_id},${3:int state})$0"
    },
    "REAPER.SETTOGGLECOMMANDSTATE lua": {
        "prefix": "reaper.SetToggleCommandState",
        "scope": "lua",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "reaper.SetToggleCommandState(${1:integer section_id},${2:integer command_id},${3:integer state})$0"
    },
    "RPR_SETTOGGLECOMMANDSTATE python": {
        "prefix": "RPR_SetToggleCommandState",
        "scope": "python",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "RPR_SetToggleCommandState(${1:Int section_id},${2:Int command_id},${3:Int state})$0"
    },
    "SETTRACKAUTOMATIONMODE c": {
        "prefix": "SetTrackAutomationMode",
        "scope": "c",
        "description": "\n",
        "body": "SetTrackAutomationMode(${1:MediaTrack* tr},${2:int mode})$0"
    },
    "SETTRACKAUTOMATIONMODE eel2": {
        "prefix": "SetTrackAutomationMode",
        "scope": "eel2",
        "description": "\n",
        "body": "SetTrackAutomationMode(${1:MediaTrack tr},${2:int mode})$0"
    },
    "REAPER.SETTRACKAUTOMATIONMODE lua": {
        "prefix": "reaper.SetTrackAutomationMode",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetTrackAutomationMode(${1:MediaTrack tr},${2:integer mode})$0"
    },
    "RPR_SETTRACKAUTOMATIONMODE python": {
        "prefix": "RPR_SetTrackAutomationMode",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetTrackAutomationMode(${1:MediaTrack tr},${2:Int mode})$0"
    },
    "SETTRACKCOLOR c": {
        "prefix": "SetTrackColor",
        "scope": "c",
        "description": "Set the custom track color, color is OS dependent (i.e. ColorToNative(r,g,b).\n",
        "body": "SetTrackColor(${1:MediaTrack* track},${2:int color})$0"
    },
    "SETTRACKCOLOR eel2": {
        "prefix": "SetTrackColor",
        "scope": "eel2",
        "description": "Set the custom track color, color is OS dependent (i.e. ColorToNative(r,g,b).\n",
        "body": "SetTrackColor(${1:MediaTrack track},${2:int color})$0"
    },
    "REAPER.SETTRACKCOLOR lua": {
        "prefix": "reaper.SetTrackColor",
        "scope": "lua",
        "description": "Set the custom track color, color is OS dependent (i.e. ColorToNative(r,g,b).\n",
        "body": "reaper.SetTrackColor(${1:MediaTrack track},${2:integer color})$0"
    },
    "RPR_SETTRACKCOLOR python": {
        "prefix": "RPR_SetTrackColor",
        "scope": "python",
        "description": "Set the custom track color, color is OS dependent (i.e. ColorToNative(r,g,b).\n",
        "body": "RPR_SetTrackColor(${1:MediaTrack track},${2:Int color})$0"
    },
    "SETTRACKMIDILYRICS c": {
        "prefix": "SetTrackMIDILyrics",
        "scope": "c",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "SetTrackMIDILyrics(${1:MediaTrack* track},${2:int flag},${3:const char* str})$0"
    },
    "SETTRACKMIDILYRICS eel2": {
        "prefix": "SetTrackMIDILyrics",
        "scope": "eel2",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "SetTrackMIDILyrics(${1:MediaTrack track},${2:int flag},${3:\"str\"})$0"
    },
    "REAPER.SETTRACKMIDILYRICS lua": {
        "prefix": "reaper.SetTrackMIDILyrics",
        "scope": "lua",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "reaper.SetTrackMIDILyrics(${1:MediaTrack track},${2:integer flag},${3:string str})$0"
    },
    "RPR_SETTRACKMIDILYRICS python": {
        "prefix": "RPR_SetTrackMIDILyrics",
        "scope": "python",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "RPR_SetTrackMIDILyrics(${1:MediaTrack track},${2:Int flag},${3:String str})$0"
    },
    "SETTRACKMIDINOTENAME c": {
        "prefix": "SetTrackMIDINoteName",
        "scope": "c",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "SetTrackMIDINoteName(${1:int track},${2:int pitch},${3:int chan},${4:const char* name})$0"
    },
    "SETTRACKMIDINOTENAME eel2": {
        "prefix": "SetTrackMIDINoteName",
        "scope": "eel2",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "SetTrackMIDINoteName(${1:int track},${2:int pitch},${3:int chan},${4:\"name\"})$0"
    },
    "REAPER.SETTRACKMIDINOTENAME lua": {
        "prefix": "reaper.SetTrackMIDINoteName",
        "scope": "lua",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "reaper.SetTrackMIDINoteName(${1:integer track},${2:integer pitch},${3:integer chan},${4:string name})$0"
    },
    "RPR_SETTRACKMIDINOTENAME python": {
        "prefix": "RPR_SetTrackMIDINoteName",
        "scope": "python",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "RPR_SetTrackMIDINoteName(${1:Int track},${2:Int pitch},${3:Int chan},${4:String name})$0"
    },
    "SETTRACKMIDINOTENAMEEX c": {
        "prefix": "SetTrackMIDINoteNameEx",
        "scope": "c",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "SetTrackMIDINoteNameEx(${1:ReaProject* proj},${2:MediaTrack* track},${3:int pitch},${4:int chan},${5:const char* name})$0"
    },
    "SETTRACKMIDINOTENAMEEX eel2": {
        "prefix": "SetTrackMIDINoteNameEx",
        "scope": "eel2",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "SetTrackMIDINoteNameEx(${1:ReaProject proj},${2:MediaTrack track},${3:int pitch},${4:int chan},${5:\"name\"})$0"
    },
    "REAPER.SETTRACKMIDINOTENAMEEX lua": {
        "prefix": "reaper.SetTrackMIDINoteNameEx",
        "scope": "lua",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "reaper.SetTrackMIDINoteNameEx(${1:ReaProject proj},${2:MediaTrack track},${3:integer pitch},${4:integer chan},${5:string name})$0"
    },
    "RPR_SETTRACKMIDINOTENAMEEX python": {
        "prefix": "RPR_SetTrackMIDINoteNameEx",
        "scope": "python",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "RPR_SetTrackMIDINoteNameEx(${1:ReaProject proj},${2:MediaTrack track},${3:Int pitch},${4:Int chan},${5:String name})$0"
    },
    "SETTRACKSELECTED c": {
        "prefix": "SetTrackSelected",
        "scope": "c",
        "description": "\n",
        "body": "SetTrackSelected(${1:MediaTrack* track},${2:bool selected})$0"
    },
    "SETTRACKSELECTED eel2": {
        "prefix": "SetTrackSelected",
        "scope": "eel2",
        "description": "\n",
        "body": "SetTrackSelected(${1:MediaTrack track},${2:bool selected})$0"
    },
    "REAPER.SETTRACKSELECTED lua": {
        "prefix": "reaper.SetTrackSelected",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SetTrackSelected(${1:MediaTrack track},${2:boolean selected})$0"
    },
    "RPR_SETTRACKSELECTED python": {
        "prefix": "RPR_SetTrackSelected",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SetTrackSelected(${1:MediaTrack track},${2:Boolean selected})$0"
    },
    "SETTRACKSENDINFO_VALUE c": {
        "prefix": "SetTrackSendInfo_Value",
        "scope": "c",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "SetTrackSendInfo_Value(${1:MediaTrack* tr},${2:int category},${3:int sendidx},${4|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\"|},${5:double newvalue})$0"
    },
    "SETTRACKSENDINFO_VALUE eel2": {
        "prefix": "SetTrackSendInfo_Value",
        "scope": "eel2",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "SetTrackSendInfo_Value(${1:MediaTrack tr},${2:int category},${3:int sendidx},${4:\"parmname\"},${5:newvalue})$0"
    },
    "REAPER.SETTRACKSENDINFO_VALUE lua": {
        "prefix": "reaper.SetTrackSendInfo_Value",
        "scope": "lua",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "reaper.SetTrackSendInfo_Value(${1:MediaTrack tr},${2:integer category},${3:integer sendidx},${4|string parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\"|},${5:number newvalue})$0"
    },
    "RPR_SETTRACKSENDINFO_VALUE python": {
        "prefix": "RPR_SetTrackSendInfo_Value",
        "scope": "python",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "RPR_SetTrackSendInfo_Value(${1:MediaTrack tr},${2:Int category},${3:Int sendidx},${4|String parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\"|},${5:Float newvalue})$0"
    },
    "SETTRACKSENDUIPAN c": {
        "prefix": "SetTrackSendUIPan",
        "scope": "c",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "SetTrackSendUIPan(${1:MediaTrack* track},${2:int send_idx},${3:double pan},${4:int isend})$0"
    },
    "SETTRACKSENDUIPAN eel2": {
        "prefix": "SetTrackSendUIPan",
        "scope": "eel2",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "SetTrackSendUIPan(${1:MediaTrack track},${2:int send_idx},${3:pan},${4:int isend})$0"
    },
    "REAPER.SETTRACKSENDUIPAN lua": {
        "prefix": "reaper.SetTrackSendUIPan",
        "scope": "lua",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "reaper.SetTrackSendUIPan(${1:MediaTrack track},${2:integer send_idx},${3:number pan},${4:integer isend})$0"
    },
    "RPR_SETTRACKSENDUIPAN python": {
        "prefix": "RPR_SetTrackSendUIPan",
        "scope": "python",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "RPR_SetTrackSendUIPan(${1:MediaTrack track},${2:Int send_idx},${3:Float pan},${4:Int isend})$0"
    },
    "SETTRACKSENDUIVOL c": {
        "prefix": "SetTrackSendUIVol",
        "scope": "c",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "SetTrackSendUIVol(${1:MediaTrack* track},${2:int send_idx},${3:double vol},${4:int isend})$0"
    },
    "SETTRACKSENDUIVOL eel2": {
        "prefix": "SetTrackSendUIVol",
        "scope": "eel2",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "SetTrackSendUIVol(${1:MediaTrack track},${2:int send_idx},${3:vol},${4:int isend})$0"
    },
    "REAPER.SETTRACKSENDUIVOL lua": {
        "prefix": "reaper.SetTrackSendUIVol",
        "scope": "lua",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "reaper.SetTrackSendUIVol(${1:MediaTrack track},${2:integer send_idx},${3:number vol},${4:integer isend})$0"
    },
    "RPR_SETTRACKSENDUIVOL python": {
        "prefix": "RPR_SetTrackSendUIVol",
        "scope": "python",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "RPR_SetTrackSendUIVol(${1:MediaTrack track},${2:Int send_idx},${3:Float vol},${4:Int isend})$0"
    },
    "SETTRACKSTATECHUNK c": {
        "prefix": "SetTrackStateChunk",
        "scope": "c",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "SetTrackStateChunk(${1:MediaTrack* track},${2:const char* str},${3:bool isundoOptional})$0"
    },
    "SETTRACKSTATECHUNK eel2": {
        "prefix": "SetTrackStateChunk",
        "scope": "eel2",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "SetTrackStateChunk(${1:MediaTrack track},${2:\"str\"},${3:bool isundo})$0"
    },
    "REAPER.SETTRACKSTATECHUNK lua": {
        "prefix": "reaper.SetTrackStateChunk",
        "scope": "lua",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "reaper.SetTrackStateChunk(${1:MediaTrack track},${2:string str},${3:boolean isundo})$0"
    },
    "RPR_SETTRACKSTATECHUNK python": {
        "prefix": "RPR_SetTrackStateChunk",
        "scope": "python",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "RPR_SetTrackStateChunk(${1:MediaTrack track},${2:String str},${3:Boolean isundoOptional})$0"
    },
    "SHOWACTIONLIST c": {
        "prefix": "ShowActionList",
        "scope": "c",
        "description": "\n",
        "body": "ShowActionList(${1:KbdSectionInfo* caller},${2:HWND callerWnd})$0"
    },
    "SHOWACTIONLIST eel2": {
        "prefix": "ShowActionList",
        "scope": "eel2",
        "description": "\n",
        "body": "ShowActionList(${1:KbdSectionInfo caller},${2:HWND callerWnd})$0"
    },
    "REAPER.SHOWACTIONLIST lua": {
        "prefix": "reaper.ShowActionList",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.ShowActionList(${1:KbdSectionInfo caller},${2:HWND callerWnd})$0"
    },
    "RPR_SHOWACTIONLIST python": {
        "prefix": "RPR_ShowActionList",
        "scope": "python",
        "description": "\n",
        "body": "RPR_ShowActionList(${1:KbdSectionInfo caller},${2:HWND callerWnd})$0"
    },
    "SHOWCONSOLEMSG c": {
        "prefix": "ShowConsoleMsg",
        "scope": "c",
        "description": "Show a message to the user (also useful for debugging). Send \"\\n\" for newline, \"\" to clear the console. See ClearConsole\n",
        "body": "ShowConsoleMsg(${1:const char* msg})$0"
    },
    "SHOWCONSOLEMSG eel2": {
        "prefix": "ShowConsoleMsg",
        "scope": "eel2",
        "description": "Show a message to the user (also useful for debugging). Send \"\\n\" for newline, \"\" to clear the console. See ClearConsole\n",
        "body": "ShowConsoleMsg(${1:\"msg\"})$0"
    },
    "REAPER.SHOWCONSOLEMSG lua": {
        "prefix": "reaper.ShowConsoleMsg",
        "scope": "lua",
        "description": "Show a message to the user (also useful for debugging). Send \"\\n\" for newline, \"\" to clear the console. See ClearConsole\n",
        "body": "reaper.ShowConsoleMsg(${1:string msg})$0"
    },
    "RPR_SHOWCONSOLEMSG python": {
        "prefix": "RPR_ShowConsoleMsg",
        "scope": "python",
        "description": "Show a message to the user (also useful for debugging). Send \"\\n\" for newline, \"\" to clear the console. See ClearConsole\n",
        "body": "RPR_ShowConsoleMsg(${1:String msg})$0"
    },
    "SHOWMESSAGEBOX c": {
        "prefix": "ShowMessageBox",
        "scope": "c",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "ShowMessageBox(${1:const char* msg},${2:const char* title},${3:int type})$0"
    },
    "SHOWMESSAGEBOX eel2": {
        "prefix": "ShowMessageBox",
        "scope": "eel2",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "ShowMessageBox(${1:\"msg\"},${2:\"title\"},${3:int type})$0"
    },
    "REAPER.SHOWMESSAGEBOX lua": {
        "prefix": "reaper.ShowMessageBox",
        "scope": "lua",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "reaper.ShowMessageBox(${1:string msg},${2:string title},${3:integer type})$0"
    },
    "RPR_SHOWMESSAGEBOX python": {
        "prefix": "RPR_ShowMessageBox",
        "scope": "python",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "RPR_ShowMessageBox(${1:String msg},${2:String title},${3:Int type})$0"
    },
    "SHOWPOPUPMENU c": {
        "prefix": "ShowPopupMenu",
        "scope": "c",
        "description": "shows a context menu, valid names include: track_input, track_panel,\ntrack_area, track_routing, item, ruler, envelope, envelope_point,\nenvelope_item. ctxOptional can be a track pointer for track_*, item\npointer for item* (but is optional). for envelope_point, ctx2Optional\nhas point index, ctx3Optional has item index (0=main envelope, 1=first\nAI). for envelope_item, ctx2Optional has AI index (1=first AI)\n",
        "body": "ShowPopupMenu(${1:const char* name},${2:int x},${3:int y},${4:HWND hwndParentOptional},${5:void* ctxOptional},${6:int ctx2Optional},${7:int ctx3Optional})$0"
    },
    "SHOWPOPUPMENU eel2": {
        "prefix": "ShowPopupMenu",
        "scope": "eel2",
        "description": "shows a context menu, valid names include: track_input, track_panel,\ntrack_area, track_routing, item, ruler, envelope, envelope_point,\nenvelope_item. ctxOptional can be a track pointer for track_*, item\npointer for item* (but is optional). for envelope_point, ctx2Optional\nhas point index, ctx3Optional has item index (0=main envelope, 1=first\nAI). for envelope_item, ctx2Optional has AI index (1=first AI)\n",
        "body": "ShowPopupMenu(${1:\"name\"},${2:int x},${3:int y},${4:HWND hwndParent},${5:void* ctx},${6:int ctx2},${7:int ctx3})$0"
    },
    "REAPER.SHOWPOPUPMENU lua": {
        "prefix": "reaper.ShowPopupMenu",
        "scope": "lua",
        "description": "shows a context menu, valid names include: track_input, track_panel,\ntrack_area, track_routing, item, ruler, envelope, envelope_point,\nenvelope_item. ctxOptional can be a track pointer for track_*, item\npointer for item* (but is optional). for envelope_point, ctx2Optional\nhas point index, ctx3Optional has item index (0=main envelope, 1=first\nAI). for envelope_item, ctx2Optional has AI index (1=first AI)\n",
        "body": "reaper.ShowPopupMenu(${1:string name},${2:integer x},${3:integer y},${4:HWND hwndParent},${5:identifier ctx},${6:integer ctx2},${7:integer ctx3})$0"
    },
    "RPR_SHOWPOPUPMENU python": {
        "prefix": "RPR_ShowPopupMenu",
        "scope": "python",
        "description": "shows a context menu, valid names include: track_input, track_panel,\ntrack_area, track_routing, item, ruler, envelope, envelope_point,\nenvelope_item. ctxOptional can be a track pointer for track_*, item\npointer for item* (but is optional). for envelope_point, ctx2Optional\nhas point index, ctx3Optional has item index (0=main envelope, 1=first\nAI). for envelope_item, ctx2Optional has AI index (1=first AI)\n",
        "body": "RPR_ShowPopupMenu(${1:String name},${2:Int x},${3:Int y},${4:HWND hwndParentOptional},${5:void ctxOptional},${6:Int ctx2Optional},${7:Int ctx3Optional})$0"
    },
    "SLIDER2DB c": {
        "prefix": "SLIDER2DB",
        "scope": "c",
        "description": "\n",
        "body": "SLIDER2DB(${1:double y})$0"
    },
    "SLIDER2DB eel2": {
        "prefix": "SLIDER2DB",
        "scope": "eel2",
        "description": "\n",
        "body": "SLIDER2DB(${1:y})$0"
    },
    "REAPER.SLIDER2DB lua": {
        "prefix": "reaper.SLIDER2DB",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SLIDER2DB(${1:number y})$0"
    },
    "RPR_SLIDER2DB python": {
        "prefix": "RPR_SLIDER2DB",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SLIDER2DB(${1:Float y})$0"
    },
    "SNAPTOGRID c": {
        "prefix": "SnapToGrid",
        "scope": "c",
        "description": "\n",
        "body": "SnapToGrid(${1:ReaProject* project},${2:double time_pos})$0"
    },
    "SNAPTOGRID eel2": {
        "prefix": "SnapToGrid",
        "scope": "eel2",
        "description": "\n",
        "body": "SnapToGrid(${1:ReaProject project},${2:time_pos})$0"
    },
    "REAPER.SNAPTOGRID lua": {
        "prefix": "reaper.SnapToGrid",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.SnapToGrid(${1:ReaProject project},${2:number time_pos})$0"
    },
    "RPR_SNAPTOGRID python": {
        "prefix": "RPR_SnapToGrid",
        "scope": "python",
        "description": "\n",
        "body": "RPR_SnapToGrid(${1:ReaProject project},${2:Float time_pos})$0"
    },
    "SOLOALLTRACKS c": {
        "prefix": "SoloAllTracks",
        "scope": "c",
        "description": "solo=2 for SIP\n",
        "body": "SoloAllTracks(${1:int solo})$0"
    },
    "SOLOALLTRACKS eel2": {
        "prefix": "SoloAllTracks",
        "scope": "eel2",
        "description": "solo=2 for SIP\n",
        "body": "SoloAllTracks(${1:int solo})$0"
    },
    "REAPER.SOLOALLTRACKS lua": {
        "prefix": "reaper.SoloAllTracks",
        "scope": "lua",
        "description": "solo=2 for SIP\n",
        "body": "reaper.SoloAllTracks(${1:integer solo})$0"
    },
    "RPR_SOLOALLTRACKS python": {
        "prefix": "RPR_SoloAllTracks",
        "scope": "python",
        "description": "solo=2 for SIP\n",
        "body": "RPR_SoloAllTracks(${1:Int solo})$0"
    },
    "SPLASH_GETWND c": {
        "prefix": "Splash_GetWnd",
        "scope": "c",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "Splash_GetWnd()$0"
    },
    "SPLASH_GETWND eel2": {
        "prefix": "Splash_GetWnd",
        "scope": "eel2",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "Splash_GetWnd()$0"
    },
    "REAPER.SPLASH_GETWND lua": {
        "prefix": "reaper.Splash_GetWnd",
        "scope": "lua",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "reaper.Splash_GetWnd()$0"
    },
    "RPR_SPLASH_GETWND python": {
        "prefix": "RPR_Splash_GetWnd",
        "scope": "python",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "RPR_Splash_GetWnd()$0"
    },
    "SPLITMEDIAITEM c": {
        "prefix": "SplitMediaItem",
        "scope": "c",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "SplitMediaItem(${1:MediaItem* item},${2:double position})$0"
    },
    "SPLITMEDIAITEM eel2": {
        "prefix": "SplitMediaItem",
        "scope": "eel2",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "SplitMediaItem(${1:MediaItem item},${2:position})$0"
    },
    "REAPER.SPLITMEDIAITEM lua": {
        "prefix": "reaper.SplitMediaItem",
        "scope": "lua",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "reaper.SplitMediaItem(${1:MediaItem item},${2:number position})$0"
    },
    "RPR_SPLITMEDIAITEM python": {
        "prefix": "RPR_SplitMediaItem",
        "scope": "python",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "RPR_SplitMediaItem(${1:MediaItem item},${2:Float position})$0"
    },
    "STRINGTOGUID c": {
        "prefix": "stringToGuid",
        "scope": "c",
        "description": "\n",
        "body": "stringToGuid(${1:const char* str},${2:GUID* g})$0"
    },
    "STRINGTOGUID eel2": {
        "prefix": "stringToGuid",
        "scope": "eel2",
        "description": "\n",
        "body": "stringToGuid(${1:\"str\"},${2:#gGUID})$0"
    },
    "REAPER.STRINGTOGUID lua": {
        "prefix": "reaper.stringToGuid",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.stringToGuid(${1:string str},${2:string gGUID})$0"
    },
    "RPR_STRINGTOGUID python": {
        "prefix": "RPR_stringToGuid",
        "scope": "python",
        "description": "\n",
        "body": "RPR_stringToGuid(${1:String str},${2:GUID g})$0"
    },
    "STUFFMIDIMESSAGE c": {
        "prefix": "StuffMIDIMessage",
        "scope": "c",
        "description": "Stuffs a 3 byte MIDI message into either the Virtual MIDI Keyboard\nqueue, or the MIDI-as-control input queue, or sends to a MIDI hardware\noutput. mode=0 for VKB, 1 for control (actions map etc), 2 for\nVKB-on-current-channel; 16 for external MIDI device 0, 17 for external\nMIDI device 1, etc; see GetNumMIDIOutputs, GetMIDIOutputName.\n",
        "body": "StuffMIDIMessage(${1:int mode},${2:int msg1},${3:int msg2},${4:int msg3})$0"
    },
    "STUFFMIDIMESSAGE eel2": {
        "prefix": "StuffMIDIMessage",
        "scope": "eel2",
        "description": "Stuffs a 3 byte MIDI message into either the Virtual MIDI Keyboard\nqueue, or the MIDI-as-control input queue, or sends to a MIDI hardware\noutput. mode=0 for VKB, 1 for control (actions map etc), 2 for\nVKB-on-current-channel; 16 for external MIDI device 0, 17 for external\nMIDI device 1, etc; see GetNumMIDIOutputs, GetMIDIOutputName.\n",
        "body": "StuffMIDIMessage(${1:int mode},${2:int msg1},${3:int msg2},${4:int msg3})$0"
    },
    "REAPER.STUFFMIDIMESSAGE lua": {
        "prefix": "reaper.StuffMIDIMessage",
        "scope": "lua",
        "description": "Stuffs a 3 byte MIDI message into either the Virtual MIDI Keyboard\nqueue, or the MIDI-as-control input queue, or sends to a MIDI hardware\noutput. mode=0 for VKB, 1 for control (actions map etc), 2 for\nVKB-on-current-channel; 16 for external MIDI device 0, 17 for external\nMIDI device 1, etc; see GetNumMIDIOutputs, GetMIDIOutputName.\n",
        "body": "reaper.StuffMIDIMessage(${1:integer mode},${2:integer msg1},${3:integer msg2},${4:integer msg3})$0"
    },
    "RPR_STUFFMIDIMESSAGE python": {
        "prefix": "RPR_StuffMIDIMessage",
        "scope": "python",
        "description": "Stuffs a 3 byte MIDI message into either the Virtual MIDI Keyboard\nqueue, or the MIDI-as-control input queue, or sends to a MIDI hardware\noutput. mode=0 for VKB, 1 for control (actions map etc), 2 for\nVKB-on-current-channel; 16 for external MIDI device 0, 17 for external\nMIDI device 1, etc; see GetNumMIDIOutputs, GetMIDIOutputName.\n",
        "body": "RPR_StuffMIDIMessage(${1:Int mode},${2:Int msg1},${3:Int msg2},${4:Int msg3})$0"
    },
    "TAKEFX_ADDBYNAME c": {
        "prefix": "TakeFX_AddByName",
        "scope": "c",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "TakeFX_AddByName(${1:MediaItem_Take* take},${2:const char* fxname},${3:int instantiate})$0"
    },
    "TAKEFX_ADDBYNAME eel2": {
        "prefix": "TakeFX_AddByName",
        "scope": "eel2",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "TakeFX_AddByName(${1:MediaItem_Take take},${2:\"fxname\"},${3:int instantiate})$0"
    },
    "REAPER.TAKEFX_ADDBYNAME lua": {
        "prefix": "reaper.TakeFX_AddByName",
        "scope": "lua",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "reaper.TakeFX_AddByName(${1:MediaItem_Take take},${2:string fxname},${3:integer instantiate})$0"
    },
    "RPR_TAKEFX_ADDBYNAME python": {
        "prefix": "RPR_TakeFX_AddByName",
        "scope": "python",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "RPR_TakeFX_AddByName(${1:MediaItem_Take take},${2:String fxname},${3:Int instantiate})$0"
    },
    "TAKEFX_COPYTOTAKE c": {
        "prefix": "TakeFX_CopyToTake",
        "scope": "c",
        "description": "Copies (or moves) FX from src_take to dest_take. Can be used with src_track=dest_track to reorder.\n",
        "body": "TakeFX_CopyToTake(${1:MediaItem_Take* src_take},${2:int src_fx},${3:MediaItem_Take* dest_take},${4:int dest_fx},${5:bool is_move})$0"
    },
    "TAKEFX_COPYTOTAKE eel2": {
        "prefix": "TakeFX_CopyToTake",
        "scope": "eel2",
        "description": "Copies (or moves) FX from src_take to dest_take. Can be used with src_track=dest_track to reorder.\n",
        "body": "TakeFX_CopyToTake(${1:MediaItem_Take src_take},${2:int src_fx},${3:MediaItem_Take dest_take},${4:int dest_fx},${5:bool is_move})$0"
    },
    "REAPER.TAKEFX_COPYTOTAKE lua": {
        "prefix": "reaper.TakeFX_CopyToTake",
        "scope": "lua",
        "description": "Copies (or moves) FX from src_take to dest_take. Can be used with src_track=dest_track to reorder.\n",
        "body": "reaper.TakeFX_CopyToTake(${1:MediaItem_Take src_take},${2:integer src_fx},${3:MediaItem_Take dest_take},${4:integer dest_fx},${5:boolean is_move})$0"
    },
    "RPR_TAKEFX_COPYTOTAKE python": {
        "prefix": "RPR_TakeFX_CopyToTake",
        "scope": "python",
        "description": "Copies (or moves) FX from src_take to dest_take. Can be used with src_track=dest_track to reorder.\n",
        "body": "RPR_TakeFX_CopyToTake(${1:MediaItem_Take src_take},${2:Int src_fx},${3:MediaItem_Take dest_take},${4:Int dest_fx},${5:Boolean is_move})$0"
    },
    "TAKEFX_COPYTOTRACK c": {
        "prefix": "TakeFX_CopyToTrack",
        "scope": "c",
        "description": "Copies (or moves) FX from src_take to dest_track. dest_fx can have 0x1000000 set to reference input FX.\n",
        "body": "TakeFX_CopyToTrack(${1:MediaItem_Take* src_take},${2:int src_fx},${3:MediaTrack* dest_track},${4:int dest_fx},${5:bool is_move})$0"
    },
    "TAKEFX_COPYTOTRACK eel2": {
        "prefix": "TakeFX_CopyToTrack",
        "scope": "eel2",
        "description": "Copies (or moves) FX from src_take to dest_track. dest_fx can have 0x1000000 set to reference input FX.\n",
        "body": "TakeFX_CopyToTrack(${1:MediaItem_Take src_take},${2:int src_fx},${3:MediaTrack dest_track},${4:int dest_fx},${5:bool is_move})$0"
    },
    "REAPER.TAKEFX_COPYTOTRACK lua": {
        "prefix": "reaper.TakeFX_CopyToTrack",
        "scope": "lua",
        "description": "Copies (or moves) FX from src_take to dest_track. dest_fx can have 0x1000000 set to reference input FX.\n",
        "body": "reaper.TakeFX_CopyToTrack(${1:MediaItem_Take src_take},${2:integer src_fx},${3:MediaTrack dest_track},${4:integer dest_fx},${5:boolean is_move})$0"
    },
    "RPR_TAKEFX_COPYTOTRACK python": {
        "prefix": "RPR_TakeFX_CopyToTrack",
        "scope": "python",
        "description": "Copies (or moves) FX from src_take to dest_track. dest_fx can have 0x1000000 set to reference input FX.\n",
        "body": "RPR_TakeFX_CopyToTrack(${1:MediaItem_Take src_take},${2:Int src_fx},${3:MediaTrack dest_track},${4:Int dest_fx},${5:Boolean is_move})$0"
    },
    "TAKEFX_DELETE c": {
        "prefix": "TakeFX_Delete",
        "scope": "c",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "TakeFX_Delete(${1:MediaItem_Take* take},${2:int fx})$0"
    },
    "TAKEFX_DELETE eel2": {
        "prefix": "TakeFX_Delete",
        "scope": "eel2",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "TakeFX_Delete(${1:MediaItem_Take take},${2:int fx})$0"
    },
    "REAPER.TAKEFX_DELETE lua": {
        "prefix": "reaper.TakeFX_Delete",
        "scope": "lua",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "reaper.TakeFX_Delete(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_DELETE python": {
        "prefix": "RPR_TakeFX_Delete",
        "scope": "python",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "RPR_TakeFX_Delete(${1:MediaItem_Take take},${2:Int fx})$0"
    },
    "TAKEFX_ENDPARAMEDIT c": {
        "prefix": "TakeFX_EndParamEdit",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_EndParamEdit(${1:MediaItem_Take* take},${2:int fx},${3:int param})$0"
    },
    "TAKEFX_ENDPARAMEDIT eel2": {
        "prefix": "TakeFX_EndParamEdit",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_EndParamEdit(${1:MediaItem_Take take},${2:int fx},${3:int param})$0"
    },
    "REAPER.TAKEFX_ENDPARAMEDIT lua": {
        "prefix": "reaper.TakeFX_EndParamEdit",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_EndParamEdit(${1:MediaItem_Take take},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TAKEFX_ENDPARAMEDIT python": {
        "prefix": "RPR_TakeFX_EndParamEdit",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_EndParamEdit(${1:MediaItem_Take take},${2:Int fx},${3:Int param})$0"
    },
    "TAKEFX_FORMATPARAMVALUE c": {
        "prefix": "TakeFX_FormatParamValue",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TakeFX_FormatParamValue(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:double val},${5:char* buf},${6:int buf_sz})$0"
    },
    "TAKEFX_FORMATPARAMVALUE eel2": {
        "prefix": "TakeFX_FormatParamValue",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TakeFX_FormatParamValue(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:val},${5:#buf})$0"
    },
    "REAPER.TAKEFX_FORMATPARAMVALUE lua": {
        "prefix": "reaper.TakeFX_FormatParamValue",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "reaper.TakeFX_FormatParamValue(${1:MediaItem_Take take},${2:integer fx},${3:integer param},${4:number val},${5:string buf})$0"
    },
    "RPR_TAKEFX_FORMATPARAMVALUE python": {
        "prefix": "RPR_TakeFX_FormatParamValue",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "RPR_TakeFX_FormatParamValue(${1:take},${2:fx},${3:param},${4:val},${5:buf},${6:buf_sz})$0"
    },
    "TAKEFX_FORMATPARAMVALUENORMALIZED c": {
        "prefix": "TakeFX_FormatParamValueNormalized",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TakeFX_FormatParamValueNormalized(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:double value},${5:char* buf},${6:int buf_sz})$0"
    },
    "TAKEFX_FORMATPARAMVALUENORMALIZED eel2": {
        "prefix": "TakeFX_FormatParamValueNormalized",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TakeFX_FormatParamValueNormalized(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:value},${5:#buf})$0"
    },
    "REAPER.TAKEFX_FORMATPARAMVALUENORMALIZED lua": {
        "prefix": "reaper.TakeFX_FormatParamValueNormalized",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "reaper.TakeFX_FormatParamValueNormalized(${1:MediaItem_Take take},${2:integer fx},${3:integer param},${4:number value},${5:string buf})$0"
    },
    "RPR_TAKEFX_FORMATPARAMVALUENORMALIZED python": {
        "prefix": "RPR_TakeFX_FormatParamValueNormalized",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "RPR_TakeFX_FormatParamValueNormalized(${1:take},${2:fx},${3:param},${4:value},${5:buf},${6:buf_sz})$0"
    },
    "TAKEFX_GETCHAINVISIBLE c": {
        "prefix": "TakeFX_GetChainVisible",
        "scope": "c",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "TakeFX_GetChainVisible(${1:MediaItem_Take* take})$0"
    },
    "TAKEFX_GETCHAINVISIBLE eel2": {
        "prefix": "TakeFX_GetChainVisible",
        "scope": "eel2",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "TakeFX_GetChainVisible(${1:MediaItem_Take take})$0"
    },
    "REAPER.TAKEFX_GETCHAINVISIBLE lua": {
        "prefix": "reaper.TakeFX_GetChainVisible",
        "scope": "lua",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "reaper.TakeFX_GetChainVisible(${1:MediaItem_Take take})$0"
    },
    "RPR_TAKEFX_GETCHAINVISIBLE python": {
        "prefix": "RPR_TakeFX_GetChainVisible",
        "scope": "python",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "RPR_TakeFX_GetChainVisible(${1:MediaItem_Take take})$0"
    },
    "TAKEFX_GETCOUNT c": {
        "prefix": "TakeFX_GetCount",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetCount(${1:MediaItem_Take* take})$0"
    },
    "TAKEFX_GETCOUNT eel2": {
        "prefix": "TakeFX_GetCount",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetCount(${1:MediaItem_Take take})$0"
    },
    "REAPER.TAKEFX_GETCOUNT lua": {
        "prefix": "reaper.TakeFX_GetCount",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetCount(${1:MediaItem_Take take})$0"
    },
    "RPR_TAKEFX_GETCOUNT python": {
        "prefix": "RPR_TakeFX_GetCount",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetCount(${1:MediaItem_Take take})$0"
    },
    "TAKEFX_GETENABLED c": {
        "prefix": "TakeFX_GetEnabled",
        "scope": "c",
        "description": "See TakeFX_SetEnabled\n",
        "body": "TakeFX_GetEnabled(${1:MediaItem_Take* take},${2:int fx})$0"
    },
    "TAKEFX_GETENABLED eel2": {
        "prefix": "TakeFX_GetEnabled",
        "scope": "eel2",
        "description": "See TakeFX_SetEnabled\n",
        "body": "TakeFX_GetEnabled(${1:MediaItem_Take take},${2:int fx})$0"
    },
    "REAPER.TAKEFX_GETENABLED lua": {
        "prefix": "reaper.TakeFX_GetEnabled",
        "scope": "lua",
        "description": "See TakeFX_SetEnabled\n",
        "body": "reaper.TakeFX_GetEnabled(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_GETENABLED python": {
        "prefix": "RPR_TakeFX_GetEnabled",
        "scope": "python",
        "description": "See TakeFX_SetEnabled\n",
        "body": "RPR_TakeFX_GetEnabled(${1:MediaItem_Take take},${2:Int fx})$0"
    },
    "TAKEFX_GETENVELOPE c": {
        "prefix": "TakeFX_GetEnvelope",
        "scope": "c",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "TakeFX_GetEnvelope(${1:MediaItem_Take* take},${2:int fxindex},${3:int parameterindex},${4:bool create})$0"
    },
    "TAKEFX_GETENVELOPE eel2": {
        "prefix": "TakeFX_GetEnvelope",
        "scope": "eel2",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "TakeFX_GetEnvelope(${1:MediaItem_Take take},${2:int fxindex},${3:int parameterindex},${4:bool create})$0"
    },
    "REAPER.TAKEFX_GETENVELOPE lua": {
        "prefix": "reaper.TakeFX_GetEnvelope",
        "scope": "lua",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "reaper.TakeFX_GetEnvelope(${1:MediaItem_Take take},${2:integer fxindex},${3:integer parameterindex},${4:boolean create})$0"
    },
    "RPR_TAKEFX_GETENVELOPE python": {
        "prefix": "RPR_TakeFX_GetEnvelope",
        "scope": "python",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "RPR_TakeFX_GetEnvelope(${1:MediaItem_Take take},${2:Int fxindex},${3:Int parameterindex},${4:Boolean create})$0"
    },
    "TAKEFX_GETFLOATINGWINDOW c": {
        "prefix": "TakeFX_GetFloatingWindow",
        "scope": "c",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "TakeFX_GetFloatingWindow(${1:MediaItem_Take* take},${2:int index})$0"
    },
    "TAKEFX_GETFLOATINGWINDOW eel2": {
        "prefix": "TakeFX_GetFloatingWindow",
        "scope": "eel2",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "TakeFX_GetFloatingWindow(${1:MediaItem_Take take},${2:int index})$0"
    },
    "REAPER.TAKEFX_GETFLOATINGWINDOW lua": {
        "prefix": "reaper.TakeFX_GetFloatingWindow",
        "scope": "lua",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "reaper.TakeFX_GetFloatingWindow(${1:MediaItem_Take take},${2:integer index})$0"
    },
    "RPR_TAKEFX_GETFLOATINGWINDOW python": {
        "prefix": "RPR_TakeFX_GetFloatingWindow",
        "scope": "python",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "RPR_TakeFX_GetFloatingWindow(${1:MediaItem_Take take},${2:Int index})$0"
    },
    "TAKEFX_GETFORMATTEDPARAMVALUE c": {
        "prefix": "TakeFX_GetFormattedParamValue",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetFormattedParamValue(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:char* buf},${5:int buf_sz})$0"
    },
    "TAKEFX_GETFORMATTEDPARAMVALUE eel2": {
        "prefix": "TakeFX_GetFormattedParamValue",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetFormattedParamValue(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:#buf})$0"
    },
    "REAPER.TAKEFX_GETFORMATTEDPARAMVALUE lua": {
        "prefix": "reaper.TakeFX_GetFormattedParamValue",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetFormattedParamValue(${1:MediaItem_Take take},${2:integer fx},${3:integer param},${4:string buf})$0"
    },
    "RPR_TAKEFX_GETFORMATTEDPARAMVALUE python": {
        "prefix": "RPR_TakeFX_GetFormattedParamValue",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetFormattedParamValue(${1:take},${2:fx},${3:param},${4:buf},${5:buf_sz})$0"
    },
    "TAKEFX_GETFXGUID c": {
        "prefix": "TakeFX_GetFXGUID",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetFXGUID(${1:MediaItem_Take* take},${2:int fx})$0"
    },
    "TAKEFX_GETFXGUID eel2": {
        "prefix": "TakeFX_GetFXGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetFXGUID(${1:#retguid},${2:MediaItem_Take take},${3:int fx})$0"
    },
    "REAPER.TAKEFX_GETFXGUID lua": {
        "prefix": "reaper.TakeFX_GetFXGUID",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetFXGUID(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_GETFXGUID python": {
        "prefix": "RPR_TakeFX_GetFXGUID",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetFXGUID(${1:MediaItem_Take take},${2:Int fx})$0"
    },
    "TAKEFX_GETFXNAME c": {
        "prefix": "TakeFX_GetFXName",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetFXName(${1:MediaItem_Take* take},${2:int fx},${3:char* buf},${4:int buf_sz})$0"
    },
    "TAKEFX_GETFXNAME eel2": {
        "prefix": "TakeFX_GetFXName",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetFXName(${1:MediaItem_Take take},${2:int fx},${3:#buf})$0"
    },
    "REAPER.TAKEFX_GETFXNAME lua": {
        "prefix": "reaper.TakeFX_GetFXName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetFXName(${1:MediaItem_Take take},${2:integer fx},${3:string buf})$0"
    },
    "RPR_TAKEFX_GETFXNAME python": {
        "prefix": "RPR_TakeFX_GetFXName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetFXName(${1:take},${2:fx},${3:buf},${4:buf_sz})$0"
    },
    "TAKEFX_GETIOSIZE c": {
        "prefix": "TakeFX_GetIOSize",
        "scope": "c",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "TakeFX_GetIOSize(${1:MediaItem_Take* take},${2:int fx},${3:int* inputPinsOutOptional},${4:int* outputPinsOutOptional})$0"
    },
    "TAKEFX_GETIOSIZE eel2": {
        "prefix": "TakeFX_GetIOSize",
        "scope": "eel2",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "TakeFX_GetIOSize(${1:MediaItem_Take take},${2:int fx},${3:optional int &inputPins},${4:optional int &outputPins})$0"
    },
    "REAPER.TAKEFX_GETIOSIZE lua": {
        "prefix": "reaper.TakeFX_GetIOSize",
        "scope": "lua",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "reaper.TakeFX_GetIOSize(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_GETIOSIZE python": {
        "prefix": "RPR_TakeFX_GetIOSize",
        "scope": "python",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "RPR_TakeFX_GetIOSize(${1:take},${2:fx},${3:inputPinsOutOptional},${4:outputPinsOutOptional})$0"
    },
    "TAKEFX_GETNAMEDCONFIGPARM c": {
        "prefix": "TakeFX_GetNamedConfigParm",
        "scope": "c",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "TakeFX_GetNamedConfigParm(${1:MediaItem_Take* take},${2:int fx},${3:const char* parmname},${4:char* bufOut},${5:int bufOut_sz})$0"
    },
    "TAKEFX_GETNAMEDCONFIGPARM eel2": {
        "prefix": "TakeFX_GetNamedConfigParm",
        "scope": "eel2",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "TakeFX_GetNamedConfigParm(${1:MediaItem_Take take},${2:int fx},${3:\"parmname\"},${4:#buf})$0"
    },
    "REAPER.TAKEFX_GETNAMEDCONFIGPARM lua": {
        "prefix": "reaper.TakeFX_GetNamedConfigParm",
        "scope": "lua",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "reaper.TakeFX_GetNamedConfigParm(${1:MediaItem_Take take},${2:integer fx},${3:string parmname})$0"
    },
    "RPR_TAKEFX_GETNAMEDCONFIGPARM python": {
        "prefix": "RPR_TakeFX_GetNamedConfigParm",
        "scope": "python",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "RPR_TakeFX_GetNamedConfigParm(${1:take},${2:fx},${3:parmname},${4:bufOut},${5:bufOut_sz})$0"
    },
    "TAKEFX_GETNUMPARAMS c": {
        "prefix": "TakeFX_GetNumParams",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetNumParams(${1:MediaItem_Take* take},${2:int fx})$0"
    },
    "TAKEFX_GETNUMPARAMS eel2": {
        "prefix": "TakeFX_GetNumParams",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetNumParams(${1:MediaItem_Take take},${2:int fx})$0"
    },
    "REAPER.TAKEFX_GETNUMPARAMS lua": {
        "prefix": "reaper.TakeFX_GetNumParams",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetNumParams(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_GETNUMPARAMS python": {
        "prefix": "RPR_TakeFX_GetNumParams",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetNumParams(${1:MediaItem_Take take},${2:Int fx})$0"
    },
    "TAKEFX_GETOFFLINE c": {
        "prefix": "TakeFX_GetOffline",
        "scope": "c",
        "description": "See TakeFX_SetOffline\n",
        "body": "TakeFX_GetOffline(${1:MediaItem_Take* take},${2:int fx})$0"
    },
    "TAKEFX_GETOFFLINE eel2": {
        "prefix": "TakeFX_GetOffline",
        "scope": "eel2",
        "description": "See TakeFX_SetOffline\n",
        "body": "TakeFX_GetOffline(${1:MediaItem_Take take},${2:int fx})$0"
    },
    "REAPER.TAKEFX_GETOFFLINE lua": {
        "prefix": "reaper.TakeFX_GetOffline",
        "scope": "lua",
        "description": "See TakeFX_SetOffline\n",
        "body": "reaper.TakeFX_GetOffline(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_GETOFFLINE python": {
        "prefix": "RPR_TakeFX_GetOffline",
        "scope": "python",
        "description": "See TakeFX_SetOffline\n",
        "body": "RPR_TakeFX_GetOffline(${1:MediaItem_Take take},${2:Int fx})$0"
    },
    "TAKEFX_GETOPEN c": {
        "prefix": "TakeFX_GetOpen",
        "scope": "c",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "TakeFX_GetOpen(${1:MediaItem_Take* take},${2:int fx})$0"
    },
    "TAKEFX_GETOPEN eel2": {
        "prefix": "TakeFX_GetOpen",
        "scope": "eel2",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "TakeFX_GetOpen(${1:MediaItem_Take take},${2:int fx})$0"
    },
    "REAPER.TAKEFX_GETOPEN lua": {
        "prefix": "reaper.TakeFX_GetOpen",
        "scope": "lua",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "reaper.TakeFX_GetOpen(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_GETOPEN python": {
        "prefix": "RPR_TakeFX_GetOpen",
        "scope": "python",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "RPR_TakeFX_GetOpen(${1:MediaItem_Take take},${2:Int fx})$0"
    },
    "TAKEFX_GETPARAM c": {
        "prefix": "TakeFX_GetParam",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetParam(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:double* minvalOut},${5:double* maxvalOut})$0"
    },
    "TAKEFX_GETPARAM eel2": {
        "prefix": "TakeFX_GetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetParam(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:&minval},${5:&maxval})$0"
    },
    "REAPER.TAKEFX_GETPARAM lua": {
        "prefix": "reaper.TakeFX_GetParam",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetParam(${1:MediaItem_Take take},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAM python": {
        "prefix": "RPR_TakeFX_GetParam",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetParam(${1:take},${2:fx},${3:param},${4:minvalOut},${5:maxvalOut})$0"
    },
    "TAKEFX_GETPARAMETERSTEPSIZES c": {
        "prefix": "TakeFX_GetParameterStepSizes",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetParameterStepSizes(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:double* stepOut},${5:double* smallstepOut},${6:double* largestepOut},${7:bool* istoggleOut})$0"
    },
    "TAKEFX_GETPARAMETERSTEPSIZES eel2": {
        "prefix": "TakeFX_GetParameterStepSizes",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetParameterStepSizes(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:&step},${5:&smallstep},${6:&largestep},${7:bool &istoggle})$0"
    },
    "REAPER.TAKEFX_GETPARAMETERSTEPSIZES lua": {
        "prefix": "reaper.TakeFX_GetParameterStepSizes",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetParameterStepSizes(${1:MediaItem_Take take},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAMETERSTEPSIZES python": {
        "prefix": "RPR_TakeFX_GetParameterStepSizes",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetParameterStepSizes(${1:take},${2:fx},${3:param},${4:stepOut},${5:smallstepOut},${6:largestepOut},${7:istoggleOut})$0"
    },
    "TAKEFX_GETPARAMEX c": {
        "prefix": "TakeFX_GetParamEx",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetParamEx(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:double* minvalOut},${5:double* maxvalOut},${6:double* midvalOut})$0"
    },
    "TAKEFX_GETPARAMEX eel2": {
        "prefix": "TakeFX_GetParamEx",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetParamEx(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:&minval},${5:&maxval},${6:&midval})$0"
    },
    "REAPER.TAKEFX_GETPARAMEX lua": {
        "prefix": "reaper.TakeFX_GetParamEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetParamEx(${1:MediaItem_Take take},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAMEX python": {
        "prefix": "RPR_TakeFX_GetParamEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetParamEx(${1:take},${2:fx},${3:param},${4:minvalOut},${5:maxvalOut},${6:midvalOut})$0"
    },
    "TAKEFX_GETPARAMNAME c": {
        "prefix": "TakeFX_GetParamName",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetParamName(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:char* buf},${5:int buf_sz})$0"
    },
    "TAKEFX_GETPARAMNAME eel2": {
        "prefix": "TakeFX_GetParamName",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetParamName(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:#buf})$0"
    },
    "REAPER.TAKEFX_GETPARAMNAME lua": {
        "prefix": "reaper.TakeFX_GetParamName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetParamName(${1:MediaItem_Take take},${2:integer fx},${3:integer param},${4:string buf})$0"
    },
    "RPR_TAKEFX_GETPARAMNAME python": {
        "prefix": "RPR_TakeFX_GetParamName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetParamName(${1:take},${2:fx},${3:param},${4:buf},${5:buf_sz})$0"
    },
    "TAKEFX_GETPARAMNORMALIZED c": {
        "prefix": "TakeFX_GetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetParamNormalized(${1:MediaItem_Take* take},${2:int fx},${3:int param})$0"
    },
    "TAKEFX_GETPARAMNORMALIZED eel2": {
        "prefix": "TakeFX_GetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetParamNormalized(${1:MediaItem_Take take},${2:int fx},${3:int param})$0"
    },
    "REAPER.TAKEFX_GETPARAMNORMALIZED lua": {
        "prefix": "reaper.TakeFX_GetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetParamNormalized(${1:MediaItem_Take take},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAMNORMALIZED python": {
        "prefix": "RPR_TakeFX_GetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetParamNormalized(${1:MediaItem_Take take},${2:Int fx},${3:Int param})$0"
    },
    "TAKEFX_GETPINMAPPINGS c": {
        "prefix": "TakeFX_GetPinMappings",
        "scope": "c",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "TakeFX_GetPinMappings(${1:MediaItem_Take* tr},${2:int fx},${3:int isoutput},${4:int pin},${5:int* high32OutOptional})$0"
    },
    "TAKEFX_GETPINMAPPINGS eel2": {
        "prefix": "TakeFX_GetPinMappings",
        "scope": "eel2",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "TakeFX_GetPinMappings(${1:MediaItem_Take tr},${2:int fx},${3:int isoutput},${4:int pin},${5:optional int &high32})$0"
    },
    "REAPER.TAKEFX_GETPINMAPPINGS lua": {
        "prefix": "reaper.TakeFX_GetPinMappings",
        "scope": "lua",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "reaper.TakeFX_GetPinMappings(${1:MediaItem_Take tr},${2:integer fx},${3:integer isoutput},${4:integer pin})$0"
    },
    "RPR_TAKEFX_GETPINMAPPINGS python": {
        "prefix": "RPR_TakeFX_GetPinMappings",
        "scope": "python",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "RPR_TakeFX_GetPinMappings(${1:tr},${2:fx},${3:isoutput},${4:pin},${5:high32OutOptional})$0"
    },
    "TAKEFX_GETPRESET c": {
        "prefix": "TakeFX_GetPreset",
        "scope": "c",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "TakeFX_GetPreset(${1:MediaItem_Take* take},${2:int fx},${3:char* presetname},${4:int presetname_sz})$0"
    },
    "TAKEFX_GETPRESET eel2": {
        "prefix": "TakeFX_GetPreset",
        "scope": "eel2",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "TakeFX_GetPreset(${1:MediaItem_Take take},${2:int fx},${3:#presetname})$0"
    },
    "REAPER.TAKEFX_GETPRESET lua": {
        "prefix": "reaper.TakeFX_GetPreset",
        "scope": "lua",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "reaper.TakeFX_GetPreset(${1:MediaItem_Take take},${2:integer fx},${3:string presetname})$0"
    },
    "RPR_TAKEFX_GETPRESET python": {
        "prefix": "RPR_TakeFX_GetPreset",
        "scope": "python",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "RPR_TakeFX_GetPreset(${1:take},${2:fx},${3:presetname},${4:presetname_sz})$0"
    },
    "TAKEFX_GETPRESETINDEX c": {
        "prefix": "TakeFX_GetPresetIndex",
        "scope": "c",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "TakeFX_GetPresetIndex(${1:MediaItem_Take* take},${2:int fx},${3:int* numberOfPresetsOut})$0"
    },
    "TAKEFX_GETPRESETINDEX eel2": {
        "prefix": "TakeFX_GetPresetIndex",
        "scope": "eel2",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "TakeFX_GetPresetIndex(${1:MediaItem_Take take},${2:int fx},${3:int &numberOfPresets})$0"
    },
    "REAPER.TAKEFX_GETPRESETINDEX lua": {
        "prefix": "reaper.TakeFX_GetPresetIndex",
        "scope": "lua",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "reaper.TakeFX_GetPresetIndex(${1:MediaItem_Take take},${2:integer fx})$0"
    },
    "RPR_TAKEFX_GETPRESETINDEX python": {
        "prefix": "RPR_TakeFX_GetPresetIndex",
        "scope": "python",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "RPR_TakeFX_GetPresetIndex(${1:take},${2:fx},${3:numberOfPresetsOut})$0"
    },
    "TAKEFX_GETUSERPRESETFILENAME c": {
        "prefix": "TakeFX_GetUserPresetFilename",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_GetUserPresetFilename(${1:MediaItem_Take* take},${2:int fx},${3:char* fn},${4:int fn_sz})$0"
    },
    "TAKEFX_GETUSERPRESETFILENAME eel2": {
        "prefix": "TakeFX_GetUserPresetFilename",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_GetUserPresetFilename(${1:MediaItem_Take take},${2:int fx},${3:#fn})$0"
    },
    "REAPER.TAKEFX_GETUSERPRESETFILENAME lua": {
        "prefix": "reaper.TakeFX_GetUserPresetFilename",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_GetUserPresetFilename(${1:MediaItem_Take take},${2:integer fx},${3:string fn})$0"
    },
    "RPR_TAKEFX_GETUSERPRESETFILENAME python": {
        "prefix": "RPR_TakeFX_GetUserPresetFilename",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_GetUserPresetFilename(${1:take},${2:fx},${3:fn},${4:fn_sz})$0"
    },
    "TAKEFX_NAVIGATEPRESETS c": {
        "prefix": "TakeFX_NavigatePresets",
        "scope": "c",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "TakeFX_NavigatePresets(${1:MediaItem_Take* take},${2:int fx},${3:int presetmove})$0"
    },
    "TAKEFX_NAVIGATEPRESETS eel2": {
        "prefix": "TakeFX_NavigatePresets",
        "scope": "eel2",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "TakeFX_NavigatePresets(${1:MediaItem_Take take},${2:int fx},${3:int presetmove})$0"
    },
    "REAPER.TAKEFX_NAVIGATEPRESETS lua": {
        "prefix": "reaper.TakeFX_NavigatePresets",
        "scope": "lua",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "reaper.TakeFX_NavigatePresets(${1:MediaItem_Take take},${2:integer fx},${3:integer presetmove})$0"
    },
    "RPR_TAKEFX_NAVIGATEPRESETS python": {
        "prefix": "RPR_TakeFX_NavigatePresets",
        "scope": "python",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "RPR_TakeFX_NavigatePresets(${1:MediaItem_Take take},${2:Int fx},${3:Int presetmove})$0"
    },
    "TAKEFX_SETENABLED c": {
        "prefix": "TakeFX_SetEnabled",
        "scope": "c",
        "description": "See TakeFX_GetEnabled\n",
        "body": "TakeFX_SetEnabled(${1:MediaItem_Take* take},${2:int fx},${3:bool enabled})$0"
    },
    "TAKEFX_SETENABLED eel2": {
        "prefix": "TakeFX_SetEnabled",
        "scope": "eel2",
        "description": "See TakeFX_GetEnabled\n",
        "body": "TakeFX_SetEnabled(${1:MediaItem_Take take},${2:int fx},${3:bool enabled})$0"
    },
    "REAPER.TAKEFX_SETENABLED lua": {
        "prefix": "reaper.TakeFX_SetEnabled",
        "scope": "lua",
        "description": "See TakeFX_GetEnabled\n",
        "body": "reaper.TakeFX_SetEnabled(${1:MediaItem_Take take},${2:integer fx},${3:boolean enabled})$0"
    },
    "RPR_TAKEFX_SETENABLED python": {
        "prefix": "RPR_TakeFX_SetEnabled",
        "scope": "python",
        "description": "See TakeFX_GetEnabled\n",
        "body": "RPR_TakeFX_SetEnabled(${1:MediaItem_Take take},${2:Int fx},${3:Boolean enabled})$0"
    },
    "TAKEFX_SETNAMEDCONFIGPARM c": {
        "prefix": "TakeFX_SetNamedConfigParm",
        "scope": "c",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "TakeFX_SetNamedConfigParm(${1:MediaItem_Take* take},${2:int fx},${3:const char* parmname},${4:const char* value})$0"
    },
    "TAKEFX_SETNAMEDCONFIGPARM eel2": {
        "prefix": "TakeFX_SetNamedConfigParm",
        "scope": "eel2",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "TakeFX_SetNamedConfigParm(${1:MediaItem_Take take},${2:int fx},${3:\"parmname\"},${4:\"value\"})$0"
    },
    "REAPER.TAKEFX_SETNAMEDCONFIGPARM lua": {
        "prefix": "reaper.TakeFX_SetNamedConfigParm",
        "scope": "lua",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "reaper.TakeFX_SetNamedConfigParm(${1:MediaItem_Take take},${2:integer fx},${3:string parmname},${4:string value})$0"
    },
    "RPR_TAKEFX_SETNAMEDCONFIGPARM python": {
        "prefix": "RPR_TakeFX_SetNamedConfigParm",
        "scope": "python",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "RPR_TakeFX_SetNamedConfigParm(${1:MediaItem_Take take},${2:Int fx},${3:String parmname},${4:String value})$0"
    },
    "TAKEFX_SETOFFLINE c": {
        "prefix": "TakeFX_SetOffline",
        "scope": "c",
        "description": "See TakeFX_GetOffline\n",
        "body": "TakeFX_SetOffline(${1:MediaItem_Take* take},${2:int fx},${3:bool offline})$0"
    },
    "TAKEFX_SETOFFLINE eel2": {
        "prefix": "TakeFX_SetOffline",
        "scope": "eel2",
        "description": "See TakeFX_GetOffline\n",
        "body": "TakeFX_SetOffline(${1:MediaItem_Take take},${2:int fx},${3:bool offline})$0"
    },
    "REAPER.TAKEFX_SETOFFLINE lua": {
        "prefix": "reaper.TakeFX_SetOffline",
        "scope": "lua",
        "description": "See TakeFX_GetOffline\n",
        "body": "reaper.TakeFX_SetOffline(${1:MediaItem_Take take},${2:integer fx},${3:boolean offline})$0"
    },
    "RPR_TAKEFX_SETOFFLINE python": {
        "prefix": "RPR_TakeFX_SetOffline",
        "scope": "python",
        "description": "See TakeFX_GetOffline\n",
        "body": "RPR_TakeFX_SetOffline(${1:MediaItem_Take take},${2:Int fx},${3:Boolean offline})$0"
    },
    "TAKEFX_SETOPEN c": {
        "prefix": "TakeFX_SetOpen",
        "scope": "c",
        "description": "Open this FX UI. See TakeFX_GetOpen\n",
        "body": "TakeFX_SetOpen(${1:MediaItem_Take* take},${2:int fx},${3:bool open})$0"
    },
    "TAKEFX_SETOPEN eel2": {
        "prefix": "TakeFX_SetOpen",
        "scope": "eel2",
        "description": "Open this FX UI. See TakeFX_GetOpen\n",
        "body": "TakeFX_SetOpen(${1:MediaItem_Take take},${2:int fx},${3:bool open})$0"
    },
    "REAPER.TAKEFX_SETOPEN lua": {
        "prefix": "reaper.TakeFX_SetOpen",
        "scope": "lua",
        "description": "Open this FX UI. See TakeFX_GetOpen\n",
        "body": "reaper.TakeFX_SetOpen(${1:MediaItem_Take take},${2:integer fx},${3:boolean open})$0"
    },
    "RPR_TAKEFX_SETOPEN python": {
        "prefix": "RPR_TakeFX_SetOpen",
        "scope": "python",
        "description": "Open this FX UI. See TakeFX_GetOpen\n",
        "body": "RPR_TakeFX_SetOpen(${1:MediaItem_Take take},${2:Int fx},${3:Boolean open})$0"
    },
    "TAKEFX_SETPARAM c": {
        "prefix": "TakeFX_SetParam",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_SetParam(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:double val})$0"
    },
    "TAKEFX_SETPARAM eel2": {
        "prefix": "TakeFX_SetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_SetParam(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:val})$0"
    },
    "REAPER.TAKEFX_SETPARAM lua": {
        "prefix": "reaper.TakeFX_SetParam",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_SetParam(${1:MediaItem_Take take},${2:integer fx},${3:integer param},${4:number val})$0"
    },
    "RPR_TAKEFX_SETPARAM python": {
        "prefix": "RPR_TakeFX_SetParam",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_SetParam(${1:MediaItem_Take take},${2:Int fx},${3:Int param},${4:Float val})$0"
    },
    "TAKEFX_SETPARAMNORMALIZED c": {
        "prefix": "TakeFX_SetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "TakeFX_SetParamNormalized(${1:MediaItem_Take* take},${2:int fx},${3:int param},${4:double value})$0"
    },
    "TAKEFX_SETPARAMNORMALIZED eel2": {
        "prefix": "TakeFX_SetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "TakeFX_SetParamNormalized(${1:MediaItem_Take take},${2:int fx},${3:int param},${4:value})$0"
    },
    "REAPER.TAKEFX_SETPARAMNORMALIZED lua": {
        "prefix": "reaper.TakeFX_SetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TakeFX_SetParamNormalized(${1:MediaItem_Take take},${2:integer fx},${3:integer param},${4:number value})$0"
    },
    "RPR_TAKEFX_SETPARAMNORMALIZED python": {
        "prefix": "RPR_TakeFX_SetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TakeFX_SetParamNormalized(${1:MediaItem_Take take},${2:Int fx},${3:Int param},${4:Float value})$0"
    },
    "TAKEFX_SETPINMAPPINGS c": {
        "prefix": "TakeFX_SetPinMappings",
        "scope": "c",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "TakeFX_SetPinMappings(${1:MediaItem_Take* tr},${2:int fx},${3:int isoutput},${4:int pin},${5:int low32bits},${6:int hi32bits})$0"
    },
    "TAKEFX_SETPINMAPPINGS eel2": {
        "prefix": "TakeFX_SetPinMappings",
        "scope": "eel2",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "TakeFX_SetPinMappings(${1:MediaItem_Take tr},${2:int fx},${3:int isoutput},${4:int pin},${5:int low32bits},${6:int hi32bits})$0"
    },
    "REAPER.TAKEFX_SETPINMAPPINGS lua": {
        "prefix": "reaper.TakeFX_SetPinMappings",
        "scope": "lua",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "reaper.TakeFX_SetPinMappings(${1:MediaItem_Take tr},${2:integer fx},${3:integer isoutput},${4:integer pin},${5:integer low32bits},${6:integer hi32bits})$0"
    },
    "RPR_TAKEFX_SETPINMAPPINGS python": {
        "prefix": "RPR_TakeFX_SetPinMappings",
        "scope": "python",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "RPR_TakeFX_SetPinMappings(${1:MediaItem_Take tr},${2:Int fx},${3:Int isoutput},${4:Int pin},${5:Int low32bits},${6:Int hi32bits})$0"
    },
    "TAKEFX_SETPRESET c": {
        "prefix": "TakeFX_SetPreset",
        "scope": "c",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "TakeFX_SetPreset(${1:MediaItem_Take* take},${2:int fx},${3:const char* presetname})$0"
    },
    "TAKEFX_SETPRESET eel2": {
        "prefix": "TakeFX_SetPreset",
        "scope": "eel2",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "TakeFX_SetPreset(${1:MediaItem_Take take},${2:int fx},${3:\"presetname\"})$0"
    },
    "REAPER.TAKEFX_SETPRESET lua": {
        "prefix": "reaper.TakeFX_SetPreset",
        "scope": "lua",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "reaper.TakeFX_SetPreset(${1:MediaItem_Take take},${2:integer fx},${3:string presetname})$0"
    },
    "RPR_TAKEFX_SETPRESET python": {
        "prefix": "RPR_TakeFX_SetPreset",
        "scope": "python",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "RPR_TakeFX_SetPreset(${1:MediaItem_Take take},${2:Int fx},${3:String presetname})$0"
    },
    "TAKEFX_SETPRESETBYINDEX c": {
        "prefix": "TakeFX_SetPresetByIndex",
        "scope": "c",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "TakeFX_SetPresetByIndex(${1:MediaItem_Take* take},${2:int fx},${3:int idx})$0"
    },
    "TAKEFX_SETPRESETBYINDEX eel2": {
        "prefix": "TakeFX_SetPresetByIndex",
        "scope": "eel2",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "TakeFX_SetPresetByIndex(${1:MediaItem_Take take},${2:int fx},${3:int idx})$0"
    },
    "REAPER.TAKEFX_SETPRESETBYINDEX lua": {
        "prefix": "reaper.TakeFX_SetPresetByIndex",
        "scope": "lua",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "reaper.TakeFX_SetPresetByIndex(${1:MediaItem_Take take},${2:integer fx},${3:integer idx})$0"
    },
    "RPR_TAKEFX_SETPRESETBYINDEX python": {
        "prefix": "RPR_TakeFX_SetPresetByIndex",
        "scope": "python",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "RPR_TakeFX_SetPresetByIndex(${1:MediaItem_Take take},${2:Int fx},${3:Int idx})$0"
    },
    "TAKEFX_SHOW c": {
        "prefix": "TakeFX_Show",
        "scope": "c",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "TakeFX_Show(${1:MediaItem_Take* take},${2:int index},${3:int showFlag})$0"
    },
    "TAKEFX_SHOW eel2": {
        "prefix": "TakeFX_Show",
        "scope": "eel2",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "TakeFX_Show(${1:MediaItem_Take take},${2:int index},${3:int showFlag})$0"
    },
    "REAPER.TAKEFX_SHOW lua": {
        "prefix": "reaper.TakeFX_Show",
        "scope": "lua",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "reaper.TakeFX_Show(${1:MediaItem_Take take},${2:integer index},${3:integer showFlag})$0"
    },
    "RPR_TAKEFX_SHOW python": {
        "prefix": "RPR_TakeFX_Show",
        "scope": "python",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "RPR_TakeFX_Show(${1:MediaItem_Take take},${2:Int index},${3:Int showFlag})$0"
    },
    "TAKEISMIDI c": {
        "prefix": "TakeIsMIDI",
        "scope": "c",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "TakeIsMIDI(${1:MediaItem_Take* take})$0"
    },
    "TAKEISMIDI eel2": {
        "prefix": "TakeIsMIDI",
        "scope": "eel2",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "TakeIsMIDI(${1:MediaItem_Take take})$0"
    },
    "REAPER.TAKEISMIDI lua": {
        "prefix": "reaper.TakeIsMIDI",
        "scope": "lua",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "reaper.TakeIsMIDI(${1:MediaItem_Take take})$0"
    },
    "RPR_TAKEISMIDI python": {
        "prefix": "RPR_TakeIsMIDI",
        "scope": "python",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "RPR_TakeIsMIDI(${1:MediaItem_Take take})$0"
    },
    "THEMELAYOUT_GETLAYOUT c": {
        "prefix": "ThemeLayout_GetLayout",
        "scope": "c",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "ThemeLayout_GetLayout(${1:const char* section},${2:int idx},${3:char* nameOut},${4:int nameOut_sz})$0"
    },
    "THEMELAYOUT_GETLAYOUT eel2": {
        "prefix": "ThemeLayout_GetLayout",
        "scope": "eel2",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "ThemeLayout_GetLayout(${1:\"section\"},${2:int idx},${3:#name})$0"
    },
    "REAPER.THEMELAYOUT_GETLAYOUT lua": {
        "prefix": "reaper.ThemeLayout_GetLayout",
        "scope": "lua",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "reaper.ThemeLayout_GetLayout(${1:string section},${2:integer idx})$0"
    },
    "RPR_THEMELAYOUT_GETLAYOUT python": {
        "prefix": "RPR_ThemeLayout_GetLayout",
        "scope": "python",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "RPR_ThemeLayout_GetLayout(${1:section},${2:idx},${3:nameOut},${4:nameOut_sz})$0"
    },
    "THEMELAYOUT_GETPARAMETER c": {
        "prefix": "ThemeLayout_GetParameter",
        "scope": "c",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "ThemeLayout_GetParameter(${1:int wp},${2:const char** descOutOptional},${3:int* valueOutOptional},${4:int* defValueOutOptional},${5:int* minValueOutOptional},${6:int* maxValueOutOptional})$0"
    },
    "THEMELAYOUT_GETPARAMETER eel2": {
        "prefix": "ThemeLayout_GetParameter",
        "scope": "eel2",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "ThemeLayout_GetParameter(${1:#retval},${2:int wp},${3:optional #desc},${4:optional int &value},${5:optional int &defValue},${6:optional int &minValue},${7:optional int &maxValue})$0"
    },
    "REAPER.THEMELAYOUT_GETPARAMETER lua": {
        "prefix": "reaper.ThemeLayout_GetParameter",
        "scope": "lua",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "reaper.ThemeLayout_GetParameter(${1:integer wp})$0"
    },
    "RPR_THEMELAYOUT_GETPARAMETER python": {
        "prefix": "RPR_ThemeLayout_GetParameter",
        "scope": "python",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "RPR_ThemeLayout_GetParameter(${1:wp},${2:descOutOptional},${3:valueOutOptional},${4:defValueOutOptional},${5:minValueOutOptional},${6:maxValueOutOptional})$0"
    },
    "THEMELAYOUT_REFRESHALL c": {
        "prefix": "ThemeLayout_RefreshAll",
        "scope": "c",
        "description": "Refreshes all layouts\n",
        "body": "ThemeLayout_RefreshAll()$0"
    },
    "THEMELAYOUT_REFRESHALL eel2": {
        "prefix": "ThemeLayout_RefreshAll",
        "scope": "eel2",
        "description": "Refreshes all layouts\n",
        "body": "ThemeLayout_RefreshAll()$0"
    },
    "REAPER.THEMELAYOUT_REFRESHALL lua": {
        "prefix": "reaper.ThemeLayout_RefreshAll",
        "scope": "lua",
        "description": "Refreshes all layouts\n",
        "body": "reaper.ThemeLayout_RefreshAll()$0"
    },
    "RPR_THEMELAYOUT_REFRESHALL python": {
        "prefix": "RPR_ThemeLayout_RefreshAll",
        "scope": "python",
        "description": "Refreshes all layouts\n",
        "body": "RPR_ThemeLayout_RefreshAll()$0"
    },
    "THEMELAYOUT_SETLAYOUT c": {
        "prefix": "ThemeLayout_SetLayout",
        "scope": "c",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "ThemeLayout_SetLayout(${1:const char* section},${2:const char*  layout})$0"
    },
    "THEMELAYOUT_SETLAYOUT eel2": {
        "prefix": "ThemeLayout_SetLayout",
        "scope": "eel2",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "ThemeLayout_SetLayout(${1:\"section\"},${2:\" layout\"})$0"
    },
    "REAPER.THEMELAYOUT_SETLAYOUT lua": {
        "prefix": "reaper.ThemeLayout_SetLayout",
        "scope": "lua",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "reaper.ThemeLayout_SetLayout(${1:string section},${2:string  layout})$0"
    },
    "RPR_THEMELAYOUT_SETLAYOUT python": {
        "prefix": "RPR_ThemeLayout_SetLayout",
        "scope": "python",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "RPR_ThemeLayout_SetLayout(${1:String section},${2:String  layout})$0"
    },
    "THEMELAYOUT_SETPARAMETER c": {
        "prefix": "ThemeLayout_SetParameter",
        "scope": "c",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "ThemeLayout_SetParameter(${1:int wp},${2:int value},${3:bool persist})$0"
    },
    "THEMELAYOUT_SETPARAMETER eel2": {
        "prefix": "ThemeLayout_SetParameter",
        "scope": "eel2",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "ThemeLayout_SetParameter(${1:int wp},${2:int value},${3:bool persist})$0"
    },
    "REAPER.THEMELAYOUT_SETPARAMETER lua": {
        "prefix": "reaper.ThemeLayout_SetParameter",
        "scope": "lua",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "reaper.ThemeLayout_SetParameter(${1:integer wp},${2:integer value},${3:boolean persist})$0"
    },
    "RPR_THEMELAYOUT_SETPARAMETER python": {
        "prefix": "RPR_ThemeLayout_SetParameter",
        "scope": "python",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "RPR_ThemeLayout_SetParameter(${1:Int wp},${2:Int value},${3:Boolean persist})$0"
    },
    "TIME_PRECISE c": {
        "prefix": "time_precise",
        "scope": "c",
        "description": "Gets a precise system timestamp in seconds\n",
        "body": "time_precise()$0"
    },
    "REAPER.TIME_PRECISE lua": {
        "prefix": "reaper.time_precise",
        "scope": "lua",
        "description": "Gets a precise system timestamp in seconds\n",
        "body": "reaper.time_precise()$0"
    },
    "RPR_TIME_PRECISE python": {
        "prefix": "RPR_time_precise",
        "scope": "python",
        "description": "Gets a precise system timestamp in seconds\n",
        "body": "RPR_time_precise()$0"
    },
    "TIMEMAP2_BEATSTOTIME c": {
        "prefix": "TimeMap2_beatsToTime",
        "scope": "c",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "TimeMap2_beatsToTime(${1:ReaProject* proj},${2:double tpos},${3:const int* measuresInOptional})$0"
    },
    "TIMEMAP2_BEATSTOTIME eel2": {
        "prefix": "TimeMap2_beatsToTime",
        "scope": "eel2",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "TimeMap2_beatsToTime(${1:ReaProject proj},${2:tpos},${3:optional int measuresIn})$0"
    },
    "REAPER.TIMEMAP2_BEATSTOTIME lua": {
        "prefix": "reaper.TimeMap2_beatsToTime",
        "scope": "lua",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "reaper.TimeMap2_beatsToTime(${1:ReaProject proj},${2:number tpos},${3:optional number measuresIn})$0"
    },
    "RPR_TIMEMAP2_BEATSTOTIME python": {
        "prefix": "RPR_TimeMap2_beatsToTime",
        "scope": "python",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "RPR_TimeMap2_beatsToTime(${1:ReaProject proj},${2:Float tpos},${3:const int measuresInOptional})$0"
    },
    "TIMEMAP2_GETDIVIDEDBPMATTIME c": {
        "prefix": "TimeMap2_GetDividedBpmAtTime",
        "scope": "c",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "TimeMap2_GetDividedBpmAtTime(${1:ReaProject* proj},${2:double time})$0"
    },
    "TIMEMAP2_GETDIVIDEDBPMATTIME eel2": {
        "prefix": "TimeMap2_GetDividedBpmAtTime",
        "scope": "eel2",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "TimeMap2_GetDividedBpmAtTime(${1:ReaProject proj},${2:time})$0"
    },
    "REAPER.TIMEMAP2_GETDIVIDEDBPMATTIME lua": {
        "prefix": "reaper.TimeMap2_GetDividedBpmAtTime",
        "scope": "lua",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "reaper.TimeMap2_GetDividedBpmAtTime(${1:ReaProject proj},${2:number time})$0"
    },
    "RPR_TIMEMAP2_GETDIVIDEDBPMATTIME python": {
        "prefix": "RPR_TimeMap2_GetDividedBpmAtTime",
        "scope": "python",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "RPR_TimeMap2_GetDividedBpmAtTime(${1:ReaProject proj},${2:Float time})$0"
    },
    "TIMEMAP2_GETNEXTCHANGETIME c": {
        "prefix": "TimeMap2_GetNextChangeTime",
        "scope": "c",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "TimeMap2_GetNextChangeTime(${1:ReaProject* proj},${2:double time})$0"
    },
    "TIMEMAP2_GETNEXTCHANGETIME eel2": {
        "prefix": "TimeMap2_GetNextChangeTime",
        "scope": "eel2",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "TimeMap2_GetNextChangeTime(${1:ReaProject proj},${2:time})$0"
    },
    "REAPER.TIMEMAP2_GETNEXTCHANGETIME lua": {
        "prefix": "reaper.TimeMap2_GetNextChangeTime",
        "scope": "lua",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "reaper.TimeMap2_GetNextChangeTime(${1:ReaProject proj},${2:number time})$0"
    },
    "RPR_TIMEMAP2_GETNEXTCHANGETIME python": {
        "prefix": "RPR_TimeMap2_GetNextChangeTime",
        "scope": "python",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "RPR_TimeMap2_GetNextChangeTime(${1:ReaProject proj},${2:Float time})$0"
    },
    "TIMEMAP2_QNTOTIME c": {
        "prefix": "TimeMap2_QNToTime",
        "scope": "c",
        "description": "converts project QN position to time.\n",
        "body": "TimeMap2_QNToTime(${1:ReaProject* proj},${2:double qn})$0"
    },
    "TIMEMAP2_QNTOTIME eel2": {
        "prefix": "TimeMap2_QNToTime",
        "scope": "eel2",
        "description": "converts project QN position to time.\n",
        "body": "TimeMap2_QNToTime(${1:ReaProject proj},${2:qn})$0"
    },
    "REAPER.TIMEMAP2_QNTOTIME lua": {
        "prefix": "reaper.TimeMap2_QNToTime",
        "scope": "lua",
        "description": "converts project QN position to time.\n",
        "body": "reaper.TimeMap2_QNToTime(${1:ReaProject proj},${2:number qn})$0"
    },
    "RPR_TIMEMAP2_QNTOTIME python": {
        "prefix": "RPR_TimeMap2_QNToTime",
        "scope": "python",
        "description": "converts project QN position to time.\n",
        "body": "RPR_TimeMap2_QNToTime(${1:ReaProject proj},${2:Float qn})$0"
    },
    "TIMEMAP2_TIMETOBEATS c": {
        "prefix": "TimeMap2_timeToBeats",
        "scope": "c",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "TimeMap2_timeToBeats(${1:ReaProject* proj},${2:double tpos},${3:int* measuresOutOptional},${4:int* cmlOutOptional},${5:double* fullbeatsOutOptional},${6:int* cdenomOutOptional})$0"
    },
    "TIMEMAP2_TIMETOBEATS eel2": {
        "prefix": "TimeMap2_timeToBeats",
        "scope": "eel2",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "TimeMap2_timeToBeats(${1:ReaProject proj},${2:tpos},${3:optional int &measures},${4:optional int &cml},${5:optional &fullbeats},${6:optional int &cdenom})$0"
    },
    "REAPER.TIMEMAP2_TIMETOBEATS lua": {
        "prefix": "reaper.TimeMap2_timeToBeats",
        "scope": "lua",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "reaper.TimeMap2_timeToBeats(${1:ReaProject proj},${2:number tpos})$0"
    },
    "RPR_TIMEMAP2_TIMETOBEATS python": {
        "prefix": "RPR_TimeMap2_timeToBeats",
        "scope": "python",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "RPR_TimeMap2_timeToBeats(${1:proj},${2:tpos},${3:measuresOutOptional},${4:cmlOutOptional},${5:fullbeatsOutOptional},${6:cdenomOutOptional})$0"
    },
    "TIMEMAP2_TIMETOQN c": {
        "prefix": "TimeMap2_timeToQN",
        "scope": "c",
        "description": "converts project time position to QN position.\n",
        "body": "TimeMap2_timeToQN(${1:ReaProject* proj},${2:double tpos})$0"
    },
    "TIMEMAP2_TIMETOQN eel2": {
        "prefix": "TimeMap2_timeToQN",
        "scope": "eel2",
        "description": "converts project time position to QN position.\n",
        "body": "TimeMap2_timeToQN(${1:ReaProject proj},${2:tpos})$0"
    },
    "REAPER.TIMEMAP2_TIMETOQN lua": {
        "prefix": "reaper.TimeMap2_timeToQN",
        "scope": "lua",
        "description": "converts project time position to QN position.\n",
        "body": "reaper.TimeMap2_timeToQN(${1:ReaProject proj},${2:number tpos})$0"
    },
    "RPR_TIMEMAP2_TIMETOQN python": {
        "prefix": "RPR_TimeMap2_timeToQN",
        "scope": "python",
        "description": "converts project time position to QN position.\n",
        "body": "RPR_TimeMap2_timeToQN(${1:ReaProject proj},${2:Float tpos})$0"
    },
    "TIMEMAP_CURFRAMERATE c": {
        "prefix": "TimeMap_curFrameRate",
        "scope": "c",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "TimeMap_curFrameRate(${1:ReaProject* proj},${2:bool* dropFrameOutOptional})$0"
    },
    "TIMEMAP_CURFRAMERATE eel2": {
        "prefix": "TimeMap_curFrameRate",
        "scope": "eel2",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "TimeMap_curFrameRate(${1:ReaProject proj},${2:optional bool &dropFrame})$0"
    },
    "REAPER.TIMEMAP_CURFRAMERATE lua": {
        "prefix": "reaper.TimeMap_curFrameRate",
        "scope": "lua",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "reaper.TimeMap_curFrameRate(${1:ReaProject proj})$0"
    },
    "RPR_TIMEMAP_CURFRAMERATE python": {
        "prefix": "RPR_TimeMap_curFrameRate",
        "scope": "python",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "RPR_TimeMap_curFrameRate(${1:proj},${2:dropFrameOutOptional})$0"
    },
    "TIMEMAP_GETDIVIDEDBPMATTIME c": {
        "prefix": "TimeMap_GetDividedBpmAtTime",
        "scope": "c",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "TimeMap_GetDividedBpmAtTime(${1:double time})$0"
    },
    "TIMEMAP_GETDIVIDEDBPMATTIME eel2": {
        "prefix": "TimeMap_GetDividedBpmAtTime",
        "scope": "eel2",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "TimeMap_GetDividedBpmAtTime(${1:time})$0"
    },
    "REAPER.TIMEMAP_GETDIVIDEDBPMATTIME lua": {
        "prefix": "reaper.TimeMap_GetDividedBpmAtTime",
        "scope": "lua",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "reaper.TimeMap_GetDividedBpmAtTime(${1:number time})$0"
    },
    "RPR_TIMEMAP_GETDIVIDEDBPMATTIME python": {
        "prefix": "RPR_TimeMap_GetDividedBpmAtTime",
        "scope": "python",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "RPR_TimeMap_GetDividedBpmAtTime(${1:Float time})$0"
    },
    "TIMEMAP_GETMEASUREINFO c": {
        "prefix": "TimeMap_GetMeasureInfo",
        "scope": "c",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "TimeMap_GetMeasureInfo(${1:ReaProject* proj},${2:int measure},${3:double* qn_startOut},${4:double* qn_endOut},${5:int* timesig_numOut},${6:int* timesig_denomOut},${7:double* tempoOut})$0"
    },
    "TIMEMAP_GETMEASUREINFO eel2": {
        "prefix": "TimeMap_GetMeasureInfo",
        "scope": "eel2",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "TimeMap_GetMeasureInfo(${1:ReaProject proj},${2:int measure},${3:&qn_start},${4:&qn_end},${5:int &timesig_num},${6:int &timesig_denom},${7:&tempo})$0"
    },
    "REAPER.TIMEMAP_GETMEASUREINFO lua": {
        "prefix": "reaper.TimeMap_GetMeasureInfo",
        "scope": "lua",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "reaper.TimeMap_GetMeasureInfo(${1:ReaProject proj},${2:integer measure})$0"
    },
    "RPR_TIMEMAP_GETMEASUREINFO python": {
        "prefix": "RPR_TimeMap_GetMeasureInfo",
        "scope": "python",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "RPR_TimeMap_GetMeasureInfo(${1:proj},${2:measure},${3:qn_startOut},${4:qn_endOut},${5:timesig_numOut},${6:timesig_denomOut},${7:tempoOut})$0"
    },
    "TIMEMAP_GETMETRONOMEPATTERN c": {
        "prefix": "TimeMap_GetMetronomePattern",
        "scope": "c",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "TimeMap_GetMetronomePattern(${1:ReaProject* proj},${2:double time},${3:char* pattern},${4:int pattern_sz})$0"
    },
    "TIMEMAP_GETMETRONOMEPATTERN eel2": {
        "prefix": "TimeMap_GetMetronomePattern",
        "scope": "eel2",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "TimeMap_GetMetronomePattern(${1:ReaProject proj},${2:time},${3:#pattern})$0"
    },
    "REAPER.TIMEMAP_GETMETRONOMEPATTERN lua": {
        "prefix": "reaper.TimeMap_GetMetronomePattern",
        "scope": "lua",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "reaper.TimeMap_GetMetronomePattern(${1:ReaProject proj},${2:number time},${3:string pattern})$0"
    },
    "RPR_TIMEMAP_GETMETRONOMEPATTERN python": {
        "prefix": "RPR_TimeMap_GetMetronomePattern",
        "scope": "python",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "RPR_TimeMap_GetMetronomePattern(${1:proj},${2:time},${3:pattern},${4:pattern_sz})$0"
    },
    "TIMEMAP_GETTIMESIGATTIME c": {
        "prefix": "TimeMap_GetTimeSigAtTime",
        "scope": "c",
        "description": "get the effective time signature and tempo\n",
        "body": "TimeMap_GetTimeSigAtTime(${1:ReaProject* proj},${2:double time},${3:int* timesig_numOut},${4:int* timesig_denomOut},${5:double* tempoOut})$0"
    },
    "TIMEMAP_GETTIMESIGATTIME eel2": {
        "prefix": "TimeMap_GetTimeSigAtTime",
        "scope": "eel2",
        "description": "get the effective time signature and tempo\n",
        "body": "TimeMap_GetTimeSigAtTime(${1:ReaProject proj},${2:time},${3:int &timesig_num},${4:int &timesig_denom},${5:&tempo})$0"
    },
    "REAPER.TIMEMAP_GETTIMESIGATTIME lua": {
        "prefix": "reaper.TimeMap_GetTimeSigAtTime",
        "scope": "lua",
        "description": "get the effective time signature and tempo\n",
        "body": "reaper.TimeMap_GetTimeSigAtTime(${1:ReaProject proj},${2:number time})$0"
    },
    "RPR_TIMEMAP_GETTIMESIGATTIME python": {
        "prefix": "RPR_TimeMap_GetTimeSigAtTime",
        "scope": "python",
        "description": "get the effective time signature and tempo\n",
        "body": "RPR_TimeMap_GetTimeSigAtTime(${1:proj},${2:time},${3:timesig_numOut},${4:timesig_denomOut},${5:tempoOut})$0"
    },
    "TIMEMAP_QNTOMEASURES c": {
        "prefix": "TimeMap_QNToMeasures",
        "scope": "c",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "TimeMap_QNToMeasures(${1:ReaProject* proj},${2:double qn},${3:double* qnMeasureStartOutOptional},${4:double* qnMeasureEndOutOptional})$0"
    },
    "TIMEMAP_QNTOMEASURES eel2": {
        "prefix": "TimeMap_QNToMeasures",
        "scope": "eel2",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "TimeMap_QNToMeasures(${1:ReaProject proj},${2:qn},${3:optional &qnMeasureStart},${4:optional &qnMeasureEnd})$0"
    },
    "REAPER.TIMEMAP_QNTOMEASURES lua": {
        "prefix": "reaper.TimeMap_QNToMeasures",
        "scope": "lua",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "reaper.TimeMap_QNToMeasures(${1:ReaProject proj},${2:number qn})$0"
    },
    "RPR_TIMEMAP_QNTOMEASURES python": {
        "prefix": "RPR_TimeMap_QNToMeasures",
        "scope": "python",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "RPR_TimeMap_QNToMeasures(${1:proj},${2:qn},${3:qnMeasureStartOutOptional},${4:qnMeasureEndOutOptional})$0"
    },
    "TIMEMAP_QNTOTIME c": {
        "prefix": "TimeMap_QNToTime",
        "scope": "c",
        "description": "converts project QN position to time.\n",
        "body": "TimeMap_QNToTime(${1:double qn})$0"
    },
    "TIMEMAP_QNTOTIME eel2": {
        "prefix": "TimeMap_QNToTime",
        "scope": "eel2",
        "description": "converts project QN position to time.\n",
        "body": "TimeMap_QNToTime(${1:qn})$0"
    },
    "REAPER.TIMEMAP_QNTOTIME lua": {
        "prefix": "reaper.TimeMap_QNToTime",
        "scope": "lua",
        "description": "converts project QN position to time.\n",
        "body": "reaper.TimeMap_QNToTime(${1:number qn})$0"
    },
    "RPR_TIMEMAP_QNTOTIME python": {
        "prefix": "RPR_TimeMap_QNToTime",
        "scope": "python",
        "description": "converts project QN position to time.\n",
        "body": "RPR_TimeMap_QNToTime(${1:Float qn})$0"
    },
    "TIMEMAP_QNTOTIME_ABS c": {
        "prefix": "TimeMap_QNToTime_abs",
        "scope": "c",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "TimeMap_QNToTime_abs(${1:ReaProject* proj},${2:double qn})$0"
    },
    "TIMEMAP_QNTOTIME_ABS eel2": {
        "prefix": "TimeMap_QNToTime_abs",
        "scope": "eel2",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "TimeMap_QNToTime_abs(${1:ReaProject proj},${2:qn})$0"
    },
    "REAPER.TIMEMAP_QNTOTIME_ABS lua": {
        "prefix": "reaper.TimeMap_QNToTime_abs",
        "scope": "lua",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "reaper.TimeMap_QNToTime_abs(${1:ReaProject proj},${2:number qn})$0"
    },
    "RPR_TIMEMAP_QNTOTIME_ABS python": {
        "prefix": "RPR_TimeMap_QNToTime_abs",
        "scope": "python",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "RPR_TimeMap_QNToTime_abs(${1:ReaProject proj},${2:Float qn})$0"
    },
    "TIMEMAP_TIMETOQN c": {
        "prefix": "TimeMap_timeToQN",
        "scope": "c",
        "description": "converts project QN position to time.\n",
        "body": "TimeMap_timeToQN(${1:double tpos})$0"
    },
    "TIMEMAP_TIMETOQN eel2": {
        "prefix": "TimeMap_timeToQN",
        "scope": "eel2",
        "description": "converts project QN position to time.\n",
        "body": "TimeMap_timeToQN(${1:tpos})$0"
    },
    "REAPER.TIMEMAP_TIMETOQN lua": {
        "prefix": "reaper.TimeMap_timeToQN",
        "scope": "lua",
        "description": "converts project QN position to time.\n",
        "body": "reaper.TimeMap_timeToQN(${1:number tpos})$0"
    },
    "RPR_TIMEMAP_TIMETOQN python": {
        "prefix": "RPR_TimeMap_timeToQN",
        "scope": "python",
        "description": "converts project QN position to time.\n",
        "body": "RPR_TimeMap_timeToQN(${1:Float tpos})$0"
    },
    "TIMEMAP_TIMETOQN_ABS c": {
        "prefix": "TimeMap_timeToQN_abs",
        "scope": "c",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "TimeMap_timeToQN_abs(${1:ReaProject* proj},${2:double tpos})$0"
    },
    "TIMEMAP_TIMETOQN_ABS eel2": {
        "prefix": "TimeMap_timeToQN_abs",
        "scope": "eel2",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "TimeMap_timeToQN_abs(${1:ReaProject proj},${2:tpos})$0"
    },
    "REAPER.TIMEMAP_TIMETOQN_ABS lua": {
        "prefix": "reaper.TimeMap_timeToQN_abs",
        "scope": "lua",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "reaper.TimeMap_timeToQN_abs(${1:ReaProject proj},${2:number tpos})$0"
    },
    "RPR_TIMEMAP_TIMETOQN_ABS python": {
        "prefix": "RPR_TimeMap_timeToQN_abs",
        "scope": "python",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "RPR_TimeMap_timeToQN_abs(${1:ReaProject proj},${2:Float tpos})$0"
    },
    "TOGGLETRACKSENDUIMUTE c": {
        "prefix": "ToggleTrackSendUIMute",
        "scope": "c",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "ToggleTrackSendUIMute(${1:MediaTrack* track},${2:int send_idx})$0"
    },
    "TOGGLETRACKSENDUIMUTE eel2": {
        "prefix": "ToggleTrackSendUIMute",
        "scope": "eel2",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "ToggleTrackSendUIMute(${1:MediaTrack track},${2:int send_idx})$0"
    },
    "REAPER.TOGGLETRACKSENDUIMUTE lua": {
        "prefix": "reaper.ToggleTrackSendUIMute",
        "scope": "lua",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "reaper.ToggleTrackSendUIMute(${1:MediaTrack track},${2:integer send_idx})$0"
    },
    "RPR_TOGGLETRACKSENDUIMUTE python": {
        "prefix": "RPR_ToggleTrackSendUIMute",
        "scope": "python",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "RPR_ToggleTrackSendUIMute(${1:MediaTrack track},${2:Int send_idx})$0"
    },
    "TRACK_GETPEAKHOLDDB c": {
        "prefix": "Track_GetPeakHoldDB",
        "scope": "c",
        "description": "\n",
        "body": "Track_GetPeakHoldDB(${1:MediaTrack* track},${2:int channel},${3:bool clear})$0"
    },
    "TRACK_GETPEAKHOLDDB eel2": {
        "prefix": "Track_GetPeakHoldDB",
        "scope": "eel2",
        "description": "\n",
        "body": "Track_GetPeakHoldDB(${1:MediaTrack track},${2:int channel},${3:bool clear})$0"
    },
    "REAPER.TRACK_GETPEAKHOLDDB lua": {
        "prefix": "reaper.Track_GetPeakHoldDB",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Track_GetPeakHoldDB(${1:MediaTrack track},${2:integer channel},${3:boolean clear})$0"
    },
    "RPR_TRACK_GETPEAKHOLDDB python": {
        "prefix": "RPR_Track_GetPeakHoldDB",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Track_GetPeakHoldDB(${1:MediaTrack track},${2:Int channel},${3:Boolean clear})$0"
    },
    "TRACK_GETPEAKINFO c": {
        "prefix": "Track_GetPeakInfo",
        "scope": "c",
        "description": "\n",
        "body": "Track_GetPeakInfo(${1:MediaTrack* track},${2:int channel})$0"
    },
    "TRACK_GETPEAKINFO eel2": {
        "prefix": "Track_GetPeakInfo",
        "scope": "eel2",
        "description": "\n",
        "body": "Track_GetPeakInfo(${1:MediaTrack track},${2:int channel})$0"
    },
    "REAPER.TRACK_GETPEAKINFO lua": {
        "prefix": "reaper.Track_GetPeakInfo",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Track_GetPeakInfo(${1:MediaTrack track},${2:integer channel})$0"
    },
    "RPR_TRACK_GETPEAKINFO python": {
        "prefix": "RPR_Track_GetPeakInfo",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Track_GetPeakInfo(${1:MediaTrack track},${2:Int channel})$0"
    },
    "TRACKCTL_SETTOOLTIP c": {
        "prefix": "TrackCtl_SetToolTip",
        "scope": "c",
        "description": "displays tooltip at location, or removes if empty string\n",
        "body": "TrackCtl_SetToolTip(${1:const char* fmt},${2:int xpos},${3:int ypos},${4:bool topmost})$0"
    },
    "TRACKCTL_SETTOOLTIP eel2": {
        "prefix": "TrackCtl_SetToolTip",
        "scope": "eel2",
        "description": "displays tooltip at location, or removes if empty string\n",
        "body": "TrackCtl_SetToolTip(${1:\"fmt\"},${2:int xpos},${3:int ypos},${4:bool topmost})$0"
    },
    "REAPER.TRACKCTL_SETTOOLTIP lua": {
        "prefix": "reaper.TrackCtl_SetToolTip",
        "scope": "lua",
        "description": "displays tooltip at location, or removes if empty string\n",
        "body": "reaper.TrackCtl_SetToolTip(${1:string fmt},${2:integer xpos},${3:integer ypos},${4:boolean topmost})$0"
    },
    "RPR_TRACKCTL_SETTOOLTIP python": {
        "prefix": "RPR_TrackCtl_SetToolTip",
        "scope": "python",
        "description": "displays tooltip at location, or removes if empty string\n",
        "body": "RPR_TrackCtl_SetToolTip(${1:String fmt},${2:Int xpos},${3:Int ypos},${4:Boolean topmost})$0"
    },
    "TRACKFX_ADDBYNAME c": {
        "prefix": "TrackFX_AddByName",
        "scope": "c",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "TrackFX_AddByName(${1:MediaTrack* track},${2:const char* fxname},${3:bool recFX},${4:int instantiate})$0"
    },
    "TRACKFX_ADDBYNAME eel2": {
        "prefix": "TrackFX_AddByName",
        "scope": "eel2",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "TrackFX_AddByName(${1:MediaTrack track},${2:\"fxname\"},${3:bool recFX},${4:int instantiate})$0"
    },
    "REAPER.TRACKFX_ADDBYNAME lua": {
        "prefix": "reaper.TrackFX_AddByName",
        "scope": "lua",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "reaper.TrackFX_AddByName(${1:MediaTrack track},${2:string fxname},${3:boolean recFX},${4:integer instantiate})$0"
    },
    "RPR_TRACKFX_ADDBYNAME python": {
        "prefix": "RPR_TrackFX_AddByName",
        "scope": "python",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "RPR_TrackFX_AddByName(${1:MediaTrack track},${2:String fxname},${3:Boolean recFX},${4:Int instantiate})$0"
    },
    "TRACKFX_COPYTOTAKE c": {
        "prefix": "TrackFX_CopyToTake",
        "scope": "c",
        "description": "Copies (or moves) FX from src_track to dest_take. src_fx can have 0x1000000 set to reference input FX.\n",
        "body": "TrackFX_CopyToTake(${1:MediaTrack* src_track},${2:int src_fx},${3:MediaItem_Take* dest_take},${4:int dest_fx},${5:bool is_move})$0"
    },
    "TRACKFX_COPYTOTAKE eel2": {
        "prefix": "TrackFX_CopyToTake",
        "scope": "eel2",
        "description": "Copies (or moves) FX from src_track to dest_take. src_fx can have 0x1000000 set to reference input FX.\n",
        "body": "TrackFX_CopyToTake(${1:MediaTrack src_track},${2:int src_fx},${3:MediaItem_Take dest_take},${4:int dest_fx},${5:bool is_move})$0"
    },
    "REAPER.TRACKFX_COPYTOTAKE lua": {
        "prefix": "reaper.TrackFX_CopyToTake",
        "scope": "lua",
        "description": "Copies (or moves) FX from src_track to dest_take. src_fx can have 0x1000000 set to reference input FX.\n",
        "body": "reaper.TrackFX_CopyToTake(${1:MediaTrack src_track},${2:integer src_fx},${3:MediaItem_Take dest_take},${4:integer dest_fx},${5:boolean is_move})$0"
    },
    "RPR_TRACKFX_COPYTOTAKE python": {
        "prefix": "RPR_TrackFX_CopyToTake",
        "scope": "python",
        "description": "Copies (or moves) FX from src_track to dest_take. src_fx can have 0x1000000 set to reference input FX.\n",
        "body": "RPR_TrackFX_CopyToTake(${1:MediaTrack src_track},${2:Int src_fx},${3:MediaItem_Take dest_take},${4:Int dest_fx},${5:Boolean is_move})$0"
    },
    "TRACKFX_COPYTOTRACK c": {
        "prefix": "TrackFX_CopyToTrack",
        "scope": "c",
        "description": "Copies (or moves) FX from src_track to dest_track. Can be used with\nsrc_track=dest_track to reorder, FX indices have 0x1000000 set to\nreference input FX.\n",
        "body": "TrackFX_CopyToTrack(${1:MediaTrack* src_track},${2:int src_fx},${3:MediaTrack* dest_track},${4:int dest_fx},${5:bool is_move})$0"
    },
    "TRACKFX_COPYTOTRACK eel2": {
        "prefix": "TrackFX_CopyToTrack",
        "scope": "eel2",
        "description": "Copies (or moves) FX from src_track to dest_track. Can be used with\nsrc_track=dest_track to reorder, FX indices have 0x1000000 set to\nreference input FX.\n",
        "body": "TrackFX_CopyToTrack(${1:MediaTrack src_track},${2:int src_fx},${3:MediaTrack dest_track},${4:int dest_fx},${5:bool is_move})$0"
    },
    "REAPER.TRACKFX_COPYTOTRACK lua": {
        "prefix": "reaper.TrackFX_CopyToTrack",
        "scope": "lua",
        "description": "Copies (or moves) FX from src_track to dest_track. Can be used with\nsrc_track=dest_track to reorder, FX indices have 0x1000000 set to\nreference input FX.\n",
        "body": "reaper.TrackFX_CopyToTrack(${1:MediaTrack src_track},${2:integer src_fx},${3:MediaTrack dest_track},${4:integer dest_fx},${5:boolean is_move})$0"
    },
    "RPR_TRACKFX_COPYTOTRACK python": {
        "prefix": "RPR_TrackFX_CopyToTrack",
        "scope": "python",
        "description": "Copies (or moves) FX from src_track to dest_track. Can be used with\nsrc_track=dest_track to reorder, FX indices have 0x1000000 set to\nreference input FX.\n",
        "body": "RPR_TrackFX_CopyToTrack(${1:MediaTrack src_track},${2:Int src_fx},${3:MediaTrack dest_track},${4:Int dest_fx},${5:Boolean is_move})$0"
    },
    "TRACKFX_DELETE c": {
        "prefix": "TrackFX_Delete",
        "scope": "c",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "TrackFX_Delete(${1:MediaTrack* track},${2:int fx})$0"
    },
    "TRACKFX_DELETE eel2": {
        "prefix": "TrackFX_Delete",
        "scope": "eel2",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "TrackFX_Delete(${1:MediaTrack track},${2:int fx})$0"
    },
    "REAPER.TRACKFX_DELETE lua": {
        "prefix": "reaper.TrackFX_Delete",
        "scope": "lua",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "reaper.TrackFX_Delete(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_DELETE python": {
        "prefix": "RPR_TrackFX_Delete",
        "scope": "python",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "RPR_TrackFX_Delete(${1:MediaTrack track},${2:Int fx})$0"
    },
    "TRACKFX_ENDPARAMEDIT c": {
        "prefix": "TrackFX_EndParamEdit",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_EndParamEdit(${1:MediaTrack* track},${2:int fx},${3:int param})$0"
    },
    "TRACKFX_ENDPARAMEDIT eel2": {
        "prefix": "TrackFX_EndParamEdit",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_EndParamEdit(${1:MediaTrack track},${2:int fx},${3:int param})$0"
    },
    "REAPER.TRACKFX_ENDPARAMEDIT lua": {
        "prefix": "reaper.TrackFX_EndParamEdit",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_EndParamEdit(${1:MediaTrack track},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TRACKFX_ENDPARAMEDIT python": {
        "prefix": "RPR_TrackFX_EndParamEdit",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_EndParamEdit(${1:MediaTrack track},${2:Int fx},${3:Int param})$0"
    },
    "TRACKFX_FORMATPARAMVALUE c": {
        "prefix": "TrackFX_FormatParamValue",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TrackFX_FormatParamValue(${1:MediaTrack* track},${2:int fx},${3:int param},${4:double val},${5:char* buf},${6:int buf_sz})$0"
    },
    "TRACKFX_FORMATPARAMVALUE eel2": {
        "prefix": "TrackFX_FormatParamValue",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TrackFX_FormatParamValue(${1:MediaTrack track},${2:int fx},${3:int param},${4:val},${5:#buf})$0"
    },
    "REAPER.TRACKFX_FORMATPARAMVALUE lua": {
        "prefix": "reaper.TrackFX_FormatParamValue",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "reaper.TrackFX_FormatParamValue(${1:MediaTrack track},${2:integer fx},${3:integer param},${4:number val},${5:string buf})$0"
    },
    "RPR_TRACKFX_FORMATPARAMVALUE python": {
        "prefix": "RPR_TrackFX_FormatParamValue",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "RPR_TrackFX_FormatParamValue(${1:track},${2:fx},${3:param},${4:val},${5:buf},${6:buf_sz})$0"
    },
    "TRACKFX_FORMATPARAMVALUENORMALIZED c": {
        "prefix": "TrackFX_FormatParamValueNormalized",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TrackFX_FormatParamValueNormalized(${1:MediaTrack* track},${2:int fx},${3:int param},${4:double value},${5:char* buf},${6:int buf_sz})$0"
    },
    "TRACKFX_FORMATPARAMVALUENORMALIZED eel2": {
        "prefix": "TrackFX_FormatParamValueNormalized",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "TrackFX_FormatParamValueNormalized(${1:MediaTrack track},${2:int fx},${3:int param},${4:value},${5:#buf})$0"
    },
    "REAPER.TRACKFX_FORMATPARAMVALUENORMALIZED lua": {
        "prefix": "reaper.TrackFX_FormatParamValueNormalized",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "reaper.TrackFX_FormatParamValueNormalized(${1:MediaTrack track},${2:integer fx},${3:integer param},${4:number value},${5:string buf})$0"
    },
    "RPR_TRACKFX_FORMATPARAMVALUENORMALIZED python": {
        "prefix": "RPR_TrackFX_FormatParamValueNormalized",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "RPR_TrackFX_FormatParamValueNormalized(${1:track},${2:fx},${3:param},${4:value},${5:buf},${6:buf_sz})$0"
    },
    "TRACKFX_GETBYNAME c": {
        "prefix": "TrackFX_GetByName",
        "scope": "c",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "TrackFX_GetByName(${1:MediaTrack* track},${2:const char* fxname},${3:bool instantiate})$0"
    },
    "TRACKFX_GETBYNAME eel2": {
        "prefix": "TrackFX_GetByName",
        "scope": "eel2",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "TrackFX_GetByName(${1:MediaTrack track},${2:\"fxname\"},${3:bool instantiate})$0"
    },
    "REAPER.TRACKFX_GETBYNAME lua": {
        "prefix": "reaper.TrackFX_GetByName",
        "scope": "lua",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "reaper.TrackFX_GetByName(${1:MediaTrack track},${2:string fxname},${3:boolean instantiate})$0"
    },
    "RPR_TRACKFX_GETBYNAME python": {
        "prefix": "RPR_TrackFX_GetByName",
        "scope": "python",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "RPR_TrackFX_GetByName(${1:MediaTrack track},${2:String fxname},${3:Boolean instantiate})$0"
    },
    "TRACKFX_GETCHAINVISIBLE c": {
        "prefix": "TrackFX_GetChainVisible",
        "scope": "c",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "TrackFX_GetChainVisible(${1:MediaTrack* track})$0"
    },
    "TRACKFX_GETCHAINVISIBLE eel2": {
        "prefix": "TrackFX_GetChainVisible",
        "scope": "eel2",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "TrackFX_GetChainVisible(${1:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETCHAINVISIBLE lua": {
        "prefix": "reaper.TrackFX_GetChainVisible",
        "scope": "lua",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "reaper.TrackFX_GetChainVisible(${1:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETCHAINVISIBLE python": {
        "prefix": "RPR_TrackFX_GetChainVisible",
        "scope": "python",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "RPR_TrackFX_GetChainVisible(${1:MediaTrack track})$0"
    },
    "TRACKFX_GETCOUNT c": {
        "prefix": "TrackFX_GetCount",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetCount(${1:MediaTrack* track})$0"
    },
    "TRACKFX_GETCOUNT eel2": {
        "prefix": "TrackFX_GetCount",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetCount(${1:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETCOUNT lua": {
        "prefix": "reaper.TrackFX_GetCount",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetCount(${1:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETCOUNT python": {
        "prefix": "RPR_TrackFX_GetCount",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetCount(${1:MediaTrack track})$0"
    },
    "TRACKFX_GETENABLED c": {
        "prefix": "TrackFX_GetEnabled",
        "scope": "c",
        "description": "See TrackFX_SetEnabled\n",
        "body": "TrackFX_GetEnabled(${1:MediaTrack* track},${2:int fx})$0"
    },
    "TRACKFX_GETENABLED eel2": {
        "prefix": "TrackFX_GetEnabled",
        "scope": "eel2",
        "description": "See TrackFX_SetEnabled\n",
        "body": "TrackFX_GetEnabled(${1:MediaTrack track},${2:int fx})$0"
    },
    "REAPER.TRACKFX_GETENABLED lua": {
        "prefix": "reaper.TrackFX_GetEnabled",
        "scope": "lua",
        "description": "See TrackFX_SetEnabled\n",
        "body": "reaper.TrackFX_GetEnabled(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_GETENABLED python": {
        "prefix": "RPR_TrackFX_GetEnabled",
        "scope": "python",
        "description": "See TrackFX_SetEnabled\n",
        "body": "RPR_TrackFX_GetEnabled(${1:MediaTrack track},${2:Int fx})$0"
    },
    "TRACKFX_GETEQ c": {
        "prefix": "TrackFX_GetEQ",
        "scope": "c",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "TrackFX_GetEQ(${1:MediaTrack* track},${2:bool instantiate})$0"
    },
    "TRACKFX_GETEQ eel2": {
        "prefix": "TrackFX_GetEQ",
        "scope": "eel2",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "TrackFX_GetEQ(${1:MediaTrack track},${2:bool instantiate})$0"
    },
    "REAPER.TRACKFX_GETEQ lua": {
        "prefix": "reaper.TrackFX_GetEQ",
        "scope": "lua",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "reaper.TrackFX_GetEQ(${1:MediaTrack track},${2:boolean instantiate})$0"
    },
    "RPR_TRACKFX_GETEQ python": {
        "prefix": "RPR_TrackFX_GetEQ",
        "scope": "python",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "RPR_TrackFX_GetEQ(${1:MediaTrack track},${2:Boolean instantiate})$0"
    },
    "TRACKFX_GETEQBANDENABLED c": {
        "prefix": "TrackFX_GetEQBandEnabled",
        "scope": "c",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "TrackFX_GetEQBandEnabled(${1:MediaTrack* track},${2:int fxidx},${3:int bandtype},${4:int bandidx})$0"
    },
    "TRACKFX_GETEQBANDENABLED eel2": {
        "prefix": "TrackFX_GetEQBandEnabled",
        "scope": "eel2",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "TrackFX_GetEQBandEnabled(${1:MediaTrack track},${2:int fxidx},${3:int bandtype},${4:int bandidx})$0"
    },
    "REAPER.TRACKFX_GETEQBANDENABLED lua": {
        "prefix": "reaper.TrackFX_GetEQBandEnabled",
        "scope": "lua",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "reaper.TrackFX_GetEQBandEnabled(${1:MediaTrack track},${2:integer fxidx},${3:integer bandtype},${4:integer bandidx})$0"
    },
    "RPR_TRACKFX_GETEQBANDENABLED python": {
        "prefix": "RPR_TrackFX_GetEQBandEnabled",
        "scope": "python",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "RPR_TrackFX_GetEQBandEnabled(${1:MediaTrack track},${2:Int fxidx},${3:Int bandtype},${4:Int bandidx})$0"
    },
    "TRACKFX_GETEQPARAM c": {
        "prefix": "TrackFX_GetEQParam",
        "scope": "c",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "TrackFX_GetEQParam(${1:MediaTrack* track},${2:int fxidx},${3:int paramidx},${4:int* bandtypeOut},${5:int* bandidxOut},${6:int* paramtypeOut},${7:double* normvalOut})$0"
    },
    "TRACKFX_GETEQPARAM eel2": {
        "prefix": "TrackFX_GetEQParam",
        "scope": "eel2",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "TrackFX_GetEQParam(${1:MediaTrack track},${2:int fxidx},${3:int paramidx},${4:int &bandtype},${5:int &bandidx},${6:int &paramtype},${7:&normval})$0"
    },
    "REAPER.TRACKFX_GETEQPARAM lua": {
        "prefix": "reaper.TrackFX_GetEQParam",
        "scope": "lua",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "reaper.TrackFX_GetEQParam(${1:MediaTrack track},${2:integer fxidx},${3:integer paramidx})$0"
    },
    "RPR_TRACKFX_GETEQPARAM python": {
        "prefix": "RPR_TrackFX_GetEQParam",
        "scope": "python",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "RPR_TrackFX_GetEQParam(${1:track},${2:fxidx},${3:paramidx},${4:bandtypeOut},${5:bandidxOut},${6:paramtypeOut},${7:normvalOut})$0"
    },
    "TRACKFX_GETFLOATINGWINDOW c": {
        "prefix": "TrackFX_GetFloatingWindow",
        "scope": "c",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "TrackFX_GetFloatingWindow(${1:MediaTrack* track},${2:int index})$0"
    },
    "TRACKFX_GETFLOATINGWINDOW eel2": {
        "prefix": "TrackFX_GetFloatingWindow",
        "scope": "eel2",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "TrackFX_GetFloatingWindow(${1:MediaTrack track},${2:int index})$0"
    },
    "REAPER.TRACKFX_GETFLOATINGWINDOW lua": {
        "prefix": "reaper.TrackFX_GetFloatingWindow",
        "scope": "lua",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "reaper.TrackFX_GetFloatingWindow(${1:MediaTrack track},${2:integer index})$0"
    },
    "RPR_TRACKFX_GETFLOATINGWINDOW python": {
        "prefix": "RPR_TrackFX_GetFloatingWindow",
        "scope": "python",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "RPR_TrackFX_GetFloatingWindow(${1:MediaTrack track},${2:Int index})$0"
    },
    "TRACKFX_GETFORMATTEDPARAMVALUE c": {
        "prefix": "TrackFX_GetFormattedParamValue",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetFormattedParamValue(${1:MediaTrack* track},${2:int fx},${3:int param},${4:char* buf},${5:int buf_sz})$0"
    },
    "TRACKFX_GETFORMATTEDPARAMVALUE eel2": {
        "prefix": "TrackFX_GetFormattedParamValue",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetFormattedParamValue(${1:MediaTrack track},${2:int fx},${3:int param},${4:#buf})$0"
    },
    "REAPER.TRACKFX_GETFORMATTEDPARAMVALUE lua": {
        "prefix": "reaper.TrackFX_GetFormattedParamValue",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetFormattedParamValue(${1:MediaTrack track},${2:integer fx},${3:integer param},${4:string buf})$0"
    },
    "RPR_TRACKFX_GETFORMATTEDPARAMVALUE python": {
        "prefix": "RPR_TrackFX_GetFormattedParamValue",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetFormattedParamValue(${1:track},${2:fx},${3:param},${4:buf},${5:buf_sz})$0"
    },
    "TRACKFX_GETFXGUID c": {
        "prefix": "TrackFX_GetFXGUID",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetFXGUID(${1:MediaTrack* track},${2:int fx})$0"
    },
    "TRACKFX_GETFXGUID eel2": {
        "prefix": "TrackFX_GetFXGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetFXGUID(${1:#retguid},${2:MediaTrack track},${3:int fx})$0"
    },
    "REAPER.TRACKFX_GETFXGUID lua": {
        "prefix": "reaper.TrackFX_GetFXGUID",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetFXGUID(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_GETFXGUID python": {
        "prefix": "RPR_TrackFX_GetFXGUID",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetFXGUID(${1:MediaTrack track},${2:Int fx})$0"
    },
    "TRACKFX_GETFXNAME c": {
        "prefix": "TrackFX_GetFXName",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetFXName(${1:MediaTrack* track},${2:int fx},${3:char* buf},${4:int buf_sz})$0"
    },
    "TRACKFX_GETFXNAME eel2": {
        "prefix": "TrackFX_GetFXName",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetFXName(${1:MediaTrack track},${2:int fx},${3:#buf})$0"
    },
    "REAPER.TRACKFX_GETFXNAME lua": {
        "prefix": "reaper.TrackFX_GetFXName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetFXName(${1:MediaTrack track},${2:integer fx},${3:string buf})$0"
    },
    "RPR_TRACKFX_GETFXNAME python": {
        "prefix": "RPR_TrackFX_GetFXName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetFXName(${1:track},${2:fx},${3:buf},${4:buf_sz})$0"
    },
    "TRACKFX_GETINSTRUMENT c": {
        "prefix": "TrackFX_GetInstrument",
        "scope": "c",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "TrackFX_GetInstrument(${1:MediaTrack* track})$0"
    },
    "TRACKFX_GETINSTRUMENT eel2": {
        "prefix": "TrackFX_GetInstrument",
        "scope": "eel2",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "TrackFX_GetInstrument(${1:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETINSTRUMENT lua": {
        "prefix": "reaper.TrackFX_GetInstrument",
        "scope": "lua",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "reaper.TrackFX_GetInstrument(${1:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETINSTRUMENT python": {
        "prefix": "RPR_TrackFX_GetInstrument",
        "scope": "python",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "RPR_TrackFX_GetInstrument(${1:MediaTrack track})$0"
    },
    "TRACKFX_GETIOSIZE c": {
        "prefix": "TrackFX_GetIOSize",
        "scope": "c",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "TrackFX_GetIOSize(${1:MediaTrack* track},${2:int fx},${3:int* inputPinsOutOptional},${4:int* outputPinsOutOptional})$0"
    },
    "TRACKFX_GETIOSIZE eel2": {
        "prefix": "TrackFX_GetIOSize",
        "scope": "eel2",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "TrackFX_GetIOSize(${1:MediaTrack track},${2:int fx},${3:optional int &inputPins},${4:optional int &outputPins})$0"
    },
    "REAPER.TRACKFX_GETIOSIZE lua": {
        "prefix": "reaper.TrackFX_GetIOSize",
        "scope": "lua",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "reaper.TrackFX_GetIOSize(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_GETIOSIZE python": {
        "prefix": "RPR_TrackFX_GetIOSize",
        "scope": "python",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "RPR_TrackFX_GetIOSize(${1:track},${2:fx},${3:inputPinsOutOptional},${4:outputPinsOutOptional})$0"
    },
    "TRACKFX_GETNAMEDCONFIGPARM c": {
        "prefix": "TrackFX_GetNamedConfigParm",
        "scope": "c",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "TrackFX_GetNamedConfigParm(${1:MediaTrack* track},${2:int fx},${3:const char* parmname},${4:char* bufOut},${5:int bufOut_sz})$0"
    },
    "TRACKFX_GETNAMEDCONFIGPARM eel2": {
        "prefix": "TrackFX_GetNamedConfigParm",
        "scope": "eel2",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "TrackFX_GetNamedConfigParm(${1:MediaTrack track},${2:int fx},${3:\"parmname\"},${4:#buf})$0"
    },
    "REAPER.TRACKFX_GETNAMEDCONFIGPARM lua": {
        "prefix": "reaper.TrackFX_GetNamedConfigParm",
        "scope": "lua",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "reaper.TrackFX_GetNamedConfigParm(${1:MediaTrack track},${2:integer fx},${3:string parmname})$0"
    },
    "RPR_TRACKFX_GETNAMEDCONFIGPARM python": {
        "prefix": "RPR_TrackFX_GetNamedConfigParm",
        "scope": "python",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "RPR_TrackFX_GetNamedConfigParm(${1:track},${2:fx},${3:parmname},${4:bufOut},${5:bufOut_sz})$0"
    },
    "TRACKFX_GETNUMPARAMS c": {
        "prefix": "TrackFX_GetNumParams",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetNumParams(${1:MediaTrack* track},${2:int fx})$0"
    },
    "TRACKFX_GETNUMPARAMS eel2": {
        "prefix": "TrackFX_GetNumParams",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetNumParams(${1:MediaTrack track},${2:int fx})$0"
    },
    "REAPER.TRACKFX_GETNUMPARAMS lua": {
        "prefix": "reaper.TrackFX_GetNumParams",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetNumParams(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_GETNUMPARAMS python": {
        "prefix": "RPR_TrackFX_GetNumParams",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetNumParams(${1:MediaTrack track},${2:Int fx})$0"
    },
    "TRACKFX_GETOFFLINE c": {
        "prefix": "TrackFX_GetOffline",
        "scope": "c",
        "description": "See TrackFX_SetOffline\n",
        "body": "TrackFX_GetOffline(${1:MediaTrack* track},${2:int fx})$0"
    },
    "TRACKFX_GETOFFLINE eel2": {
        "prefix": "TrackFX_GetOffline",
        "scope": "eel2",
        "description": "See TrackFX_SetOffline\n",
        "body": "TrackFX_GetOffline(${1:MediaTrack track},${2:int fx})$0"
    },
    "REAPER.TRACKFX_GETOFFLINE lua": {
        "prefix": "reaper.TrackFX_GetOffline",
        "scope": "lua",
        "description": "See TrackFX_SetOffline\n",
        "body": "reaper.TrackFX_GetOffline(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_GETOFFLINE python": {
        "prefix": "RPR_TrackFX_GetOffline",
        "scope": "python",
        "description": "See TrackFX_SetOffline\n",
        "body": "RPR_TrackFX_GetOffline(${1:MediaTrack track},${2:Int fx})$0"
    },
    "TRACKFX_GETOPEN c": {
        "prefix": "TrackFX_GetOpen",
        "scope": "c",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "TrackFX_GetOpen(${1:MediaTrack* track},${2:int fx})$0"
    },
    "TRACKFX_GETOPEN eel2": {
        "prefix": "TrackFX_GetOpen",
        "scope": "eel2",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "TrackFX_GetOpen(${1:MediaTrack track},${2:int fx})$0"
    },
    "REAPER.TRACKFX_GETOPEN lua": {
        "prefix": "reaper.TrackFX_GetOpen",
        "scope": "lua",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "reaper.TrackFX_GetOpen(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_GETOPEN python": {
        "prefix": "RPR_TrackFX_GetOpen",
        "scope": "python",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "RPR_TrackFX_GetOpen(${1:MediaTrack track},${2:Int fx})$0"
    },
    "TRACKFX_GETPARAM c": {
        "prefix": "TrackFX_GetParam",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetParam(${1:MediaTrack* track},${2:int fx},${3:int param},${4:double* minvalOut},${5:double* maxvalOut})$0"
    },
    "TRACKFX_GETPARAM eel2": {
        "prefix": "TrackFX_GetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetParam(${1:MediaTrack track},${2:int fx},${3:int param},${4:&minval},${5:&maxval})$0"
    },
    "REAPER.TRACKFX_GETPARAM lua": {
        "prefix": "reaper.TrackFX_GetParam",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetParam(${1:MediaTrack track},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAM python": {
        "prefix": "RPR_TrackFX_GetParam",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetParam(${1:track},${2:fx},${3:param},${4:minvalOut},${5:maxvalOut})$0"
    },
    "TRACKFX_GETPARAMETERSTEPSIZES c": {
        "prefix": "TrackFX_GetParameterStepSizes",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetParameterStepSizes(${1:MediaTrack* track},${2:int fx},${3:int param},${4:double* stepOut},${5:double* smallstepOut},${6:double* largestepOut},${7:bool* istoggleOut})$0"
    },
    "TRACKFX_GETPARAMETERSTEPSIZES eel2": {
        "prefix": "TrackFX_GetParameterStepSizes",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetParameterStepSizes(${1:MediaTrack track},${2:int fx},${3:int param},${4:&step},${5:&smallstep},${6:&largestep},${7:bool &istoggle})$0"
    },
    "REAPER.TRACKFX_GETPARAMETERSTEPSIZES lua": {
        "prefix": "reaper.TrackFX_GetParameterStepSizes",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetParameterStepSizes(${1:MediaTrack track},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAMETERSTEPSIZES python": {
        "prefix": "RPR_TrackFX_GetParameterStepSizes",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetParameterStepSizes(${1:track},${2:fx},${3:param},${4:stepOut},${5:smallstepOut},${6:largestepOut},${7:istoggleOut})$0"
    },
    "TRACKFX_GETPARAMEX c": {
        "prefix": "TrackFX_GetParamEx",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetParamEx(${1:MediaTrack* track},${2:int fx},${3:int param},${4:double* minvalOut},${5:double* maxvalOut},${6:double* midvalOut})$0"
    },
    "TRACKFX_GETPARAMEX eel2": {
        "prefix": "TrackFX_GetParamEx",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetParamEx(${1:MediaTrack track},${2:int fx},${3:int param},${4:&minval},${5:&maxval},${6:&midval})$0"
    },
    "REAPER.TRACKFX_GETPARAMEX lua": {
        "prefix": "reaper.TrackFX_GetParamEx",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetParamEx(${1:MediaTrack track},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAMEX python": {
        "prefix": "RPR_TrackFX_GetParamEx",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetParamEx(${1:track},${2:fx},${3:param},${4:minvalOut},${5:maxvalOut},${6:midvalOut})$0"
    },
    "TRACKFX_GETPARAMNAME c": {
        "prefix": "TrackFX_GetParamName",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetParamName(${1:MediaTrack* track},${2:int fx},${3:int param},${4:char* buf},${5:int buf_sz})$0"
    },
    "TRACKFX_GETPARAMNAME eel2": {
        "prefix": "TrackFX_GetParamName",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetParamName(${1:MediaTrack track},${2:int fx},${3:int param},${4:#buf})$0"
    },
    "REAPER.TRACKFX_GETPARAMNAME lua": {
        "prefix": "reaper.TrackFX_GetParamName",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetParamName(${1:MediaTrack track},${2:integer fx},${3:integer param},${4:string buf})$0"
    },
    "RPR_TRACKFX_GETPARAMNAME python": {
        "prefix": "RPR_TrackFX_GetParamName",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetParamName(${1:track},${2:fx},${3:param},${4:buf},${5:buf_sz})$0"
    },
    "TRACKFX_GETPARAMNORMALIZED c": {
        "prefix": "TrackFX_GetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetParamNormalized(${1:MediaTrack* track},${2:int fx},${3:int param})$0"
    },
    "TRACKFX_GETPARAMNORMALIZED eel2": {
        "prefix": "TrackFX_GetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetParamNormalized(${1:MediaTrack track},${2:int fx},${3:int param})$0"
    },
    "REAPER.TRACKFX_GETPARAMNORMALIZED lua": {
        "prefix": "reaper.TrackFX_GetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetParamNormalized(${1:MediaTrack track},${2:integer fx},${3:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAMNORMALIZED python": {
        "prefix": "RPR_TrackFX_GetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetParamNormalized(${1:MediaTrack track},${2:Int fx},${3:Int param})$0"
    },
    "TRACKFX_GETPINMAPPINGS c": {
        "prefix": "TrackFX_GetPinMappings",
        "scope": "c",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "TrackFX_GetPinMappings(${1:MediaTrack* tr},${2:int fx},${3:int isoutput},${4:int pin},${5:int* high32OutOptional})$0"
    },
    "TRACKFX_GETPINMAPPINGS eel2": {
        "prefix": "TrackFX_GetPinMappings",
        "scope": "eel2",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "TrackFX_GetPinMappings(${1:MediaTrack tr},${2:int fx},${3:int isoutput},${4:int pin},${5:optional int &high32})$0"
    },
    "REAPER.TRACKFX_GETPINMAPPINGS lua": {
        "prefix": "reaper.TrackFX_GetPinMappings",
        "scope": "lua",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "reaper.TrackFX_GetPinMappings(${1:MediaTrack tr},${2:integer fx},${3:integer isoutput},${4:integer pin})$0"
    },
    "RPR_TRACKFX_GETPINMAPPINGS python": {
        "prefix": "RPR_TrackFX_GetPinMappings",
        "scope": "python",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "RPR_TrackFX_GetPinMappings(${1:tr},${2:fx},${3:isoutput},${4:pin},${5:high32OutOptional})$0"
    },
    "TRACKFX_GETPRESET c": {
        "prefix": "TrackFX_GetPreset",
        "scope": "c",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "TrackFX_GetPreset(${1:MediaTrack* track},${2:int fx},${3:char* presetname},${4:int presetname_sz})$0"
    },
    "TRACKFX_GETPRESET eel2": {
        "prefix": "TrackFX_GetPreset",
        "scope": "eel2",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "TrackFX_GetPreset(${1:MediaTrack track},${2:int fx},${3:#presetname})$0"
    },
    "REAPER.TRACKFX_GETPRESET lua": {
        "prefix": "reaper.TrackFX_GetPreset",
        "scope": "lua",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "reaper.TrackFX_GetPreset(${1:MediaTrack track},${2:integer fx},${3:string presetname})$0"
    },
    "RPR_TRACKFX_GETPRESET python": {
        "prefix": "RPR_TrackFX_GetPreset",
        "scope": "python",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "RPR_TrackFX_GetPreset(${1:track},${2:fx},${3:presetname},${4:presetname_sz})$0"
    },
    "TRACKFX_GETPRESETINDEX c": {
        "prefix": "TrackFX_GetPresetIndex",
        "scope": "c",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "TrackFX_GetPresetIndex(${1:MediaTrack* track},${2:int fx},${3:int* numberOfPresetsOut})$0"
    },
    "TRACKFX_GETPRESETINDEX eel2": {
        "prefix": "TrackFX_GetPresetIndex",
        "scope": "eel2",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "TrackFX_GetPresetIndex(${1:MediaTrack track},${2:int fx},${3:int &numberOfPresets})$0"
    },
    "REAPER.TRACKFX_GETPRESETINDEX lua": {
        "prefix": "reaper.TrackFX_GetPresetIndex",
        "scope": "lua",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "reaper.TrackFX_GetPresetIndex(${1:MediaTrack track},${2:integer fx})$0"
    },
    "RPR_TRACKFX_GETPRESETINDEX python": {
        "prefix": "RPR_TrackFX_GetPresetIndex",
        "scope": "python",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "RPR_TrackFX_GetPresetIndex(${1:track},${2:fx},${3:numberOfPresetsOut})$0"
    },
    "TRACKFX_GETRECCHAINVISIBLE c": {
        "prefix": "TrackFX_GetRecChainVisible",
        "scope": "c",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "TrackFX_GetRecChainVisible(${1:MediaTrack* track})$0"
    },
    "TRACKFX_GETRECCHAINVISIBLE eel2": {
        "prefix": "TrackFX_GetRecChainVisible",
        "scope": "eel2",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "TrackFX_GetRecChainVisible(${1:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETRECCHAINVISIBLE lua": {
        "prefix": "reaper.TrackFX_GetRecChainVisible",
        "scope": "lua",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "reaper.TrackFX_GetRecChainVisible(${1:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETRECCHAINVISIBLE python": {
        "prefix": "RPR_TrackFX_GetRecChainVisible",
        "scope": "python",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "RPR_TrackFX_GetRecChainVisible(${1:MediaTrack track})$0"
    },
    "TRACKFX_GETRECCOUNT c": {
        "prefix": "TrackFX_GetRecCount",
        "scope": "c",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "TrackFX_GetRecCount(${1:MediaTrack* track})$0"
    },
    "TRACKFX_GETRECCOUNT eel2": {
        "prefix": "TrackFX_GetRecCount",
        "scope": "eel2",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "TrackFX_GetRecCount(${1:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETRECCOUNT lua": {
        "prefix": "reaper.TrackFX_GetRecCount",
        "scope": "lua",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "reaper.TrackFX_GetRecCount(${1:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETRECCOUNT python": {
        "prefix": "RPR_TrackFX_GetRecCount",
        "scope": "python",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "RPR_TrackFX_GetRecCount(${1:MediaTrack track})$0"
    },
    "TRACKFX_GETUSERPRESETFILENAME c": {
        "prefix": "TrackFX_GetUserPresetFilename",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_GetUserPresetFilename(${1:MediaTrack* track},${2:int fx},${3:char* fn},${4:int fn_sz})$0"
    },
    "TRACKFX_GETUSERPRESETFILENAME eel2": {
        "prefix": "TrackFX_GetUserPresetFilename",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_GetUserPresetFilename(${1:MediaTrack track},${2:int fx},${3:#fn})$0"
    },
    "REAPER.TRACKFX_GETUSERPRESETFILENAME lua": {
        "prefix": "reaper.TrackFX_GetUserPresetFilename",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_GetUserPresetFilename(${1:MediaTrack track},${2:integer fx},${3:string fn})$0"
    },
    "RPR_TRACKFX_GETUSERPRESETFILENAME python": {
        "prefix": "RPR_TrackFX_GetUserPresetFilename",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_GetUserPresetFilename(${1:track},${2:fx},${3:fn},${4:fn_sz})$0"
    },
    "TRACKFX_NAVIGATEPRESETS c": {
        "prefix": "TrackFX_NavigatePresets",
        "scope": "c",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "TrackFX_NavigatePresets(${1:MediaTrack* track},${2:int fx},${3:int presetmove})$0"
    },
    "TRACKFX_NAVIGATEPRESETS eel2": {
        "prefix": "TrackFX_NavigatePresets",
        "scope": "eel2",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "TrackFX_NavigatePresets(${1:MediaTrack track},${2:int fx},${3:int presetmove})$0"
    },
    "REAPER.TRACKFX_NAVIGATEPRESETS lua": {
        "prefix": "reaper.TrackFX_NavigatePresets",
        "scope": "lua",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "reaper.TrackFX_NavigatePresets(${1:MediaTrack track},${2:integer fx},${3:integer presetmove})$0"
    },
    "RPR_TRACKFX_NAVIGATEPRESETS python": {
        "prefix": "RPR_TrackFX_NavigatePresets",
        "scope": "python",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "RPR_TrackFX_NavigatePresets(${1:MediaTrack track},${2:Int fx},${3:Int presetmove})$0"
    },
    "TRACKFX_SETENABLED c": {
        "prefix": "TrackFX_SetEnabled",
        "scope": "c",
        "description": "See TrackFX_GetEnabled\n",
        "body": "TrackFX_SetEnabled(${1:MediaTrack* track},${2:int fx},${3:bool enabled})$0"
    },
    "TRACKFX_SETENABLED eel2": {
        "prefix": "TrackFX_SetEnabled",
        "scope": "eel2",
        "description": "See TrackFX_GetEnabled\n",
        "body": "TrackFX_SetEnabled(${1:MediaTrack track},${2:int fx},${3:bool enabled})$0"
    },
    "REAPER.TRACKFX_SETENABLED lua": {
        "prefix": "reaper.TrackFX_SetEnabled",
        "scope": "lua",
        "description": "See TrackFX_GetEnabled\n",
        "body": "reaper.TrackFX_SetEnabled(${1:MediaTrack track},${2:integer fx},${3:boolean enabled})$0"
    },
    "RPR_TRACKFX_SETENABLED python": {
        "prefix": "RPR_TrackFX_SetEnabled",
        "scope": "python",
        "description": "See TrackFX_GetEnabled\n",
        "body": "RPR_TrackFX_SetEnabled(${1:MediaTrack track},${2:Int fx},${3:Boolean enabled})$0"
    },
    "TRACKFX_SETEQBANDENABLED c": {
        "prefix": "TrackFX_SetEQBandEnabled",
        "scope": "c",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "TrackFX_SetEQBandEnabled(${1:MediaTrack* track},${2:int fxidx},${3:int bandtype},${4:int bandidx},${5:bool enable})$0"
    },
    "TRACKFX_SETEQBANDENABLED eel2": {
        "prefix": "TrackFX_SetEQBandEnabled",
        "scope": "eel2",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "TrackFX_SetEQBandEnabled(${1:MediaTrack track},${2:int fxidx},${3:int bandtype},${4:int bandidx},${5:bool enable})$0"
    },
    "REAPER.TRACKFX_SETEQBANDENABLED lua": {
        "prefix": "reaper.TrackFX_SetEQBandEnabled",
        "scope": "lua",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "reaper.TrackFX_SetEQBandEnabled(${1:MediaTrack track},${2:integer fxidx},${3:integer bandtype},${4:integer bandidx},${5:boolean enable})$0"
    },
    "RPR_TRACKFX_SETEQBANDENABLED python": {
        "prefix": "RPR_TrackFX_SetEQBandEnabled",
        "scope": "python",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "RPR_TrackFX_SetEQBandEnabled(${1:MediaTrack track},${2:Int fxidx},${3:Int bandtype},${4:Int bandidx},${5:Boolean enable})$0"
    },
    "TRACKFX_SETEQPARAM c": {
        "prefix": "TrackFX_SetEQParam",
        "scope": "c",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "TrackFX_SetEQParam(${1:MediaTrack* track},${2:int fxidx},${3:int bandtype},${4:int bandidx},${5:int paramtype},${6:double val},${7:bool isnorm})$0"
    },
    "TRACKFX_SETEQPARAM eel2": {
        "prefix": "TrackFX_SetEQParam",
        "scope": "eel2",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "TrackFX_SetEQParam(${1:MediaTrack track},${2:int fxidx},${3:int bandtype},${4:int bandidx},${5:int paramtype},${6:val},${7:bool isnorm})$0"
    },
    "REAPER.TRACKFX_SETEQPARAM lua": {
        "prefix": "reaper.TrackFX_SetEQParam",
        "scope": "lua",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "reaper.TrackFX_SetEQParam(${1:MediaTrack track},${2:integer fxidx},${3:integer bandtype},${4:integer bandidx},${5:integer paramtype},${6:number val},${7:boolean isnorm})$0"
    },
    "RPR_TRACKFX_SETEQPARAM python": {
        "prefix": "RPR_TrackFX_SetEQParam",
        "scope": "python",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "RPR_TrackFX_SetEQParam(${1:MediaTrack track},${2:Int fxidx},${3:Int bandtype},${4:Int bandidx},${5:Int paramtype},${6:Float val},${7:Boolean isnorm})$0"
    },
    "TRACKFX_SETNAMEDCONFIGPARM c": {
        "prefix": "TrackFX_SetNamedConfigParm",
        "scope": "c",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "TrackFX_SetNamedConfigParm(${1:MediaTrack* track},${2:int fx},${3:const char* parmname},${4:const char* value})$0"
    },
    "TRACKFX_SETNAMEDCONFIGPARM eel2": {
        "prefix": "TrackFX_SetNamedConfigParm",
        "scope": "eel2",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "TrackFX_SetNamedConfigParm(${1:MediaTrack track},${2:int fx},${3:\"parmname\"},${4:\"value\"})$0"
    },
    "REAPER.TRACKFX_SETNAMEDCONFIGPARM lua": {
        "prefix": "reaper.TrackFX_SetNamedConfigParm",
        "scope": "lua",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "reaper.TrackFX_SetNamedConfigParm(${1:MediaTrack track},${2:integer fx},${3:string parmname},${4:string value})$0"
    },
    "RPR_TRACKFX_SETNAMEDCONFIGPARM python": {
        "prefix": "RPR_TrackFX_SetNamedConfigParm",
        "scope": "python",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "RPR_TrackFX_SetNamedConfigParm(${1:MediaTrack track},${2:Int fx},${3:String parmname},${4:String value})$0"
    },
    "TRACKFX_SETOFFLINE c": {
        "prefix": "TrackFX_SetOffline",
        "scope": "c",
        "description": "See TrackFX_GetOffline\n",
        "body": "TrackFX_SetOffline(${1:MediaTrack* track},${2:int fx},${3:bool offline})$0"
    },
    "TRACKFX_SETOFFLINE eel2": {
        "prefix": "TrackFX_SetOffline",
        "scope": "eel2",
        "description": "See TrackFX_GetOffline\n",
        "body": "TrackFX_SetOffline(${1:MediaTrack track},${2:int fx},${3:bool offline})$0"
    },
    "REAPER.TRACKFX_SETOFFLINE lua": {
        "prefix": "reaper.TrackFX_SetOffline",
        "scope": "lua",
        "description": "See TrackFX_GetOffline\n",
        "body": "reaper.TrackFX_SetOffline(${1:MediaTrack track},${2:integer fx},${3:boolean offline})$0"
    },
    "RPR_TRACKFX_SETOFFLINE python": {
        "prefix": "RPR_TrackFX_SetOffline",
        "scope": "python",
        "description": "See TrackFX_GetOffline\n",
        "body": "RPR_TrackFX_SetOffline(${1:MediaTrack track},${2:Int fx},${3:Boolean offline})$0"
    },
    "TRACKFX_SETOPEN c": {
        "prefix": "TrackFX_SetOpen",
        "scope": "c",
        "description": "Open this FX UI. See TrackFX_GetOpen\n",
        "body": "TrackFX_SetOpen(${1:MediaTrack* track},${2:int fx},${3:bool open})$0"
    },
    "TRACKFX_SETOPEN eel2": {
        "prefix": "TrackFX_SetOpen",
        "scope": "eel2",
        "description": "Open this FX UI. See TrackFX_GetOpen\n",
        "body": "TrackFX_SetOpen(${1:MediaTrack track},${2:int fx},${3:bool open})$0"
    },
    "REAPER.TRACKFX_SETOPEN lua": {
        "prefix": "reaper.TrackFX_SetOpen",
        "scope": "lua",
        "description": "Open this FX UI. See TrackFX_GetOpen\n",
        "body": "reaper.TrackFX_SetOpen(${1:MediaTrack track},${2:integer fx},${3:boolean open})$0"
    },
    "RPR_TRACKFX_SETOPEN python": {
        "prefix": "RPR_TrackFX_SetOpen",
        "scope": "python",
        "description": "Open this FX UI. See TrackFX_GetOpen\n",
        "body": "RPR_TrackFX_SetOpen(${1:MediaTrack track},${2:Int fx},${3:Boolean open})$0"
    },
    "TRACKFX_SETPARAM c": {
        "prefix": "TrackFX_SetParam",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_SetParam(${1:MediaTrack* track},${2:int fx},${3:int param},${4:double val})$0"
    },
    "TRACKFX_SETPARAM eel2": {
        "prefix": "TrackFX_SetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_SetParam(${1:MediaTrack track},${2:int fx},${3:int param},${4:val})$0"
    },
    "REAPER.TRACKFX_SETPARAM lua": {
        "prefix": "reaper.TrackFX_SetParam",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_SetParam(${1:MediaTrack track},${2:integer fx},${3:integer param},${4:number val})$0"
    },
    "RPR_TRACKFX_SETPARAM python": {
        "prefix": "RPR_TrackFX_SetParam",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_SetParam(${1:MediaTrack track},${2:Int fx},${3:Int param},${4:Float val})$0"
    },
    "TRACKFX_SETPARAMNORMALIZED c": {
        "prefix": "TrackFX_SetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "TrackFX_SetParamNormalized(${1:MediaTrack* track},${2:int fx},${3:int param},${4:double value})$0"
    },
    "TRACKFX_SETPARAMNORMALIZED eel2": {
        "prefix": "TrackFX_SetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackFX_SetParamNormalized(${1:MediaTrack track},${2:int fx},${3:int param},${4:value})$0"
    },
    "REAPER.TRACKFX_SETPARAMNORMALIZED lua": {
        "prefix": "reaper.TrackFX_SetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackFX_SetParamNormalized(${1:MediaTrack track},${2:integer fx},${3:integer param},${4:number value})$0"
    },
    "RPR_TRACKFX_SETPARAMNORMALIZED python": {
        "prefix": "RPR_TrackFX_SetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackFX_SetParamNormalized(${1:MediaTrack track},${2:Int fx},${3:Int param},${4:Float value})$0"
    },
    "TRACKFX_SETPINMAPPINGS c": {
        "prefix": "TrackFX_SetPinMappings",
        "scope": "c",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "TrackFX_SetPinMappings(${1:MediaTrack* tr},${2:int fx},${3:int isoutput},${4:int pin},${5:int low32bits},${6:int hi32bits})$0"
    },
    "TRACKFX_SETPINMAPPINGS eel2": {
        "prefix": "TrackFX_SetPinMappings",
        "scope": "eel2",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "TrackFX_SetPinMappings(${1:MediaTrack tr},${2:int fx},${3:int isoutput},${4:int pin},${5:int low32bits},${6:int hi32bits})$0"
    },
    "REAPER.TRACKFX_SETPINMAPPINGS lua": {
        "prefix": "reaper.TrackFX_SetPinMappings",
        "scope": "lua",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "reaper.TrackFX_SetPinMappings(${1:MediaTrack tr},${2:integer fx},${3:integer isoutput},${4:integer pin},${5:integer low32bits},${6:integer hi32bits})$0"
    },
    "RPR_TRACKFX_SETPINMAPPINGS python": {
        "prefix": "RPR_TrackFX_SetPinMappings",
        "scope": "python",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "RPR_TrackFX_SetPinMappings(${1:MediaTrack tr},${2:Int fx},${3:Int isoutput},${4:Int pin},${5:Int low32bits},${6:Int hi32bits})$0"
    },
    "TRACKFX_SETPRESET c": {
        "prefix": "TrackFX_SetPreset",
        "scope": "c",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "TrackFX_SetPreset(${1:MediaTrack* track},${2:int fx},${3:const char* presetname})$0"
    },
    "TRACKFX_SETPRESET eel2": {
        "prefix": "TrackFX_SetPreset",
        "scope": "eel2",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "TrackFX_SetPreset(${1:MediaTrack track},${2:int fx},${3:\"presetname\"})$0"
    },
    "REAPER.TRACKFX_SETPRESET lua": {
        "prefix": "reaper.TrackFX_SetPreset",
        "scope": "lua",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "reaper.TrackFX_SetPreset(${1:MediaTrack track},${2:integer fx},${3:string presetname})$0"
    },
    "RPR_TRACKFX_SETPRESET python": {
        "prefix": "RPR_TrackFX_SetPreset",
        "scope": "python",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "RPR_TrackFX_SetPreset(${1:MediaTrack track},${2:Int fx},${3:String presetname})$0"
    },
    "TRACKFX_SETPRESETBYINDEX c": {
        "prefix": "TrackFX_SetPresetByIndex",
        "scope": "c",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "TrackFX_SetPresetByIndex(${1:MediaTrack* track},${2:int fx},${3:int idx})$0"
    },
    "TRACKFX_SETPRESETBYINDEX eel2": {
        "prefix": "TrackFX_SetPresetByIndex",
        "scope": "eel2",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "TrackFX_SetPresetByIndex(${1:MediaTrack track},${2:int fx},${3:int idx})$0"
    },
    "REAPER.TRACKFX_SETPRESETBYINDEX lua": {
        "prefix": "reaper.TrackFX_SetPresetByIndex",
        "scope": "lua",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "reaper.TrackFX_SetPresetByIndex(${1:MediaTrack track},${2:integer fx},${3:integer idx})$0"
    },
    "RPR_TRACKFX_SETPRESETBYINDEX python": {
        "prefix": "RPR_TrackFX_SetPresetByIndex",
        "scope": "python",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "RPR_TrackFX_SetPresetByIndex(${1:MediaTrack track},${2:Int fx},${3:Int idx})$0"
    },
    "TRACKFX_SHOW c": {
        "prefix": "TrackFX_Show",
        "scope": "c",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "TrackFX_Show(${1:MediaTrack* track},${2:int index},${3:int showFlag})$0"
    },
    "TRACKFX_SHOW eel2": {
        "prefix": "TrackFX_Show",
        "scope": "eel2",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "TrackFX_Show(${1:MediaTrack track},${2:int index},${3:int showFlag})$0"
    },
    "REAPER.TRACKFX_SHOW lua": {
        "prefix": "reaper.TrackFX_Show",
        "scope": "lua",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "reaper.TrackFX_Show(${1:MediaTrack track},${2:integer index},${3:integer showFlag})$0"
    },
    "RPR_TRACKFX_SHOW python": {
        "prefix": "RPR_TrackFX_Show",
        "scope": "python",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "RPR_TrackFX_Show(${1:MediaTrack track},${2:Int index},${3:Int showFlag})$0"
    },
    "TRACKLIST_ADJUSTWINDOWS c": {
        "prefix": "TrackList_AdjustWindows",
        "scope": "c",
        "description": "\n",
        "body": "TrackList_AdjustWindows(${1:bool isMinor})$0"
    },
    "TRACKLIST_ADJUSTWINDOWS eel2": {
        "prefix": "TrackList_AdjustWindows",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackList_AdjustWindows(${1:bool isMinor})$0"
    },
    "REAPER.TRACKLIST_ADJUSTWINDOWS lua": {
        "prefix": "reaper.TrackList_AdjustWindows",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackList_AdjustWindows(${1:boolean isMinor})$0"
    },
    "RPR_TRACKLIST_ADJUSTWINDOWS python": {
        "prefix": "RPR_TrackList_AdjustWindows",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackList_AdjustWindows(${1:Boolean isMinor})$0"
    },
    "TRACKLIST_UPDATEALLEXTERNALSURFACES c": {
        "prefix": "TrackList_UpdateAllExternalSurfaces",
        "scope": "c",
        "description": "\n",
        "body": "TrackList_UpdateAllExternalSurfaces()$0"
    },
    "TRACKLIST_UPDATEALLEXTERNALSURFACES eel2": {
        "prefix": "TrackList_UpdateAllExternalSurfaces",
        "scope": "eel2",
        "description": "\n",
        "body": "TrackList_UpdateAllExternalSurfaces()$0"
    },
    "REAPER.TRACKLIST_UPDATEALLEXTERNALSURFACES lua": {
        "prefix": "reaper.TrackList_UpdateAllExternalSurfaces",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.TrackList_UpdateAllExternalSurfaces()$0"
    },
    "RPR_TRACKLIST_UPDATEALLEXTERNALSURFACES python": {
        "prefix": "RPR_TrackList_UpdateAllExternalSurfaces",
        "scope": "python",
        "description": "\n",
        "body": "RPR_TrackList_UpdateAllExternalSurfaces()$0"
    },
    "UNDO_BEGINBLOCK c": {
        "prefix": "Undo_BeginBlock",
        "scope": "c",
        "description": "call to start a new block\n",
        "body": "Undo_BeginBlock()$0"
    },
    "UNDO_BEGINBLOCK eel2": {
        "prefix": "Undo_BeginBlock",
        "scope": "eel2",
        "description": "call to start a new block\n",
        "body": "Undo_BeginBlock()$0"
    },
    "REAPER.UNDO_BEGINBLOCK lua": {
        "prefix": "reaper.Undo_BeginBlock",
        "scope": "lua",
        "description": "call to start a new block\n",
        "body": "reaper.Undo_BeginBlock()$0"
    },
    "RPR_UNDO_BEGINBLOCK python": {
        "prefix": "RPR_Undo_BeginBlock",
        "scope": "python",
        "description": "call to start a new block\n",
        "body": "RPR_Undo_BeginBlock()$0"
    },
    "UNDO_BEGINBLOCK2 c": {
        "prefix": "Undo_BeginBlock2",
        "scope": "c",
        "description": "call to start a new block\n",
        "body": "Undo_BeginBlock2(${1:ReaProject* proj})$0"
    },
    "UNDO_BEGINBLOCK2 eel2": {
        "prefix": "Undo_BeginBlock2",
        "scope": "eel2",
        "description": "call to start a new block\n",
        "body": "Undo_BeginBlock2(${1:ReaProject proj})$0"
    },
    "REAPER.UNDO_BEGINBLOCK2 lua": {
        "prefix": "reaper.Undo_BeginBlock2",
        "scope": "lua",
        "description": "call to start a new block\n",
        "body": "reaper.Undo_BeginBlock2(${1:ReaProject proj})$0"
    },
    "RPR_UNDO_BEGINBLOCK2 python": {
        "prefix": "RPR_Undo_BeginBlock2",
        "scope": "python",
        "description": "call to start a new block\n",
        "body": "RPR_Undo_BeginBlock2(${1:ReaProject proj})$0"
    },
    "UNDO_CANREDO2 c": {
        "prefix": "Undo_CanRedo2",
        "scope": "c",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "Undo_CanRedo2(${1:ReaProject* proj})$0"
    },
    "UNDO_CANREDO2 eel2": {
        "prefix": "Undo_CanRedo2",
        "scope": "eel2",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "Undo_CanRedo2(${1:#retval},${2:ReaProject proj})$0"
    },
    "REAPER.UNDO_CANREDO2 lua": {
        "prefix": "reaper.Undo_CanRedo2",
        "scope": "lua",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "reaper.Undo_CanRedo2(${1:ReaProject proj})$0"
    },
    "RPR_UNDO_CANREDO2 python": {
        "prefix": "RPR_Undo_CanRedo2",
        "scope": "python",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "RPR_Undo_CanRedo2(${1:ReaProject proj})$0"
    },
    "UNDO_CANUNDO2 c": {
        "prefix": "Undo_CanUndo2",
        "scope": "c",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "Undo_CanUndo2(${1:ReaProject* proj})$0"
    },
    "UNDO_CANUNDO2 eel2": {
        "prefix": "Undo_CanUndo2",
        "scope": "eel2",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "Undo_CanUndo2(${1:#retval},${2:ReaProject proj})$0"
    },
    "REAPER.UNDO_CANUNDO2 lua": {
        "prefix": "reaper.Undo_CanUndo2",
        "scope": "lua",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "reaper.Undo_CanUndo2(${1:ReaProject proj})$0"
    },
    "RPR_UNDO_CANUNDO2 python": {
        "prefix": "RPR_Undo_CanUndo2",
        "scope": "python",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "RPR_Undo_CanUndo2(${1:ReaProject proj})$0"
    },
    "UNDO_DOREDO2 c": {
        "prefix": "Undo_DoRedo2",
        "scope": "c",
        "description": "nonzero if success\n",
        "body": "Undo_DoRedo2(${1:ReaProject* proj})$0"
    },
    "UNDO_DOREDO2 eel2": {
        "prefix": "Undo_DoRedo2",
        "scope": "eel2",
        "description": "nonzero if success\n",
        "body": "Undo_DoRedo2(${1:ReaProject proj})$0"
    },
    "REAPER.UNDO_DOREDO2 lua": {
        "prefix": "reaper.Undo_DoRedo2",
        "scope": "lua",
        "description": "nonzero if success\n",
        "body": "reaper.Undo_DoRedo2(${1:ReaProject proj})$0"
    },
    "RPR_UNDO_DOREDO2 python": {
        "prefix": "RPR_Undo_DoRedo2",
        "scope": "python",
        "description": "nonzero if success\n",
        "body": "RPR_Undo_DoRedo2(${1:ReaProject proj})$0"
    },
    "UNDO_DOUNDO2 c": {
        "prefix": "Undo_DoUndo2",
        "scope": "c",
        "description": "nonzero if success\n",
        "body": "Undo_DoUndo2(${1:ReaProject* proj})$0"
    },
    "UNDO_DOUNDO2 eel2": {
        "prefix": "Undo_DoUndo2",
        "scope": "eel2",
        "description": "nonzero if success\n",
        "body": "Undo_DoUndo2(${1:ReaProject proj})$0"
    },
    "REAPER.UNDO_DOUNDO2 lua": {
        "prefix": "reaper.Undo_DoUndo2",
        "scope": "lua",
        "description": "nonzero if success\n",
        "body": "reaper.Undo_DoUndo2(${1:ReaProject proj})$0"
    },
    "RPR_UNDO_DOUNDO2 python": {
        "prefix": "RPR_Undo_DoUndo2",
        "scope": "python",
        "description": "nonzero if success\n",
        "body": "RPR_Undo_DoUndo2(${1:ReaProject proj})$0"
    },
    "UNDO_ENDBLOCK c": {
        "prefix": "Undo_EndBlock",
        "scope": "c",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "Undo_EndBlock(${1:const char* descchange},${2:int extraflags})$0"
    },
    "UNDO_ENDBLOCK eel2": {
        "prefix": "Undo_EndBlock",
        "scope": "eel2",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "Undo_EndBlock(${1:\"descchange\"},${2:int extraflags})$0"
    },
    "REAPER.UNDO_ENDBLOCK lua": {
        "prefix": "reaper.Undo_EndBlock",
        "scope": "lua",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "reaper.Undo_EndBlock(${1:string descchange},${2:integer extraflags})$0"
    },
    "RPR_UNDO_ENDBLOCK python": {
        "prefix": "RPR_Undo_EndBlock",
        "scope": "python",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "RPR_Undo_EndBlock(${1:String descchange},${2:Int extraflags})$0"
    },
    "UNDO_ENDBLOCK2 c": {
        "prefix": "Undo_EndBlock2",
        "scope": "c",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "Undo_EndBlock2(${1:ReaProject* proj},${2:const char* descchange},${3:int extraflags})$0"
    },
    "UNDO_ENDBLOCK2 eel2": {
        "prefix": "Undo_EndBlock2",
        "scope": "eel2",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "Undo_EndBlock2(${1:ReaProject proj},${2:\"descchange\"},${3:int extraflags})$0"
    },
    "REAPER.UNDO_ENDBLOCK2 lua": {
        "prefix": "reaper.Undo_EndBlock2",
        "scope": "lua",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "reaper.Undo_EndBlock2(${1:ReaProject proj},${2:string descchange},${3:integer extraflags})$0"
    },
    "RPR_UNDO_ENDBLOCK2 python": {
        "prefix": "RPR_Undo_EndBlock2",
        "scope": "python",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "RPR_Undo_EndBlock2(${1:ReaProject proj},${2:String descchange},${3:Int extraflags})$0"
    },
    "UNDO_ONSTATECHANGE c": {
        "prefix": "Undo_OnStateChange",
        "scope": "c",
        "description": "limited state change to items\n",
        "body": "Undo_OnStateChange(${1:const char* descchange})$0"
    },
    "UNDO_ONSTATECHANGE eel2": {
        "prefix": "Undo_OnStateChange",
        "scope": "eel2",
        "description": "limited state change to items\n",
        "body": "Undo_OnStateChange(${1:\"descchange\"})$0"
    },
    "REAPER.UNDO_ONSTATECHANGE lua": {
        "prefix": "reaper.Undo_OnStateChange",
        "scope": "lua",
        "description": "limited state change to items\n",
        "body": "reaper.Undo_OnStateChange(${1:string descchange})$0"
    },
    "RPR_UNDO_ONSTATECHANGE python": {
        "prefix": "RPR_Undo_OnStateChange",
        "scope": "python",
        "description": "limited state change to items\n",
        "body": "RPR_Undo_OnStateChange(${1:String descchange})$0"
    },
    "UNDO_ONSTATECHANGE2 c": {
        "prefix": "Undo_OnStateChange2",
        "scope": "c",
        "description": "limited state change to items\n",
        "body": "Undo_OnStateChange2(${1:ReaProject* proj},${2:const char* descchange})$0"
    },
    "UNDO_ONSTATECHANGE2 eel2": {
        "prefix": "Undo_OnStateChange2",
        "scope": "eel2",
        "description": "limited state change to items\n",
        "body": "Undo_OnStateChange2(${1:ReaProject proj},${2:\"descchange\"})$0"
    },
    "REAPER.UNDO_ONSTATECHANGE2 lua": {
        "prefix": "reaper.Undo_OnStateChange2",
        "scope": "lua",
        "description": "limited state change to items\n",
        "body": "reaper.Undo_OnStateChange2(${1:ReaProject proj},${2:string descchange})$0"
    },
    "RPR_UNDO_ONSTATECHANGE2 python": {
        "prefix": "RPR_Undo_OnStateChange2",
        "scope": "python",
        "description": "limited state change to items\n",
        "body": "RPR_Undo_OnStateChange2(${1:ReaProject proj},${2:String descchange})$0"
    },
    "UNDO_ONSTATECHANGE_ITEM c": {
        "prefix": "Undo_OnStateChange_Item",
        "scope": "c",
        "description": "\n",
        "body": "Undo_OnStateChange_Item(${1:ReaProject* proj},${2:const char* name},${3:MediaItem* item})$0"
    },
    "UNDO_ONSTATECHANGE_ITEM eel2": {
        "prefix": "Undo_OnStateChange_Item",
        "scope": "eel2",
        "description": "\n",
        "body": "Undo_OnStateChange_Item(${1:ReaProject proj},${2:\"name\"},${3:MediaItem item})$0"
    },
    "REAPER.UNDO_ONSTATECHANGE_ITEM lua": {
        "prefix": "reaper.Undo_OnStateChange_Item",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.Undo_OnStateChange_Item(${1:ReaProject proj},${2:string name},${3:MediaItem item})$0"
    },
    "RPR_UNDO_ONSTATECHANGE_ITEM python": {
        "prefix": "RPR_Undo_OnStateChange_Item",
        "scope": "python",
        "description": "\n",
        "body": "RPR_Undo_OnStateChange_Item(${1:ReaProject proj},${2:String name},${3:MediaItem item})$0"
    },
    "UNDO_ONSTATECHANGEEX c": {
        "prefix": "Undo_OnStateChangeEx",
        "scope": "c",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "Undo_OnStateChangeEx(${1:const char* descchange},${2:int whichStates},${3:int trackparm})$0"
    },
    "UNDO_ONSTATECHANGEEX eel2": {
        "prefix": "Undo_OnStateChangeEx",
        "scope": "eel2",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "Undo_OnStateChangeEx(${1:\"descchange\"},${2:int whichStates},${3:int trackparm})$0"
    },
    "REAPER.UNDO_ONSTATECHANGEEX lua": {
        "prefix": "reaper.Undo_OnStateChangeEx",
        "scope": "lua",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "reaper.Undo_OnStateChangeEx(${1:string descchange},${2:integer whichStates},${3:integer trackparm})$0"
    },
    "RPR_UNDO_ONSTATECHANGEEX python": {
        "prefix": "RPR_Undo_OnStateChangeEx",
        "scope": "python",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "RPR_Undo_OnStateChangeEx(${1:String descchange},${2:Int whichStates},${3:Int trackparm})$0"
    },
    "UNDO_ONSTATECHANGEEX2 c": {
        "prefix": "Undo_OnStateChangeEx2",
        "scope": "c",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "Undo_OnStateChangeEx2(${1:ReaProject* proj},${2:const char* descchange},${3:int whichStates},${4:int trackparm})$0"
    },
    "UNDO_ONSTATECHANGEEX2 eel2": {
        "prefix": "Undo_OnStateChangeEx2",
        "scope": "eel2",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "Undo_OnStateChangeEx2(${1:ReaProject proj},${2:\"descchange\"},${3:int whichStates},${4:int trackparm})$0"
    },
    "REAPER.UNDO_ONSTATECHANGEEX2 lua": {
        "prefix": "reaper.Undo_OnStateChangeEx2",
        "scope": "lua",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "reaper.Undo_OnStateChangeEx2(${1:ReaProject proj},${2:string descchange},${3:integer whichStates},${4:integer trackparm})$0"
    },
    "RPR_UNDO_ONSTATECHANGEEX2 python": {
        "prefix": "RPR_Undo_OnStateChangeEx2",
        "scope": "python",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "RPR_Undo_OnStateChangeEx2(${1:ReaProject proj},${2:String descchange},${3:Int whichStates},${4:Int trackparm})$0"
    },
    "UPDATEARRANGE c": {
        "prefix": "UpdateArrange",
        "scope": "c",
        "description": "Redraw the arrange view\n",
        "body": "UpdateArrange()$0"
    },
    "UPDATEARRANGE eel2": {
        "prefix": "UpdateArrange",
        "scope": "eel2",
        "description": "Redraw the arrange view\n",
        "body": "UpdateArrange()$0"
    },
    "REAPER.UPDATEARRANGE lua": {
        "prefix": "reaper.UpdateArrange",
        "scope": "lua",
        "description": "Redraw the arrange view\n",
        "body": "reaper.UpdateArrange()$0"
    },
    "RPR_UPDATEARRANGE python": {
        "prefix": "RPR_UpdateArrange",
        "scope": "python",
        "description": "Redraw the arrange view\n",
        "body": "RPR_UpdateArrange()$0"
    },
    "UPDATEITEMINPROJECT c": {
        "prefix": "UpdateItemInProject",
        "scope": "c",
        "description": "\n",
        "body": "UpdateItemInProject(${1:MediaItem* item})$0"
    },
    "UPDATEITEMINPROJECT eel2": {
        "prefix": "UpdateItemInProject",
        "scope": "eel2",
        "description": "\n",
        "body": "UpdateItemInProject(${1:MediaItem item})$0"
    },
    "REAPER.UPDATEITEMINPROJECT lua": {
        "prefix": "reaper.UpdateItemInProject",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.UpdateItemInProject(${1:MediaItem item})$0"
    },
    "RPR_UPDATEITEMINPROJECT python": {
        "prefix": "RPR_UpdateItemInProject",
        "scope": "python",
        "description": "\n",
        "body": "RPR_UpdateItemInProject(${1:MediaItem item})$0"
    },
    "UPDATETIMELINE c": {
        "prefix": "UpdateTimeline",
        "scope": "c",
        "description": "Redraw the arrange view and ruler\n",
        "body": "UpdateTimeline()$0"
    },
    "UPDATETIMELINE eel2": {
        "prefix": "UpdateTimeline",
        "scope": "eel2",
        "description": "Redraw the arrange view and ruler\n",
        "body": "UpdateTimeline()$0"
    },
    "REAPER.UPDATETIMELINE lua": {
        "prefix": "reaper.UpdateTimeline",
        "scope": "lua",
        "description": "Redraw the arrange view and ruler\n",
        "body": "reaper.UpdateTimeline()$0"
    },
    "RPR_UPDATETIMELINE python": {
        "prefix": "RPR_UpdateTimeline",
        "scope": "python",
        "description": "Redraw the arrange view and ruler\n",
        "body": "RPR_UpdateTimeline()$0"
    },
    "VALIDATEPTR c": {
        "prefix": "ValidatePtr",
        "scope": "c",
        "description": "see ValidatePtr2\n",
        "body": "ValidatePtr(${1:void* pointer},${2:const char* ctypename})$0"
    },
    "VALIDATEPTR eel2": {
        "prefix": "ValidatePtr",
        "scope": "eel2",
        "description": "see ValidatePtr2\n",
        "body": "ValidatePtr(${1:void* pointer},${2:\"ctypename\"})$0"
    },
    "REAPER.VALIDATEPTR lua": {
        "prefix": "reaper.ValidatePtr",
        "scope": "lua",
        "description": "see ValidatePtr2\n",
        "body": "reaper.ValidatePtr(${1:identifier pointer},${2:string ctypename})$0"
    },
    "RPR_VALIDATEPTR python": {
        "prefix": "RPR_ValidatePtr",
        "scope": "python",
        "description": "see ValidatePtr2\n",
        "body": "RPR_ValidatePtr(${1:void pointer},${2:String ctypename})$0"
    },
    "VALIDATEPTR2 c": {
        "prefix": "ValidatePtr2",
        "scope": "c",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "ValidatePtr2(${1:ReaProject* proj},${2:void* pointer},${3:const char* ctypename})$0"
    },
    "VALIDATEPTR2 eel2": {
        "prefix": "ValidatePtr2",
        "scope": "eel2",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "ValidatePtr2(${1:ReaProject proj},${2:void* pointer},${3:\"ctypename\"})$0"
    },
    "REAPER.VALIDATEPTR2 lua": {
        "prefix": "reaper.ValidatePtr2",
        "scope": "lua",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "reaper.ValidatePtr2(${1:ReaProject proj},${2:identifier pointer},${3:string ctypename})$0"
    },
    "RPR_VALIDATEPTR2 python": {
        "prefix": "RPR_ValidatePtr2",
        "scope": "python",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "RPR_ValidatePtr2(${1:ReaProject proj},${2:void pointer},${3:String ctypename})$0"
    },
    "VIEWPREFS c": {
        "prefix": "ViewPrefs",
        "scope": "c",
        "description": "Opens the prefs to a page, use pageByName if page is 0.\n",
        "body": "ViewPrefs(${1:int page},${2:const char* pageByName})$0"
    },
    "VIEWPREFS eel2": {
        "prefix": "ViewPrefs",
        "scope": "eel2",
        "description": "Opens the prefs to a page, use pageByName if page is 0.\n",
        "body": "ViewPrefs(${1:int page},${2:\"pageByName\"})$0"
    },
    "REAPER.VIEWPREFS lua": {
        "prefix": "reaper.ViewPrefs",
        "scope": "lua",
        "description": "Opens the prefs to a page, use pageByName if page is 0.\n",
        "body": "reaper.ViewPrefs(${1:integer page},${2:string pageByName})$0"
    },
    "RPR_VIEWPREFS python": {
        "prefix": "RPR_ViewPrefs",
        "scope": "python",
        "description": "Opens the prefs to a page, use pageByName if page is 0.\n",
        "body": "RPR_ViewPrefs(${1:Int page},${2:String pageByName})$0"
    },
    "BR_ENVALLOC c": {
        "prefix": "BR_EnvAlloc",
        "scope": "c",
        "description": "[BR] Allocate envelope object from track or take envelope pointer. Always call BR_EnvFree when done to release the object and commit changes if needed.\ntakeEnvelopesUseProjectTime: take envelope points' positions are\ncounted from take position, not project start time. If you want to work\nwith project time instead, pass this as true.\nFor further manipulation see BR_EnvCountPoints, BR_EnvDeletePoint, BR_EnvFind, BR_EnvFindNext, BR_EnvFindPrevious, BR_EnvGetParentTake, BR_EnvGetParentTrack, BR_EnvGetPoint, BR_EnvGetProperties, BR_EnvSetPoint, BR_EnvSetProperties, BR_EnvValueAtPos.\n",
        "body": "BR_EnvAlloc(${1:TrackEnvelope* envelope},${2:bool takeEnvelopesUseProjectTime})$0"
    },
    "EXTENSION_API eel2": {
        "prefix": "extension_api",
        "scope": "eel2",
        "description": "Used to\ncall functions exported by extension plugins. The first parameter must\nbe the exported function name, then its own parameters (as if the\nfunction was called directly).\n",
        "body": "extension_api(${1:\"function_name\"},${2:...})$0"
    },
    "REAPER.BR_ENVALLOC lua": {
        "prefix": "reaper.BR_EnvAlloc",
        "scope": "lua",
        "description": "[BR] Allocate envelope object from track or take envelope pointer. Always call BR_EnvFree when done to release the object and commit changes if needed.\ntakeEnvelopesUseProjectTime: take envelope points' positions are\ncounted from take position, not project start time. If you want to work\nwith project time instead, pass this as true.\nFor further manipulation see BR_EnvCountPoints, BR_EnvDeletePoint, BR_EnvFind, BR_EnvFindNext, BR_EnvFindPrevious, BR_EnvGetParentTake, BR_EnvGetParentTrack, BR_EnvGetPoint, BR_EnvGetProperties, BR_EnvSetPoint, BR_EnvSetProperties, BR_EnvValueAtPos.\n",
        "body": "reaper.BR_EnvAlloc(${1:TrackEnvelope envelope},${2:boolean takeEnvelopesUseProjectTime})$0"
    },
    "BR_ENVALLOC python": {
        "prefix": "BR_EnvAlloc",
        "scope": "python",
        "description": "[BR] Allocate envelope object from track or take envelope pointer. Always call BR_EnvFree when done to release the object and commit changes if needed.\ntakeEnvelopesUseProjectTime: take envelope points' positions are\ncounted from take position, not project start time. If you want to work\nwith project time instead, pass this as true.\nFor further manipulation see BR_EnvCountPoints, BR_EnvDeletePoint, BR_EnvFind, BR_EnvFindNext, BR_EnvFindPrevious, BR_EnvGetParentTake, BR_EnvGetParentTrack, BR_EnvGetPoint, BR_EnvGetProperties, BR_EnvSetPoint, BR_EnvSetProperties, BR_EnvValueAtPos.\n",
        "body": "BR_EnvAlloc(${1:TrackEnvelope envelope},${2:Boolean takeEnvelopesUseProjectTime})$0"
    },
    "BR_ENVCOUNTPOINTS c": {
        "prefix": "BR_EnvCountPoints",
        "scope": "c",
        "description": "[BR] Count envelope points in the envelope object allocated with BR_EnvAlloc.\n",
        "body": "BR_EnvCountPoints(${1:BR_Envelope* envelope})$0"
    },
    "REAPER.BR_ENVCOUNTPOINTS lua": {
        "prefix": "reaper.BR_EnvCountPoints",
        "scope": "lua",
        "description": "[BR] Count envelope points in the envelope object allocated with BR_EnvAlloc.\n",
        "body": "reaper.BR_EnvCountPoints(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVCOUNTPOINTS python": {
        "prefix": "BR_EnvCountPoints",
        "scope": "python",
        "description": "[BR] Count envelope points in the envelope object allocated with BR_EnvAlloc.\n",
        "body": "BR_EnvCountPoints(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVDELETEPOINT c": {
        "prefix": "BR_EnvDeletePoint",
        "scope": "c",
        "description": "[BR] Delete envelope point by index (zero-based) in the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "BR_EnvDeletePoint(${1:BR_Envelope* envelope},${2:int id})$0"
    },
    "REAPER.BR_ENVDELETEPOINT lua": {
        "prefix": "reaper.BR_EnvDeletePoint",
        "scope": "lua",
        "description": "[BR] Delete envelope point by index (zero-based) in the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "reaper.BR_EnvDeletePoint(${1:BR_Envelope envelope},${2:integer id})$0"
    },
    "BR_ENVDELETEPOINT python": {
        "prefix": "BR_EnvDeletePoint",
        "scope": "python",
        "description": "[BR] Delete envelope point by index (zero-based) in the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "BR_EnvDeletePoint(${1:BR_Envelope envelope},${2:Int id})$0"
    },
    "BR_ENVFIND c": {
        "prefix": "BR_EnvFind",
        "scope": "c",
        "description": "[BR] Find envelope point at time position in the envelope object allocated with BR_EnvAlloc.\nPass delta > 0 to search surrounding range - in that case the\nclosest point to position within delta will be searched for. Returns\nenvelope point id (zero-based) on success or -1 on failure.\n",
        "body": "BR_EnvFind(${1:BR_Envelope* envelope},${2:double position},${3:double delta})$0"
    },
    "REAPER.BR_ENVFIND lua": {
        "prefix": "reaper.BR_EnvFind",
        "scope": "lua",
        "description": "[BR] Find envelope point at time position in the envelope object allocated with BR_EnvAlloc.\nPass delta > 0 to search surrounding range - in that case the\nclosest point to position within delta will be searched for. Returns\nenvelope point id (zero-based) on success or -1 on failure.\n",
        "body": "reaper.BR_EnvFind(${1:BR_Envelope envelope},${2:number position},${3:number delta})$0"
    },
    "BR_ENVFIND python": {
        "prefix": "BR_EnvFind",
        "scope": "python",
        "description": "[BR] Find envelope point at time position in the envelope object allocated with BR_EnvAlloc.\nPass delta > 0 to search surrounding range - in that case the\nclosest point to position within delta will be searched for. Returns\nenvelope point id (zero-based) on success or -1 on failure.\n",
        "body": "BR_EnvFind(${1:BR_Envelope envelope},${2:Float position},${3:Float delta})$0"
    },
    "BR_ENVFINDNEXT c": {
        "prefix": "BR_EnvFindNext",
        "scope": "c",
        "description": "[BR] Find next envelope point after time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "BR_EnvFindNext(${1:BR_Envelope* envelope},${2:double position})$0"
    },
    "REAPER.BR_ENVFINDNEXT lua": {
        "prefix": "reaper.BR_EnvFindNext",
        "scope": "lua",
        "description": "[BR] Find next envelope point after time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "reaper.BR_EnvFindNext(${1:BR_Envelope envelope},${2:number position})$0"
    },
    "BR_ENVFINDNEXT python": {
        "prefix": "BR_EnvFindNext",
        "scope": "python",
        "description": "[BR] Find next envelope point after time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "BR_EnvFindNext(${1:BR_Envelope envelope},${2:Float position})$0"
    },
    "BR_ENVFINDPREVIOUS c": {
        "prefix": "BR_EnvFindPrevious",
        "scope": "c",
        "description": "[BR] Find previous envelope point before time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "BR_EnvFindPrevious(${1:BR_Envelope* envelope},${2:double position})$0"
    },
    "REAPER.BR_ENVFINDPREVIOUS lua": {
        "prefix": "reaper.BR_EnvFindPrevious",
        "scope": "lua",
        "description": "[BR] Find previous envelope point before time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "reaper.BR_EnvFindPrevious(${1:BR_Envelope envelope},${2:number position})$0"
    },
    "BR_ENVFINDPREVIOUS python": {
        "prefix": "BR_EnvFindPrevious",
        "scope": "python",
        "description": "[BR] Find previous envelope point before time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "BR_EnvFindPrevious(${1:BR_Envelope envelope},${2:Float position})$0"
    },
    "BR_ENVFREE c": {
        "prefix": "BR_EnvFree",
        "scope": "c",
        "description": "[BR] Free envelope object allocated with BR_EnvAlloc\nand commit changes if needed. Returns true if changes were committed\nsuccessfully. Note that when envelope object wasn't modified nothing\nwill get committed even if commit = true - in that case function returns\nfalse.\n",
        "body": "BR_EnvFree(${1:BR_Envelope* envelope},${2:bool commit})$0"
    },
    "REAPER.BR_ENVFREE lua": {
        "prefix": "reaper.BR_EnvFree",
        "scope": "lua",
        "description": "[BR] Free envelope object allocated with BR_EnvAlloc\nand commit changes if needed. Returns true if changes were committed\nsuccessfully. Note that when envelope object wasn't modified nothing\nwill get committed even if commit = true - in that case function returns\nfalse.\n",
        "body": "reaper.BR_EnvFree(${1:BR_Envelope envelope},${2:boolean commit})$0"
    },
    "BR_ENVFREE python": {
        "prefix": "BR_EnvFree",
        "scope": "python",
        "description": "[BR] Free envelope object allocated with BR_EnvAlloc\nand commit changes if needed. Returns true if changes were committed\nsuccessfully. Note that when envelope object wasn't modified nothing\nwill get committed even if commit = true - in that case function returns\nfalse.\n",
        "body": "BR_EnvFree(${1:BR_Envelope envelope},${2:Boolean commit})$0"
    },
    "BR_ENVGETPARENTTAKE c": {
        "prefix": "BR_EnvGetParentTake",
        "scope": "c",
        "description": "[BR] If envelope object allocated with BR_EnvAlloc is take envelope, returns parent media item take, otherwise NULL.\n",
        "body": "BR_EnvGetParentTake(${1:BR_Envelope* envelope})$0"
    },
    "REAPER.BR_ENVGETPARENTTAKE lua": {
        "prefix": "reaper.BR_EnvGetParentTake",
        "scope": "lua",
        "description": "[BR] If envelope object allocated with BR_EnvAlloc is take envelope, returns parent media item take, otherwise NULL.\n",
        "body": "reaper.BR_EnvGetParentTake(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPARENTTAKE python": {
        "prefix": "BR_EnvGetParentTake",
        "scope": "python",
        "description": "[BR] If envelope object allocated with BR_EnvAlloc is take envelope, returns parent media item take, otherwise NULL.\n",
        "body": "BR_EnvGetParentTake(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPARENTTRACK c": {
        "prefix": "BR_EnvGetParentTrack",
        "scope": "c",
        "description": "[BR] Get parent track of envelope object allocated with BR_EnvAlloc. If take envelope, returns NULL.\n",
        "body": "BR_EnvGetParentTrack(${1:BR_Envelope* envelope})$0"
    },
    "REAPER.BR_ENVGETPARENTTRACK lua": {
        "prefix": "reaper.BR_EnvGetParentTrack",
        "scope": "lua",
        "description": "[BR] Get parent track of envelope object allocated with BR_EnvAlloc. If take envelope, returns NULL.\n",
        "body": "reaper.BR_EnvGetParentTrack(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPARENTTRACK python": {
        "prefix": "BR_EnvGetParentTrack",
        "scope": "python",
        "description": "[BR] Get parent track of envelope object allocated with BR_EnvAlloc. If take envelope, returns NULL.\n",
        "body": "BR_EnvGetParentTrack(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPOINT c": {
        "prefix": "BR_EnvGetPoint",
        "scope": "c",
        "description": "[BR] Get envelope point by id (zero-based) from the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "BR_EnvGetPoint(${1:BR_Envelope* envelope},${2:int id},${3:double* positionOut},${4:double* valueOut},${5:int* shapeOut},${6:bool* selectedOut},${7:double* bezierOut})$0"
    },
    "REAPER.BR_ENVGETPOINT lua": {
        "prefix": "reaper.BR_EnvGetPoint",
        "scope": "lua",
        "description": "[BR] Get envelope point by id (zero-based) from the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "reaper.BR_EnvGetPoint(${1:BR_Envelope envelope},${2:integer id})$0"
    },
    "BR_ENVGETPOINT python": {
        "prefix": "BR_EnvGetPoint",
        "scope": "python",
        "description": "[BR] Get envelope point by id (zero-based) from the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "BR_EnvGetPoint(${1:envelope},${2:id},${3:positionOut},${4:valueOut},${5:shapeOut},${6:selectedOut},${7:bezierOut})$0"
    },
    "BR_ENVGETPROPERTIES c": {
        "prefix": "BR_EnvGetProperties",
        "scope": "c",
        "description": "[BR] Get envelope properties for the envelope object allocated with BR_EnvAlloc.\nactive: true if envelope is active\nvisible: true if envelope is visible\narmed: true if envelope is armed\ninLane: true if envelope has it's own envelope lane\nlaneHeight: envelope lane override height. 0 for none, otherwise size in pixels\ndefaultShape: default point shape: 0->Linear, 1->Square,\n2->Slow start/end, 3->Fast start, 4->Fast end, 5->Bezier\nminValue: minimum envelope value\nmaxValue: maximum envelope value\ntype: envelope type: 0->Volume, 1->Volume (Pre-FX), 2->Pan,\n3->Pan (Pre-FX), 4->Width, 5->Width (Pre-FX), 6->Mute,\n7->Pitch, 8->Playrate, 9->Tempo map, 10->Parameter\nfaderScaling: true if envelope uses fader scaling\n",
        "body": "BR_EnvGetProperties(${1:BR_Envelope* envelope},${2:bool* activeOut},${3:bool* visibleOut},${4:bool* armedOut},${5:bool* inLaneOut},${6:int* laneHeightOut},${7:int* defaultShapeOut},${8:double* minValueOut},${9:double* maxValueOut},${10:double* centerValueOut},${11:int* typeOut},${12:bool* faderScalingOut})$0"
    },
    "REAPER.BR_ENVGETPROPERTIES lua": {
        "prefix": "reaper.BR_EnvGetProperties",
        "scope": "lua",
        "description": "[BR] Get envelope properties for the envelope object allocated with BR_EnvAlloc.\nactive: true if envelope is active\nvisible: true if envelope is visible\narmed: true if envelope is armed\ninLane: true if envelope has it's own envelope lane\nlaneHeight: envelope lane override height. 0 for none, otherwise size in pixels\ndefaultShape: default point shape: 0->Linear, 1->Square,\n2->Slow start/end, 3->Fast start, 4->Fast end, 5->Bezier\nminValue: minimum envelope value\nmaxValue: maximum envelope value\ntype: envelope type: 0->Volume, 1->Volume (Pre-FX), 2->Pan,\n3->Pan (Pre-FX), 4->Width, 5->Width (Pre-FX), 6->Mute,\n7->Pitch, 8->Playrate, 9->Tempo map, 10->Parameter\nfaderScaling: true if envelope uses fader scaling\n",
        "body": "reaper.BR_EnvGetProperties(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPROPERTIES python": {
        "prefix": "BR_EnvGetProperties",
        "scope": "python",
        "description": "[BR] Get envelope properties for the envelope object allocated with BR_EnvAlloc.\nactive: true if envelope is active\nvisible: true if envelope is visible\narmed: true if envelope is armed\ninLane: true if envelope has it's own envelope lane\nlaneHeight: envelope lane override height. 0 for none, otherwise size in pixels\ndefaultShape: default point shape: 0->Linear, 1->Square,\n2->Slow start/end, 3->Fast start, 4->Fast end, 5->Bezier\nminValue: minimum envelope value\nmaxValue: maximum envelope value\ntype: envelope type: 0->Volume, 1->Volume (Pre-FX), 2->Pan,\n3->Pan (Pre-FX), 4->Width, 5->Width (Pre-FX), 6->Mute,\n7->Pitch, 8->Playrate, 9->Tempo map, 10->Parameter\nfaderScaling: true if envelope uses fader scaling\n",
        "body": "BR_EnvGetProperties(${1:envelope},${2:activeOut},${3:visibleOut},${4:armedOut},${5:inLaneOut},${6:laneHeightOut},${7:defaultShapeOut},${8:minValueOut},${9:maxValueOut},${10:centerValueOut},${11:typeOut},${12:faderScalingOut})$0"
    },
    "BR_ENVSETPOINT c": {
        "prefix": "BR_EnvSetPoint",
        "scope": "c",
        "description": "[BR] Set envelope point by id (zero-based) in the envelope object allocated with BR_EnvAlloc.\nTo create point instead, pass id = -1. Note that if new point is\ninserted or existing point's time position is changed, points won't\nautomatically get sorted. To do that, see BR_EnvSortPoints.\nReturns true on success.\n",
        "body": "BR_EnvSetPoint(${1:BR_Envelope* envelope},${2:int id},${3:double position},${4:double value},${5:int shape},${6:bool selected},${7:double bezier})$0"
    },
    "REAPER.BR_ENVSETPOINT lua": {
        "prefix": "reaper.BR_EnvSetPoint",
        "scope": "lua",
        "description": "[BR] Set envelope point by id (zero-based) in the envelope object allocated with BR_EnvAlloc.\nTo create point instead, pass id = -1. Note that if new point is\ninserted or existing point's time position is changed, points won't\nautomatically get sorted. To do that, see BR_EnvSortPoints.\nReturns true on success.\n",
        "body": "reaper.BR_EnvSetPoint(${1:BR_Envelope envelope},${2:integer id},${3:number position},${4:number value},${5:integer shape},${6:boolean selected},${7:number bezier})$0"
    },
    "BR_ENVSETPOINT python": {
        "prefix": "BR_EnvSetPoint",
        "scope": "python",
        "description": "[BR] Set envelope point by id (zero-based) in the envelope object allocated with BR_EnvAlloc.\nTo create point instead, pass id = -1. Note that if new point is\ninserted or existing point's time position is changed, points won't\nautomatically get sorted. To do that, see BR_EnvSortPoints.\nReturns true on success.\n",
        "body": "BR_EnvSetPoint(${1:BR_Envelope envelope},${2:Int id},${3:Float position},${4:Float value},${5:Int shape},${6:Boolean selected},${7:Float bezier})$0"
    },
    "BR_ENVSETPROPERTIES c": {
        "prefix": "BR_EnvSetProperties",
        "scope": "c",
        "description": "[BR] Set envelope properties for the envelope object allocated with BR_EnvAlloc. For parameter description see BR_EnvGetProperties.\n",
        "body": "BR_EnvSetProperties(${1:BR_Envelope* envelope},${2:bool active},${3:bool visible},${4:bool armed},${5:bool inLane},${6:int laneHeight},${7:int defaultShape},${8:bool faderScaling})$0"
    },
    "REAPER.BR_ENVSETPROPERTIES lua": {
        "prefix": "reaper.BR_EnvSetProperties",
        "scope": "lua",
        "description": "[BR] Set envelope properties for the envelope object allocated with BR_EnvAlloc. For parameter description see BR_EnvGetProperties.\n",
        "body": "reaper.BR_EnvSetProperties(${1:BR_Envelope envelope},${2:boolean active},${3:boolean visible},${4:boolean armed},${5:boolean inLane},${6:integer laneHeight},${7:integer defaultShape},${8:boolean faderScaling})$0"
    },
    "BR_ENVSETPROPERTIES python": {
        "prefix": "BR_EnvSetProperties",
        "scope": "python",
        "description": "[BR] Set envelope properties for the envelope object allocated with BR_EnvAlloc. For parameter description see BR_EnvGetProperties.\n",
        "body": "BR_EnvSetProperties(${1:BR_Envelope envelope},${2:Boolean active},${3:Boolean visible},${4:Boolean armed},${5:Boolean inLane},${6:Int laneHeight},${7:Int defaultShape},${8:Boolean faderScaling})$0"
    },
    "BR_ENVSORTPOINTS c": {
        "prefix": "BR_EnvSortPoints",
        "scope": "c",
        "description": "[BR] Sort envelope points by position. The only reason to call this is\nif sorted points are explicitly needed after editing them with BR_EnvSetPoint. Note that you do not have to call this before doing BR_EnvFree since it does handle unsorted points too.\n",
        "body": "BR_EnvSortPoints(${1:BR_Envelope* envelope})$0"
    },
    "REAPER.BR_ENVSORTPOINTS lua": {
        "prefix": "reaper.BR_EnvSortPoints",
        "scope": "lua",
        "description": "[BR] Sort envelope points by position. The only reason to call this is\nif sorted points are explicitly needed after editing them with BR_EnvSetPoint. Note that you do not have to call this before doing BR_EnvFree since it does handle unsorted points too.\n",
        "body": "reaper.BR_EnvSortPoints(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVSORTPOINTS python": {
        "prefix": "BR_EnvSortPoints",
        "scope": "python",
        "description": "[BR] Sort envelope points by position. The only reason to call this is\nif sorted points are explicitly needed after editing them with BR_EnvSetPoint. Note that you do not have to call this before doing BR_EnvFree since it does handle unsorted points too.\n",
        "body": "BR_EnvSortPoints(${1:BR_Envelope envelope})$0"
    },
    "BR_ENVVALUEATPOS c": {
        "prefix": "BR_EnvValueAtPos",
        "scope": "c",
        "description": "[BR] Get envelope value at time position for the envelope object allocated with BR_EnvAlloc.\n",
        "body": "BR_EnvValueAtPos(${1:BR_Envelope* envelope},${2:double position})$0"
    },
    "REAPER.BR_ENVVALUEATPOS lua": {
        "prefix": "reaper.BR_EnvValueAtPos",
        "scope": "lua",
        "description": "[BR] Get envelope value at time position for the envelope object allocated with BR_EnvAlloc.\n",
        "body": "reaper.BR_EnvValueAtPos(${1:BR_Envelope envelope},${2:number position})$0"
    },
    "BR_ENVVALUEATPOS python": {
        "prefix": "BR_EnvValueAtPos",
        "scope": "python",
        "description": "[BR] Get envelope value at time position for the envelope object allocated with BR_EnvAlloc.\n",
        "body": "BR_EnvValueAtPos(${1:BR_Envelope envelope},${2:Float position})$0"
    },
    "BR_GETARRANGEVIEW c": {
        "prefix": "BR_GetArrangeView",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Get start and end time position of arrange view. To set arrange view instead, see BR_SetArrangeView.\n",
        "body": "BR_GetArrangeView(${1:ReaProject* proj},${2:double* startTimeOut},${3:double* endTimeOut})$0"
    },
    "REAPER.BR_GETARRANGEVIEW lua": {
        "prefix": "reaper.BR_GetArrangeView",
        "scope": "lua",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Get start and end time position of arrange view. To set arrange view instead, see BR_SetArrangeView.\n",
        "body": "reaper.BR_GetArrangeView(${1:ReaProject proj})$0"
    },
    "BR_GETARRANGEVIEW python": {
        "prefix": "BR_GetArrangeView",
        "scope": "python",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Get start and end time position of arrange view. To set arrange view instead, see BR_SetArrangeView.\n",
        "body": "BR_GetArrangeView(${1:proj},${2:startTimeOut},${3:endTimeOut})$0"
    },
    "BR_GETCLOSESTGRIDDIVISION c": {
        "prefix": "BR_GetClosestGridDivision",
        "scope": "c",
        "description": "[BR] Get closest grid division to position. Note that this functions is different from SnapToGrid\nin two regards. SnapToGrid() needs snap enabled to work and this one\nworks always. Secondly, grid divisions are different from grid lines\nbecause some grid lines may be hidden due to zoom level - this function\nignores grid line visibility and always searches for the closest grid\ndivision at given position. For more grid division functions, see BR_GetNextGridDivision and BR_GetPrevGridDivision.\n",
        "body": "BR_GetClosestGridDivision(${1:double position})$0"
    },
    "REAPER.BR_GETCLOSESTGRIDDIVISION lua": {
        "prefix": "reaper.BR_GetClosestGridDivision",
        "scope": "lua",
        "description": "[BR] Get closest grid division to position. Note that this functions is different from SnapToGrid\nin two regards. SnapToGrid() needs snap enabled to work and this one\nworks always. Secondly, grid divisions are different from grid lines\nbecause some grid lines may be hidden due to zoom level - this function\nignores grid line visibility and always searches for the closest grid\ndivision at given position. For more grid division functions, see BR_GetNextGridDivision and BR_GetPrevGridDivision.\n",
        "body": "reaper.BR_GetClosestGridDivision(${1:number position})$0"
    },
    "BR_GETCLOSESTGRIDDIVISION python": {
        "prefix": "BR_GetClosestGridDivision",
        "scope": "python",
        "description": "[BR] Get closest grid division to position. Note that this functions is different from SnapToGrid\nin two regards. SnapToGrid() needs snap enabled to work and this one\nworks always. Secondly, grid divisions are different from grid lines\nbecause some grid lines may be hidden due to zoom level - this function\nignores grid line visibility and always searches for the closest grid\ndivision at given position. For more grid division functions, see BR_GetNextGridDivision and BR_GetPrevGridDivision.\n",
        "body": "BR_GetClosestGridDivision(${1:Float position})$0"
    },
    "BR_GETCURRENTTHEME c": {
        "prefix": "BR_GetCurrentTheme",
        "scope": "c",
        "description": "[BR] Get current theme information. themePathOut is set to full theme\npath and themeNameOut is set to theme name excluding any path info and\nextension\n",
        "body": "BR_GetCurrentTheme(${1:char* themePathOut},${2:int themePathOut_sz},${3:char* themeNameOut},${4:int themeNameOut_sz})$0"
    },
    "REAPER.BR_GETCURRENTTHEME lua": {
        "prefix": "reaper.BR_GetCurrentTheme",
        "scope": "lua",
        "description": "[BR] Get current theme information. themePathOut is set to full theme\npath and themeNameOut is set to theme name excluding any path info and\nextension\n",
        "body": "reaper.BR_GetCurrentTheme()$0"
    },
    "BR_GETCURRENTTHEME python": {
        "prefix": "BR_GetCurrentTheme",
        "scope": "python",
        "description": "[BR] Get current theme information. themePathOut is set to full theme\npath and themeNameOut is set to theme name excluding any path info and\nextension\n",
        "body": "BR_GetCurrentTheme(${1:themePathOut},${2:themePathOut_sz},${3:themeNameOut},${4:themeNameOut_sz})$0"
    },
    "BR_GETMEDIAITEMBYGUID c": {
        "prefix": "BR_GetMediaItemByGUID",
        "scope": "c",
        "description": "[BR] Get media item from GUID string. Note that the GUID must be enclosed in braces {}. To get item's GUID as a string, see BR_GetMediaItemGUID.\n",
        "body": "BR_GetMediaItemByGUID(${1:ReaProject* proj},${2:const char* guidStringIn})$0"
    },
    "REAPER.BR_GETMEDIAITEMBYGUID lua": {
        "prefix": "reaper.BR_GetMediaItemByGUID",
        "scope": "lua",
        "description": "[BR] Get media item from GUID string. Note that the GUID must be enclosed in braces {}. To get item's GUID as a string, see BR_GetMediaItemGUID.\n",
        "body": "reaper.BR_GetMediaItemByGUID(${1:ReaProject proj},${2:string guidStringIn})$0"
    },
    "BR_GETMEDIAITEMBYGUID python": {
        "prefix": "BR_GetMediaItemByGUID",
        "scope": "python",
        "description": "[BR] Get media item from GUID string. Note that the GUID must be enclosed in braces {}. To get item's GUID as a string, see BR_GetMediaItemGUID.\n",
        "body": "BR_GetMediaItemByGUID(${1:ReaProject proj},${2:String guidStringIn})$0"
    },
    "BR_GETMEDIAITEMGUID c": {
        "prefix": "BR_GetMediaItemGUID",
        "scope": "c",
        "description": "[BR] Get media item GUID as a string (guidStringOut_sz should be at least 64). To get media item back from GUID string, see BR_GetMediaItemByGUID.\n",
        "body": "BR_GetMediaItemGUID(${1:MediaItem* item},${2:char* guidStringOut},${3:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMEDIAITEMGUID lua": {
        "prefix": "reaper.BR_GetMediaItemGUID",
        "scope": "lua",
        "description": "[BR] Get media item GUID as a string (guidStringOut_sz should be at least 64). To get media item back from GUID string, see BR_GetMediaItemByGUID.\n",
        "body": "reaper.BR_GetMediaItemGUID(${1:MediaItem item})$0"
    },
    "BR_GETMEDIAITEMGUID python": {
        "prefix": "BR_GetMediaItemGUID",
        "scope": "python",
        "description": "[BR] Get media item GUID as a string (guidStringOut_sz should be at least 64). To get media item back from GUID string, see BR_GetMediaItemByGUID.\n",
        "body": "BR_GetMediaItemGUID(${1:item},${2:guidStringOut},${3:guidStringOut_sz})$0"
    },
    "BR_GETMEDIAITEMIMAGERESOURCE c": {
        "prefix": "BR_GetMediaItemImageResource",
        "scope": "c",
        "description": "[BR] Get currently loaded image resource and it's flags for a given\nitem. Returns false if there is no image resource set. To set image\nresource, see BR_SetMediaItemImageResource.\n",
        "body": "BR_GetMediaItemImageResource(${1:MediaItem* item},${2:char* imageOut},${3:int imageOut_sz},${4:int* imageFlagsOut})$0"
    },
    "REAPER.BR_GETMEDIAITEMIMAGERESOURCE lua": {
        "prefix": "reaper.BR_GetMediaItemImageResource",
        "scope": "lua",
        "description": "[BR] Get currently loaded image resource and it's flags for a given\nitem. Returns false if there is no image resource set. To set image\nresource, see BR_SetMediaItemImageResource.\n",
        "body": "reaper.BR_GetMediaItemImageResource(${1:MediaItem item})$0"
    },
    "BR_GETMEDIAITEMIMAGERESOURCE python": {
        "prefix": "BR_GetMediaItemImageResource",
        "scope": "python",
        "description": "[BR] Get currently loaded image resource and it's flags for a given\nitem. Returns false if there is no image resource set. To set image\nresource, see BR_SetMediaItemImageResource.\n",
        "body": "BR_GetMediaItemImageResource(${1:item},${2:imageOut},${3:imageOut_sz},${4:imageFlagsOut})$0"
    },
    "BR_GETMEDIAITEMTAKEGUID c": {
        "prefix": "BR_GetMediaItemTakeGUID",
        "scope": "c",
        "description": "[BR] Get media item take GUID as a string (guidStringOut_sz should be at least 64). To get take from GUID string, see SNM_GetMediaItemTakeByGUID.\n",
        "body": "BR_GetMediaItemTakeGUID(${1:MediaItem_Take* take},${2:char* guidStringOut},${3:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMEDIAITEMTAKEGUID lua": {
        "prefix": "reaper.BR_GetMediaItemTakeGUID",
        "scope": "lua",
        "description": "[BR] Get media item take GUID as a string (guidStringOut_sz should be at least 64). To get take from GUID string, see SNM_GetMediaItemTakeByGUID.\n",
        "body": "reaper.BR_GetMediaItemTakeGUID(${1:MediaItem_Take take})$0"
    },
    "BR_GETMEDIAITEMTAKEGUID python": {
        "prefix": "BR_GetMediaItemTakeGUID",
        "scope": "python",
        "description": "[BR] Get media item take GUID as a string (guidStringOut_sz should be at least 64). To get take from GUID string, see SNM_GetMediaItemTakeByGUID.\n",
        "body": "BR_GetMediaItemTakeGUID(${1:take},${2:guidStringOut},${3:guidStringOut_sz})$0"
    },
    "BR_GETMEDIASOURCEPROPERTIES c": {
        "prefix": "BR_GetMediaSourceProperties",
        "scope": "c",
        "description": "[BR] Get take media source properties as they appear in Item properties. Returns false if take can't have them (MIDI items etc.).\nTo set source properties, see BR_SetMediaSourceProperties.\n",
        "body": "BR_GetMediaSourceProperties(${1:MediaItem_Take* take},${2:bool* sectionOut},${3:double* startOut},${4:double* lengthOut},${5:double* fadeOut},${6:bool* reverseOut})$0"
    },
    "REAPER.BR_GETMEDIASOURCEPROPERTIES lua": {
        "prefix": "reaper.BR_GetMediaSourceProperties",
        "scope": "lua",
        "description": "[BR] Get take media source properties as they appear in Item properties. Returns false if take can't have them (MIDI items etc.).\nTo set source properties, see BR_SetMediaSourceProperties.\n",
        "body": "reaper.BR_GetMediaSourceProperties(${1:MediaItem_Take take})$0"
    },
    "BR_GETMEDIASOURCEPROPERTIES python": {
        "prefix": "BR_GetMediaSourceProperties",
        "scope": "python",
        "description": "[BR] Get take media source properties as they appear in Item properties. Returns false if take can't have them (MIDI items etc.).\nTo set source properties, see BR_SetMediaSourceProperties.\n",
        "body": "BR_GetMediaSourceProperties(${1:take},${2:sectionOut},${3:startOut},${4:lengthOut},${5:fadeOut},${6:reverseOut})$0"
    },
    "BR_GETMEDIATRACKBYGUID c": {
        "prefix": "BR_GetMediaTrackByGUID",
        "scope": "c",
        "description": "[BR] Get media track from GUID string. Note that the GUID must be enclosed in braces {}. To get track's GUID as a string, see BR_GetMediaTrackGUID.\n",
        "body": "BR_GetMediaTrackByGUID(${1:ReaProject* proj},${2:const char* guidStringIn})$0"
    },
    "REAPER.BR_GETMEDIATRACKBYGUID lua": {
        "prefix": "reaper.BR_GetMediaTrackByGUID",
        "scope": "lua",
        "description": "[BR] Get media track from GUID string. Note that the GUID must be enclosed in braces {}. To get track's GUID as a string, see BR_GetMediaTrackGUID.\n",
        "body": "reaper.BR_GetMediaTrackByGUID(${1:ReaProject proj},${2:string guidStringIn})$0"
    },
    "BR_GETMEDIATRACKBYGUID python": {
        "prefix": "BR_GetMediaTrackByGUID",
        "scope": "python",
        "description": "[BR] Get media track from GUID string. Note that the GUID must be enclosed in braces {}. To get track's GUID as a string, see BR_GetMediaTrackGUID.\n",
        "body": "BR_GetMediaTrackByGUID(${1:ReaProject proj},${2:String guidStringIn})$0"
    },
    "BR_GETMEDIATRACKFREEZECOUNT c": {
        "prefix": "BR_GetMediaTrackFreezeCount",
        "scope": "c",
        "description": "[BR] Get media track freeze count (if track isn't frozen at all, returns 0).\n",
        "body": "BR_GetMediaTrackFreezeCount(${1:MediaTrack* track})$0"
    },
    "REAPER.BR_GETMEDIATRACKFREEZECOUNT lua": {
        "prefix": "reaper.BR_GetMediaTrackFreezeCount",
        "scope": "lua",
        "description": "[BR] Get media track freeze count (if track isn't frozen at all, returns 0).\n",
        "body": "reaper.BR_GetMediaTrackFreezeCount(${1:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKFREEZECOUNT python": {
        "prefix": "BR_GetMediaTrackFreezeCount",
        "scope": "python",
        "description": "[BR] Get media track freeze count (if track isn't frozen at all, returns 0).\n",
        "body": "BR_GetMediaTrackFreezeCount(${1:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKGUID c": {
        "prefix": "BR_GetMediaTrackGUID",
        "scope": "c",
        "description": "[BR] Get media track GUID as a string (guidStringOut_sz should be at least 64). To get media track back from GUID string, see BR_GetMediaTrackByGUID.\n",
        "body": "BR_GetMediaTrackGUID(${1:MediaTrack* track},${2:char* guidStringOut},${3:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMEDIATRACKGUID lua": {
        "prefix": "reaper.BR_GetMediaTrackGUID",
        "scope": "lua",
        "description": "[BR] Get media track GUID as a string (guidStringOut_sz should be at least 64). To get media track back from GUID string, see BR_GetMediaTrackByGUID.\n",
        "body": "reaper.BR_GetMediaTrackGUID(${1:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKGUID python": {
        "prefix": "BR_GetMediaTrackGUID",
        "scope": "python",
        "description": "[BR] Get media track GUID as a string (guidStringOut_sz should be at least 64). To get media track back from GUID string, see BR_GetMediaTrackByGUID.\n",
        "body": "BR_GetMediaTrackGUID(${1:track},${2:guidStringOut},${3:guidStringOut_sz})$0"
    },
    "BR_GETMEDIATRACKLAYOUTS c": {
        "prefix": "BR_GetMediaTrackLayouts",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Get media track layouts for MCP and TCP. Empty string\n(\"\") means that layout is set to the default layout. To set media track\nlayouts, see BR_SetMediaTrackLayouts.\n",
        "body": "BR_GetMediaTrackLayouts(${1:MediaTrack* track},${2:char* mcpLayoutNameOut},${3:int mcpLayoutNameOut_sz},${4:char* tcpLayoutNameOut},${5:int tcpLayoutNameOut_sz})$0"
    },
    "REAPER.BR_GETMEDIATRACKLAYOUTS lua": {
        "prefix": "reaper.BR_GetMediaTrackLayouts",
        "scope": "lua",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Get media track layouts for MCP and TCP. Empty string\n(\"\") means that layout is set to the default layout. To set media track\nlayouts, see BR_SetMediaTrackLayouts.\n",
        "body": "reaper.BR_GetMediaTrackLayouts(${1:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKLAYOUTS python": {
        "prefix": "BR_GetMediaTrackLayouts",
        "scope": "python",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Get media track layouts for MCP and TCP. Empty string\n(\"\") means that layout is set to the default layout. To set media track\nlayouts, see BR_SetMediaTrackLayouts.\n",
        "body": "BR_GetMediaTrackLayouts(${1:track},${2:mcpLayoutNameOut},${3:mcpLayoutNameOut_sz},${4:tcpLayoutNameOut},${5:tcpLayoutNameOut_sz})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_ENVELOPE c": {
        "prefix": "BR_GetMediaTrackSendInfo_Envelope",
        "scope": "c",
        "description": "[BR] Get track envelope for send/receive/hardware output.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nenvelopeType determines which envelope is returned (0=volume, 1=pan, 2=mute)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "BR_GetMediaTrackSendInfo_Envelope(${1:MediaTrack* track},${2:int category},${3:int sendidx},${4:int envelopeType})$0"
    },
    "REAPER.BR_GETMEDIATRACKSENDINFO_ENVELOPE lua": {
        "prefix": "reaper.BR_GetMediaTrackSendInfo_Envelope",
        "scope": "lua",
        "description": "[BR] Get track envelope for send/receive/hardware output.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nenvelopeType determines which envelope is returned (0=volume, 1=pan, 2=mute)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "reaper.BR_GetMediaTrackSendInfo_Envelope(${1:MediaTrack track},${2:integer category},${3:integer sendidx},${4:integer envelopeType})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_ENVELOPE python": {
        "prefix": "BR_GetMediaTrackSendInfo_Envelope",
        "scope": "python",
        "description": "[BR] Get track envelope for send/receive/hardware output.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nenvelopeType determines which envelope is returned (0=volume, 1=pan, 2=mute)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "BR_GetMediaTrackSendInfo_Envelope(${1:MediaTrack track},${2:Int category},${3:Int sendidx},${4:Int envelopeType})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_TRACK c": {
        "prefix": "BR_GetMediaTrackSendInfo_Track",
        "scope": "c",
        "description": "[BR] Get source or destination media track for send/receive.\ncategory is <0 for receives, 0=sends\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives)\ntrackType determines which track is returned (0=source track, 1=destination track)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Envelope.\n",
        "body": "BR_GetMediaTrackSendInfo_Track(${1:MediaTrack* track},${2:int category},${3:int sendidx},${4:int trackType})$0"
    },
    "REAPER.BR_GETMEDIATRACKSENDINFO_TRACK lua": {
        "prefix": "reaper.BR_GetMediaTrackSendInfo_Track",
        "scope": "lua",
        "description": "[BR] Get source or destination media track for send/receive.\ncategory is <0 for receives, 0=sends\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives)\ntrackType determines which track is returned (0=source track, 1=destination track)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Envelope.\n",
        "body": "reaper.BR_GetMediaTrackSendInfo_Track(${1:MediaTrack track},${2:integer category},${3:integer sendidx},${4:integer trackType})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_TRACK python": {
        "prefix": "BR_GetMediaTrackSendInfo_Track",
        "scope": "python",
        "description": "[BR] Get source or destination media track for send/receive.\ncategory is <0 for receives, 0=sends\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives)\ntrackType determines which track is returned (0=source track, 1=destination track)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Envelope.\n",
        "body": "BR_GetMediaTrackSendInfo_Track(${1:MediaTrack track},${2:Int category},${3:Int sendidx},${4:Int trackType})$0"
    },
    "BR_GETMIDISOURCELENPPQ c": {
        "prefix": "BR_GetMidiSourceLenPPQ",
        "scope": "c",
        "description": "[BR] Get MIDI take source length in PPQ. In case the take isn't MIDI, return value will be -1.\n",
        "body": "BR_GetMidiSourceLenPPQ(${1:MediaItem_Take* take})$0"
    },
    "REAPER.BR_GETMIDISOURCELENPPQ lua": {
        "prefix": "reaper.BR_GetMidiSourceLenPPQ",
        "scope": "lua",
        "description": "[BR] Get MIDI take source length in PPQ. In case the take isn't MIDI, return value will be -1.\n",
        "body": "reaper.BR_GetMidiSourceLenPPQ(${1:MediaItem_Take take})$0"
    },
    "BR_GETMIDISOURCELENPPQ python": {
        "prefix": "BR_GetMidiSourceLenPPQ",
        "scope": "python",
        "description": "[BR] Get MIDI take source length in PPQ. In case the take isn't MIDI, return value will be -1.\n",
        "body": "BR_GetMidiSourceLenPPQ(${1:MediaItem_Take take})$0"
    },
    "BR_GETMIDITAKEPOOLGUID c": {
        "prefix": "BR_GetMidiTakePoolGUID",
        "scope": "c",
        "description": "[BR] Get MIDI take pool GUID as a string (guidStringOut_sz should be at least 64). Returns true if take is pooled.\n",
        "body": "BR_GetMidiTakePoolGUID(${1:MediaItem_Take* take},${2:char* guidStringOut},${3:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMIDITAKEPOOLGUID lua": {
        "prefix": "reaper.BR_GetMidiTakePoolGUID",
        "scope": "lua",
        "description": "[BR] Get MIDI take pool GUID as a string (guidStringOut_sz should be at least 64). Returns true if take is pooled.\n",
        "body": "reaper.BR_GetMidiTakePoolGUID(${1:MediaItem_Take take})$0"
    },
    "BR_GETMIDITAKEPOOLGUID python": {
        "prefix": "BR_GetMidiTakePoolGUID",
        "scope": "python",
        "description": "[BR] Get MIDI take pool GUID as a string (guidStringOut_sz should be at least 64). Returns true if take is pooled.\n",
        "body": "BR_GetMidiTakePoolGUID(${1:take},${2:guidStringOut},${3:guidStringOut_sz})$0"
    },
    "BR_GETMIDITAKETEMPOINFO c": {
        "prefix": "BR_GetMidiTakeTempoInfo",
        "scope": "c",
        "description": "[BR] Get \"ignore project tempo\" information for MIDI take. Returns true\nif take can ignore project tempo (no matter if it's actually ignored),\notherwise false.\n",
        "body": "BR_GetMidiTakeTempoInfo(${1:MediaItem_Take* take},${2:bool* ignoreProjTempoOut},${3:double* bpmOut},${4:int* numOut},${5:int* denOut})$0"
    },
    "REAPER.BR_GETMIDITAKETEMPOINFO lua": {
        "prefix": "reaper.BR_GetMidiTakeTempoInfo",
        "scope": "lua",
        "description": "[BR] Get \"ignore project tempo\" information for MIDI take. Returns true\nif take can ignore project tempo (no matter if it's actually ignored),\notherwise false.\n",
        "body": "reaper.BR_GetMidiTakeTempoInfo(${1:MediaItem_Take take})$0"
    },
    "BR_GETMIDITAKETEMPOINFO python": {
        "prefix": "BR_GetMidiTakeTempoInfo",
        "scope": "python",
        "description": "[BR] Get \"ignore project tempo\" information for MIDI take. Returns true\nif take can ignore project tempo (no matter if it's actually ignored),\notherwise false.\n",
        "body": "BR_GetMidiTakeTempoInfo(${1:take},${2:ignoreProjTempoOut},${3:bpmOut},${4:numOut},${5:denOut})$0"
    },
    "BR_GETMOUSECURSORCONTEXT c": {
        "prefix": "BR_GetMouseCursorContext",
        "scope": "c",
        "description": "[BR] Get mouse cursor context. Each parameter returns information in a form of string as specified in the table below.\nTo get more info on stuff that was found under mouse cursor see BR_GetMouseCursorContext_Envelope, BR_GetMouseCursorContext_Item, BR_GetMouseCursorContext_MIDI, BR_GetMouseCursorContext_Position, BR_GetMouseCursorContext_Take, BR_GetMouseCursorContext_Track\nWindow Segment Details  unknown       \"\"          \"\"                                                             ruler         region_lane   \"\"                                                              marker_lane   \"\"                                                              tempo_lane    \"\"                                                              timeline      \"\"                                                             transport     \"\"          \"\"                                                             tcp           track         \"\"                                                              envelope      \"\"                                                              empty         \"\"                                                             mcp           track         \"\"                                                              empty         \"\"                                                             arrange       track         empty,item, item_stretch_marker,env_point, env_segment    envelope      empty, env_point, env_segment                                     empty         \"\"                                                             midi_editor   unknown       \"\"                                                              ruler         \"\"                                                              piano         \"\"                                                              notes         \"\"                                                              cc_lane       cc_selector, cc_lane\n",
        "body": "BR_GetMouseCursorContext(${1:char* windowOut},${2:int windowOut_sz},${3:char* segmentOut},${4:int segmentOut_sz},${5:char* detailsOut},${6:int detailsOut_sz})$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT lua": {
        "prefix": "reaper.BR_GetMouseCursorContext",
        "scope": "lua",
        "description": "[BR] Get mouse cursor context. Each parameter returns information in a form of string as specified in the table below.\nTo get more info on stuff that was found under mouse cursor see BR_GetMouseCursorContext_Envelope, BR_GetMouseCursorContext_Item, BR_GetMouseCursorContext_MIDI, BR_GetMouseCursorContext_Position, BR_GetMouseCursorContext_Take, BR_GetMouseCursorContext_Track\nWindow Segment Details  unknown       \"\"          \"\"                                                             ruler         region_lane   \"\"                                                              marker_lane   \"\"                                                              tempo_lane    \"\"                                                              timeline      \"\"                                                             transport     \"\"          \"\"                                                             tcp           track         \"\"                                                              envelope      \"\"                                                              empty         \"\"                                                             mcp           track         \"\"                                                              empty         \"\"                                                             arrange       track         empty,item, item_stretch_marker,env_point, env_segment    envelope      empty, env_point, env_segment                                     empty         \"\"                                                             midi_editor   unknown       \"\"                                                              ruler         \"\"                                                              piano         \"\"                                                              notes         \"\"                                                              cc_lane       cc_selector, cc_lane\n",
        "body": "reaper.BR_GetMouseCursorContext()$0"
    },
    "BR_GETMOUSECURSORCONTEXT python": {
        "prefix": "BR_GetMouseCursorContext",
        "scope": "python",
        "description": "[BR] Get mouse cursor context. Each parameter returns information in a form of string as specified in the table below.\nTo get more info on stuff that was found under mouse cursor see BR_GetMouseCursorContext_Envelope, BR_GetMouseCursorContext_Item, BR_GetMouseCursorContext_MIDI, BR_GetMouseCursorContext_Position, BR_GetMouseCursorContext_Take, BR_GetMouseCursorContext_Track\nWindow Segment Details  unknown       \"\"          \"\"                                                             ruler         region_lane   \"\"                                                              marker_lane   \"\"                                                              tempo_lane    \"\"                                                              timeline      \"\"                                                             transport     \"\"          \"\"                                                             tcp           track         \"\"                                                              envelope      \"\"                                                              empty         \"\"                                                             mcp           track         \"\"                                                              empty         \"\"                                                             arrange       track         empty,item, item_stretch_marker,env_point, env_segment    envelope      empty, env_point, env_segment                                     empty         \"\"                                                             midi_editor   unknown       \"\"                                                              ruler         \"\"                                                              piano         \"\"                                                              notes         \"\"                                                              cc_lane       cc_selector, cc_lane\n",
        "body": "BR_GetMouseCursorContext(${1:windowOut},${2:windowOut_sz},${3:segmentOut},${4:segmentOut_sz},${5:detailsOut},${6:detailsOut_sz})$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ENVELOPE c": {
        "prefix": "BR_GetMouseCursorContext_Envelope",
        "scope": "c",
        "description": "[BR] Returns envelope that was captured with the last call to BR_GetMouseCursorContext. In case the envelope belongs to take, takeEnvelope will be true.\n",
        "body": "BR_GetMouseCursorContext_Envelope(${1:bool* takeEnvelopeOut})$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_ENVELOPE lua": {
        "prefix": "reaper.BR_GetMouseCursorContext_Envelope",
        "scope": "lua",
        "description": "[BR] Returns envelope that was captured with the last call to BR_GetMouseCursorContext. In case the envelope belongs to take, takeEnvelope will be true.\n",
        "body": "reaper.BR_GetMouseCursorContext_Envelope()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ENVELOPE python": {
        "prefix": "BR_GetMouseCursorContext_Envelope",
        "scope": "python",
        "description": "[BR] Returns envelope that was captured with the last call to BR_GetMouseCursorContext. In case the envelope belongs to take, takeEnvelope will be true.\n",
        "body": "BR_GetMouseCursorContext_Envelope(${1:takeEnvelopeOut})$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ITEM c": {
        "prefix": "BR_GetMouseCursorContext_Item",
        "scope": "c",
        "description": "[BR] Returns item under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\nNote that the function will return item even if mouse cursor is over\nsome other track lane element like stretch marker or envelope. This\nenables for easier identification of items when you want to ignore\nelements within the item.\n",
        "body": "BR_GetMouseCursorContext_Item()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_ITEM lua": {
        "prefix": "reaper.BR_GetMouseCursorContext_Item",
        "scope": "lua",
        "description": "[BR] Returns item under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\nNote that the function will return item even if mouse cursor is over\nsome other track lane element like stretch marker or envelope. This\nenables for easier identification of items when you want to ignore\nelements within the item.\n",
        "body": "reaper.BR_GetMouseCursorContext_Item()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ITEM python": {
        "prefix": "BR_GetMouseCursorContext_Item",
        "scope": "python",
        "description": "[BR] Returns item under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\nNote that the function will return item even if mouse cursor is over\nsome other track lane element like stretch marker or envelope. This\nenables for easier identification of items when you want to ignore\nelements within the item.\n",
        "body": "BR_GetMouseCursorContext_Item()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_MIDI c": {
        "prefix": "BR_GetMouseCursorContext_MIDI",
        "scope": "c",
        "description": "[BR] Returns midi editor under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\ninlineEditor: if mouse was captured in inline MIDI editor, this will be\ntrue (consequentially, returned MIDI editor will be NULL)\nnoteRow: note row or piano key under mouse cursor (0-127)\nccLane: CC lane under mouse cursor (CC0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events)\nccLaneVal: value in CC lane under mouse cursor (0-127 or 0-16383)\nccLaneId: lane position, counting from the top (0 based)\nNote: due to API limitations, if mouse is over inline MIDI editor with some note rows hidden, noteRow will be -1\n",
        "body": "BR_GetMouseCursorContext_MIDI(${1:bool* inlineEditorOut},${2:int* noteRowOut},${3:int* ccLaneOut},${4:int* ccLaneValOut},${5:int* ccLaneIdOut})$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_MIDI lua": {
        "prefix": "reaper.BR_GetMouseCursorContext_MIDI",
        "scope": "lua",
        "description": "[BR] Returns midi editor under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\ninlineEditor: if mouse was captured in inline MIDI editor, this will be\ntrue (consequentially, returned MIDI editor will be NULL)\nnoteRow: note row or piano key under mouse cursor (0-127)\nccLane: CC lane under mouse cursor (CC0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events)\nccLaneVal: value in CC lane under mouse cursor (0-127 or 0-16383)\nccLaneId: lane position, counting from the top (0 based)\nNote: due to API limitations, if mouse is over inline MIDI editor with some note rows hidden, noteRow will be -1\n",
        "body": "reaper.BR_GetMouseCursorContext_MIDI()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_MIDI python": {
        "prefix": "BR_GetMouseCursorContext_MIDI",
        "scope": "python",
        "description": "[BR] Returns midi editor under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\ninlineEditor: if mouse was captured in inline MIDI editor, this will be\ntrue (consequentially, returned MIDI editor will be NULL)\nnoteRow: note row or piano key under mouse cursor (0-127)\nccLane: CC lane under mouse cursor (CC0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events)\nccLaneVal: value in CC lane under mouse cursor (0-127 or 0-16383)\nccLaneId: lane position, counting from the top (0 based)\nNote: due to API limitations, if mouse is over inline MIDI editor with some note rows hidden, noteRow will be -1\n",
        "body": "BR_GetMouseCursorContext_MIDI(${1:inlineEditorOut},${2:noteRowOut},${3:ccLaneOut},${4:ccLaneValOut},${5:ccLaneIdOut})$0"
    },
    "BR_GETMOUSECURSORCONTEXT_POSITION c": {
        "prefix": "BR_GetMouseCursorContext_Position",
        "scope": "c",
        "description": "[BR] Returns project time position in arrange/ruler/midi editor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_Position()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_POSITION lua": {
        "prefix": "reaper.BR_GetMouseCursorContext_Position",
        "scope": "lua",
        "description": "[BR] Returns project time position in arrange/ruler/midi editor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "reaper.BR_GetMouseCursorContext_Position()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_POSITION python": {
        "prefix": "BR_GetMouseCursorContext_Position",
        "scope": "python",
        "description": "[BR] Returns project time position in arrange/ruler/midi editor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_Position()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_STRETCHMARKER c": {
        "prefix": "BR_GetMouseCursorContext_StretchMarker",
        "scope": "c",
        "description": "[BR] Returns id of a stretch marker under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_StretchMarker()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_STRETCHMARKER lua": {
        "prefix": "reaper.BR_GetMouseCursorContext_StretchMarker",
        "scope": "lua",
        "description": "[BR] Returns id of a stretch marker under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "reaper.BR_GetMouseCursorContext_StretchMarker()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_STRETCHMARKER python": {
        "prefix": "BR_GetMouseCursorContext_StretchMarker",
        "scope": "python",
        "description": "[BR] Returns id of a stretch marker under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_StretchMarker()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TAKE c": {
        "prefix": "BR_GetMouseCursorContext_Take",
        "scope": "c",
        "description": "[BR] Returns take under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_Take()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_TAKE lua": {
        "prefix": "reaper.BR_GetMouseCursorContext_Take",
        "scope": "lua",
        "description": "[BR] Returns take under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "reaper.BR_GetMouseCursorContext_Take()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TAKE python": {
        "prefix": "BR_GetMouseCursorContext_Take",
        "scope": "python",
        "description": "[BR] Returns take under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_Take()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TRACK c": {
        "prefix": "BR_GetMouseCursorContext_Track",
        "scope": "c",
        "description": "[BR] Returns track under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_Track()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_TRACK lua": {
        "prefix": "reaper.BR_GetMouseCursorContext_Track",
        "scope": "lua",
        "description": "[BR] Returns track under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "reaper.BR_GetMouseCursorContext_Track()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TRACK python": {
        "prefix": "BR_GetMouseCursorContext_Track",
        "scope": "python",
        "description": "[BR] Returns track under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "BR_GetMouseCursorContext_Track()$0"
    },
    "BR_GETNEXTGRIDDIVISION c": {
        "prefix": "BR_GetNextGridDivision",
        "scope": "c",
        "description": "[BR] Get next grid division after the time position. For more grid divisions function, see BR_GetClosestGridDivision and BR_GetPrevGridDivision.\n",
        "body": "BR_GetNextGridDivision(${1:double position})$0"
    },
    "REAPER.BR_GETNEXTGRIDDIVISION lua": {
        "prefix": "reaper.BR_GetNextGridDivision",
        "scope": "lua",
        "description": "[BR] Get next grid division after the time position. For more grid divisions function, see BR_GetClosestGridDivision and BR_GetPrevGridDivision.\n",
        "body": "reaper.BR_GetNextGridDivision(${1:number position})$0"
    },
    "BR_GETNEXTGRIDDIVISION python": {
        "prefix": "BR_GetNextGridDivision",
        "scope": "python",
        "description": "[BR] Get next grid division after the time position. For more grid divisions function, see BR_GetClosestGridDivision and BR_GetPrevGridDivision.\n",
        "body": "BR_GetNextGridDivision(${1:Float position})$0"
    },
    "BR_GETPREVGRIDDIVISION c": {
        "prefix": "BR_GetPrevGridDivision",
        "scope": "c",
        "description": "[BR] Get previous grid division before the time position. For more grid division functions, see BR_GetClosestGridDivision and BR_GetNextGridDivision.\n",
        "body": "BR_GetPrevGridDivision(${1:double position})$0"
    },
    "REAPER.BR_GETPREVGRIDDIVISION lua": {
        "prefix": "reaper.BR_GetPrevGridDivision",
        "scope": "lua",
        "description": "[BR] Get previous grid division before the time position. For more grid division functions, see BR_GetClosestGridDivision and BR_GetNextGridDivision.\n",
        "body": "reaper.BR_GetPrevGridDivision(${1:number position})$0"
    },
    "BR_GETPREVGRIDDIVISION python": {
        "prefix": "BR_GetPrevGridDivision",
        "scope": "python",
        "description": "[BR] Get previous grid division before the time position. For more grid division functions, see BR_GetClosestGridDivision and BR_GetNextGridDivision.\n",
        "body": "BR_GetPrevGridDivision(${1:Float position})$0"
    },
    "BR_GETSETTRACKSENDINFO c": {
        "prefix": "BR_GetSetTrackSendInfo",
        "scope": "c",
        "description": "[BR] Get or set send attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nTo set attribute, pass setNewValue as true\nList of possible parameters:\nB_MUTE : send mute state (1.0 if muted, otherwise 0.0)\nB_PHASE : send phase state (1.0 if phase is inverted, otherwise 0.0)\nB_MONO : send mono state (1.0 if send is set to mono, otherwise 0.0)\nD_VOL : send volume (1.0=+0dB etc...)\nD_PAN : send pan (-1.0=100%L, 0=center, 1.0=100%R)\nD_PANLAW : send pan law (1.0=+0.0db, 0.5=-6dB, -1.0=project default etc...)\nI_SENDMODE : send mode (0=post-fader, 1=pre-fx, 2=post-fx(deprecated), 3=post-fx)\nI_SRCCHAN : audio source starting channel index or -1 if audio send is\ndisabled (&1024=mono...note that in that case, when reading index,\nyou should do (index XOR 1024) to get starting channel index)\nI_DSTCHAN : audio destination starting channel index (&1024=mono\n(and in case of hardware output &512=rearoute)...note that in that\ncase, when reading index, you should do (index XOR (1024 OR 512)) to get\nstarting channel index)\nI_MIDI_SRCCHAN : source MIDI channel, -1 if MIDI send is disabled (0=all, 1-16)\nI_MIDI_DSTCHAN : destination MIDI channel, -1 if MIDI send is disabled (0=original, 1-16)\nI_MIDI_SRCBUS : source MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_DSTBUS : receive MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_LINK_VOLPAN : link volume/pan controls to MIDI\nNote: To get or set other send attributes, see BR_GetMediaTrackSendInfo_Envelope and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "BR_GetSetTrackSendInfo(${1:MediaTrack* track},${2:int category},${3:int sendidx},${4|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDI_SRCCHAN\",\"I_MIDI_DSTCHAN\",\"I_MIDI_SRCBUS\",\"I_MIDI_DSTBUS\",\"I_MIDI_LINK_VOLPAN\"|},${5:bool setNewValue},${6:double newValue})$0"
    },
    "REAPER.BR_GETSETTRACKSENDINFO lua": {
        "prefix": "reaper.BR_GetSetTrackSendInfo",
        "scope": "lua",
        "description": "[BR] Get or set send attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nTo set attribute, pass setNewValue as true\nList of possible parameters:\nB_MUTE : send mute state (1.0 if muted, otherwise 0.0)\nB_PHASE : send phase state (1.0 if phase is inverted, otherwise 0.0)\nB_MONO : send mono state (1.0 if send is set to mono, otherwise 0.0)\nD_VOL : send volume (1.0=+0dB etc...)\nD_PAN : send pan (-1.0=100%L, 0=center, 1.0=100%R)\nD_PANLAW : send pan law (1.0=+0.0db, 0.5=-6dB, -1.0=project default etc...)\nI_SENDMODE : send mode (0=post-fader, 1=pre-fx, 2=post-fx(deprecated), 3=post-fx)\nI_SRCCHAN : audio source starting channel index or -1 if audio send is\ndisabled (&1024=mono...note that in that case, when reading index,\nyou should do (index XOR 1024) to get starting channel index)\nI_DSTCHAN : audio destination starting channel index (&1024=mono\n(and in case of hardware output &512=rearoute)...note that in that\ncase, when reading index, you should do (index XOR (1024 OR 512)) to get\nstarting channel index)\nI_MIDI_SRCCHAN : source MIDI channel, -1 if MIDI send is disabled (0=all, 1-16)\nI_MIDI_DSTCHAN : destination MIDI channel, -1 if MIDI send is disabled (0=original, 1-16)\nI_MIDI_SRCBUS : source MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_DSTBUS : receive MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_LINK_VOLPAN : link volume/pan controls to MIDI\nNote: To get or set other send attributes, see BR_GetMediaTrackSendInfo_Envelope and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "reaper.BR_GetSetTrackSendInfo(${1:MediaTrack track},${2:integer category},${3:integer sendidx},${4|string parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDI_SRCCHAN\",\"I_MIDI_DSTCHAN\",\"I_MIDI_SRCBUS\",\"I_MIDI_DSTBUS\",\"I_MIDI_LINK_VOLPAN\"|},${5:boolean setNewValue},${6:number newValue})$0"
    },
    "BR_GETSETTRACKSENDINFO python": {
        "prefix": "BR_GetSetTrackSendInfo",
        "scope": "python",
        "description": "[BR] Get or set send attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nTo set attribute, pass setNewValue as true\nList of possible parameters:\nB_MUTE : send mute state (1.0 if muted, otherwise 0.0)\nB_PHASE : send phase state (1.0 if phase is inverted, otherwise 0.0)\nB_MONO : send mono state (1.0 if send is set to mono, otherwise 0.0)\nD_VOL : send volume (1.0=+0dB etc...)\nD_PAN : send pan (-1.0=100%L, 0=center, 1.0=100%R)\nD_PANLAW : send pan law (1.0=+0.0db, 0.5=-6dB, -1.0=project default etc...)\nI_SENDMODE : send mode (0=post-fader, 1=pre-fx, 2=post-fx(deprecated), 3=post-fx)\nI_SRCCHAN : audio source starting channel index or -1 if audio send is\ndisabled (&1024=mono...note that in that case, when reading index,\nyou should do (index XOR 1024) to get starting channel index)\nI_DSTCHAN : audio destination starting channel index (&1024=mono\n(and in case of hardware output &512=rearoute)...note that in that\ncase, when reading index, you should do (index XOR (1024 OR 512)) to get\nstarting channel index)\nI_MIDI_SRCCHAN : source MIDI channel, -1 if MIDI send is disabled (0=all, 1-16)\nI_MIDI_DSTCHAN : destination MIDI channel, -1 if MIDI send is disabled (0=original, 1-16)\nI_MIDI_SRCBUS : source MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_DSTBUS : receive MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_LINK_VOLPAN : link volume/pan controls to MIDI\nNote: To get or set other send attributes, see BR_GetMediaTrackSendInfo_Envelope and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "BR_GetSetTrackSendInfo(${1:MediaTrack track},${2:Int category},${3:Int sendidx},${4|String parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDI_SRCCHAN\",\"I_MIDI_DSTCHAN\",\"I_MIDI_SRCBUS\",\"I_MIDI_DSTBUS\",\"I_MIDI_LINK_VOLPAN\"|},${5:Boolean setNewValue},${6:Float newValue})$0"
    },
    "BR_GETTAKEFXCOUNT c": {
        "prefix": "BR_GetTakeFXCount",
        "scope": "c",
        "description": "[BR] Returns FX count for supplied take\n",
        "body": "BR_GetTakeFXCount(${1:MediaItem_Take* take})$0"
    },
    "REAPER.BR_GETTAKEFXCOUNT lua": {
        "prefix": "reaper.BR_GetTakeFXCount",
        "scope": "lua",
        "description": "[BR] Returns FX count for supplied take\n",
        "body": "reaper.BR_GetTakeFXCount(${1:MediaItem_Take take})$0"
    },
    "BR_GETTAKEFXCOUNT python": {
        "prefix": "BR_GetTakeFXCount",
        "scope": "python",
        "description": "[BR] Returns FX count for supplied take\n",
        "body": "BR_GetTakeFXCount(${1:MediaItem_Take take})$0"
    },
    "BR_ISMIDIOPENININLINEEDITOR c": {
        "prefix": "BR_IsMidiOpenInInlineEditor",
        "scope": "c",
        "description": "[SWS] Check if take has MIDI inline editor open and returns true or false.\n",
        "body": "BR_IsMidiOpenInInlineEditor(${1:MediaItem_Take* take})$0"
    },
    "REAPER.BR_ISMIDIOPENININLINEEDITOR lua": {
        "prefix": "reaper.BR_IsMidiOpenInInlineEditor",
        "scope": "lua",
        "description": "[SWS] Check if take has MIDI inline editor open and returns true or false.\n",
        "body": "reaper.BR_IsMidiOpenInInlineEditor(${1:MediaItem_Take take})$0"
    },
    "BR_ISMIDIOPENININLINEEDITOR python": {
        "prefix": "BR_IsMidiOpenInInlineEditor",
        "scope": "python",
        "description": "[SWS] Check if take has MIDI inline editor open and returns true or false.\n",
        "body": "BR_IsMidiOpenInInlineEditor(${1:MediaItem_Take take})$0"
    },
    "BR_ISTAKEMIDI c": {
        "prefix": "BR_IsTakeMidi",
        "scope": "c",
        "description": "[BR] Check if take is MIDI take, in case MIDI take is in-project MIDI\nsource data, inProjectMidiOut will be true, otherwise false.\n",
        "body": "BR_IsTakeMidi(${1:MediaItem_Take* take},${2:bool* inProjectMidiOut})$0"
    },
    "REAPER.BR_ISTAKEMIDI lua": {
        "prefix": "reaper.BR_IsTakeMidi",
        "scope": "lua",
        "description": "[BR] Check if take is MIDI take, in case MIDI take is in-project MIDI\nsource data, inProjectMidiOut will be true, otherwise false.\n",
        "body": "reaper.BR_IsTakeMidi(${1:MediaItem_Take take})$0"
    },
    "BR_ISTAKEMIDI python": {
        "prefix": "BR_IsTakeMidi",
        "scope": "python",
        "description": "[BR] Check if take is MIDI take, in case MIDI take is in-project MIDI\nsource data, inProjectMidiOut will be true, otherwise false.\n",
        "body": "BR_IsTakeMidi(${1:take},${2:inProjectMidiOut})$0"
    },
    "BR_ITEMATMOUSECURSOR c": {
        "prefix": "BR_ItemAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get media item under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "BR_ItemAtMouseCursor(${1:double* positionOut})$0"
    },
    "REAPER.BR_ITEMATMOUSECURSOR lua": {
        "prefix": "reaper.BR_ItemAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get media item under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "reaper.BR_ItemAtMouseCursor()$0"
    },
    "BR_ITEMATMOUSECURSOR python": {
        "prefix": "BR_ItemAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get media item under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "BR_ItemAtMouseCursor(${1:positionOut})$0"
    },
    "BR_MIDI_CCLANEREMOVE c": {
        "prefix": "BR_MIDI_CCLaneRemove",
        "scope": "c",
        "description": "[BR] Remove CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success\n",
        "body": "BR_MIDI_CCLaneRemove(${1:void* midiEditor},${2:int laneId})$0"
    },
    "REAPER.BR_MIDI_CCLANEREMOVE lua": {
        "prefix": "reaper.BR_MIDI_CCLaneRemove",
        "scope": "lua",
        "description": "[BR] Remove CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success\n",
        "body": "reaper.BR_MIDI_CCLaneRemove(${1:identifier midiEditor},${2:integer laneId})$0"
    },
    "BR_MIDI_CCLANEREMOVE python": {
        "prefix": "BR_MIDI_CCLaneRemove",
        "scope": "python",
        "description": "[BR] Remove CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success\n",
        "body": "BR_MIDI_CCLaneRemove(${1:void midiEditor},${2:Int laneId})$0"
    },
    "BR_MIDI_CCLANEREPLACE c": {
        "prefix": "BR_MIDI_CCLaneReplace",
        "scope": "c",
        "description": "[BR] Replace CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success.\nValid CC lanes: CC0-127=CC, 0x100|(0-31)=14-bit CC, 0x200=velocity,\n0x201=pitch, 0x202=program, 0x203=channel pressure, 0x204=bank/program\nselect, 0x205=text, 0x206=sysex, 0x207\n",
        "body": "BR_MIDI_CCLaneReplace(${1:void* midiEditor},${2:int laneId},${3:int newCC})$0"
    },
    "REAPER.BR_MIDI_CCLANEREPLACE lua": {
        "prefix": "reaper.BR_MIDI_CCLaneReplace",
        "scope": "lua",
        "description": "[BR] Replace CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success.\nValid CC lanes: CC0-127=CC, 0x100|(0-31)=14-bit CC, 0x200=velocity,\n0x201=pitch, 0x202=program, 0x203=channel pressure, 0x204=bank/program\nselect, 0x205=text, 0x206=sysex, 0x207\n",
        "body": "reaper.BR_MIDI_CCLaneReplace(${1:identifier midiEditor},${2:integer laneId},${3:integer newCC})$0"
    },
    "BR_MIDI_CCLANEREPLACE python": {
        "prefix": "BR_MIDI_CCLaneReplace",
        "scope": "python",
        "description": "[BR] Replace CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success.\nValid CC lanes: CC0-127=CC, 0x100|(0-31)=14-bit CC, 0x200=velocity,\n0x201=pitch, 0x202=program, 0x203=channel pressure, 0x204=bank/program\nselect, 0x205=text, 0x206=sysex, 0x207\n",
        "body": "BR_MIDI_CCLaneReplace(${1:void midiEditor},${2:Int laneId},${3:Int newCC})$0"
    },
    "BR_POSITIONATMOUSECURSOR c": {
        "prefix": "BR_PositionAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get position at mouse cursor. To check ruler along with arrange,\npass checkRuler=true. Returns -1 if cursor is not over arrange/ruler.\n",
        "body": "BR_PositionAtMouseCursor(${1:bool checkRuler})$0"
    },
    "REAPER.BR_POSITIONATMOUSECURSOR lua": {
        "prefix": "reaper.BR_PositionAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get position at mouse cursor. To check ruler along with arrange,\npass checkRuler=true. Returns -1 if cursor is not over arrange/ruler.\n",
        "body": "reaper.BR_PositionAtMouseCursor(${1:boolean checkRuler})$0"
    },
    "BR_POSITIONATMOUSECURSOR python": {
        "prefix": "BR_PositionAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get position at mouse cursor. To check ruler along with arrange,\npass checkRuler=true. Returns -1 if cursor is not over arrange/ruler.\n",
        "body": "BR_PositionAtMouseCursor(${1:Boolean checkRuler})$0"
    },
    "BR_SETARRANGEVIEW c": {
        "prefix": "BR_SetArrangeView",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Set start and end time position of arrange view. To get arrange view instead, see BR_GetArrangeView.\n",
        "body": "BR_SetArrangeView(${1:ReaProject* proj},${2:double startTime},${3:double endTime})$0"
    },
    "REAPER.BR_SETARRANGEVIEW lua": {
        "prefix": "reaper.BR_SetArrangeView",
        "scope": "lua",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Set start and end time position of arrange view. To get arrange view instead, see BR_GetArrangeView.\n",
        "body": "reaper.BR_SetArrangeView(${1:ReaProject proj},${2:number startTime},${3:number endTime})$0"
    },
    "BR_SETARRANGEVIEW python": {
        "prefix": "BR_SetArrangeView",
        "scope": "python",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Set start and end time position of arrange view. To get arrange view instead, see BR_GetArrangeView.\n",
        "body": "BR_SetArrangeView(${1:ReaProject proj},${2:Float startTime},${3:Float endTime})$0"
    },
    "BR_SETITEMEDGES c": {
        "prefix": "BR_SetItemEdges",
        "scope": "c",
        "description": "[BR] Set item start and end edges' position - returns true in case of any changes\n",
        "body": "BR_SetItemEdges(${1:MediaItem* item},${2:double startTime},${3:double endTime})$0"
    },
    "REAPER.BR_SETITEMEDGES lua": {
        "prefix": "reaper.BR_SetItemEdges",
        "scope": "lua",
        "description": "[BR] Set item start and end edges' position - returns true in case of any changes\n",
        "body": "reaper.BR_SetItemEdges(${1:MediaItem item},${2:number startTime},${3:number endTime})$0"
    },
    "BR_SETITEMEDGES python": {
        "prefix": "BR_SetItemEdges",
        "scope": "python",
        "description": "[BR] Set item start and end edges' position - returns true in case of any changes\n",
        "body": "BR_SetItemEdges(${1:MediaItem item},${2:Float startTime},${3:Float endTime})$0"
    },
    "BR_SETMEDIAITEMIMAGERESOURCE c": {
        "prefix": "BR_SetMediaItemImageResource",
        "scope": "c",
        "description": "[BR] Set image resource and it's flags for a given item. To clear\ncurrent image resource, pass imageIn as . To get image resource, see BR_GetMediaItemImageResource.\n",
        "body": "BR_SetMediaItemImageResource(${1:MediaItem* item},${2:const char* imageIn},${3:int imageFlags})$0"
    },
    "REAPER.BR_SETMEDIAITEMIMAGERESOURCE lua": {
        "prefix": "reaper.BR_SetMediaItemImageResource",
        "scope": "lua",
        "description": "[BR] Set image resource and it's flags for a given item. To clear\ncurrent image resource, pass imageIn as . To get image resource, see BR_GetMediaItemImageResource.\n",
        "body": "reaper.BR_SetMediaItemImageResource(${1:MediaItem item},${2:string imageIn},${3:integer imageFlags})$0"
    },
    "BR_SETMEDIAITEMIMAGERESOURCE python": {
        "prefix": "BR_SetMediaItemImageResource",
        "scope": "python",
        "description": "[BR] Set image resource and it's flags for a given item. To clear\ncurrent image resource, pass imageIn as . To get image resource, see BR_GetMediaItemImageResource.\n",
        "body": "BR_SetMediaItemImageResource(${1:MediaItem item},${2:String imageIn},${3:Int imageFlags})$0"
    },
    "BR_SETMEDIASOURCEPROPERTIES c": {
        "prefix": "BR_SetMediaSourceProperties",
        "scope": "c",
        "description": "[BR] Set take media source properties. Returns false if take can't have\nthem (MIDI items etc.). Section parameters have to be valid only when\npassing section=true.\nTo get source properties, see BR_GetMediaSourceProperties.\n",
        "body": "BR_SetMediaSourceProperties(${1:MediaItem_Take* take},${2:bool section},${3:double start},${4:double length},${5:double fade},${6:bool reverse})$0"
    },
    "REAPER.BR_SETMEDIASOURCEPROPERTIES lua": {
        "prefix": "reaper.BR_SetMediaSourceProperties",
        "scope": "lua",
        "description": "[BR] Set take media source properties. Returns false if take can't have\nthem (MIDI items etc.). Section parameters have to be valid only when\npassing section=true.\nTo get source properties, see BR_GetMediaSourceProperties.\n",
        "body": "reaper.BR_SetMediaSourceProperties(${1:MediaItem_Take take},${2:boolean section},${3:number start},${4:number length},${5:number fade},${6:boolean reverse})$0"
    },
    "BR_SETMEDIASOURCEPROPERTIES python": {
        "prefix": "BR_SetMediaSourceProperties",
        "scope": "python",
        "description": "[BR] Set take media source properties. Returns false if take can't have\nthem (MIDI items etc.). Section parameters have to be valid only when\npassing section=true.\nTo get source properties, see BR_GetMediaSourceProperties.\n",
        "body": "BR_SetMediaSourceProperties(${1:MediaItem_Take take},${2:Boolean section},${3:Float start},${4:Float length},${5:Float fade},${6:Boolean reverse})$0"
    },
    "BR_SETMEDIATRACKLAYOUTS c": {
        "prefix": "BR_SetMediaTrackLayouts",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Set media track layouts for MCP and TCP. To set\ndefault layout, pass empty string (\"\") as layout name. In case layouts\nwere successfully set, returns true (if layouts are already set to\nsupplied layout names, it will return false since no changes were made).\nTo get media track layouts, see BR_GetMediaTrackLayouts.\n",
        "body": "BR_SetMediaTrackLayouts(${1:MediaTrack* track},${2:const char* mcpLayoutNameIn},${3:const char* tcpLayoutNameIn})$0"
    },
    "REAPER.BR_SETMEDIATRACKLAYOUTS lua": {
        "prefix": "reaper.BR_SetMediaTrackLayouts",
        "scope": "lua",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Set media track layouts for MCP and TCP. To set\ndefault layout, pass empty string (\"\") as layout name. In case layouts\nwere successfully set, returns true (if layouts are already set to\nsupplied layout names, it will return false since no changes were made).\nTo get media track layouts, see BR_GetMediaTrackLayouts.\n",
        "body": "reaper.BR_SetMediaTrackLayouts(${1:MediaTrack track},${2:string mcpLayoutNameIn},${3:string tcpLayoutNameIn})$0"
    },
    "BR_SETMEDIATRACKLAYOUTS python": {
        "prefix": "BR_SetMediaTrackLayouts",
        "scope": "python",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Set media track layouts for MCP and TCP. To set\ndefault layout, pass empty string (\"\") as layout name. In case layouts\nwere successfully set, returns true (if layouts are already set to\nsupplied layout names, it will return false since no changes were made).\nTo get media track layouts, see BR_GetMediaTrackLayouts.\n",
        "body": "BR_SetMediaTrackLayouts(${1:MediaTrack track},${2:String mcpLayoutNameIn},${3:String tcpLayoutNameIn})$0"
    },
    "BR_SETMIDITAKETEMPOINFO c": {
        "prefix": "BR_SetMidiTakeTempoInfo",
        "scope": "c",
        "description": "[BR] Set \"ignore project tempo\" information for MIDI take. Returns true in case the take was successfully updated.\n",
        "body": "BR_SetMidiTakeTempoInfo(${1:MediaItem_Take* take},${2:bool ignoreProjTempo},${3:double bpm},${4:int num},${5:int den})$0"
    },
    "REAPER.BR_SETMIDITAKETEMPOINFO lua": {
        "prefix": "reaper.BR_SetMidiTakeTempoInfo",
        "scope": "lua",
        "description": "[BR] Set \"ignore project tempo\" information for MIDI take. Returns true in case the take was successfully updated.\n",
        "body": "reaper.BR_SetMidiTakeTempoInfo(${1:MediaItem_Take take},${2:boolean ignoreProjTempo},${3:number bpm},${4:integer num},${5:integer den})$0"
    },
    "BR_SETMIDITAKETEMPOINFO python": {
        "prefix": "BR_SetMidiTakeTempoInfo",
        "scope": "python",
        "description": "[BR] Set \"ignore project tempo\" information for MIDI take. Returns true in case the take was successfully updated.\n",
        "body": "BR_SetMidiTakeTempoInfo(${1:MediaItem_Take take},${2:Boolean ignoreProjTempo},${3:Float bpm},${4:Int num},${5:Int den})$0"
    },
    "BR_SETTAKESOURCEFROMFILE c": {
        "prefix": "BR_SetTakeSourceFromFile",
        "scope": "c",
        "description": "[BR] Set new take source from file. To import MIDI file as in-project\nsource data pass inProjectData=true. Returns false if failed.\nAny take source properties from the previous source will be lost - to preserve them, see BR_SetTakeSourceFromFile2.\nNote: To set source from existing take, see SNM_GetSetSourceState2.\n",
        "body": "BR_SetTakeSourceFromFile(${1:MediaItem_Take* take},${2:const char* filenameIn},${3:bool inProjectData})$0"
    },
    "REAPER.BR_SETTAKESOURCEFROMFILE lua": {
        "prefix": "reaper.BR_SetTakeSourceFromFile",
        "scope": "lua",
        "description": "[BR] Set new take source from file. To import MIDI file as in-project\nsource data pass inProjectData=true. Returns false if failed.\nAny take source properties from the previous source will be lost - to preserve them, see BR_SetTakeSourceFromFile2.\nNote: To set source from existing take, see SNM_GetSetSourceState2.\n",
        "body": "reaper.BR_SetTakeSourceFromFile(${1:MediaItem_Take take},${2:string filenameIn},${3:boolean inProjectData})$0"
    },
    "BR_SETTAKESOURCEFROMFILE python": {
        "prefix": "BR_SetTakeSourceFromFile",
        "scope": "python",
        "description": "[BR] Set new take source from file. To import MIDI file as in-project\nsource data pass inProjectData=true. Returns false if failed.\nAny take source properties from the previous source will be lost - to preserve them, see BR_SetTakeSourceFromFile2.\nNote: To set source from existing take, see SNM_GetSetSourceState2.\n",
        "body": "BR_SetTakeSourceFromFile(${1:MediaItem_Take take},${2:String filenameIn},${3:Boolean inProjectData})$0"
    },
    "BR_SETTAKESOURCEFROMFILE2 c": {
        "prefix": "BR_SetTakeSourceFromFile2",
        "scope": "c",
        "description": "[BR] Differs from BR_SetTakeSourceFromFile only that it can also preserve existing take media source properties.\n",
        "body": "BR_SetTakeSourceFromFile2(${1:MediaItem_Take* take},${2:const char* filenameIn},${3:bool inProjectData},${4:bool keepSourceProperties})$0"
    },
    "REAPER.BR_SETTAKESOURCEFROMFILE2 lua": {
        "prefix": "reaper.BR_SetTakeSourceFromFile2",
        "scope": "lua",
        "description": "[BR] Differs from BR_SetTakeSourceFromFile only that it can also preserve existing take media source properties.\n",
        "body": "reaper.BR_SetTakeSourceFromFile2(${1:MediaItem_Take take},${2:string filenameIn},${3:boolean inProjectData},${4:boolean keepSourceProperties})$0"
    },
    "BR_SETTAKESOURCEFROMFILE2 python": {
        "prefix": "BR_SetTakeSourceFromFile2",
        "scope": "python",
        "description": "[BR] Differs from BR_SetTakeSourceFromFile only that it can also preserve existing take media source properties.\n",
        "body": "BR_SetTakeSourceFromFile2(${1:MediaItem_Take take},${2:String filenameIn},${3:Boolean inProjectData},${4:Boolean keepSourceProperties})$0"
    },
    "BR_TAKEATMOUSECURSOR c": {
        "prefix": "BR_TakeAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get take under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "BR_TakeAtMouseCursor(${1:double* positionOut})$0"
    },
    "REAPER.BR_TAKEATMOUSECURSOR lua": {
        "prefix": "reaper.BR_TakeAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get take under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "reaper.BR_TakeAtMouseCursor()$0"
    },
    "BR_TAKEATMOUSECURSOR python": {
        "prefix": "BR_TakeAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get take under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "BR_TakeAtMouseCursor(${1:positionOut})$0"
    },
    "BR_TRACKATMOUSECURSOR c": {
        "prefix": "BR_TrackAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get track under mouse cursor.\nContext signifies where the track was found: 0 = TCP, 1 = MCP, 2 = Arrange.\nPosition will hold mouse cursor position in arrange if applicable.\n",
        "body": "BR_TrackAtMouseCursor(${1:int* contextOut},${2:double* positionOut})$0"
    },
    "REAPER.BR_TRACKATMOUSECURSOR lua": {
        "prefix": "reaper.BR_TrackAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get track under mouse cursor.\nContext signifies where the track was found: 0 = TCP, 1 = MCP, 2 = Arrange.\nPosition will hold mouse cursor position in arrange if applicable.\n",
        "body": "reaper.BR_TrackAtMouseCursor()$0"
    },
    "BR_TRACKATMOUSECURSOR python": {
        "prefix": "BR_TrackAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get track under mouse cursor.\nContext signifies where the track was found: 0 = TCP, 1 = MCP, 2 = Arrange.\nPosition will hold mouse cursor position in arrange if applicable.\n",
        "body": "BR_TrackAtMouseCursor(${1:contextOut},${2:positionOut})$0"
    },
    "BR_TRACKFX_GETFXMODULENAME c": {
        "prefix": "BR_TrackFX_GetFXModuleName",
        "scope": "c",
        "description": "[BR] Get the exact name (like effect.dll, effect.vst3, etc...) of an FX.\n",
        "body": "BR_TrackFX_GetFXModuleName(${1:MediaTrack* track},${2:int fx},${3:char*  nameOut},${4:int  nameOutSz})$0"
    },
    "REAPER.BR_TRACKFX_GETFXMODULENAME lua": {
        "prefix": "reaper.BR_TrackFX_GetFXModuleName",
        "scope": "lua",
        "description": "[BR] Get the exact name (like effect.dll, effect.vst3, etc...) of an FX.\n",
        "body": "reaper.BR_TrackFX_GetFXModuleName(${1:MediaTrack track},${2:integer fx})$0"
    },
    "BR_TRACKFX_GETFXMODULENAME python": {
        "prefix": "BR_TrackFX_GetFXModuleName",
        "scope": "python",
        "description": "[BR] Get the exact name (like effect.dll, effect.vst3, etc...) of an FX.\n",
        "body": "BR_TrackFX_GetFXModuleName(${1:track},${2:fx},${3: nameOut},${4: nameOutSz})$0"
    },
    "BR_WIN32_CB_FINDSTRING c": {
        "prefix": "BR_Win32_CB_FindString",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ComboBox_FindString().\n",
        "body": "BR_Win32_CB_FindString(${1:void* comboBoxHwnd},${2:int startId},${3:const char* string})$0"
    },
    "REAPER.BR_WIN32_CB_FINDSTRING lua": {
        "prefix": "reaper.BR_Win32_CB_FindString",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ComboBox_FindString().\n",
        "body": "reaper.BR_Win32_CB_FindString(${1:identifier comboBoxHwnd},${2:integer startId},${3:string string})$0"
    },
    "BR_WIN32_CB_FINDSTRING python": {
        "prefix": "BR_Win32_CB_FindString",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ComboBox_FindString().\n",
        "body": "BR_Win32_CB_FindString(${1:void comboBoxHwnd},${2:Int startId},${3:String string})$0"
    },
    "BR_WIN32_CB_FINDSTRINGEXACT c": {
        "prefix": "BR_Win32_CB_FindStringExact",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ComboBox_FindStringExact().\n",
        "body": "BR_Win32_CB_FindStringExact(${1:void* comboBoxHwnd},${2:int startId},${3:const char* string})$0"
    },
    "REAPER.BR_WIN32_CB_FINDSTRINGEXACT lua": {
        "prefix": "reaper.BR_Win32_CB_FindStringExact",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ComboBox_FindStringExact().\n",
        "body": "reaper.BR_Win32_CB_FindStringExact(${1:identifier comboBoxHwnd},${2:integer startId},${3:string string})$0"
    },
    "BR_WIN32_CB_FINDSTRINGEXACT python": {
        "prefix": "BR_Win32_CB_FindStringExact",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ComboBox_FindStringExact().\n",
        "body": "BR_Win32_CB_FindStringExact(${1:void comboBoxHwnd},${2:Int startId},${3:String string})$0"
    },
    "BR_WIN32_CLIENTTOSCREEN c": {
        "prefix": "BR_Win32_ClientToScreen",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "BR_Win32_ClientToScreen(${1:void* hwnd},${2:int xIn},${3:int yIn},${4:int* xOut},${5:int* yOut})$0"
    },
    "REAPER.BR_WIN32_CLIENTTOSCREEN lua": {
        "prefix": "reaper.BR_Win32_ClientToScreen",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "reaper.BR_Win32_ClientToScreen(${1:identifier hwnd},${2:integer xIn},${3:integer yIn})$0"
    },
    "BR_WIN32_CLIENTTOSCREEN python": {
        "prefix": "BR_Win32_ClientToScreen",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "BR_Win32_ClientToScreen(${1:hwnd},${2:xIn},${3:yIn},${4:xOut},${5:yOut})$0"
    },
    "BR_WIN32_FINDWINDOWEX c": {
        "prefix": "BR_Win32_FindWindowEx",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API FindWindowEx(). Since ReaScript doesn't\nallow passing NULL (None in Python, nil in Lua etc...) parameters, to\nsearch by supplied class or name set searchClass and searchName\naccordingly. HWND parameters should be passed as either \"0\" to signify\nNULL or as string obtained from BR_Win32_HwndToString.\n",
        "body": "BR_Win32_FindWindowEx(${1:const char* hwndParent},${2:const char* hwndChildAfter},${3:const char* className},${4:const char* windowName},${5:bool searchClass},${6:bool searchName})$0"
    },
    "REAPER.BR_WIN32_FINDWINDOWEX lua": {
        "prefix": "reaper.BR_Win32_FindWindowEx",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API FindWindowEx(). Since ReaScript doesn't\nallow passing NULL (None in Python, nil in Lua etc...) parameters, to\nsearch by supplied class or name set searchClass and searchName\naccordingly. HWND parameters should be passed as either \"0\" to signify\nNULL or as string obtained from BR_Win32_HwndToString.\n",
        "body": "reaper.BR_Win32_FindWindowEx(${1:string hwndParent},${2:string hwndChildAfter},${3:string className},${4:string windowName},${5:boolean searchClass},${6:boolean searchName})$0"
    },
    "BR_WIN32_FINDWINDOWEX python": {
        "prefix": "BR_Win32_FindWindowEx",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API FindWindowEx(). Since ReaScript doesn't\nallow passing NULL (None in Python, nil in Lua etc...) parameters, to\nsearch by supplied class or name set searchClass and searchName\naccordingly. HWND parameters should be passed as either \"0\" to signify\nNULL or as string obtained from BR_Win32_HwndToString.\n",
        "body": "BR_Win32_FindWindowEx(${1:String hwndParent},${2:String hwndChildAfter},${3:String className},${4:String windowName},${5:Boolean searchClass},${6:Boolean searchName})$0"
    },
    "BR_WIN32_GET_X_LPARAM c": {
        "prefix": "BR_Win32_GET_X_LPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GET_X_LPARAM().\n",
        "body": "BR_Win32_GET_X_LPARAM(${1:int lParam})$0"
    },
    "REAPER.BR_WIN32_GET_X_LPARAM lua": {
        "prefix": "reaper.BR_Win32_GET_X_LPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GET_X_LPARAM().\n",
        "body": "reaper.BR_Win32_GET_X_LPARAM(${1:integer lParam})$0"
    },
    "BR_WIN32_GET_X_LPARAM python": {
        "prefix": "BR_Win32_GET_X_LPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GET_X_LPARAM().\n",
        "body": "BR_Win32_GET_X_LPARAM(${1:Int lParam})$0"
    },
    "BR_WIN32_GET_Y_LPARAM c": {
        "prefix": "BR_Win32_GET_Y_LPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GET_Y_LPARAM().\n",
        "body": "BR_Win32_GET_Y_LPARAM(${1:int lParam})$0"
    },
    "REAPER.BR_WIN32_GET_Y_LPARAM lua": {
        "prefix": "reaper.BR_Win32_GET_Y_LPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GET_Y_LPARAM().\n",
        "body": "reaper.BR_Win32_GET_Y_LPARAM(${1:integer lParam})$0"
    },
    "BR_WIN32_GET_Y_LPARAM python": {
        "prefix": "BR_Win32_GET_Y_LPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GET_Y_LPARAM().\n",
        "body": "BR_Win32_GET_Y_LPARAM(${1:Int lParam})$0"
    },
    "BR_WIN32_GETCONSTANT c": {
        "prefix": "BR_Win32_GetConstant",
        "scope": "c",
        "description": "[BR] Returns various constants needed for BR_Win32 functions.\nSupported constants are:\nCB_ERR, CB_GETCOUNT, CB_GETCURSEL, CB_SETCURSEL\nEM_SETSEL\nGW_CHILD, GW_HWNDFIRST, GW_HWNDLAST, GW_HWNDNEXT, GW_HWNDPREV, GW_OWNER\nGWL_STYLE\nSW_HIDE, SW_MAXIMIZE, SW_SHOW, SW_SHOWMINIMIZED, SW_SHOWNA, SW_SHOWNOACTIVATE, SW_SHOWNORMAL\nSWP_FRAMECHANGED, SWP_FRAMECHANGED, SWP_NOMOVE, SWP_NOOWNERZORDER, SWP_NOSIZE, SWP_NOZORDER\nVK_DOWN, VK_UP\nWM_CLOSE, WM_KEYDOWN\nWS_MAXIMIZE, WS_OVERLAPPEDWINDOW\n",
        "body": "BR_Win32_GetConstant(${1:const char* constantName})$0"
    },
    "REAPER.BR_WIN32_GETCONSTANT lua": {
        "prefix": "reaper.BR_Win32_GetConstant",
        "scope": "lua",
        "description": "[BR] Returns various constants needed for BR_Win32 functions.\nSupported constants are:\nCB_ERR, CB_GETCOUNT, CB_GETCURSEL, CB_SETCURSEL\nEM_SETSEL\nGW_CHILD, GW_HWNDFIRST, GW_HWNDLAST, GW_HWNDNEXT, GW_HWNDPREV, GW_OWNER\nGWL_STYLE\nSW_HIDE, SW_MAXIMIZE, SW_SHOW, SW_SHOWMINIMIZED, SW_SHOWNA, SW_SHOWNOACTIVATE, SW_SHOWNORMAL\nSWP_FRAMECHANGED, SWP_FRAMECHANGED, SWP_NOMOVE, SWP_NOOWNERZORDER, SWP_NOSIZE, SWP_NOZORDER\nVK_DOWN, VK_UP\nWM_CLOSE, WM_KEYDOWN\nWS_MAXIMIZE, WS_OVERLAPPEDWINDOW\n",
        "body": "reaper.BR_Win32_GetConstant(${1:string constantName})$0"
    },
    "BR_WIN32_GETCONSTANT python": {
        "prefix": "BR_Win32_GetConstant",
        "scope": "python",
        "description": "[BR] Returns various constants needed for BR_Win32 functions.\nSupported constants are:\nCB_ERR, CB_GETCOUNT, CB_GETCURSEL, CB_SETCURSEL\nEM_SETSEL\nGW_CHILD, GW_HWNDFIRST, GW_HWNDLAST, GW_HWNDNEXT, GW_HWNDPREV, GW_OWNER\nGWL_STYLE\nSW_HIDE, SW_MAXIMIZE, SW_SHOW, SW_SHOWMINIMIZED, SW_SHOWNA, SW_SHOWNOACTIVATE, SW_SHOWNORMAL\nSWP_FRAMECHANGED, SWP_FRAMECHANGED, SWP_NOMOVE, SWP_NOOWNERZORDER, SWP_NOSIZE, SWP_NOZORDER\nVK_DOWN, VK_UP\nWM_CLOSE, WM_KEYDOWN\nWS_MAXIMIZE, WS_OVERLAPPEDWINDOW\n",
        "body": "BR_Win32_GetConstant(${1:String constantName})$0"
    },
    "BR_WIN32_GETCURSORPOS c": {
        "prefix": "BR_Win32_GetCursorPos",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetCursorPos().\n",
        "body": "BR_Win32_GetCursorPos(${1:int* xOut},${2:int* yOut})$0"
    },
    "REAPER.BR_WIN32_GETCURSORPOS lua": {
        "prefix": "reaper.BR_Win32_GetCursorPos",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetCursorPos().\n",
        "body": "reaper.BR_Win32_GetCursorPos()$0"
    },
    "BR_WIN32_GETCURSORPOS python": {
        "prefix": "BR_Win32_GetCursorPos",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetCursorPos().\n",
        "body": "BR_Win32_GetCursorPos(${1:xOut},${2:yOut})$0"
    },
    "BR_WIN32_GETFOCUS c": {
        "prefix": "BR_Win32_GetFocus",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetFocus().\n",
        "body": "BR_Win32_GetFocus()$0"
    },
    "REAPER.BR_WIN32_GETFOCUS lua": {
        "prefix": "reaper.BR_Win32_GetFocus",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetFocus().\n",
        "body": "reaper.BR_Win32_GetFocus()$0"
    },
    "BR_WIN32_GETFOCUS python": {
        "prefix": "BR_Win32_GetFocus",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetFocus().\n",
        "body": "BR_Win32_GetFocus()$0"
    },
    "BR_WIN32_GETFOREGROUNDWINDOW c": {
        "prefix": "BR_Win32_GetForegroundWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetForegroundWindow().\n",
        "body": "BR_Win32_GetForegroundWindow()$0"
    },
    "REAPER.BR_WIN32_GETFOREGROUNDWINDOW lua": {
        "prefix": "reaper.BR_Win32_GetForegroundWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetForegroundWindow().\n",
        "body": "reaper.BR_Win32_GetForegroundWindow()$0"
    },
    "BR_WIN32_GETFOREGROUNDWINDOW python": {
        "prefix": "BR_Win32_GetForegroundWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetForegroundWindow().\n",
        "body": "BR_Win32_GetForegroundWindow()$0"
    },
    "BR_WIN32_GETMAINHWND c": {
        "prefix": "BR_Win32_GetMainHwnd",
        "scope": "c",
        "description": "[BR] Alternative to GetMainHwnd. REAPER seems\nto have problems with extensions using HWND type for exported functions\nso all BR_Win32 functions use void* instead of HWND type\n",
        "body": "BR_Win32_GetMainHwnd()$0"
    },
    "REAPER.BR_WIN32_GETMAINHWND lua": {
        "prefix": "reaper.BR_Win32_GetMainHwnd",
        "scope": "lua",
        "description": "[BR] Alternative to GetMainHwnd. REAPER seems\nto have problems with extensions using HWND type for exported functions\nso all BR_Win32 functions use void* instead of HWND type\n",
        "body": "reaper.BR_Win32_GetMainHwnd()$0"
    },
    "BR_WIN32_GETMAINHWND python": {
        "prefix": "BR_Win32_GetMainHwnd",
        "scope": "python",
        "description": "[BR] Alternative to GetMainHwnd. REAPER seems\nto have problems with extensions using HWND type for exported functions\nso all BR_Win32 functions use void* instead of HWND type\n",
        "body": "BR_Win32_GetMainHwnd()$0"
    },
    "BR_WIN32_GETMIXERHWND c": {
        "prefix": "BR_Win32_GetMixerHwnd",
        "scope": "c",
        "description": "[BR] Get mixer window HWND. isDockedOut will be set to true if mixer is docked\n",
        "body": "BR_Win32_GetMixerHwnd(${1:bool* isDockedOut})$0"
    },
    "REAPER.BR_WIN32_GETMIXERHWND lua": {
        "prefix": "reaper.BR_Win32_GetMixerHwnd",
        "scope": "lua",
        "description": "[BR] Get mixer window HWND. isDockedOut will be set to true if mixer is docked\n",
        "body": "reaper.BR_Win32_GetMixerHwnd()$0"
    },
    "BR_WIN32_GETMIXERHWND python": {
        "prefix": "BR_Win32_GetMixerHwnd",
        "scope": "python",
        "description": "[BR] Get mixer window HWND. isDockedOut will be set to true if mixer is docked\n",
        "body": "BR_Win32_GetMixerHwnd(${1:isDockedOut})$0"
    },
    "BR_WIN32_GETMONITORRECTFROMRECT c": {
        "prefix": "BR_Win32_GetMonitorRectFromRect",
        "scope": "c",
        "description": "[BR] Get coordinates for screen which is nearest to supplied\ncoordinates. Pass workingAreaOnly as true to get screen coordinates\nexcluding taskbar (or menu bar on OSX).\n",
        "body": "BR_Win32_GetMonitorRectFromRect(${1:bool workingAreaOnly},${2:int leftIn},${3:int topIn},${4:int rightIn},${5:int bottomIn},${6:int* leftOut},${7:int* topOut},${8:int* rightOut},${9:int* bottomOut})$0"
    },
    "REAPER.BR_WIN32_GETMONITORRECTFROMRECT lua": {
        "prefix": "reaper.BR_Win32_GetMonitorRectFromRect",
        "scope": "lua",
        "description": "[BR] Get coordinates for screen which is nearest to supplied\ncoordinates. Pass workingAreaOnly as true to get screen coordinates\nexcluding taskbar (or menu bar on OSX).\n",
        "body": "reaper.BR_Win32_GetMonitorRectFromRect(${1:boolean workingAreaOnly},${2:integer leftIn},${3:integer topIn},${4:integer rightIn},${5:integer bottomIn})$0"
    },
    "BR_WIN32_GETMONITORRECTFROMRECT python": {
        "prefix": "BR_Win32_GetMonitorRectFromRect",
        "scope": "python",
        "description": "[BR] Get coordinates for screen which is nearest to supplied\ncoordinates. Pass workingAreaOnly as true to get screen coordinates\nexcluding taskbar (or menu bar on OSX).\n",
        "body": "BR_Win32_GetMonitorRectFromRect(${1:workingAreaOnly},${2:leftIn},${3:topIn},${4:rightIn},${5:bottomIn},${6:leftOut},${7:topOut},${8:rightOut},${9:bottomOut})$0"
    },
    "BR_WIN32_GETPARENT c": {
        "prefix": "BR_Win32_GetParent",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetParent().\n",
        "body": "BR_Win32_GetParent(${1:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_GETPARENT lua": {
        "prefix": "reaper.BR_Win32_GetParent",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetParent().\n",
        "body": "reaper.BR_Win32_GetParent(${1:identifier hwnd})$0"
    },
    "BR_WIN32_GETPARENT python": {
        "prefix": "BR_Win32_GetParent",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetParent().\n",
        "body": "BR_Win32_GetParent(${1:void hwnd})$0"
    },
    "BR_WIN32_GETPRIVATEPROFILESTRING c": {
        "prefix": "BR_Win32_GetPrivateProfileString",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetPrivateProfileString(). For example, you can use this to get values from REAPER.ini\n",
        "body": "BR_Win32_GetPrivateProfileString(${1:const char* sectionName},${2:const char* keyName},${3:const char* defaultString},${4:const char* filePath},${5:char* stringOut},${6:int stringOut_sz})$0"
    },
    "REAPER.BR_WIN32_GETPRIVATEPROFILESTRING lua": {
        "prefix": "reaper.BR_Win32_GetPrivateProfileString",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetPrivateProfileString(). For example, you can use this to get values from REAPER.ini\n",
        "body": "reaper.BR_Win32_GetPrivateProfileString(${1:string sectionName},${2:string keyName},${3:string defaultString},${4:string filePath})$0"
    },
    "BR_WIN32_GETPRIVATEPROFILESTRING python": {
        "prefix": "BR_Win32_GetPrivateProfileString",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetPrivateProfileString(). For example, you can use this to get values from REAPER.ini\n",
        "body": "BR_Win32_GetPrivateProfileString(${1:sectionName},${2:keyName},${3:defaultString},${4:filePath},${5:stringOut},${6:stringOut_sz})$0"
    },
    "BR_WIN32_GETWINDOW c": {
        "prefix": "BR_Win32_GetWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindow().\n",
        "body": "BR_Win32_GetWindow(${1:void* hwnd},${2:int cmd})$0"
    },
    "REAPER.BR_WIN32_GETWINDOW lua": {
        "prefix": "reaper.BR_Win32_GetWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindow().\n",
        "body": "reaper.BR_Win32_GetWindow(${1:identifier hwnd},${2:integer cmd})$0"
    },
    "BR_WIN32_GETWINDOW python": {
        "prefix": "BR_Win32_GetWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindow().\n",
        "body": "BR_Win32_GetWindow(${1:void hwnd},${2:Int cmd})$0"
    },
    "BR_WIN32_GETWINDOWLONG c": {
        "prefix": "BR_Win32_GetWindowLong",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindowLong().\n",
        "body": "BR_Win32_GetWindowLong(${1:void* hwnd},${2:int index})$0"
    },
    "REAPER.BR_WIN32_GETWINDOWLONG lua": {
        "prefix": "reaper.BR_Win32_GetWindowLong",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindowLong().\n",
        "body": "reaper.BR_Win32_GetWindowLong(${1:identifier hwnd},${2:integer index})$0"
    },
    "BR_WIN32_GETWINDOWLONG python": {
        "prefix": "BR_Win32_GetWindowLong",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindowLong().\n",
        "body": "BR_Win32_GetWindowLong(${1:void hwnd},${2:Int index})$0"
    },
    "BR_WIN32_GETWINDOWRECT c": {
        "prefix": "BR_Win32_GetWindowRect",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindowRect().\n",
        "body": "BR_Win32_GetWindowRect(${1:void* hwnd},${2:int* leftOut},${3:int* topOut},${4:int* rightOut},${5:int* bottomOut})$0"
    },
    "REAPER.BR_WIN32_GETWINDOWRECT lua": {
        "prefix": "reaper.BR_Win32_GetWindowRect",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindowRect().\n",
        "body": "reaper.BR_Win32_GetWindowRect(${1:identifier hwnd})$0"
    },
    "BR_WIN32_GETWINDOWRECT python": {
        "prefix": "BR_Win32_GetWindowRect",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindowRect().\n",
        "body": "BR_Win32_GetWindowRect(${1:hwnd},${2:leftOut},${3:topOut},${4:rightOut},${5:bottomOut})$0"
    },
    "BR_WIN32_GETWINDOWTEXT c": {
        "prefix": "BR_Win32_GetWindowText",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindowText().\n",
        "body": "BR_Win32_GetWindowText(${1:void* hwnd},${2:char* textOut},${3:int textOut_sz})$0"
    },
    "REAPER.BR_WIN32_GETWINDOWTEXT lua": {
        "prefix": "reaper.BR_Win32_GetWindowText",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindowText().\n",
        "body": "reaper.BR_Win32_GetWindowText(${1:identifier hwnd})$0"
    },
    "BR_WIN32_GETWINDOWTEXT python": {
        "prefix": "BR_Win32_GetWindowText",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindowText().\n",
        "body": "BR_Win32_GetWindowText(${1:hwnd},${2:textOut},${3:textOut_sz})$0"
    },
    "BR_WIN32_HIBYTE c": {
        "prefix": "BR_Win32_HIBYTE",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API HIBYTE().\n",
        "body": "BR_Win32_HIBYTE(${1:int value})$0"
    },
    "REAPER.BR_WIN32_HIBYTE lua": {
        "prefix": "reaper.BR_Win32_HIBYTE",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API HIBYTE().\n",
        "body": "reaper.BR_Win32_HIBYTE(${1:integer value})$0"
    },
    "BR_WIN32_HIBYTE python": {
        "prefix": "BR_Win32_HIBYTE",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API HIBYTE().\n",
        "body": "BR_Win32_HIBYTE(${1:Int value})$0"
    },
    "BR_WIN32_HIWORD c": {
        "prefix": "BR_Win32_HIWORD",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API HIWORD().\n",
        "body": "BR_Win32_HIWORD(${1:int value})$0"
    },
    "REAPER.BR_WIN32_HIWORD lua": {
        "prefix": "reaper.BR_Win32_HIWORD",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API HIWORD().\n",
        "body": "reaper.BR_Win32_HIWORD(${1:integer value})$0"
    },
    "BR_WIN32_HIWORD python": {
        "prefix": "BR_Win32_HIWORD",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API HIWORD().\n",
        "body": "BR_Win32_HIWORD(${1:Int value})$0"
    },
    "BR_WIN32_HWNDTOSTRING c": {
        "prefix": "BR_Win32_HwndToString",
        "scope": "c",
        "description": "[BR] Convert HWND to string. To convert string back to HWND, see BR_Win32_StringToHwnd.\n",
        "body": "BR_Win32_HwndToString(${1:void* hwnd},${2:char* stringOut},${3:int stringOut_sz})$0"
    },
    "REAPER.BR_WIN32_HWNDTOSTRING lua": {
        "prefix": "reaper.BR_Win32_HwndToString",
        "scope": "lua",
        "description": "[BR] Convert HWND to string. To convert string back to HWND, see BR_Win32_StringToHwnd.\n",
        "body": "reaper.BR_Win32_HwndToString(${1:identifier hwnd})$0"
    },
    "BR_WIN32_HWNDTOSTRING python": {
        "prefix": "BR_Win32_HwndToString",
        "scope": "python",
        "description": "[BR] Convert HWND to string. To convert string back to HWND, see BR_Win32_StringToHwnd.\n",
        "body": "BR_Win32_HwndToString(${1:hwnd},${2:stringOut},${3:stringOut_sz})$0"
    },
    "BR_WIN32_ISWINDOW c": {
        "prefix": "BR_Win32_IsWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API IsWindow().\n",
        "body": "BR_Win32_IsWindow(${1:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_ISWINDOW lua": {
        "prefix": "reaper.BR_Win32_IsWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API IsWindow().\n",
        "body": "reaper.BR_Win32_IsWindow(${1:identifier hwnd})$0"
    },
    "BR_WIN32_ISWINDOW python": {
        "prefix": "BR_Win32_IsWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API IsWindow().\n",
        "body": "BR_Win32_IsWindow(${1:void hwnd})$0"
    },
    "BR_WIN32_ISWINDOWVISIBLE c": {
        "prefix": "BR_Win32_IsWindowVisible",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API IsWindowVisible().\n",
        "body": "BR_Win32_IsWindowVisible(${1:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_ISWINDOWVISIBLE lua": {
        "prefix": "reaper.BR_Win32_IsWindowVisible",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API IsWindowVisible().\n",
        "body": "reaper.BR_Win32_IsWindowVisible(${1:identifier hwnd})$0"
    },
    "BR_WIN32_ISWINDOWVISIBLE python": {
        "prefix": "BR_Win32_IsWindowVisible",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API IsWindowVisible().\n",
        "body": "BR_Win32_IsWindowVisible(${1:void hwnd})$0"
    },
    "BR_WIN32_LOBYTE c": {
        "prefix": "BR_Win32_LOBYTE",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API LOBYTE().\n",
        "body": "BR_Win32_LOBYTE(${1:int value})$0"
    },
    "REAPER.BR_WIN32_LOBYTE lua": {
        "prefix": "reaper.BR_Win32_LOBYTE",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API LOBYTE().\n",
        "body": "reaper.BR_Win32_LOBYTE(${1:integer value})$0"
    },
    "BR_WIN32_LOBYTE python": {
        "prefix": "BR_Win32_LOBYTE",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API LOBYTE().\n",
        "body": "BR_Win32_LOBYTE(${1:Int value})$0"
    },
    "BR_WIN32_LOWORD c": {
        "prefix": "BR_Win32_LOWORD",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API LOWORD().\n",
        "body": "BR_Win32_LOWORD(${1:int value})$0"
    },
    "REAPER.BR_WIN32_LOWORD lua": {
        "prefix": "reaper.BR_Win32_LOWORD",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API LOWORD().\n",
        "body": "reaper.BR_Win32_LOWORD(${1:integer value})$0"
    },
    "BR_WIN32_LOWORD python": {
        "prefix": "BR_Win32_LOWORD",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API LOWORD().\n",
        "body": "BR_Win32_LOWORD(${1:Int value})$0"
    },
    "BR_WIN32_MAKELONG c": {
        "prefix": "BR_Win32_MAKELONG",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKELONG().\n",
        "body": "BR_Win32_MAKELONG(${1:int low},${2:int high})$0"
    },
    "REAPER.BR_WIN32_MAKELONG lua": {
        "prefix": "reaper.BR_Win32_MAKELONG",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKELONG().\n",
        "body": "reaper.BR_Win32_MAKELONG(${1:integer low},${2:integer high})$0"
    },
    "BR_WIN32_MAKELONG python": {
        "prefix": "BR_Win32_MAKELONG",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKELONG().\n",
        "body": "BR_Win32_MAKELONG(${1:Int low},${2:Int high})$0"
    },
    "BR_WIN32_MAKELPARAM c": {
        "prefix": "BR_Win32_MAKELPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKELPARAM().\n",
        "body": "BR_Win32_MAKELPARAM(${1:int low},${2:int high})$0"
    },
    "REAPER.BR_WIN32_MAKELPARAM lua": {
        "prefix": "reaper.BR_Win32_MAKELPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKELPARAM().\n",
        "body": "reaper.BR_Win32_MAKELPARAM(${1:integer low},${2:integer high})$0"
    },
    "BR_WIN32_MAKELPARAM python": {
        "prefix": "BR_Win32_MAKELPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKELPARAM().\n",
        "body": "BR_Win32_MAKELPARAM(${1:Int low},${2:Int high})$0"
    },
    "BR_WIN32_MAKELRESULT c": {
        "prefix": "BR_Win32_MAKELRESULT",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKELRESULT().\n",
        "body": "BR_Win32_MAKELRESULT(${1:int low},${2:int high})$0"
    },
    "REAPER.BR_WIN32_MAKELRESULT lua": {
        "prefix": "reaper.BR_Win32_MAKELRESULT",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKELRESULT().\n",
        "body": "reaper.BR_Win32_MAKELRESULT(${1:integer low},${2:integer high})$0"
    },
    "BR_WIN32_MAKELRESULT python": {
        "prefix": "BR_Win32_MAKELRESULT",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKELRESULT().\n",
        "body": "BR_Win32_MAKELRESULT(${1:Int low},${2:Int high})$0"
    },
    "BR_WIN32_MAKEWORD c": {
        "prefix": "BR_Win32_MAKEWORD",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKEWORD().\n",
        "body": "BR_Win32_MAKEWORD(${1:int low},${2:int high})$0"
    },
    "REAPER.BR_WIN32_MAKEWORD lua": {
        "prefix": "reaper.BR_Win32_MAKEWORD",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKEWORD().\n",
        "body": "reaper.BR_Win32_MAKEWORD(${1:integer low},${2:integer high})$0"
    },
    "BR_WIN32_MAKEWORD python": {
        "prefix": "BR_Win32_MAKEWORD",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKEWORD().\n",
        "body": "BR_Win32_MAKEWORD(${1:Int low},${2:Int high})$0"
    },
    "BR_WIN32_MAKEWPARAM c": {
        "prefix": "BR_Win32_MAKEWPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKEWPARAM().\n",
        "body": "BR_Win32_MAKEWPARAM(${1:int low},${2:int high})$0"
    },
    "REAPER.BR_WIN32_MAKEWPARAM lua": {
        "prefix": "reaper.BR_Win32_MAKEWPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKEWPARAM().\n",
        "body": "reaper.BR_Win32_MAKEWPARAM(${1:integer low},${2:integer high})$0"
    },
    "BR_WIN32_MAKEWPARAM python": {
        "prefix": "BR_Win32_MAKEWPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKEWPARAM().\n",
        "body": "BR_Win32_MAKEWPARAM(${1:Int low},${2:Int high})$0"
    },
    "BR_WIN32_MIDIEDITOR_GETACTIVE c": {
        "prefix": "BR_Win32_MIDIEditor_GetActive",
        "scope": "c",
        "description": "[BR] Alternative to MIDIEditor_GetActive.\nREAPER seems to have problems with extensions using HWND type for\nexported functions so all BR_Win32 functions use void* instead of HWND\ntype.\n",
        "body": "BR_Win32_MIDIEditor_GetActive()$0"
    },
    "REAPER.BR_WIN32_MIDIEDITOR_GETACTIVE lua": {
        "prefix": "reaper.BR_Win32_MIDIEditor_GetActive",
        "scope": "lua",
        "description": "[BR] Alternative to MIDIEditor_GetActive.\nREAPER seems to have problems with extensions using HWND type for\nexported functions so all BR_Win32 functions use void* instead of HWND\ntype.\n",
        "body": "reaper.BR_Win32_MIDIEditor_GetActive()$0"
    },
    "BR_WIN32_MIDIEDITOR_GETACTIVE python": {
        "prefix": "BR_Win32_MIDIEditor_GetActive",
        "scope": "python",
        "description": "[BR] Alternative to MIDIEditor_GetActive.\nREAPER seems to have problems with extensions using HWND type for\nexported functions so all BR_Win32 functions use void* instead of HWND\ntype.\n",
        "body": "BR_Win32_MIDIEditor_GetActive()$0"
    },
    "BR_WIN32_SCREENTOCLIENT c": {
        "prefix": "BR_Win32_ScreenToClient",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "BR_Win32_ScreenToClient(${1:void* hwnd},${2:int xIn},${3:int yIn},${4:int* xOut},${5:int* yOut})$0"
    },
    "REAPER.BR_WIN32_SCREENTOCLIENT lua": {
        "prefix": "reaper.BR_Win32_ScreenToClient",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "reaper.BR_Win32_ScreenToClient(${1:identifier hwnd},${2:integer xIn},${3:integer yIn})$0"
    },
    "BR_WIN32_SCREENTOCLIENT python": {
        "prefix": "BR_Win32_ScreenToClient",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "BR_Win32_ScreenToClient(${1:hwnd},${2:xIn},${3:yIn},${4:xOut},${5:yOut})$0"
    },
    "BR_WIN32_SENDMESSAGE c": {
        "prefix": "BR_Win32_SendMessage",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SendMessage().\n",
        "body": "BR_Win32_SendMessage(${1:void* hwnd},${2:int msg},${3:int lParam},${4:int wParam})$0"
    },
    "REAPER.BR_WIN32_SENDMESSAGE lua": {
        "prefix": "reaper.BR_Win32_SendMessage",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SendMessage().\n",
        "body": "reaper.BR_Win32_SendMessage(${1:identifier hwnd},${2:integer msg},${3:integer lParam},${4:integer wParam})$0"
    },
    "BR_WIN32_SENDMESSAGE python": {
        "prefix": "BR_Win32_SendMessage",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SendMessage().\n",
        "body": "BR_Win32_SendMessage(${1:void hwnd},${2:Int msg},${3:Int lParam},${4:Int wParam})$0"
    },
    "BR_WIN32_SETFOCUS c": {
        "prefix": "BR_Win32_SetFocus",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetFocus().\n",
        "body": "BR_Win32_SetFocus(${1:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_SETFOCUS lua": {
        "prefix": "reaper.BR_Win32_SetFocus",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetFocus().\n",
        "body": "reaper.BR_Win32_SetFocus(${1:identifier hwnd})$0"
    },
    "BR_WIN32_SETFOCUS python": {
        "prefix": "BR_Win32_SetFocus",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetFocus().\n",
        "body": "BR_Win32_SetFocus(${1:void hwnd})$0"
    },
    "BR_WIN32_SETFOREGROUNDWINDOW c": {
        "prefix": "BR_Win32_SetForegroundWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetForegroundWindow().\n",
        "body": "BR_Win32_SetForegroundWindow(${1:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_SETFOREGROUNDWINDOW lua": {
        "prefix": "reaper.BR_Win32_SetForegroundWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetForegroundWindow().\n",
        "body": "reaper.BR_Win32_SetForegroundWindow(${1:identifier hwnd})$0"
    },
    "BR_WIN32_SETFOREGROUNDWINDOW python": {
        "prefix": "BR_Win32_SetForegroundWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetForegroundWindow().\n",
        "body": "BR_Win32_SetForegroundWindow(${1:void hwnd})$0"
    },
    "BR_WIN32_SETWINDOWLONG c": {
        "prefix": "BR_Win32_SetWindowLong",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetWindowLong().\n",
        "body": "BR_Win32_SetWindowLong(${1:void* hwnd},${2:int index},${3:int newLong})$0"
    },
    "REAPER.BR_WIN32_SETWINDOWLONG lua": {
        "prefix": "reaper.BR_Win32_SetWindowLong",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetWindowLong().\n",
        "body": "reaper.BR_Win32_SetWindowLong(${1:identifier hwnd},${2:integer index},${3:integer newLong})$0"
    },
    "BR_WIN32_SETWINDOWLONG python": {
        "prefix": "BR_Win32_SetWindowLong",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetWindowLong().\n",
        "body": "BR_Win32_SetWindowLong(${1:void hwnd},${2:Int index},${3:Int newLong})$0"
    },
    "BR_WIN32_SETWINDOWPOS c": {
        "prefix": "BR_Win32_SetWindowPos",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetWindowPos().\nhwndInsertAfter may be a string: \"HWND_BOTTOM\", \"HWND_NOTOPMOST\", \"HWND_TOP\", \"HWND_TOPMOST\" or a string obtained with BR_Win32_HwndToString.\n",
        "body": "BR_Win32_SetWindowPos(${1:void* hwnd},${2:const char* hwndInsertAfter},${3:int x},${4:int y},${5:int width},${6:int height},${7:int flags})$0"
    },
    "REAPER.BR_WIN32_SETWINDOWPOS lua": {
        "prefix": "reaper.BR_Win32_SetWindowPos",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetWindowPos().\nhwndInsertAfter may be a string: \"HWND_BOTTOM\", \"HWND_NOTOPMOST\", \"HWND_TOP\", \"HWND_TOPMOST\" or a string obtained with BR_Win32_HwndToString.\n",
        "body": "reaper.BR_Win32_SetWindowPos(${1:identifier hwnd},${2:string hwndInsertAfter},${3:integer x},${4:integer y},${5:integer width},${6:integer height},${7:integer flags})$0"
    },
    "BR_WIN32_SETWINDOWPOS python": {
        "prefix": "BR_Win32_SetWindowPos",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetWindowPos().\nhwndInsertAfter may be a string: \"HWND_BOTTOM\", \"HWND_NOTOPMOST\", \"HWND_TOP\", \"HWND_TOPMOST\" or a string obtained with BR_Win32_HwndToString.\n",
        "body": "BR_Win32_SetWindowPos(${1:void hwnd},${2:String hwndInsertAfter},${3:Int x},${4:Int y},${5:Int width},${6:Int height},${7:Int flags})$0"
    },
    "BR_WIN32_SHELLEXECUTE c": {
        "prefix": "BR_Win32_ShellExecute",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ShellExecute() with HWND set to main window\n",
        "body": "BR_Win32_ShellExecute(${1:const char* operation},${2:const char* file},${3:const char* parameters},${4:const char* directory},${5:int showFlags})$0"
    },
    "REAPER.BR_WIN32_SHELLEXECUTE lua": {
        "prefix": "reaper.BR_Win32_ShellExecute",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ShellExecute() with HWND set to main window\n",
        "body": "reaper.BR_Win32_ShellExecute(${1:string operation},${2:string file},${3:string parameters},${4:string directory},${5:integer showFlags})$0"
    },
    "BR_WIN32_SHELLEXECUTE python": {
        "prefix": "BR_Win32_ShellExecute",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ShellExecute() with HWND set to main window\n",
        "body": "BR_Win32_ShellExecute(${1:String operation},${2:String file},${3:String parameters},${4:String directory},${5:Int showFlags})$0"
    },
    "BR_WIN32_SHOWWINDOW c": {
        "prefix": "BR_Win32_ShowWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ShowWindow().\n",
        "body": "BR_Win32_ShowWindow(${1:void* hwnd},${2:int cmdShow})$0"
    },
    "REAPER.BR_WIN32_SHOWWINDOW lua": {
        "prefix": "reaper.BR_Win32_ShowWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ShowWindow().\n",
        "body": "reaper.BR_Win32_ShowWindow(${1:identifier hwnd},${2:integer cmdShow})$0"
    },
    "BR_WIN32_SHOWWINDOW python": {
        "prefix": "BR_Win32_ShowWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ShowWindow().\n",
        "body": "BR_Win32_ShowWindow(${1:void hwnd},${2:Int cmdShow})$0"
    },
    "BR_WIN32_STRINGTOHWND c": {
        "prefix": "BR_Win32_StringToHwnd",
        "scope": "c",
        "description": "[BR] Convert string to HWND. To convert HWND back to string, see BR_Win32_HwndToString.\n",
        "body": "BR_Win32_StringToHwnd(${1:const char* string})$0"
    },
    "REAPER.BR_WIN32_STRINGTOHWND lua": {
        "prefix": "reaper.BR_Win32_StringToHwnd",
        "scope": "lua",
        "description": "[BR] Convert string to HWND. To convert HWND back to string, see BR_Win32_HwndToString.\n",
        "body": "reaper.BR_Win32_StringToHwnd(${1:string string})$0"
    },
    "BR_WIN32_STRINGTOHWND python": {
        "prefix": "BR_Win32_StringToHwnd",
        "scope": "python",
        "description": "[BR] Convert string to HWND. To convert HWND back to string, see BR_Win32_HwndToString.\n",
        "body": "BR_Win32_StringToHwnd(${1:String string})$0"
    },
    "BR_WIN32_WINDOWFROMPOINT c": {
        "prefix": "BR_Win32_WindowFromPoint",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API WindowFromPoint().\n",
        "body": "BR_Win32_WindowFromPoint(${1:int x},${2:int y})$0"
    },
    "REAPER.BR_WIN32_WINDOWFROMPOINT lua": {
        "prefix": "reaper.BR_Win32_WindowFromPoint",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API WindowFromPoint().\n",
        "body": "reaper.BR_Win32_WindowFromPoint(${1:integer x},${2:integer y})$0"
    },
    "BR_WIN32_WINDOWFROMPOINT python": {
        "prefix": "BR_Win32_WindowFromPoint",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API WindowFromPoint().\n",
        "body": "BR_Win32_WindowFromPoint(${1:Int x},${2:Int y})$0"
    },
    "BR_WIN32_WRITEPRIVATEPROFILESTRING c": {
        "prefix": "BR_Win32_WritePrivateProfileString",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API WritePrivateProfileString(). For example, you can use this to write to REAPER.ini\n",
        "body": "BR_Win32_WritePrivateProfileString(${1:const char* sectionName},${2:const char* keyName},${3:const char* value},${4:const char* filePath})$0"
    },
    "REAPER.BR_WIN32_WRITEPRIVATEPROFILESTRING lua": {
        "prefix": "reaper.BR_Win32_WritePrivateProfileString",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API WritePrivateProfileString(). For example, you can use this to write to REAPER.ini\n",
        "body": "reaper.BR_Win32_WritePrivateProfileString(${1:string sectionName},${2:string keyName},${3:string value},${4:string filePath})$0"
    },
    "BR_WIN32_WRITEPRIVATEPROFILESTRING python": {
        "prefix": "BR_Win32_WritePrivateProfileString",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API WritePrivateProfileString(). For example, you can use this to write to REAPER.ini\n",
        "body": "BR_Win32_WritePrivateProfileString(${1:String sectionName},${2:String keyName},${3:String value},${4:String filePath})$0"
    },
    "CF_ENUMMEDIASOURCECUES c": {
        "prefix": "CF_EnumMediaSourceCues",
        "scope": "c",
        "description": "Enumerate the source's media cues. Returns the next index or 0 when finished.\n",
        "body": "CF_EnumMediaSourceCues(${1:PCM_source* src},${2:int index},${3:double* timeOut},${4:double* endTimeOut},${5:bool* isRegionOut},${6:char* nameOut},${7:int nameOut_sz})$0"
    },
    "REAPER.CF_ENUMMEDIASOURCECUES lua": {
        "prefix": "reaper.CF_EnumMediaSourceCues",
        "scope": "lua",
        "description": "Enumerate the source's media cues. Returns the next index or 0 when finished.\n",
        "body": "reaper.CF_EnumMediaSourceCues(${1:PCM_source src},${2:integer index})$0"
    },
    "CF_ENUMMEDIASOURCECUES python": {
        "prefix": "CF_EnumMediaSourceCues",
        "scope": "python",
        "description": "Enumerate the source's media cues. Returns the next index or 0 when finished.\n",
        "body": "CF_EnumMediaSourceCues(${1:src},${2:index},${3:timeOut},${4:endTimeOut},${5:isRegionOut},${6:nameOut},${7:nameOut_sz})$0"
    },
    "CF_ENUMSELECTEDFX c": {
        "prefix": "CF_EnumSelectedFX",
        "scope": "c",
        "description": "Return the index of the next selected effect in the given FX chain.\nStart index should be -1. Returns -1 if there are no more selected\neffects.\n",
        "body": "CF_EnumSelectedFX(${1:FxChain* hwnd},${2:int index})$0"
    },
    "REAPER.CF_ENUMSELECTEDFX lua": {
        "prefix": "reaper.CF_EnumSelectedFX",
        "scope": "lua",
        "description": "Return the index of the next selected effect in the given FX chain.\nStart index should be -1. Returns -1 if there are no more selected\neffects.\n",
        "body": "reaper.CF_EnumSelectedFX(${1:FxChain hwnd},${2:integer index})$0"
    },
    "CF_ENUMSELECTEDFX python": {
        "prefix": "CF_EnumSelectedFX",
        "scope": "python",
        "description": "Return the index of the next selected effect in the given FX chain.\nStart index should be -1. Returns -1 if there are no more selected\neffects.\n",
        "body": "CF_EnumSelectedFX(${1:FxChain hwnd},${2:Int index})$0"
    },
    "CF_ENUMERATEACTIONS c": {
        "prefix": "CF_EnumerateActions",
        "scope": "c",
        "description": "Wrapper for the unexposed kbd_enumerateActions API function.\nMain=0, Main (alt recording)=100, MIDI Editor=32060, MIDI Event List\nEditor=32061, MIDI Inline Editor=32062, Media Explorer=32063\n",
        "body": "CF_EnumerateActions(${1:int section},${2:int index},${3:char* name},${4:int name_sz})$0"
    },
    "REAPER.CF_ENUMERATEACTIONS lua": {
        "prefix": "reaper.CF_EnumerateActions",
        "scope": "lua",
        "description": "Wrapper for the unexposed kbd_enumerateActions API function.\nMain=0, Main (alt recording)=100, MIDI Editor=32060, MIDI Event List\nEditor=32061, MIDI Inline Editor=32062, Media Explorer=32063\n",
        "body": "reaper.CF_EnumerateActions(${1:integer section},${2:integer index},${3:string name})$0"
    },
    "CF_ENUMERATEACTIONS python": {
        "prefix": "CF_EnumerateActions",
        "scope": "python",
        "description": "Wrapper for the unexposed kbd_enumerateActions API function.\nMain=0, Main (alt recording)=100, MIDI Editor=32060, MIDI Event List\nEditor=32061, MIDI Inline Editor=32062, Media Explorer=32063\n",
        "body": "CF_EnumerateActions(${1:section},${2:index},${3:name},${4:name_sz})$0"
    },
    "CF_EXPORTMEDIASOURCE c": {
        "prefix": "CF_ExportMediaSource",
        "scope": "c",
        "description": "Export the source to the given file (MIDI only).\n",
        "body": "CF_ExportMediaSource(${1:PCM_source* src},${2:const char* fn})$0"
    },
    "REAPER.CF_EXPORTMEDIASOURCE lua": {
        "prefix": "reaper.CF_ExportMediaSource",
        "scope": "lua",
        "description": "Export the source to the given file (MIDI only).\n",
        "body": "reaper.CF_ExportMediaSource(${1:PCM_source src},${2:string fn})$0"
    },
    "CF_EXPORTMEDIASOURCE python": {
        "prefix": "CF_ExportMediaSource",
        "scope": "python",
        "description": "Export the source to the given file (MIDI only).\n",
        "body": "CF_ExportMediaSource(${1:PCM_source src},${2:String fn})$0"
    },
    "CF_GETCLIPBOARD c": {
        "prefix": "CF_GetClipboard",
        "scope": "c",
        "description": "Read the contents of the system clipboard (limited to 1023 characters in Lua).\n",
        "body": "CF_GetClipboard(${1:char* buf},${2:int buf_sz})$0"
    },
    "REAPER.CF_GETCLIPBOARD lua": {
        "prefix": "reaper.CF_GetClipboard",
        "scope": "lua",
        "description": "Read the contents of the system clipboard (limited to 1023 characters in Lua).\n",
        "body": "reaper.CF_GetClipboard(${1:string buf})$0"
    },
    "CF_GETCLIPBOARD python": {
        "prefix": "CF_GetClipboard",
        "scope": "python",
        "description": "Read the contents of the system clipboard (limited to 1023 characters in Lua).\n",
        "body": "CF_GetClipboard(${1:buf},${2:buf_sz})$0"
    },
    "CF_GETCLIPBOARDBIG c": {
        "prefix": "CF_GetClipboardBig",
        "scope": "c",
        "description": "Read the contents of the system clipboard. See SNM_CreateFastString and SNM_DeleteFastString.\n",
        "body": "CF_GetClipboardBig(${1:WDL_FastString* output})$0"
    },
    "REAPER.CF_GETCLIPBOARDBIG lua": {
        "prefix": "reaper.CF_GetClipboardBig",
        "scope": "lua",
        "description": "Read the contents of the system clipboard. See SNM_CreateFastString and SNM_DeleteFastString.\n",
        "body": "reaper.CF_GetClipboardBig(${1:WDL_FastString output})$0"
    },
    "CF_GETCLIPBOARDBIG python": {
        "prefix": "CF_GetClipboardBig",
        "scope": "python",
        "description": "Read the contents of the system clipboard. See SNM_CreateFastString and SNM_DeleteFastString.\n",
        "body": "CF_GetClipboardBig(${1:WDL_FastString output})$0"
    },
    "CF_GETCOMMANDTEXT c": {
        "prefix": "CF_GetCommandText",
        "scope": "c",
        "description": "Wrapper for the unexposed kbd_getTextFromCmd API function. See CF_EnumerateActions for common section IDs.\n",
        "body": "CF_GetCommandText(${1:int section},${2:int command})$0"
    },
    "REAPER.CF_GETCOMMANDTEXT lua": {
        "prefix": "reaper.CF_GetCommandText",
        "scope": "lua",
        "description": "Wrapper for the unexposed kbd_getTextFromCmd API function. See CF_EnumerateActions for common section IDs.\n",
        "body": "reaper.CF_GetCommandText(${1:integer section},${2:integer command})$0"
    },
    "CF_GETCOMMANDTEXT python": {
        "prefix": "CF_GetCommandText",
        "scope": "python",
        "description": "Wrapper for the unexposed kbd_getTextFromCmd API function. See CF_EnumerateActions for common section IDs.\n",
        "body": "CF_GetCommandText(${1:Int section},${2:Int command})$0"
    },
    "CF_GETFOCUSEDFXCHAIN c": {
        "prefix": "CF_GetFocusedFXChain",
        "scope": "c",
        "description": "Return a handle to the currently focused FX chain window.\n",
        "body": "CF_GetFocusedFXChain()$0"
    },
    "REAPER.CF_GETFOCUSEDFXCHAIN lua": {
        "prefix": "reaper.CF_GetFocusedFXChain",
        "scope": "lua",
        "description": "Return a handle to the currently focused FX chain window.\n",
        "body": "reaper.CF_GetFocusedFXChain()$0"
    },
    "CF_GETFOCUSEDFXCHAIN python": {
        "prefix": "CF_GetFocusedFXChain",
        "scope": "python",
        "description": "Return a handle to the currently focused FX chain window.\n",
        "body": "CF_GetFocusedFXChain()$0"
    },
    "CF_GETMEDIASOURCEBITDEPTH c": {
        "prefix": "CF_GetMediaSourceBitDepth",
        "scope": "c",
        "description": "Returns the bit depth if available (0 otherwise).\n",
        "body": "CF_GetMediaSourceBitDepth(${1:PCM_source* src})$0"
    },
    "REAPER.CF_GETMEDIASOURCEBITDEPTH lua": {
        "prefix": "reaper.CF_GetMediaSourceBitDepth",
        "scope": "lua",
        "description": "Returns the bit depth if available (0 otherwise).\n",
        "body": "reaper.CF_GetMediaSourceBitDepth(${1:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCEBITDEPTH python": {
        "prefix": "CF_GetMediaSourceBitDepth",
        "scope": "python",
        "description": "Returns the bit depth if available (0 otherwise).\n",
        "body": "CF_GetMediaSourceBitDepth(${1:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCEMETADATA c": {
        "prefix": "CF_GetMediaSourceMetadata",
        "scope": "c",
        "description": "Get the value of the given metadata field (eg. DESC, ORIG, ORIGREF, DATE, TIME, UMI, CODINGHISTORY for BWF).\n",
        "body": "CF_GetMediaSourceMetadata(${1:PCM_source* src},${2:const char* name},${3:char* out},${4:int out_sz})$0"
    },
    "REAPER.CF_GETMEDIASOURCEMETADATA lua": {
        "prefix": "reaper.CF_GetMediaSourceMetadata",
        "scope": "lua",
        "description": "Get the value of the given metadata field (eg. DESC, ORIG, ORIGREF, DATE, TIME, UMI, CODINGHISTORY for BWF).\n",
        "body": "reaper.CF_GetMediaSourceMetadata(${1:PCM_source src},${2:string name},${3:string out})$0"
    },
    "CF_GETMEDIASOURCEMETADATA python": {
        "prefix": "CF_GetMediaSourceMetadata",
        "scope": "python",
        "description": "Get the value of the given metadata field (eg. DESC, ORIG, ORIGREF, DATE, TIME, UMI, CODINGHISTORY for BWF).\n",
        "body": "CF_GetMediaSourceMetadata(${1:src},${2:name},${3:out},${4:out_sz})$0"
    },
    "CF_GETMEDIASOURCEONLINE c": {
        "prefix": "CF_GetMediaSourceOnline",
        "scope": "c",
        "description": "Returns the online/offline status of the given source.\n",
        "body": "CF_GetMediaSourceOnline(${1:PCM_source* src})$0"
    },
    "REAPER.CF_GETMEDIASOURCEONLINE lua": {
        "prefix": "reaper.CF_GetMediaSourceOnline",
        "scope": "lua",
        "description": "Returns the online/offline status of the given source.\n",
        "body": "reaper.CF_GetMediaSourceOnline(${1:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCEONLINE python": {
        "prefix": "CF_GetMediaSourceOnline",
        "scope": "python",
        "description": "Returns the online/offline status of the given source.\n",
        "body": "CF_GetMediaSourceOnline(${1:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCERPP c": {
        "prefix": "CF_GetMediaSourceRPP",
        "scope": "c",
        "description": "Get the project associated with this source (BWF, subproject...).\n",
        "body": "CF_GetMediaSourceRPP(${1:PCM_source* src},${2:char* fn},${3:int fn_sz})$0"
    },
    "REAPER.CF_GETMEDIASOURCERPP lua": {
        "prefix": "reaper.CF_GetMediaSourceRPP",
        "scope": "lua",
        "description": "Get the project associated with this source (BWF, subproject...).\n",
        "body": "reaper.CF_GetMediaSourceRPP(${1:PCM_source src},${2:string fn})$0"
    },
    "CF_GETMEDIASOURCERPP python": {
        "prefix": "CF_GetMediaSourceRPP",
        "scope": "python",
        "description": "Get the project associated with this source (BWF, subproject...).\n",
        "body": "CF_GetMediaSourceRPP(${1:src},${2:fn},${3:fn_sz})$0"
    },
    "CF_GETSWSVERSION c": {
        "prefix": "CF_GetSWSVersion",
        "scope": "c",
        "description": "Return the current SWS version number.\n",
        "body": "CF_GetSWSVersion(${1:char* buf},${2:int buf_sz})$0"
    },
    "REAPER.CF_GETSWSVERSION lua": {
        "prefix": "reaper.CF_GetSWSVersion",
        "scope": "lua",
        "description": "Return the current SWS version number.\n",
        "body": "reaper.CF_GetSWSVersion(${1:string buf})$0"
    },
    "CF_GETSWSVERSION python": {
        "prefix": "CF_GetSWSVersion",
        "scope": "python",
        "description": "Return the current SWS version number.\n",
        "body": "CF_GetSWSVersion(${1:buf},${2:buf_sz})$0"
    },
    "CF_GETTAKEFXCHAIN c": {
        "prefix": "CF_GetTakeFXChain",
        "scope": "c",
        "description": "Return a handle to the given take FX chain window. HACK: This\ntemporarily renames the take in order to disambiguate the take FX chain\nwindow from similarily named takes.\n",
        "body": "CF_GetTakeFXChain(${1:MediaItem_Take* take})$0"
    },
    "REAPER.CF_GETTAKEFXCHAIN lua": {
        "prefix": "reaper.CF_GetTakeFXChain",
        "scope": "lua",
        "description": "Return a handle to the given take FX chain window. HACK: This\ntemporarily renames the take in order to disambiguate the take FX chain\nwindow from similarily named takes.\n",
        "body": "reaper.CF_GetTakeFXChain(${1:MediaItem_Take take})$0"
    },
    "CF_GETTAKEFXCHAIN python": {
        "prefix": "CF_GetTakeFXChain",
        "scope": "python",
        "description": "Return a handle to the given take FX chain window. HACK: This\ntemporarily renames the take in order to disambiguate the take FX chain\nwindow from similarily named takes.\n",
        "body": "CF_GetTakeFXChain(${1:MediaItem_Take take})$0"
    },
    "CF_GETTRACKFXCHAIN c": {
        "prefix": "CF_GetTrackFXChain",
        "scope": "c",
        "description": "Return a handle to the given track FX chain window.\n",
        "body": "CF_GetTrackFXChain(${1:MediaTrack* track})$0"
    },
    "REAPER.CF_GETTRACKFXCHAIN lua": {
        "prefix": "reaper.CF_GetTrackFXChain",
        "scope": "lua",
        "description": "Return a handle to the given track FX chain window.\n",
        "body": "reaper.CF_GetTrackFXChain(${1:MediaTrack track})$0"
    },
    "CF_GETTRACKFXCHAIN python": {
        "prefix": "CF_GetTrackFXChain",
        "scope": "python",
        "description": "Return a handle to the given track FX chain window.\n",
        "body": "CF_GetTrackFXChain(${1:MediaTrack track})$0"
    },
    "CF_LOCATEINEXPLORER c": {
        "prefix": "CF_LocateInExplorer",
        "scope": "c",
        "description": "Select the given file in explorer/finder.\n",
        "body": "CF_LocateInExplorer(${1:const char* file})$0"
    },
    "REAPER.CF_LOCATEINEXPLORER lua": {
        "prefix": "reaper.CF_LocateInExplorer",
        "scope": "lua",
        "description": "Select the given file in explorer/finder.\n",
        "body": "reaper.CF_LocateInExplorer(${1:string file})$0"
    },
    "CF_LOCATEINEXPLORER python": {
        "prefix": "CF_LocateInExplorer",
        "scope": "python",
        "description": "Select the given file in explorer/finder.\n",
        "body": "CF_LocateInExplorer(${1:String file})$0"
    },
    "CF_SETCLIPBOARD c": {
        "prefix": "CF_SetClipboard",
        "scope": "c",
        "description": "Write the given string into the system clipboard.\n",
        "body": "CF_SetClipboard(${1:const char* str})$0"
    },
    "REAPER.CF_SETCLIPBOARD lua": {
        "prefix": "reaper.CF_SetClipboard",
        "scope": "lua",
        "description": "Write the given string into the system clipboard.\n",
        "body": "reaper.CF_SetClipboard(${1:string str})$0"
    },
    "CF_SETCLIPBOARD python": {
        "prefix": "CF_SetClipboard",
        "scope": "python",
        "description": "Write the given string into the system clipboard.\n",
        "body": "CF_SetClipboard(${1:String str})$0"
    },
    "CF_SETMEDIASOURCEONLINE c": {
        "prefix": "CF_SetMediaSourceOnline",
        "scope": "c",
        "description": "Set the online/offline status of the given source (closes files when set=false).\n",
        "body": "CF_SetMediaSourceOnline(${1:PCM_source* src},${2:bool set})$0"
    },
    "REAPER.CF_SETMEDIASOURCEONLINE lua": {
        "prefix": "reaper.CF_SetMediaSourceOnline",
        "scope": "lua",
        "description": "Set the online/offline status of the given source (closes files when set=false).\n",
        "body": "reaper.CF_SetMediaSourceOnline(${1:PCM_source src},${2:boolean set})$0"
    },
    "CF_SETMEDIASOURCEONLINE python": {
        "prefix": "CF_SetMediaSourceOnline",
        "scope": "python",
        "description": "Set the online/offline status of the given source (closes files when set=false).\n",
        "body": "CF_SetMediaSourceOnline(${1:PCM_source src},${2:Boolean set})$0"
    },
    "CF_SHELLEXECUTE c": {
        "prefix": "CF_ShellExecute",
        "scope": "c",
        "description": "Open the given file or URL in the default application. See also CF_LocateInExplorer.\n",
        "body": "CF_ShellExecute(${1:const char* file})$0"
    },
    "REAPER.CF_SHELLEXECUTE lua": {
        "prefix": "reaper.CF_ShellExecute",
        "scope": "lua",
        "description": "Open the given file or URL in the default application. See also CF_LocateInExplorer.\n",
        "body": "reaper.CF_ShellExecute(${1:string file})$0"
    },
    "CF_SHELLEXECUTE python": {
        "prefix": "CF_ShellExecute",
        "scope": "python",
        "description": "Open the given file or URL in the default application. See also CF_LocateInExplorer.\n",
        "body": "CF_ShellExecute(${1:String file})$0"
    },
    "FNG_ADDMIDINOTE c": {
        "prefix": "FNG_AddMidiNote",
        "scope": "c",
        "description": "[FNG] Add MIDI note to MIDI take\n",
        "body": "FNG_AddMidiNote(${1:RprMidiTake* midiTake})$0"
    },
    "REAPER.FNG_ADDMIDINOTE lua": {
        "prefix": "reaper.FNG_AddMidiNote",
        "scope": "lua",
        "description": "[FNG] Add MIDI note to MIDI take\n",
        "body": "reaper.FNG_AddMidiNote(${1:RprMidiTake midiTake})$0"
    },
    "FNG_ADDMIDINOTE python": {
        "prefix": "FNG_AddMidiNote",
        "scope": "python",
        "description": "[FNG] Add MIDI note to MIDI take\n",
        "body": "FNG_AddMidiNote(${1:RprMidiTake midiTake})$0"
    },
    "FNG_ALLOCMIDITAKE c": {
        "prefix": "FNG_AllocMidiTake",
        "scope": "c",
        "description": "[FNG] Allocate a RprMidiTake from a take pointer. Returns a NULL pointer if the take is not an in-project MIDI take\n",
        "body": "FNG_AllocMidiTake(${1:MediaItem_Take* take})$0"
    },
    "REAPER.FNG_ALLOCMIDITAKE lua": {
        "prefix": "reaper.FNG_AllocMidiTake",
        "scope": "lua",
        "description": "[FNG] Allocate a RprMidiTake from a take pointer. Returns a NULL pointer if the take is not an in-project MIDI take\n",
        "body": "reaper.FNG_AllocMidiTake(${1:MediaItem_Take take})$0"
    },
    "FNG_ALLOCMIDITAKE python": {
        "prefix": "FNG_AllocMidiTake",
        "scope": "python",
        "description": "[FNG] Allocate a RprMidiTake from a take pointer. Returns a NULL pointer if the take is not an in-project MIDI take\n",
        "body": "FNG_AllocMidiTake(${1:MediaItem_Take take})$0"
    },
    "FNG_COUNTMIDINOTES c": {
        "prefix": "FNG_CountMidiNotes",
        "scope": "c",
        "description": "[FNG] Count of how many MIDI notes are in the MIDI take\n",
        "body": "FNG_CountMidiNotes(${1:RprMidiTake* midiTake})$0"
    },
    "REAPER.FNG_COUNTMIDINOTES lua": {
        "prefix": "reaper.FNG_CountMidiNotes",
        "scope": "lua",
        "description": "[FNG] Count of how many MIDI notes are in the MIDI take\n",
        "body": "reaper.FNG_CountMidiNotes(${1:RprMidiTake midiTake})$0"
    },
    "FNG_COUNTMIDINOTES python": {
        "prefix": "FNG_CountMidiNotes",
        "scope": "python",
        "description": "[FNG] Count of how many MIDI notes are in the MIDI take\n",
        "body": "FNG_CountMidiNotes(${1:RprMidiTake midiTake})$0"
    },
    "FNG_FREEMIDITAKE c": {
        "prefix": "FNG_FreeMidiTake",
        "scope": "c",
        "description": "[FNG] Commit changes to MIDI take and free allocated memory\n",
        "body": "FNG_FreeMidiTake(${1:RprMidiTake* midiTake})$0"
    },
    "REAPER.FNG_FREEMIDITAKE lua": {
        "prefix": "reaper.FNG_FreeMidiTake",
        "scope": "lua",
        "description": "[FNG] Commit changes to MIDI take and free allocated memory\n",
        "body": "reaper.FNG_FreeMidiTake(${1:RprMidiTake midiTake})$0"
    },
    "FNG_FREEMIDITAKE python": {
        "prefix": "FNG_FreeMidiTake",
        "scope": "python",
        "description": "[FNG] Commit changes to MIDI take and free allocated memory\n",
        "body": "FNG_FreeMidiTake(${1:RprMidiTake midiTake})$0"
    },
    "FNG_GETMIDINOTE c": {
        "prefix": "FNG_GetMidiNote",
        "scope": "c",
        "description": "[FNG] Get a MIDI note from a MIDI take at specified index\n",
        "body": "FNG_GetMidiNote(${1:RprMidiTake* midiTake},${2:int index})$0"
    },
    "REAPER.FNG_GETMIDINOTE lua": {
        "prefix": "reaper.FNG_GetMidiNote",
        "scope": "lua",
        "description": "[FNG] Get a MIDI note from a MIDI take at specified index\n",
        "body": "reaper.FNG_GetMidiNote(${1:RprMidiTake midiTake},${2:integer index})$0"
    },
    "FNG_GETMIDINOTE python": {
        "prefix": "FNG_GetMidiNote",
        "scope": "python",
        "description": "[FNG] Get a MIDI note from a MIDI take at specified index\n",
        "body": "FNG_GetMidiNote(${1:RprMidiTake midiTake},${2:Int index})$0"
    },
    "FNG_GETMIDINOTEINTPROPERTY c": {
        "prefix": "FNG_GetMidiNoteIntProperty",
        "scope": "c",
        "description": "[FNG] Get MIDI note property\n",
        "body": "FNG_GetMidiNoteIntProperty(${1:RprMidiNote* midiNote},${2:const char* property})$0"
    },
    "REAPER.FNG_GETMIDINOTEINTPROPERTY lua": {
        "prefix": "reaper.FNG_GetMidiNoteIntProperty",
        "scope": "lua",
        "description": "[FNG] Get MIDI note property\n",
        "body": "reaper.FNG_GetMidiNoteIntProperty(${1:RprMidiNote midiNote},${2:string property})$0"
    },
    "FNG_GETMIDINOTEINTPROPERTY python": {
        "prefix": "FNG_GetMidiNoteIntProperty",
        "scope": "python",
        "description": "[FNG] Get MIDI note property\n",
        "body": "FNG_GetMidiNoteIntProperty(${1:RprMidiNote midiNote},${2:String property})$0"
    },
    "FNG_SETMIDINOTEINTPROPERTY c": {
        "prefix": "FNG_SetMidiNoteIntProperty",
        "scope": "c",
        "description": "[FNG] Set MIDI note property\n",
        "body": "FNG_SetMidiNoteIntProperty(${1:RprMidiNote* midiNote},${2:const char* property},${3:int value})$0"
    },
    "REAPER.FNG_SETMIDINOTEINTPROPERTY lua": {
        "prefix": "reaper.FNG_SetMidiNoteIntProperty",
        "scope": "lua",
        "description": "[FNG] Set MIDI note property\n",
        "body": "reaper.FNG_SetMidiNoteIntProperty(${1:RprMidiNote midiNote},${2:string property},${3:integer value})$0"
    },
    "FNG_SETMIDINOTEINTPROPERTY python": {
        "prefix": "FNG_SetMidiNoteIntProperty",
        "scope": "python",
        "description": "[FNG] Set MIDI note property\n",
        "body": "FNG_SetMidiNoteIntProperty(${1:RprMidiNote midiNote},${2:String property},${3:Int value})$0"
    },
    "JS_BYTE c": {
        "prefix": "JS_Byte",
        "scope": "c",
        "description": "Returns the unsigned byte at address[offset]. Offset is added as steps of 1 byte each.\n",
        "body": "JS_Byte(${1:void* pointer},${2:int offset},${3:int* byteOut})$0"
    },
    "REAPER.JS_BYTE lua": {
        "prefix": "reaper.JS_Byte",
        "scope": "lua",
        "description": "Returns the unsigned byte at address[offset]. Offset is added as steps of 1 byte each.\n",
        "body": "reaper.JS_Byte(${1:identifier pointer},${2:integer offset})$0"
    },
    "JS_BYTE python": {
        "prefix": "JS_Byte",
        "scope": "python",
        "description": "Returns the unsigned byte at address[offset]. Offset is added as steps of 1 byte each.\n",
        "body": "JS_Byte(${1:pointer},${2:offset},${3:byteOut})$0"
    },
    "JS_COMPOSITE c": {
        "prefix": "JS_Composite",
        "scope": "c",
        "description": "Composites a LICE bitmap with a REAPER window.  Each time that the\nwindow is re-drawn, the bitmap will be blitted over the window's client\narea (with per-pixel alpha blending).\n* If dstw or dsth is -1, the bitmap will be stretched to fill the width or height of the window, respectively.\n* autoUpdate is an optional parameter that is false by default. If\ntrue, JS_Composite will automatically invalidate and re-draw the part of\nthe window that covers the current position of the bitmap, and if the\nbitmap is being moved, also the previous position. (If only one or a\nhandful of bitmaps are being moved across the screen, autoUpdate should\nresult in smoother animation on WindowsOS; if numerous bitmaps are\nspread over the entire window, it may be faster to disable autoUpdate\nand instead call JS_Window_InvalidateRect explicitly once all bitmaps\nhave been moved.)\n* InvalidateRect should also be called whenever the contents of the\nbitmap contents have been changed, but not the position, to trigger a\nwindow update.\n* On WindowsOS, the key to reducing flickering is to slow down the\nfrequency at which the window is re-drawn. InvalidateRect should only be\ncalled when absolutely necessary, preferably not more than 10 times per\nsecond.  (Also refer to the JS_Composite_Delay function.)\n* On WindowsOS, flickering can further be reduced by keeping the\ninvalidated area as small as possible, covering only the bitmaps that\nhave been edited or moved.  However, if numerous bitmaps are spread over\nthe entire window, it may be faster to simply invalidate the entire\nclient area.\n* This function should not be applied directly to top-level windows, but rather to child windows.\n* Some classes of UI elements, particularly buttons, do not take kindly to being composited, and may crash REAPER.\n* On WindowsOS, GDI blitting does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\nReturns:\n1 if successful, otherwise -1 = windowHWND is not a window, -3 = Could\nnot obtain the original window process, -4 = sysBitmap is not a LICE\nbitmap, -5 = sysBitmap is not a system bitmap, -6 = Could not obtain the\nwindow HDC.\n",
        "body": "JS_Composite(${1:void* windowHWND},${2:int srcx},${3:int srcy},${4:int srcw},${5:int srch},${6:void* sysBitmap},${7:int dstx},${8:int dsty},${9:int dstw},${10:int dsth},${11:bool* autoUpdateOptional})$0"
    },
    "REAPER.JS_COMPOSITE lua": {
        "prefix": "reaper.JS_Composite",
        "scope": "lua",
        "description": "Composites a LICE bitmap with a REAPER window.  Each time that the\nwindow is re-drawn, the bitmap will be blitted over the window's client\narea (with per-pixel alpha blending).\n* If dstw or dsth is -1, the bitmap will be stretched to fill the width or height of the window, respectively.\n* autoUpdate is an optional parameter that is false by default. If\ntrue, JS_Composite will automatically invalidate and re-draw the part of\nthe window that covers the current position of the bitmap, and if the\nbitmap is being moved, also the previous position. (If only one or a\nhandful of bitmaps are being moved across the screen, autoUpdate should\nresult in smoother animation on WindowsOS; if numerous bitmaps are\nspread over the entire window, it may be faster to disable autoUpdate\nand instead call JS_Window_InvalidateRect explicitly once all bitmaps\nhave been moved.)\n* InvalidateRect should also be called whenever the contents of the\nbitmap contents have been changed, but not the position, to trigger a\nwindow update.\n* On WindowsOS, the key to reducing flickering is to slow down the\nfrequency at which the window is re-drawn. InvalidateRect should only be\ncalled when absolutely necessary, preferably not more than 10 times per\nsecond.  (Also refer to the JS_Composite_Delay function.)\n* On WindowsOS, flickering can further be reduced by keeping the\ninvalidated area as small as possible, covering only the bitmaps that\nhave been edited or moved.  However, if numerous bitmaps are spread over\nthe entire window, it may be faster to simply invalidate the entire\nclient area.\n* This function should not be applied directly to top-level windows, but rather to child windows.\n* Some classes of UI elements, particularly buttons, do not take kindly to being composited, and may crash REAPER.\n* On WindowsOS, GDI blitting does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\nReturns:\n1 if successful, otherwise -1 = windowHWND is not a window, -3 = Could\nnot obtain the original window process, -4 = sysBitmap is not a LICE\nbitmap, -5 = sysBitmap is not a system bitmap, -6 = Could not obtain the\nwindow HDC.\n",
        "body": "reaper.JS_Composite(${1:identifier windowHWND},${2:integer srcx},${3:integer srcy},${4:integer srcw},${5:integer srch},${6:identifier sysBitmap},${7:integer dstx},${8:integer dsty},${9:integer dstw},${10:integer dsth},${11:unsupported autoUpdate})$0"
    },
    "JS_COMPOSITE python": {
        "prefix": "JS_Composite",
        "scope": "python",
        "description": "Composites a LICE bitmap with a REAPER window.  Each time that the\nwindow is re-drawn, the bitmap will be blitted over the window's client\narea (with per-pixel alpha blending).\n* If dstw or dsth is -1, the bitmap will be stretched to fill the width or height of the window, respectively.\n* autoUpdate is an optional parameter that is false by default. If\ntrue, JS_Composite will automatically invalidate and re-draw the part of\nthe window that covers the current position of the bitmap, and if the\nbitmap is being moved, also the previous position. (If only one or a\nhandful of bitmaps are being moved across the screen, autoUpdate should\nresult in smoother animation on WindowsOS; if numerous bitmaps are\nspread over the entire window, it may be faster to disable autoUpdate\nand instead call JS_Window_InvalidateRect explicitly once all bitmaps\nhave been moved.)\n* InvalidateRect should also be called whenever the contents of the\nbitmap contents have been changed, but not the position, to trigger a\nwindow update.\n* On WindowsOS, the key to reducing flickering is to slow down the\nfrequency at which the window is re-drawn. InvalidateRect should only be\ncalled when absolutely necessary, preferably not more than 10 times per\nsecond.  (Also refer to the JS_Composite_Delay function.)\n* On WindowsOS, flickering can further be reduced by keeping the\ninvalidated area as small as possible, covering only the bitmaps that\nhave been edited or moved.  However, if numerous bitmaps are spread over\nthe entire window, it may be faster to simply invalidate the entire\nclient area.\n* This function should not be applied directly to top-level windows, but rather to child windows.\n* Some classes of UI elements, particularly buttons, do not take kindly to being composited, and may crash REAPER.\n* On WindowsOS, GDI blitting does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\nReturns:\n1 if successful, otherwise -1 = windowHWND is not a window, -3 = Could\nnot obtain the original window process, -4 = sysBitmap is not a LICE\nbitmap, -5 = sysBitmap is not a system bitmap, -6 = Could not obtain the\nwindow HDC.\n",
        "body": "JS_Composite(${1:windowHWND},${2:srcx},${3:srcy},${4:srcw},${5:srch},${6:sysBitmap},${7:dstx},${8:dsty},${9:dstw},${10:dsth},${11:autoUpdateOptional})$0"
    },
    "JS_COMPOSITE_DELAY c": {
        "prefix": "JS_Composite_Delay",
        "scope": "c",
        "description": "On WindowsOS, flickering of composited images can be improved\nconsiderably by slowing the refresh rate of the window.  The optimal\nrefresh rate may depend on the number of composited bitmaps.\nminTime is the minimum refresh delay, in seconds, when only one bitmap\nis composited onto the window.  The delay time will increase linearly\nwith the number of bitmaps, up to a maximum of maxTime when\nnumBitmapsWhenMax is reached.\nReturns:\n* retval = 1 if successful, 0 if arguments are invalid (i.e. if maxTime < minTime, or maxBitmaps < 1).\n* If delay times have not previously been set for this window, prev values are -1.\n",
        "body": "JS_Composite_Delay(${1:void* windowHWND},${2:double minTime},${3:double maxTime},${4:int numBitmapsWhenMax},${5:double* prevMinTimeOut},${6:double* prevMaxTimeOut},${7:int* prevBitmapsOut})$0"
    },
    "REAPER.JS_COMPOSITE_DELAY lua": {
        "prefix": "reaper.JS_Composite_Delay",
        "scope": "lua",
        "description": "On WindowsOS, flickering of composited images can be improved\nconsiderably by slowing the refresh rate of the window.  The optimal\nrefresh rate may depend on the number of composited bitmaps.\nminTime is the minimum refresh delay, in seconds, when only one bitmap\nis composited onto the window.  The delay time will increase linearly\nwith the number of bitmaps, up to a maximum of maxTime when\nnumBitmapsWhenMax is reached.\nReturns:\n* retval = 1 if successful, 0 if arguments are invalid (i.e. if maxTime < minTime, or maxBitmaps < 1).\n* If delay times have not previously been set for this window, prev values are -1.\n",
        "body": "reaper.JS_Composite_Delay(${1:identifier windowHWND},${2:number minTime},${3:number maxTime},${4:integer numBitmapsWhenMax})$0"
    },
    "JS_COMPOSITE_DELAY python": {
        "prefix": "JS_Composite_Delay",
        "scope": "python",
        "description": "On WindowsOS, flickering of composited images can be improved\nconsiderably by slowing the refresh rate of the window.  The optimal\nrefresh rate may depend on the number of composited bitmaps.\nminTime is the minimum refresh delay, in seconds, when only one bitmap\nis composited onto the window.  The delay time will increase linearly\nwith the number of bitmaps, up to a maximum of maxTime when\nnumBitmapsWhenMax is reached.\nReturns:\n* retval = 1 if successful, 0 if arguments are invalid (i.e. if maxTime < minTime, or maxBitmaps < 1).\n* If delay times have not previously been set for this window, prev values are -1.\n",
        "body": "JS_Composite_Delay(${1:windowHWND},${2:minTime},${3:maxTime},${4:numBitmapsWhenMax},${5:prevMinTimeOut},${6:prevMaxTimeOut},${7:prevBitmapsOut})$0"
    },
    "JS_COMPOSITE_LISTBITMAPS c": {
        "prefix": "JS_Composite_ListBitmaps",
        "scope": "c",
        "description": "Returns all bitmaps composited to the given window.\nThe list is formatted as a comma-separated string of hexadecimal values, each representing a LICE_IBitmap* pointer.\nretval is the number of linked bitmaps found, or negative if an error occured.\n",
        "body": "JS_Composite_ListBitmaps(${1:void* windowHWND},${2:char* listOutNeedBig},${3:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_COMPOSITE_LISTBITMAPS lua": {
        "prefix": "reaper.JS_Composite_ListBitmaps",
        "scope": "lua",
        "description": "Returns all bitmaps composited to the given window.\nThe list is formatted as a comma-separated string of hexadecimal values, each representing a LICE_IBitmap* pointer.\nretval is the number of linked bitmaps found, or negative if an error occured.\n",
        "body": "reaper.JS_Composite_ListBitmaps(${1:identifier windowHWND})$0"
    },
    "JS_COMPOSITE_LISTBITMAPS python": {
        "prefix": "JS_Composite_ListBitmaps",
        "scope": "python",
        "description": "Returns all bitmaps composited to the given window.\nThe list is formatted as a comma-separated string of hexadecimal values, each representing a LICE_IBitmap* pointer.\nretval is the number of linked bitmaps found, or negative if an error occured.\n",
        "body": "JS_Composite_ListBitmaps(${1:windowHWND},${2:listOutNeedBig},${3:listOutNeedBig_sz})$0"
    },
    "JS_COMPOSITE_UNLINK c": {
        "prefix": "JS_Composite_Unlink",
        "scope": "c",
        "description": "Unlinks the window and bitmap.\n* autoUpdate is an optional parameter. If unlinking a single bitmap and\nautoUpdate is true, the function will automatically re-draw the window\nto remove the blitted image.\nIf no bitmap is specified, all bitmaps composited to the window will be unlinked -- even those by other scripts.\n",
        "body": "JS_Composite_Unlink(${1:void* windowHWND},${2:void* bitmapOptional},${3:bool* autoUpdateOptional})$0"
    },
    "REAPER.JS_COMPOSITE_UNLINK lua": {
        "prefix": "reaper.JS_Composite_Unlink",
        "scope": "lua",
        "description": "Unlinks the window and bitmap.\n* autoUpdate is an optional parameter. If unlinking a single bitmap and\nautoUpdate is true, the function will automatically re-draw the window\nto remove the blitted image.\nIf no bitmap is specified, all bitmaps composited to the window will be unlinked -- even those by other scripts.\n",
        "body": "reaper.JS_Composite_Unlink(${1:identifier windowHWND},${2:identifier bitmap},${3:unsupported autoUpdate})$0"
    },
    "JS_COMPOSITE_UNLINK python": {
        "prefix": "JS_Composite_Unlink",
        "scope": "python",
        "description": "Unlinks the window and bitmap.\n* autoUpdate is an optional parameter. If unlinking a single bitmap and\nautoUpdate is true, the function will automatically re-draw the window\nto remove the blitted image.\nIf no bitmap is specified, all bitmaps composited to the window will be unlinked -- even those by other scripts.\n",
        "body": "JS_Composite_Unlink(${1:windowHWND},${2:bitmapOptional},${3:autoUpdateOptional})$0"
    },
    "JS_DIALOG_BROWSEFORFOLDER c": {
        "prefix": "JS_Dialog_BrowseForFolder",
        "scope": "c",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, and -1 if an error occurred.\n",
        "body": "JS_Dialog_BrowseForFolder(${1:const char* caption},${2:const char* initialFolder},${3:char* folderOutNeedBig},${4:int folderOutNeedBig_sz})$0"
    },
    "REAPER.JS_DIALOG_BROWSEFORFOLDER lua": {
        "prefix": "reaper.JS_Dialog_BrowseForFolder",
        "scope": "lua",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, and -1 if an error occurred.\n",
        "body": "reaper.JS_Dialog_BrowseForFolder(${1:string caption},${2:string initialFolder})$0"
    },
    "JS_DIALOG_BROWSEFORFOLDER python": {
        "prefix": "JS_Dialog_BrowseForFolder",
        "scope": "python",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, and -1 if an error occurred.\n",
        "body": "JS_Dialog_BrowseForFolder(${1:caption},${2:initialFolder},${3:folderOutNeedBig},${4:folderOutNeedBig_sz})$0"
    },
    "JS_DIALOG_BROWSEFOROPENFILES c": {
        "prefix": "JS_Dialog_BrowseForOpenFiles",
        "scope": "c",
        "description": "If allowMultiple is true, multiple files may be selected. The returned\nstring is \\0-separated, with the first substring containing the folder\npath and subsequent substrings containing the file names.\n* On macOS, the first substring may be empty, and each file name will then contain its entire path.\n* This function only allows selection of existing files, and does not allow creation of new files.\nextensionList is a string containing pairs of \\0-terminated substrings.\nThe last substring must be terminated by two \\0 characters. Each pair\ndefines one filter pattern:\n* The first substring in each pair describes the filter in\nuser-readable form (for example, \"Lua script files (*.lua)\") and will be\ndisplayed in the dialog box.\n* The second substring specifies the filter that the operating system\nmust use to search for the files (for example, \"*.txt\"; the wildcard\nshould not be omitted). To specify multiple extensions for a single\ndisplay string, use a semicolon to separate the patterns (for example,\n\"*.lua;*.eel\").\nAn example of an extensionList string:\n\"ReaScript files\\0*.lua;*.eel\\0Lua files (.lua)\\0*.lua\\0EEL files (.eel)\\0*.eel\\0\\0\".\nOn macOS, file dialogs do not accept empty extensionLists, nor wildcard\nextensions (such as \"All files\\0*.*\\0\\0\"), so each acceptable extension\nmust be listed explicitly. On Linux and Windows, wildcard extensions are\nacceptable, and if the extensionList string is empty, the dialog will\ndisplay a default \"All files (*.*)\" filter.\nretval is 1 if one or more files were selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nDisplaying \\0-separated strings:\n* REAPER's IDE and ShowConsoleMsg only display strings up to the first\n\\0 byte. If multiple files were selected, only the first substring\ncontaining the path will be displayed. This is not a problem for Lua or\nEEL, which can access the full string beyond the first \\0 byte as usual.\n",
        "body": "JS_Dialog_BrowseForOpenFiles(${1:const char* windowTitle},${2:const char* initialFolder},${3:const char* initialFile},${4:const char* extensionList},${5:bool allowMultiple},${6:char* fileNamesOutNeedBig},${7:int fileNamesOutNeedBig_sz})$0"
    },
    "REAPER.JS_DIALOG_BROWSEFOROPENFILES lua": {
        "prefix": "reaper.JS_Dialog_BrowseForOpenFiles",
        "scope": "lua",
        "description": "If allowMultiple is true, multiple files may be selected. The returned\nstring is \\0-separated, with the first substring containing the folder\npath and subsequent substrings containing the file names.\n* On macOS, the first substring may be empty, and each file name will then contain its entire path.\n* This function only allows selection of existing files, and does not allow creation of new files.\nextensionList is a string containing pairs of \\0-terminated substrings.\nThe last substring must be terminated by two \\0 characters. Each pair\ndefines one filter pattern:\n* The first substring in each pair describes the filter in\nuser-readable form (for example, \"Lua script files (*.lua)\") and will be\ndisplayed in the dialog box.\n* The second substring specifies the filter that the operating system\nmust use to search for the files (for example, \"*.txt\"; the wildcard\nshould not be omitted). To specify multiple extensions for a single\ndisplay string, use a semicolon to separate the patterns (for example,\n\"*.lua;*.eel\").\nAn example of an extensionList string:\n\"ReaScript files\\0*.lua;*.eel\\0Lua files (.lua)\\0*.lua\\0EEL files (.eel)\\0*.eel\\0\\0\".\nOn macOS, file dialogs do not accept empty extensionLists, nor wildcard\nextensions (such as \"All files\\0*.*\\0\\0\"), so each acceptable extension\nmust be listed explicitly. On Linux and Windows, wildcard extensions are\nacceptable, and if the extensionList string is empty, the dialog will\ndisplay a default \"All files (*.*)\" filter.\nretval is 1 if one or more files were selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nDisplaying \\0-separated strings:\n* REAPER's IDE and ShowConsoleMsg only display strings up to the first\n\\0 byte. If multiple files were selected, only the first substring\ncontaining the path will be displayed. This is not a problem for Lua or\nEEL, which can access the full string beyond the first \\0 byte as usual.\n",
        "body": "reaper.JS_Dialog_BrowseForOpenFiles(${1:string windowTitle},${2:string initialFolder},${3:string initialFile},${4:string extensionList},${5:boolean allowMultiple})$0"
    },
    "JS_DIALOG_BROWSEFOROPENFILES python": {
        "prefix": "JS_Dialog_BrowseForOpenFiles",
        "scope": "python",
        "description": "If allowMultiple is true, multiple files may be selected. The returned\nstring is \\0-separated, with the first substring containing the folder\npath and subsequent substrings containing the file names.\n* On macOS, the first substring may be empty, and each file name will then contain its entire path.\n* This function only allows selection of existing files, and does not allow creation of new files.\nextensionList is a string containing pairs of \\0-terminated substrings.\nThe last substring must be terminated by two \\0 characters. Each pair\ndefines one filter pattern:\n* The first substring in each pair describes the filter in\nuser-readable form (for example, \"Lua script files (*.lua)\") and will be\ndisplayed in the dialog box.\n* The second substring specifies the filter that the operating system\nmust use to search for the files (for example, \"*.txt\"; the wildcard\nshould not be omitted). To specify multiple extensions for a single\ndisplay string, use a semicolon to separate the patterns (for example,\n\"*.lua;*.eel\").\nAn example of an extensionList string:\n\"ReaScript files\\0*.lua;*.eel\\0Lua files (.lua)\\0*.lua\\0EEL files (.eel)\\0*.eel\\0\\0\".\nOn macOS, file dialogs do not accept empty extensionLists, nor wildcard\nextensions (such as \"All files\\0*.*\\0\\0\"), so each acceptable extension\nmust be listed explicitly. On Linux and Windows, wildcard extensions are\nacceptable, and if the extensionList string is empty, the dialog will\ndisplay a default \"All files (*.*)\" filter.\nretval is 1 if one or more files were selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nDisplaying \\0-separated strings:\n* REAPER's IDE and ShowConsoleMsg only display strings up to the first\n\\0 byte. If multiple files were selected, only the first substring\ncontaining the path will be displayed. This is not a problem for Lua or\nEEL, which can access the full string beyond the first \\0 byte as usual.\n",
        "body": "JS_Dialog_BrowseForOpenFiles(${1:windowTitle},${2:initialFolder},${3:initialFile},${4:extensionList},${5:allowMultiple},${6:fileNamesOutNeedBig},${7:fileNamesOutNeedBig_sz})$0"
    },
    "JS_DIALOG_BROWSEFORSAVEFILE c": {
        "prefix": "JS_Dialog_BrowseForSaveFile",
        "scope": "c",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nextensionList is as described for JS_Dialog_BrowseForOpenFiles.\n",
        "body": "JS_Dialog_BrowseForSaveFile(${1:const char* windowTitle},${2:const char* initialFolder},${3:const char* initialFile},${4:const char* extensionList},${5:char* fileNameOutNeedBig},${6:int fileNameOutNeedBig_sz})$0"
    },
    "REAPER.JS_DIALOG_BROWSEFORSAVEFILE lua": {
        "prefix": "reaper.JS_Dialog_BrowseForSaveFile",
        "scope": "lua",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nextensionList is as described for JS_Dialog_BrowseForOpenFiles.\n",
        "body": "reaper.JS_Dialog_BrowseForSaveFile(${1:string windowTitle},${2:string initialFolder},${3:string initialFile},${4:string extensionList})$0"
    },
    "JS_DIALOG_BROWSEFORSAVEFILE python": {
        "prefix": "JS_Dialog_BrowseForSaveFile",
        "scope": "python",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nextensionList is as described for JS_Dialog_BrowseForOpenFiles.\n",
        "body": "JS_Dialog_BrowseForSaveFile(${1:windowTitle},${2:initialFolder},${3:initialFile},${4:extensionList},${5:fileNameOutNeedBig},${6:fileNameOutNeedBig_sz})$0"
    },
    "JS_DOUBLE c": {
        "prefix": "JS_Double",
        "scope": "c",
        "description": "Returns the 8-byte floating point value at address[offset]. Offset is added as steps of 8 bytes each.\n",
        "body": "JS_Double(${1:void* pointer},${2:int offset},${3:double* doubleOut})$0"
    },
    "REAPER.JS_DOUBLE lua": {
        "prefix": "reaper.JS_Double",
        "scope": "lua",
        "description": "Returns the 8-byte floating point value at address[offset]. Offset is added as steps of 8 bytes each.\n",
        "body": "reaper.JS_Double(${1:identifier pointer},${2:integer offset})$0"
    },
    "JS_DOUBLE python": {
        "prefix": "JS_Double",
        "scope": "python",
        "description": "Returns the 8-byte floating point value at address[offset]. Offset is added as steps of 8 bytes each.\n",
        "body": "JS_Double(${1:pointer},${2:offset},${3:doubleOut})$0"
    },
    "JS_GDI_BLIT c": {
        "prefix": "JS_GDI_Blit",
        "scope": "c",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmode: Optional parameter. \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "JS_GDI_Blit(${1:void* destHDC},${2:int dstx},${3:int dsty},${4:void* sourceHDC},${5:int srcx},${6:int srxy},${7:int width},${8:int height},${9:const char* modeOptional})$0"
    },
    "REAPER.JS_GDI_BLIT lua": {
        "prefix": "reaper.JS_GDI_Blit",
        "scope": "lua",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmode: Optional parameter. \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "reaper.JS_GDI_Blit(${1:identifier destHDC},${2:integer dstx},${3:integer dsty},${4:identifier sourceHDC},${5:integer srcx},${6:integer srxy},${7:integer width},${8:integer height},${9:optional string mode})$0"
    },
    "JS_GDI_BLIT python": {
        "prefix": "JS_GDI_Blit",
        "scope": "python",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmode: Optional parameter. \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "JS_GDI_Blit(${1:void destHDC},${2:Int dstx},${3:Int dsty},${4:void sourceHDC},${5:Int srcx},${6:Int srxy},${7:Int width},${8:Int height},${9:String modeOptional})$0"
    },
    "JS_GDI_CREATEFILLBRUSH c": {
        "prefix": "JS_GDI_CreateFillBrush",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_CreateFillBrush(${1:int color})$0"
    },
    "REAPER.JS_GDI_CREATEFILLBRUSH lua": {
        "prefix": "reaper.JS_GDI_CreateFillBrush",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_CreateFillBrush(${1:integer color})$0"
    },
    "JS_GDI_CREATEFILLBRUSH python": {
        "prefix": "JS_GDI_CreateFillBrush",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_CreateFillBrush(${1:Int color})$0"
    },
    "JS_GDI_CREATEFONT c": {
        "prefix": "JS_GDI_CreateFont",
        "scope": "c",
        "description": "Parameters:\n* weight: 0 - 1000, with 0 = auto, 400 = normal and 700 = bold.\n* angle: the angle, in tenths of degrees, between the text and the x-axis of the device.\n* fontName: If empty string \"\", uses first font that matches the other specified attributes.\nNote: Text color must be set separately.\n",
        "body": "JS_GDI_CreateFont(${1:int height},${2:int weight},${3:int angle},${4:bool italic},${5:bool underline},${6:bool strikeOut},${7:const char* fontName})$0"
    },
    "REAPER.JS_GDI_CREATEFONT lua": {
        "prefix": "reaper.JS_GDI_CreateFont",
        "scope": "lua",
        "description": "Parameters:\n* weight: 0 - 1000, with 0 = auto, 400 = normal and 700 = bold.\n* angle: the angle, in tenths of degrees, between the text and the x-axis of the device.\n* fontName: If empty string \"\", uses first font that matches the other specified attributes.\nNote: Text color must be set separately.\n",
        "body": "reaper.JS_GDI_CreateFont(${1:integer height},${2:integer weight},${3:integer angle},${4:boolean italic},${5:boolean underline},${6:boolean strike},${7:string fontName})$0"
    },
    "JS_GDI_CREATEFONT python": {
        "prefix": "JS_GDI_CreateFont",
        "scope": "python",
        "description": "Parameters:\n* weight: 0 - 1000, with 0 = auto, 400 = normal and 700 = bold.\n* angle: the angle, in tenths of degrees, between the text and the x-axis of the device.\n* fontName: If empty string \"\", uses first font that matches the other specified attributes.\nNote: Text color must be set separately.\n",
        "body": "JS_GDI_CreateFont(${1:Int height},${2:Int weight},${3:Int angle},${4:Boolean italic},${5:Boolean underline},${6:Boolean strikeOut},${7:String fontName})$0"
    },
    "JS_GDI_CREATEPEN c": {
        "prefix": "JS_GDI_CreatePen",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_CreatePen(${1:int width},${2:int color})$0"
    },
    "REAPER.JS_GDI_CREATEPEN lua": {
        "prefix": "reaper.JS_GDI_CreatePen",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_CreatePen(${1:integer width},${2:integer color})$0"
    },
    "JS_GDI_CREATEPEN python": {
        "prefix": "JS_GDI_CreatePen",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_CreatePen(${1:Int width},${2:Int color})$0"
    },
    "JS_GDI_DELETEOBJECT c": {
        "prefix": "JS_GDI_DeleteObject",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_DeleteObject(${1:void* GDIObject})$0"
    },
    "REAPER.JS_GDI_DELETEOBJECT lua": {
        "prefix": "reaper.JS_GDI_DeleteObject",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_DeleteObject(${1:identifier GDIObject})$0"
    },
    "JS_GDI_DELETEOBJECT python": {
        "prefix": "JS_GDI_DeleteObject",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_DeleteObject(${1:void GDIObject})$0"
    },
    "JS_GDI_DRAWTEXT c": {
        "prefix": "JS_GDI_DrawText",
        "scope": "c",
        "description": "Parameters:\n* align: Combination of: \"TOP\", \"VCENTER\", \"LEFT\", \"HCENTER\", \"RIGHT\",\n\"BOTTOM\", \"WORDBREAK\", \"SINGLELINE\", \"NOCLIP\", \"CALCRECT\", \"NOPREFIX\" or\n\"ELLIPSIS\"\n",
        "body": "JS_GDI_DrawText(${1:void* deviceHDC},${2:const char* text},${3:int len},${4:int left},${5:int top},${6:int right},${7:int bottom},${8:const char* align})$0"
    },
    "REAPER.JS_GDI_DRAWTEXT lua": {
        "prefix": "reaper.JS_GDI_DrawText",
        "scope": "lua",
        "description": "Parameters:\n* align: Combination of: \"TOP\", \"VCENTER\", \"LEFT\", \"HCENTER\", \"RIGHT\",\n\"BOTTOM\", \"WORDBREAK\", \"SINGLELINE\", \"NOCLIP\", \"CALCRECT\", \"NOPREFIX\" or\n\"ELLIPSIS\"\n",
        "body": "reaper.JS_GDI_DrawText(${1:identifier deviceHDC},${2:string text},${3:integer len},${4:integer left},${5:integer top},${6:integer right},${7:integer bottom},${8:string align})$0"
    },
    "JS_GDI_DRAWTEXT python": {
        "prefix": "JS_GDI_DrawText",
        "scope": "python",
        "description": "Parameters:\n* align: Combination of: \"TOP\", \"VCENTER\", \"LEFT\", \"HCENTER\", \"RIGHT\",\n\"BOTTOM\", \"WORDBREAK\", \"SINGLELINE\", \"NOCLIP\", \"CALCRECT\", \"NOPREFIX\" or\n\"ELLIPSIS\"\n",
        "body": "JS_GDI_DrawText(${1:void deviceHDC},${2:String text},${3:Int len},${4:Int left},${5:Int top},${6:Int right},${7:Int bottom},${8:String align})$0"
    },
    "JS_GDI_FILLELLIPSE c": {
        "prefix": "JS_GDI_FillEllipse",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_FillEllipse(${1:void* deviceHDC},${2:int left},${3:int top},${4:int right},${5:int bottom})$0"
    },
    "REAPER.JS_GDI_FILLELLIPSE lua": {
        "prefix": "reaper.JS_GDI_FillEllipse",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_FillEllipse(${1:identifier deviceHDC},${2:integer left},${3:integer top},${4:integer right},${5:integer bottom})$0"
    },
    "JS_GDI_FILLELLIPSE python": {
        "prefix": "JS_GDI_FillEllipse",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_FillEllipse(${1:void deviceHDC},${2:Int left},${3:Int top},${4:Int right},${5:Int bottom})$0"
    },
    "JS_GDI_FILLPOLYGON c": {
        "prefix": "JS_GDI_FillPolygon",
        "scope": "c",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "JS_GDI_FillPolygon(${1:void* deviceHDC},${2:const char* packedX},${3:const char* packedY},${4:int numPoints})$0"
    },
    "REAPER.JS_GDI_FILLPOLYGON lua": {
        "prefix": "reaper.JS_GDI_FillPolygon",
        "scope": "lua",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "reaper.JS_GDI_FillPolygon(${1:identifier deviceHDC},${2:string packedX},${3:string packedY},${4:integer numPoints})$0"
    },
    "JS_GDI_FILLPOLYGON python": {
        "prefix": "JS_GDI_FillPolygon",
        "scope": "python",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "JS_GDI_FillPolygon(${1:void deviceHDC},${2:String packedX},${3:String packedY},${4:Int numPoints})$0"
    },
    "JS_GDI_FILLRECT c": {
        "prefix": "JS_GDI_FillRect",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_FillRect(${1:void* deviceHDC},${2:int left},${3:int top},${4:int right},${5:int bottom})$0"
    },
    "REAPER.JS_GDI_FILLRECT lua": {
        "prefix": "reaper.JS_GDI_FillRect",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_FillRect(${1:identifier deviceHDC},${2:integer left},${3:integer top},${4:integer right},${5:integer bottom})$0"
    },
    "JS_GDI_FILLRECT python": {
        "prefix": "JS_GDI_FillRect",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_FillRect(${1:void deviceHDC},${2:Int left},${3:Int top},${4:Int right},${5:Int bottom})$0"
    },
    "JS_GDI_FILLROUNDRECT c": {
        "prefix": "JS_GDI_FillRoundRect",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_FillRoundRect(${1:void* deviceHDC},${2:int left},${3:int top},${4:int right},${5:int bottom},${6:int xrnd},${7:int yrnd})$0"
    },
    "REAPER.JS_GDI_FILLROUNDRECT lua": {
        "prefix": "reaper.JS_GDI_FillRoundRect",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_FillRoundRect(${1:identifier deviceHDC},${2:integer left},${3:integer top},${4:integer right},${5:integer bottom},${6:integer xrnd},${7:integer yrnd})$0"
    },
    "JS_GDI_FILLROUNDRECT python": {
        "prefix": "JS_GDI_FillRoundRect",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_FillRoundRect(${1:void deviceHDC},${2:Int left},${3:Int top},${4:Int right},${5:Int bottom},${6:Int xrnd},${7:Int yrnd})$0"
    },
    "JS_GDI_GETCLIENTDC c": {
        "prefix": "JS_GDI_GetClientDC",
        "scope": "c",
        "description": "Returns the device context for the client area of the specified window.\n",
        "body": "JS_GDI_GetClientDC(${1:void* windowHWND})$0"
    },
    "REAPER.JS_GDI_GETCLIENTDC lua": {
        "prefix": "reaper.JS_GDI_GetClientDC",
        "scope": "lua",
        "description": "Returns the device context for the client area of the specified window.\n",
        "body": "reaper.JS_GDI_GetClientDC(${1:identifier windowHWND})$0"
    },
    "JS_GDI_GETCLIENTDC python": {
        "prefix": "JS_GDI_GetClientDC",
        "scope": "python",
        "description": "Returns the device context for the client area of the specified window.\n",
        "body": "JS_GDI_GetClientDC(${1:void windowHWND})$0"
    },
    "JS_GDI_GETSCREENDC c": {
        "prefix": "JS_GDI_GetScreenDC",
        "scope": "c",
        "description": "Returns a device context for the entire screen.\nWARNING: Only available on Windows, not Linux or macOS.\n",
        "body": "JS_GDI_GetScreenDC()$0"
    },
    "REAPER.JS_GDI_GETSCREENDC lua": {
        "prefix": "reaper.JS_GDI_GetScreenDC",
        "scope": "lua",
        "description": "Returns a device context for the entire screen.\nWARNING: Only available on Windows, not Linux or macOS.\n",
        "body": "reaper.JS_GDI_GetScreenDC()$0"
    },
    "JS_GDI_GETSCREENDC python": {
        "prefix": "JS_GDI_GetScreenDC",
        "scope": "python",
        "description": "Returns a device context for the entire screen.\nWARNING: Only available on Windows, not Linux or macOS.\n",
        "body": "JS_GDI_GetScreenDC()$0"
    },
    "JS_GDI_GETSYSCOLOR c": {
        "prefix": "JS_GDI_GetSysColor",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_GetSysColor(${1:const char* GUIElement})$0"
    },
    "REAPER.JS_GDI_GETSYSCOLOR lua": {
        "prefix": "reaper.JS_GDI_GetSysColor",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_GetSysColor(${1:string GUIElement})$0"
    },
    "JS_GDI_GETSYSCOLOR python": {
        "prefix": "JS_GDI_GetSysColor",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_GetSysColor(${1:String GUIElement})$0"
    },
    "JS_GDI_GETTEXTCOLOR c": {
        "prefix": "JS_GDI_GetTextColor",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_GetTextColor(${1:void* deviceHDC})$0"
    },
    "REAPER.JS_GDI_GETTEXTCOLOR lua": {
        "prefix": "reaper.JS_GDI_GetTextColor",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_GetTextColor(${1:identifier deviceHDC})$0"
    },
    "JS_GDI_GETTEXTCOLOR python": {
        "prefix": "JS_GDI_GetTextColor",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_GetTextColor(${1:void deviceHDC})$0"
    },
    "JS_GDI_GETWINDOWDC c": {
        "prefix": "JS_GDI_GetWindowDC",
        "scope": "c",
        "description": "Returns the device context for the entire window, including title bar and frame.\n",
        "body": "JS_GDI_GetWindowDC(${1:void* windowHWND})$0"
    },
    "REAPER.JS_GDI_GETWINDOWDC lua": {
        "prefix": "reaper.JS_GDI_GetWindowDC",
        "scope": "lua",
        "description": "Returns the device context for the entire window, including title bar and frame.\n",
        "body": "reaper.JS_GDI_GetWindowDC(${1:identifier windowHWND})$0"
    },
    "JS_GDI_GETWINDOWDC python": {
        "prefix": "JS_GDI_GetWindowDC",
        "scope": "python",
        "description": "Returns the device context for the entire window, including title bar and frame.\n",
        "body": "JS_GDI_GetWindowDC(${1:void windowHWND})$0"
    },
    "JS_GDI_LINE c": {
        "prefix": "JS_GDI_Line",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_Line(${1:void* deviceHDC},${2:int x1},${3:int y1},${4:int x2},${5:int y2})$0"
    },
    "REAPER.JS_GDI_LINE lua": {
        "prefix": "reaper.JS_GDI_Line",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_Line(${1:identifier deviceHDC},${2:integer x1},${3:integer y1},${4:integer x2},${5:integer y2})$0"
    },
    "JS_GDI_LINE python": {
        "prefix": "JS_GDI_Line",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_Line(${1:void deviceHDC},${2:Int x1},${3:Int y1},${4:Int x2},${5:Int y2})$0"
    },
    "JS_GDI_POLYLINE c": {
        "prefix": "JS_GDI_Polyline",
        "scope": "c",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "JS_GDI_Polyline(${1:void* deviceHDC},${2:const char* packedX},${3:const char* packedY},${4:int numPoints})$0"
    },
    "REAPER.JS_GDI_POLYLINE lua": {
        "prefix": "reaper.JS_GDI_Polyline",
        "scope": "lua",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "reaper.JS_GDI_Polyline(${1:identifier deviceHDC},${2:string packedX},${3:string packedY},${4:integer numPoints})$0"
    },
    "JS_GDI_POLYLINE python": {
        "prefix": "JS_GDI_Polyline",
        "scope": "python",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "JS_GDI_Polyline(${1:void deviceHDC},${2:String packedX},${3:String packedY},${4:Int numPoints})$0"
    },
    "JS_GDI_RELEASEDC c": {
        "prefix": "JS_GDI_ReleaseDC",
        "scope": "c",
        "description": "To release a window HDC, both arguments must be supplied: the HWND as\nwell as the HDC.  To release a screen DC, only the HDC needs to be\nsupplied.\nFor compatibility with previous versions, the HWND and HDC can be supplied in any order.\nNOTE: Any GDI HDC should be released immediately after drawing, and\ndeferred scripts should get and release new DCs in each cycle.\n",
        "body": "JS_GDI_ReleaseDC(${1:void* deviceHDC},${2:void*  windowHWNDOptional})$0"
    },
    "REAPER.JS_GDI_RELEASEDC lua": {
        "prefix": "reaper.JS_GDI_ReleaseDC",
        "scope": "lua",
        "description": "To release a window HDC, both arguments must be supplied: the HWND as\nwell as the HDC.  To release a screen DC, only the HDC needs to be\nsupplied.\nFor compatibility with previous versions, the HWND and HDC can be supplied in any order.\nNOTE: Any GDI HDC should be released immediately after drawing, and\ndeferred scripts should get and release new DCs in each cycle.\n",
        "body": "reaper.JS_GDI_ReleaseDC(${1:identifier deviceHDC},${2:identifier  windowHWND})$0"
    },
    "JS_GDI_RELEASEDC python": {
        "prefix": "JS_GDI_ReleaseDC",
        "scope": "python",
        "description": "To release a window HDC, both arguments must be supplied: the HWND as\nwell as the HDC.  To release a screen DC, only the HDC needs to be\nsupplied.\nFor compatibility with previous versions, the HWND and HDC can be supplied in any order.\nNOTE: Any GDI HDC should be released immediately after drawing, and\ndeferred scripts should get and release new DCs in each cycle.\n",
        "body": "JS_GDI_ReleaseDC(${1:void deviceHDC},${2:void  windowHWNDOptional})$0"
    },
    "JS_GDI_SELECTOBJECT c": {
        "prefix": "JS_GDI_SelectObject",
        "scope": "c",
        "description": "Activates a font, pen, or fill brush for subsequent drawing in the specified device context.\n",
        "body": "JS_GDI_SelectObject(${1:void* deviceHDC},${2:void* GDIObject})$0"
    },
    "REAPER.JS_GDI_SELECTOBJECT lua": {
        "prefix": "reaper.JS_GDI_SelectObject",
        "scope": "lua",
        "description": "Activates a font, pen, or fill brush for subsequent drawing in the specified device context.\n",
        "body": "reaper.JS_GDI_SelectObject(${1:identifier deviceHDC},${2:identifier GDIObject})$0"
    },
    "JS_GDI_SELECTOBJECT python": {
        "prefix": "JS_GDI_SelectObject",
        "scope": "python",
        "description": "Activates a font, pen, or fill brush for subsequent drawing in the specified device context.\n",
        "body": "JS_GDI_SelectObject(${1:void deviceHDC},${2:void GDIObject})$0"
    },
    "JS_GDI_SETPIXEL c": {
        "prefix": "JS_GDI_SetPixel",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_SetPixel(${1:void* deviceHDC},${2:int x},${3:int y},${4:int color})$0"
    },
    "REAPER.JS_GDI_SETPIXEL lua": {
        "prefix": "reaper.JS_GDI_SetPixel",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_SetPixel(${1:identifier deviceHDC},${2:integer x},${3:integer y},${4:integer color})$0"
    },
    "JS_GDI_SETPIXEL python": {
        "prefix": "JS_GDI_SetPixel",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_SetPixel(${1:void deviceHDC},${2:Int x},${3:Int y},${4:Int color})$0"
    },
    "JS_GDI_SETTEXTBKCOLOR c": {
        "prefix": "JS_GDI_SetTextBkColor",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_SetTextBkColor(${1:void* deviceHDC},${2:int color})$0"
    },
    "REAPER.JS_GDI_SETTEXTBKCOLOR lua": {
        "prefix": "reaper.JS_GDI_SetTextBkColor",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_SetTextBkColor(${1:identifier deviceHDC},${2:integer color})$0"
    },
    "JS_GDI_SETTEXTBKCOLOR python": {
        "prefix": "JS_GDI_SetTextBkColor",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_SetTextBkColor(${1:void deviceHDC},${2:Int color})$0"
    },
    "JS_GDI_SETTEXTBKMODE c": {
        "prefix": "JS_GDI_SetTextBkMode",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_SetTextBkMode(${1:void* deviceHDC},${2:int mode})$0"
    },
    "REAPER.JS_GDI_SETTEXTBKMODE lua": {
        "prefix": "reaper.JS_GDI_SetTextBkMode",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_SetTextBkMode(${1:identifier deviceHDC},${2:integer mode})$0"
    },
    "JS_GDI_SETTEXTBKMODE python": {
        "prefix": "JS_GDI_SetTextBkMode",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_SetTextBkMode(${1:void deviceHDC},${2:Int mode})$0"
    },
    "JS_GDI_SETTEXTCOLOR c": {
        "prefix": "JS_GDI_SetTextColor",
        "scope": "c",
        "description": "\n",
        "body": "JS_GDI_SetTextColor(${1:void* deviceHDC},${2:int color})$0"
    },
    "REAPER.JS_GDI_SETTEXTCOLOR lua": {
        "prefix": "reaper.JS_GDI_SetTextColor",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_GDI_SetTextColor(${1:identifier deviceHDC},${2:integer color})$0"
    },
    "JS_GDI_SETTEXTCOLOR python": {
        "prefix": "JS_GDI_SetTextColor",
        "scope": "python",
        "description": "\n",
        "body": "JS_GDI_SetTextColor(${1:void deviceHDC},${2:Int color})$0"
    },
    "JS_GDI_STRETCHBLIT c": {
        "prefix": "JS_GDI_StretchBlit",
        "scope": "c",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmodeOptional: \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "JS_GDI_StretchBlit(${1:void* destHDC},${2:int dstx},${3:int dsty},${4:int dstw},${5:int dsth},${6:void* sourceHDC},${7:int srcx},${8:int srxy},${9:int srcw},${10:int srch},${11:const char* modeOptional})$0"
    },
    "REAPER.JS_GDI_STRETCHBLIT lua": {
        "prefix": "reaper.JS_GDI_StretchBlit",
        "scope": "lua",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmodeOptional: \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "reaper.JS_GDI_StretchBlit(${1:identifier destHDC},${2:integer dstx},${3:integer dsty},${4:integer dstw},${5:integer dsth},${6:identifier sourceHDC},${7:integer srcx},${8:integer srxy},${9:integer srcw},${10:integer srch},${11:optional string mode})$0"
    },
    "JS_GDI_STRETCHBLIT python": {
        "prefix": "JS_GDI_StretchBlit",
        "scope": "python",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmodeOptional: \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "JS_GDI_StretchBlit(${1:void destHDC},${2:Int dstx},${3:Int dsty},${4:Int dstw},${5:Int dsth},${6:void sourceHDC},${7:Int srcx},${8:Int srxy},${9:Int srcw},${10:Int srch},${11:String modeOptional})$0"
    },
    "JS_INT c": {
        "prefix": "JS_Int",
        "scope": "c",
        "description": "Returns the 4-byte signed integer at address[offset]. Offset is added as steps of 4 bytes each.\n",
        "body": "JS_Int(${1:void* pointer},${2:int offset},${3:int* intOut})$0"
    },
    "REAPER.JS_INT lua": {
        "prefix": "reaper.JS_Int",
        "scope": "lua",
        "description": "Returns the 4-byte signed integer at address[offset]. Offset is added as steps of 4 bytes each.\n",
        "body": "reaper.JS_Int(${1:identifier pointer},${2:integer offset})$0"
    },
    "JS_INT python": {
        "prefix": "JS_Int",
        "scope": "python",
        "description": "Returns the 4-byte signed integer at address[offset]. Offset is added as steps of 4 bytes each.\n",
        "body": "JS_Int(${1:pointer},${2:offset},${3:intOut})$0"
    },
    "JS_LICE_ALTERBITMAPHSV c": {
        "prefix": "JS_LICE_AlterBitmapHSV",
        "scope": "c",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "JS_LICE_AlterBitmapHSV(${1:void* bitmap},${2:double hue},${3:double saturation},${4:double value})$0"
    },
    "REAPER.JS_LICE_ALTERBITMAPHSV lua": {
        "prefix": "reaper.JS_LICE_AlterBitmapHSV",
        "scope": "lua",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "reaper.JS_LICE_AlterBitmapHSV(${1:identifier bitmap},${2:number hue},${3:number saturation},${4:number value})$0"
    },
    "JS_LICE_ALTERBITMAPHSV python": {
        "prefix": "JS_LICE_AlterBitmapHSV",
        "scope": "python",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "JS_LICE_AlterBitmapHSV(${1:void bitmap},${2:Float hue},${3:Float saturation},${4:Float value})$0"
    },
    "JS_LICE_ALTERRECTHSV c": {
        "prefix": "JS_LICE_AlterRectHSV",
        "scope": "c",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "JS_LICE_AlterRectHSV(${1:void* bitmap},${2:int x},${3:int y},${4:int w},${5:int h},${6:double hue},${7:double saturation},${8:double value})$0"
    },
    "REAPER.JS_LICE_ALTERRECTHSV lua": {
        "prefix": "reaper.JS_LICE_AlterRectHSV",
        "scope": "lua",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "reaper.JS_LICE_AlterRectHSV(${1:identifier bitmap},${2:integer x},${3:integer y},${4:integer w},${5:integer h},${6:number hue},${7:number saturation},${8:number value})$0"
    },
    "JS_LICE_ALTERRECTHSV python": {
        "prefix": "JS_LICE_AlterRectHSV",
        "scope": "python",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "JS_LICE_AlterRectHSV(${1:void bitmap},${2:Int x},${3:Int y},${4:Int w},${5:Int h},${6:Float hue},${7:Float saturation},${8:Float value})$0"
    },
    "JS_LICE_ARC c": {
        "prefix": "JS_LICE_Arc",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Arc(${1:void* bitmap},${2:double cx},${3:double cy},${4:double r},${5:double minAngle},${6:double maxAngle},${7:int color},${8:double alpha},${9:const char* mode},${10:bool antialias})$0"
    },
    "REAPER.JS_LICE_ARC lua": {
        "prefix": "reaper.JS_LICE_Arc",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_Arc(${1:identifier bitmap},${2:number cx},${3:number cy},${4:number r},${5:number minAngle},${6:number maxAngle},${7:integer color},${8:number alpha},${9:string mode},${10:boolean antialias})$0"
    },
    "JS_LICE_ARC python": {
        "prefix": "JS_LICE_Arc",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Arc(${1:void bitmap},${2:Float cx},${3:Float cy},${4:Float r},${5:Float minAngle},${6:Float maxAngle},${7:Int color},${8:Float alpha},${9:String mode},${10:Boolean antialias})$0"
    },
    "JS_LICE_ARRAYALLBITMAPS c": {
        "prefix": "JS_LICE_ArrayAllBitmaps",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_ArrayAllBitmaps(${1:void* reaperarray})$0"
    },
    "REAPER.JS_LICE_ARRAYALLBITMAPS lua": {
        "prefix": "reaper.JS_LICE_ArrayAllBitmaps",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_ArrayAllBitmaps(${1:identifier reaperarray})$0"
    },
    "JS_LICE_ARRAYALLBITMAPS python": {
        "prefix": "JS_LICE_ArrayAllBitmaps",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_ArrayAllBitmaps(${1:void reaperarray})$0"
    },
    "JS_LICE_BEZIER c": {
        "prefix": "JS_LICE_Bezier",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Bezier(${1:void* bitmap},${2:double xstart},${3:double ystart},${4:double xctl1},${5:double yctl1},${6:double xctl2},${7:double yctl2},${8:double xend},${9:double yend},${10:double tol},${11:int color},${12:double alpha},${13:const char* mode},${14:bool antialias})$0"
    },
    "REAPER.JS_LICE_BEZIER lua": {
        "prefix": "reaper.JS_LICE_Bezier",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_Bezier(${1:identifier bitmap},${2:number xstart},${3:number ystart},${4:number xctl1},${5:number yctl1},${6:number xctl2},${7:number yctl2},${8:number xend},${9:number yend},${10:number tol},${11:integer color},${12:number alpha},${13:string mode},${14:boolean antialias})$0"
    },
    "JS_LICE_BEZIER python": {
        "prefix": "JS_LICE_Bezier",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Bezier(${1:void bitmap},${2:Float xstart},${3:Float ystart},${4:Float xctl1},${5:Float yctl1},${6:Float xctl2},${7:Float yctl2},${8:Float xend},${9:Float yend},${10:Float tol},${11:Int color},${12:Float alpha},${13:String mode},${14:Boolean antialias})$0"
    },
    "JS_LICE_BLIT c": {
        "prefix": "JS_LICE_Blit",
        "scope": "c",
        "description": "Standard LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\",\n\"DODGE\", \"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with\n\"ALPHA\" to enable per-pixel alpha blending.\nIn addition to the standard LICE modes, LICE_Blit also offers:\n* \"CHANCOPY_XTOY\", with X and Y any of the four channels, A, R, G or B. (CHANCOPY_ATOA is similar to MASK mode.)\n* \"BLUR\"\n* \"ALPHAMUL\", which overwrites the destination with a per-pixel\nalpha-multiplied copy of the source. (Similar to first clearing the\ndestination with 0x00000000 and then blitting with \"COPY,ALPHA\".)\n",
        "body": "JS_LICE_Blit(${1:void* destBitmap},${2:int dstx},${3:int dsty},${4:void* sourceBitmap},${5:int srcx},${6:int srcy},${7:int width},${8:int height},${9:double alpha},${10:const char* mode})$0"
    },
    "REAPER.JS_LICE_BLIT lua": {
        "prefix": "reaper.JS_LICE_Blit",
        "scope": "lua",
        "description": "Standard LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\",\n\"DODGE\", \"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with\n\"ALPHA\" to enable per-pixel alpha blending.\nIn addition to the standard LICE modes, LICE_Blit also offers:\n* \"CHANCOPY_XTOY\", with X and Y any of the four channels, A, R, G or B. (CHANCOPY_ATOA is similar to MASK mode.)\n* \"BLUR\"\n* \"ALPHAMUL\", which overwrites the destination with a per-pixel\nalpha-multiplied copy of the source. (Similar to first clearing the\ndestination with 0x00000000 and then blitting with \"COPY,ALPHA\".)\n",
        "body": "reaper.JS_LICE_Blit(${1:identifier destBitmap},${2:integer dstx},${3:integer dsty},${4:identifier sourceBitmap},${5:integer srcx},${6:integer srcy},${7:integer width},${8:integer height},${9:number alpha},${10:string mode})$0"
    },
    "JS_LICE_BLIT python": {
        "prefix": "JS_LICE_Blit",
        "scope": "python",
        "description": "Standard LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\",\n\"DODGE\", \"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with\n\"ALPHA\" to enable per-pixel alpha blending.\nIn addition to the standard LICE modes, LICE_Blit also offers:\n* \"CHANCOPY_XTOY\", with X and Y any of the four channels, A, R, G or B. (CHANCOPY_ATOA is similar to MASK mode.)\n* \"BLUR\"\n* \"ALPHAMUL\", which overwrites the destination with a per-pixel\nalpha-multiplied copy of the source. (Similar to first clearing the\ndestination with 0x00000000 and then blitting with \"COPY,ALPHA\".)\n",
        "body": "JS_LICE_Blit(${1:void destBitmap},${2:Int dstx},${3:Int dsty},${4:void sourceBitmap},${5:Int srcx},${6:Int srcy},${7:Int width},${8:Int height},${9:Float alpha},${10:String mode})$0"
    },
    "JS_LICE_CIRCLE c": {
        "prefix": "JS_LICE_Circle",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Circle(${1:void* bitmap},${2:double cx},${3:double cy},${4:double r},${5:int color},${6:double alpha},${7:const char* mode},${8:bool antialias})$0"
    },
    "REAPER.JS_LICE_CIRCLE lua": {
        "prefix": "reaper.JS_LICE_Circle",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_Circle(${1:identifier bitmap},${2:number cx},${3:number cy},${4:number r},${5:integer color},${6:number alpha},${7:string mode},${8:boolean antialias})$0"
    },
    "JS_LICE_CIRCLE python": {
        "prefix": "JS_LICE_Circle",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Circle(${1:void bitmap},${2:Float cx},${3:Float cy},${4:Float r},${5:Int color},${6:Float alpha},${7:String mode},${8:Boolean antialias})$0"
    },
    "JS_LICE_CLEAR c": {
        "prefix": "JS_LICE_Clear",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_Clear(${1:void* bitmap},${2:int color})$0"
    },
    "REAPER.JS_LICE_CLEAR lua": {
        "prefix": "reaper.JS_LICE_Clear",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_Clear(${1:identifier bitmap},${2:integer color})$0"
    },
    "JS_LICE_CLEAR python": {
        "prefix": "JS_LICE_Clear",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_Clear(${1:void bitmap},${2:Int color})$0"
    },
    "JS_LICE_CREATEBITMAP c": {
        "prefix": "JS_LICE_CreateBitmap",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_CreateBitmap(${1:bool isSysBitmap},${2:int width},${3:int height})$0"
    },
    "REAPER.JS_LICE_CREATEBITMAP lua": {
        "prefix": "reaper.JS_LICE_CreateBitmap",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_CreateBitmap(${1:boolean isSysBitmap},${2:integer width},${3:integer height})$0"
    },
    "JS_LICE_CREATEBITMAP python": {
        "prefix": "JS_LICE_CreateBitmap",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_CreateBitmap(${1:Boolean isSysBitmap},${2:Int width},${3:Int height})$0"
    },
    "JS_LICE_CREATEFONT c": {
        "prefix": "JS_LICE_CreateFont",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_CreateFont()$0"
    },
    "REAPER.JS_LICE_CREATEFONT lua": {
        "prefix": "reaper.JS_LICE_CreateFont",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_CreateFont()$0"
    },
    "JS_LICE_CREATEFONT python": {
        "prefix": "JS_LICE_CreateFont",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_CreateFont()$0"
    },
    "JS_LICE_DESTROYBITMAP c": {
        "prefix": "JS_LICE_DestroyBitmap",
        "scope": "c",
        "description": "Deletes the bitmap, and also unlinks bitmap from any composited window.\n",
        "body": "JS_LICE_DestroyBitmap(${1:void* bitmap})$0"
    },
    "REAPER.JS_LICE_DESTROYBITMAP lua": {
        "prefix": "reaper.JS_LICE_DestroyBitmap",
        "scope": "lua",
        "description": "Deletes the bitmap, and also unlinks bitmap from any composited window.\n",
        "body": "reaper.JS_LICE_DestroyBitmap(${1:identifier bitmap})$0"
    },
    "JS_LICE_DESTROYBITMAP python": {
        "prefix": "JS_LICE_DestroyBitmap",
        "scope": "python",
        "description": "Deletes the bitmap, and also unlinks bitmap from any composited window.\n",
        "body": "JS_LICE_DestroyBitmap(${1:void bitmap})$0"
    },
    "JS_LICE_DESTROYFONT c": {
        "prefix": "JS_LICE_DestroyFont",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_DestroyFont(${1:void* LICEFont})$0"
    },
    "REAPER.JS_LICE_DESTROYFONT lua": {
        "prefix": "reaper.JS_LICE_DestroyFont",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_DestroyFont(${1:identifier LICEFont})$0"
    },
    "JS_LICE_DESTROYFONT python": {
        "prefix": "JS_LICE_DestroyFont",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_DestroyFont(${1:void LICEFont})$0"
    },
    "JS_LICE_DRAWCHAR c": {
        "prefix": "JS_LICE_DrawChar",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_DrawChar(${1:void* bitmap},${2:int x},${3:int y},${4:char c},${5:int color},${6:double alpha},${7:int mode})$0"
    },
    "REAPER.JS_LICE_DRAWCHAR lua": {
        "prefix": "reaper.JS_LICE_DrawChar",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_DrawChar(${1:identifier bitmap},${2:integer x},${3:integer y},${4:integer c},${5:integer color},${6:number alpha},${7:integer mode})$0"
    },
    "JS_LICE_DRAWCHAR python": {
        "prefix": "JS_LICE_DrawChar",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_DrawChar(${1:void bitmap},${2:Int x},${3:Int y},${4:Int c},${5:Int color},${6:Float alpha},${7:Int mode})$0"
    },
    "JS_LICE_DRAWTEXT c": {
        "prefix": "JS_LICE_DrawText",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_DrawText(${1:void* bitmap},${2:void* LICEFont},${3:const char* text},${4:int textLen},${5:int x1},${6:int y1},${7:int x2},${8:int y2})$0"
    },
    "REAPER.JS_LICE_DRAWTEXT lua": {
        "prefix": "reaper.JS_LICE_DrawText",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_DrawText(${1:identifier bitmap},${2:identifier LICEFont},${3:string text},${4:integer textLen},${5:integer x1},${6:integer y1},${7:integer x2},${8:integer y2})$0"
    },
    "JS_LICE_DRAWTEXT python": {
        "prefix": "JS_LICE_DrawText",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_DrawText(${1:void bitmap},${2:void LICEFont},${3:String text},${4:Int textLen},${5:Int x1},${6:Int y1},${7:Int x2},${8:Int y2})$0"
    },
    "JS_LICE_FILLCIRCLE c": {
        "prefix": "JS_LICE_FillCircle",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillCircle(${1:void* bitmap},${2:double cx},${3:double cy},${4:double r},${5:int color},${6:double alpha},${7:const char* mode},${8:bool antialias})$0"
    },
    "REAPER.JS_LICE_FILLCIRCLE lua": {
        "prefix": "reaper.JS_LICE_FillCircle",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_FillCircle(${1:identifier bitmap},${2:number cx},${3:number cy},${4:number r},${5:integer color},${6:number alpha},${7:string mode},${8:boolean antialias})$0"
    },
    "JS_LICE_FILLCIRCLE python": {
        "prefix": "JS_LICE_FillCircle",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillCircle(${1:void bitmap},${2:Float cx},${3:Float cy},${4:Float r},${5:Int color},${6:Float alpha},${7:String mode},${8:Boolean antialias})$0"
    },
    "JS_LICE_FILLPOLYGON c": {
        "prefix": "JS_LICE_FillPolygon",
        "scope": "c",
        "description": "packedX and packedY are two strings of coordinates, each packed as \"<i4\".\nLICE modes : \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillPolygon(${1:void* bitmap},${2:const char* packedX},${3:const char* packedY},${4:int numPoints},${5:int color},${6:double alpha},${7:const char* mode})$0"
    },
    "REAPER.JS_LICE_FILLPOLYGON lua": {
        "prefix": "reaper.JS_LICE_FillPolygon",
        "scope": "lua",
        "description": "packedX and packedY are two strings of coordinates, each packed as \"<i4\".\nLICE modes : \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_FillPolygon(${1:identifier bitmap},${2:string packedX},${3:string packedY},${4:integer numPoints},${5:integer color},${6:number alpha},${7:string mode})$0"
    },
    "JS_LICE_FILLPOLYGON python": {
        "prefix": "JS_LICE_FillPolygon",
        "scope": "python",
        "description": "packedX and packedY are two strings of coordinates, each packed as \"<i4\".\nLICE modes : \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillPolygon(${1:void bitmap},${2:String packedX},${3:String packedY},${4:Int numPoints},${5:Int color},${6:Float alpha},${7:String mode})$0"
    },
    "JS_LICE_FILLRECT c": {
        "prefix": "JS_LICE_FillRect",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillRect(${1:void* bitmap},${2:int x},${3:int y},${4:int w},${5:int h},${6:int color},${7:double alpha},${8:const char* mode})$0"
    },
    "REAPER.JS_LICE_FILLRECT lua": {
        "prefix": "reaper.JS_LICE_FillRect",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_FillRect(${1:identifier bitmap},${2:integer x},${3:integer y},${4:integer w},${5:integer h},${6:integer color},${7:number alpha},${8:string mode})$0"
    },
    "JS_LICE_FILLRECT python": {
        "prefix": "JS_LICE_FillRect",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillRect(${1:void bitmap},${2:Int x},${3:Int y},${4:Int w},${5:Int h},${6:Int color},${7:Float alpha},${8:String mode})$0"
    },
    "JS_LICE_FILLTRIANGLE c": {
        "prefix": "JS_LICE_FillTriangle",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillTriangle(${1:void* bitmap},${2:int x1},${3:int y1},${4:int x2},${5:int y2},${6:int x3},${7:int y3},${8:int color},${9:double alpha},${10:const char* mode})$0"
    },
    "REAPER.JS_LICE_FILLTRIANGLE lua": {
        "prefix": "reaper.JS_LICE_FillTriangle",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_FillTriangle(${1:identifier bitmap},${2:integer x1},${3:integer y1},${4:integer x2},${5:integer y2},${6:integer x3},${7:integer y3},${8:integer color},${9:number alpha},${10:string mode})$0"
    },
    "JS_LICE_FILLTRIANGLE python": {
        "prefix": "JS_LICE_FillTriangle",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_FillTriangle(${1:void bitmap},${2:Int x1},${3:Int y1},${4:Int x2},${5:Int y2},${6:Int x3},${7:Int y3},${8:Int color},${9:Float alpha},${10:String mode})$0"
    },
    "JS_LICE_GETDC c": {
        "prefix": "JS_LICE_GetDC",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_GetDC(${1:void* bitmap})$0"
    },
    "REAPER.JS_LICE_GETDC lua": {
        "prefix": "reaper.JS_LICE_GetDC",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_GetDC(${1:identifier bitmap})$0"
    },
    "JS_LICE_GETDC python": {
        "prefix": "JS_LICE_GetDC",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_GetDC(${1:void bitmap})$0"
    },
    "JS_LICE_GETHEIGHT c": {
        "prefix": "JS_LICE_GetHeight",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_GetHeight(${1:void* bitmap})$0"
    },
    "REAPER.JS_LICE_GETHEIGHT lua": {
        "prefix": "reaper.JS_LICE_GetHeight",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_GetHeight(${1:identifier bitmap})$0"
    },
    "JS_LICE_GETHEIGHT python": {
        "prefix": "JS_LICE_GetHeight",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_GetHeight(${1:void bitmap})$0"
    },
    "JS_LICE_GETPIXEL c": {
        "prefix": "JS_LICE_GetPixel",
        "scope": "c",
        "description": "Returns the color of the specified pixel.\n",
        "body": "JS_LICE_GetPixel(${1:void* bitmap},${2:int x},${3:int y},${4:double* colorOut})$0"
    },
    "REAPER.JS_LICE_GETPIXEL lua": {
        "prefix": "reaper.JS_LICE_GetPixel",
        "scope": "lua",
        "description": "Returns the color of the specified pixel.\n",
        "body": "reaper.JS_LICE_GetPixel(${1:identifier bitmap},${2:integer x},${3:integer y})$0"
    },
    "JS_LICE_GETPIXEL python": {
        "prefix": "JS_LICE_GetPixel",
        "scope": "python",
        "description": "Returns the color of the specified pixel.\n",
        "body": "JS_LICE_GetPixel(${1:bitmap},${2:x},${3:y},${4:colorOut})$0"
    },
    "JS_LICE_GETWIDTH c": {
        "prefix": "JS_LICE_GetWidth",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_GetWidth(${1:void* bitmap})$0"
    },
    "REAPER.JS_LICE_GETWIDTH lua": {
        "prefix": "reaper.JS_LICE_GetWidth",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_GetWidth(${1:identifier bitmap})$0"
    },
    "JS_LICE_GETWIDTH python": {
        "prefix": "JS_LICE_GetWidth",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_GetWidth(${1:void bitmap})$0"
    },
    "JS_LICE_GRADRECT c": {
        "prefix": "JS_LICE_GradRect",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_GradRect(${1:void* bitmap},${2:int dstx},${3:int dsty},${4:int dstw},${5:int dsth},${6:double ir},${7:double ig},${8:double ib},${9:double ia},${10:double drdx},${11:double dgdx},${12:double dbdx},${13:double dadx},${14:double drdy},${15:double dgdy},${16:double dbdy},${17:double dady},${18:const char* mode})$0"
    },
    "REAPER.JS_LICE_GRADRECT lua": {
        "prefix": "reaper.JS_LICE_GradRect",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_GradRect(${1:identifier bitmap},${2:integer dstx},${3:integer dsty},${4:integer dstw},${5:integer dsth},${6:number ir},${7:number ig},${8:number ib},${9:number ia},${10:number drdx},${11:number dgdx},${12:number dbdx},${13:number dadx},${14:number drdy},${15:number dgdy},${16:number dbdy},${17:number dady},${18:string mode})$0"
    },
    "JS_LICE_GRADRECT python": {
        "prefix": "JS_LICE_GradRect",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_GradRect(${1:void bitmap},${2:Int dstx},${3:Int dsty},${4:Int dstw},${5:Int dsth},${6:Float ir},${7:Float ig},${8:Float ib},${9:Float ia},${10:Float drdx},${11:Float dgdx},${12:Float dbdx},${13:Float dadx},${14:Float drdy},${15:Float dgdy},${16:Float dbdy},${17:Float dady},${18:String mode})$0"
    },
    "JS_LICE_ISFLIPPED c": {
        "prefix": "JS_LICE_IsFlipped",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_IsFlipped(${1:void* bitmap})$0"
    },
    "REAPER.JS_LICE_ISFLIPPED lua": {
        "prefix": "reaper.JS_LICE_IsFlipped",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_IsFlipped(${1:identifier bitmap})$0"
    },
    "JS_LICE_ISFLIPPED python": {
        "prefix": "JS_LICE_IsFlipped",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_IsFlipped(${1:void bitmap})$0"
    },
    "JS_LICE_LINE c": {
        "prefix": "JS_LICE_Line",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Line(${1:void* bitmap},${2:double x1},${3:double y1},${4:double x2},${5:double y2},${6:int color},${7:double alpha},${8:const char* mode},${9:bool antialias})$0"
    },
    "REAPER.JS_LICE_LINE lua": {
        "prefix": "reaper.JS_LICE_Line",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_Line(${1:identifier bitmap},${2:number x1},${3:number y1},${4:number x2},${5:number y2},${6:integer color},${7:number alpha},${8:string mode},${9:boolean antialias})$0"
    },
    "JS_LICE_LINE python": {
        "prefix": "JS_LICE_Line",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_Line(${1:void bitmap},${2:Float x1},${3:Float y1},${4:Float x2},${5:Float y2},${6:Int color},${7:Float alpha},${8:String mode},${9:Boolean antialias})$0"
    },
    "JS_LICE_LISTALLBITMAPS c": {
        "prefix": "JS_LICE_ListAllBitmaps",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_ListAllBitmaps(${1:char* listOutNeedBig},${2:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_LICE_LISTALLBITMAPS lua": {
        "prefix": "reaper.JS_LICE_ListAllBitmaps",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_ListAllBitmaps()$0"
    },
    "JS_LICE_LISTALLBITMAPS python": {
        "prefix": "JS_LICE_ListAllBitmaps",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_ListAllBitmaps(${1:listOutNeedBig},${2:listOutNeedBig_sz})$0"
    },
    "JS_LICE_LOADPNG c": {
        "prefix": "JS_LICE_LoadPNG",
        "scope": "c",
        "description": "Returns a system LICE bitmap containing the PNG.\n",
        "body": "JS_LICE_LoadPNG(${1:const char* filename})$0"
    },
    "REAPER.JS_LICE_LOADPNG lua": {
        "prefix": "reaper.JS_LICE_LoadPNG",
        "scope": "lua",
        "description": "Returns a system LICE bitmap containing the PNG.\n",
        "body": "reaper.JS_LICE_LoadPNG(${1:string filename})$0"
    },
    "JS_LICE_LOADPNG python": {
        "prefix": "JS_LICE_LoadPNG",
        "scope": "python",
        "description": "Returns a system LICE bitmap containing the PNG.\n",
        "body": "JS_LICE_LoadPNG(${1:String filename})$0"
    },
    "JS_LICE_MEASURETEXT c": {
        "prefix": "JS_LICE_MeasureText",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_MeasureText(${1:const char* text},${2:int* widthOut},${3:int* HeightOut})$0"
    },
    "REAPER.JS_LICE_MEASURETEXT lua": {
        "prefix": "reaper.JS_LICE_MeasureText",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_MeasureText(${1:string text})$0"
    },
    "JS_LICE_MEASURETEXT python": {
        "prefix": "JS_LICE_MeasureText",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_MeasureText(${1:text},${2:widthOut},${3:HeightOut})$0"
    },
    "JS_LICE_PROCESSRECT c": {
        "prefix": "JS_LICE_ProcessRect",
        "scope": "c",
        "description": "Applies bitwise operations to each pixel in the target rectangle.\noperand: a color in 0xAARRGGBB format.\nmodes:\n* \"XOR\", \"OR\" or \"AND\".\n* \"SET_XYZ\", with XYZ any combination of A, R, G, and B: copies the\nspecified channels from operand to the bitmap. (Useful for setting the\nalpha values of a bitmap.)\n* \"ALPHAMUL\": Performs alpha pre-multiplication on each pixel in the\nrect. operand is ignored in this mode. (On WindowsOS, GDI_Blit does not\nperform alpha multiplication on the fly, and a separate alpha\npre-multiplication step is therefore required.)\nNOTE:\nLICE_Blit and LICE_ScaledBlit are also useful for processing bitmap colors. For example, to multiply all channel values by 1.5:\nreaper.JS_LICE_Blit(bitmap, x, y, bitmap, x, y, w, h, 0.5, \"ADD\").\n",
        "body": "JS_LICE_ProcessRect(${1:void* bitmap},${2:int x},${3:int y},${4:int w},${5:int h},${6:const char* mode},${7:double operand})$0"
    },
    "REAPER.JS_LICE_PROCESSRECT lua": {
        "prefix": "reaper.JS_LICE_ProcessRect",
        "scope": "lua",
        "description": "Applies bitwise operations to each pixel in the target rectangle.\noperand: a color in 0xAARRGGBB format.\nmodes:\n* \"XOR\", \"OR\" or \"AND\".\n* \"SET_XYZ\", with XYZ any combination of A, R, G, and B: copies the\nspecified channels from operand to the bitmap. (Useful for setting the\nalpha values of a bitmap.)\n* \"ALPHAMUL\": Performs alpha pre-multiplication on each pixel in the\nrect. operand is ignored in this mode. (On WindowsOS, GDI_Blit does not\nperform alpha multiplication on the fly, and a separate alpha\npre-multiplication step is therefore required.)\nNOTE:\nLICE_Blit and LICE_ScaledBlit are also useful for processing bitmap colors. For example, to multiply all channel values by 1.5:\nreaper.JS_LICE_Blit(bitmap, x, y, bitmap, x, y, w, h, 0.5, \"ADD\").\n",
        "body": "reaper.JS_LICE_ProcessRect(${1:identifier bitmap},${2:integer x},${3:integer y},${4:integer w},${5:integer h},${6:string mode},${7:number operand})$0"
    },
    "JS_LICE_PROCESSRECT python": {
        "prefix": "JS_LICE_ProcessRect",
        "scope": "python",
        "description": "Applies bitwise operations to each pixel in the target rectangle.\noperand: a color in 0xAARRGGBB format.\nmodes:\n* \"XOR\", \"OR\" or \"AND\".\n* \"SET_XYZ\", with XYZ any combination of A, R, G, and B: copies the\nspecified channels from operand to the bitmap. (Useful for setting the\nalpha values of a bitmap.)\n* \"ALPHAMUL\": Performs alpha pre-multiplication on each pixel in the\nrect. operand is ignored in this mode. (On WindowsOS, GDI_Blit does not\nperform alpha multiplication on the fly, and a separate alpha\npre-multiplication step is therefore required.)\nNOTE:\nLICE_Blit and LICE_ScaledBlit are also useful for processing bitmap colors. For example, to multiply all channel values by 1.5:\nreaper.JS_LICE_Blit(bitmap, x, y, bitmap, x, y, w, h, 0.5, \"ADD\").\n",
        "body": "JS_LICE_ProcessRect(${1:void bitmap},${2:Int x},${3:Int y},${4:Int w},${5:Int h},${6:String mode},${7:Float operand})$0"
    },
    "JS_LICE_PUTPIXEL c": {
        "prefix": "JS_LICE_PutPixel",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_PutPixel(${1:void* bitmap},${2:int x},${3:int y},${4:double color},${5:double alpha},${6:const char* mode})$0"
    },
    "REAPER.JS_LICE_PUTPIXEL lua": {
        "prefix": "reaper.JS_LICE_PutPixel",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_PutPixel(${1:identifier bitmap},${2:integer x},${3:integer y},${4:number color},${5:number alpha},${6:string mode})$0"
    },
    "JS_LICE_PUTPIXEL python": {
        "prefix": "JS_LICE_PutPixel",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_PutPixel(${1:void bitmap},${2:Int x},${3:Int y},${4:Float color},${5:Float alpha},${6:String mode})$0"
    },
    "JS_LICE_RESIZE c": {
        "prefix": "JS_LICE_Resize",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_Resize(${1:void* bitmap},${2:int width},${3:int height})$0"
    },
    "REAPER.JS_LICE_RESIZE lua": {
        "prefix": "reaper.JS_LICE_Resize",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_Resize(${1:identifier bitmap},${2:integer width},${3:integer height})$0"
    },
    "JS_LICE_RESIZE python": {
        "prefix": "JS_LICE_Resize",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_Resize(${1:void bitmap},${2:Int width},${3:Int height})$0"
    },
    "JS_LICE_ROTATEDBLIT c": {
        "prefix": "JS_LICE_RotatedBlit",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "JS_LICE_RotatedBlit(${1:void* destBitmap},${2:int dstx},${3:int dsty},${4:int dstw},${5:int dsth},${6:void* sourceBitmap},${7:double srcx},${8:double srcy},${9:double srcw},${10:double srch},${11:double angle},${12:double rotxcent},${13:double rotycent},${14:bool cliptosourcerect},${15:double alpha},${16:const char* mode})$0"
    },
    "REAPER.JS_LICE_ROTATEDBLIT lua": {
        "prefix": "reaper.JS_LICE_RotatedBlit",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "reaper.JS_LICE_RotatedBlit(${1:identifier destBitmap},${2:integer dstx},${3:integer dsty},${4:integer dstw},${5:integer dsth},${6:identifier sourceBitmap},${7:number srcx},${8:number srcy},${9:number srcw},${10:number srch},${11:number angle},${12:number rotxcent},${13:number rotycent},${14:boolean cliptosourcerect},${15:number alpha},${16:string mode})$0"
    },
    "JS_LICE_ROTATEDBLIT python": {
        "prefix": "JS_LICE_RotatedBlit",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "JS_LICE_RotatedBlit(${1:void destBitmap},${2:Int dstx},${3:Int dsty},${4:Int dstw},${5:Int dsth},${6:void sourceBitmap},${7:Float srcx},${8:Float srcy},${9:Float srcw},${10:Float srch},${11:Float angle},${12:Float rotxcent},${13:Float rotycent},${14:Boolean cliptosourcerect},${15:Float alpha},${16:String mode})$0"
    },
    "JS_LICE_ROUNDRECT c": {
        "prefix": "JS_LICE_RoundRect",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_RoundRect(${1:void* bitmap},${2:double x},${3:double y},${4:double w},${5:double h},${6:int cornerradius},${7:int color},${8:double alpha},${9:const char* mode},${10:bool antialias})$0"
    },
    "REAPER.JS_LICE_ROUNDRECT lua": {
        "prefix": "reaper.JS_LICE_RoundRect",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "reaper.JS_LICE_RoundRect(${1:identifier bitmap},${2:number x},${3:number y},${4:number w},${5:number h},${6:integer cornerradius},${7:integer color},${8:number alpha},${9:string mode},${10:boolean antialias})$0"
    },
    "JS_LICE_ROUNDRECT python": {
        "prefix": "JS_LICE_RoundRect",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "JS_LICE_RoundRect(${1:void bitmap},${2:Float x},${3:Float y},${4:Float w},${5:Float h},${6:Int cornerradius},${7:Int color},${8:Float alpha},${9:String mode},${10:Boolean antialias})$0"
    },
    "JS_LICE_SCALEDBLIT c": {
        "prefix": "JS_LICE_ScaledBlit",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "JS_LICE_ScaledBlit(${1:void* destBitmap},${2:int dstx},${3:int dsty},${4:int dstw},${5:int dsth},${6:void* srcBitmap},${7:double srcx},${8:double srcy},${9:double srcw},${10:double srch},${11:double alpha},${12:const char* mode})$0"
    },
    "REAPER.JS_LICE_SCALEDBLIT lua": {
        "prefix": "reaper.JS_LICE_ScaledBlit",
        "scope": "lua",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "reaper.JS_LICE_ScaledBlit(${1:identifier destBitmap},${2:integer dstx},${3:integer dsty},${4:integer dstw},${5:integer dsth},${6:identifier srcBitmap},${7:number srcx},${8:number srcy},${9:number srcw},${10:number srch},${11:number alpha},${12:string mode})$0"
    },
    "JS_LICE_SCALEDBLIT python": {
        "prefix": "JS_LICE_ScaledBlit",
        "scope": "python",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "JS_LICE_ScaledBlit(${1:void destBitmap},${2:Int dstx},${3:Int dsty},${4:Int dstw},${5:Int dsth},${6:void srcBitmap},${7:Float srcx},${8:Float srcy},${9:Float srcw},${10:Float srch},${11:Float alpha},${12:String mode})$0"
    },
    "JS_LICE_SETALPHAFROMCOLORMASK c": {
        "prefix": "JS_LICE_SetAlphaFromColorMask",
        "scope": "c",
        "description": "Sets all pixels that match the given color's RGB values to fully\ntransparent, and all other pixels to fully opaque.  (All pixels' RGB\nvalues remain unchanged.)\n",
        "body": "JS_LICE_SetAlphaFromColorMask(${1:void* bitmap},${2:int colorRGB})$0"
    },
    "REAPER.JS_LICE_SETALPHAFROMCOLORMASK lua": {
        "prefix": "reaper.JS_LICE_SetAlphaFromColorMask",
        "scope": "lua",
        "description": "Sets all pixels that match the given color's RGB values to fully\ntransparent, and all other pixels to fully opaque.  (All pixels' RGB\nvalues remain unchanged.)\n",
        "body": "reaper.JS_LICE_SetAlphaFromColorMask(${1:identifier bitmap},${2:integer colorRGB})$0"
    },
    "JS_LICE_SETALPHAFROMCOLORMASK python": {
        "prefix": "JS_LICE_SetAlphaFromColorMask",
        "scope": "python",
        "description": "Sets all pixels that match the given color's RGB values to fully\ntransparent, and all other pixels to fully opaque.  (All pixels' RGB\nvalues remain unchanged.)\n",
        "body": "JS_LICE_SetAlphaFromColorMask(${1:void bitmap},${2:Int colorRGB})$0"
    },
    "JS_LICE_SETFONTBKCOLOR c": {
        "prefix": "JS_LICE_SetFontBkColor",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_SetFontBkColor(${1:void* LICEFont},${2:int color})$0"
    },
    "REAPER.JS_LICE_SETFONTBKCOLOR lua": {
        "prefix": "reaper.JS_LICE_SetFontBkColor",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_SetFontBkColor(${1:identifier LICEFont},${2:integer color})$0"
    },
    "JS_LICE_SETFONTBKCOLOR python": {
        "prefix": "JS_LICE_SetFontBkColor",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_SetFontBkColor(${1:void LICEFont},${2:Int color})$0"
    },
    "JS_LICE_SETFONTCOLOR c": {
        "prefix": "JS_LICE_SetFontColor",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_SetFontColor(${1:void* LICEFont},${2:int color})$0"
    },
    "REAPER.JS_LICE_SETFONTCOLOR lua": {
        "prefix": "reaper.JS_LICE_SetFontColor",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_SetFontColor(${1:identifier LICEFont},${2:integer color})$0"
    },
    "JS_LICE_SETFONTCOLOR python": {
        "prefix": "JS_LICE_SetFontColor",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_SetFontColor(${1:void LICEFont},${2:Int color})$0"
    },
    "JS_LICE_SETFONTFROMGDI c": {
        "prefix": "JS_LICE_SetFontFromGDI",
        "scope": "c",
        "description": "Converts a GDI font into a LICE font.\nThe font can be modified by the following flags, in a comma-separated list:\n\"VERTICAL\", \"BOTTOMUP\", \"NATIVE\", \"BLUR\", \"INVERT\", \"MONO\", \"SHADOW\" or \"OUTLINE\".\n",
        "body": "JS_LICE_SetFontFromGDI(${1:void* LICEFont},${2:void* GDIFont},${3:const char* moreFormats})$0"
    },
    "REAPER.JS_LICE_SETFONTFROMGDI lua": {
        "prefix": "reaper.JS_LICE_SetFontFromGDI",
        "scope": "lua",
        "description": "Converts a GDI font into a LICE font.\nThe font can be modified by the following flags, in a comma-separated list:\n\"VERTICAL\", \"BOTTOMUP\", \"NATIVE\", \"BLUR\", \"INVERT\", \"MONO\", \"SHADOW\" or \"OUTLINE\".\n",
        "body": "reaper.JS_LICE_SetFontFromGDI(${1:identifier LICEFont},${2:identifier GDIFont},${3:string moreFormats})$0"
    },
    "JS_LICE_SETFONTFROMGDI python": {
        "prefix": "JS_LICE_SetFontFromGDI",
        "scope": "python",
        "description": "Converts a GDI font into a LICE font.\nThe font can be modified by the following flags, in a comma-separated list:\n\"VERTICAL\", \"BOTTOMUP\", \"NATIVE\", \"BLUR\", \"INVERT\", \"MONO\", \"SHADOW\" or \"OUTLINE\".\n",
        "body": "JS_LICE_SetFontFromGDI(${1:void LICEFont},${2:void GDIFont},${3:String moreFormats})$0"
    },
    "JS_LICE_WRITEPNG c": {
        "prefix": "JS_LICE_WritePNG",
        "scope": "c",
        "description": "\n",
        "body": "JS_LICE_WritePNG(${1:const char* filename},${2:void* bitmap},${3:bool wantAlpha})$0"
    },
    "REAPER.JS_LICE_WRITEPNG lua": {
        "prefix": "reaper.JS_LICE_WritePNG",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_LICE_WritePNG(${1:string filename},${2:identifier bitmap},${3:boolean wantAlpha})$0"
    },
    "JS_LICE_WRITEPNG python": {
        "prefix": "JS_LICE_WritePNG",
        "scope": "python",
        "description": "\n",
        "body": "JS_LICE_WritePNG(${1:String filename},${2:void bitmap},${3:Boolean wantAlpha})$0"
    },
    "JS_LISTVIEW_ENSUREVISIBLE c": {
        "prefix": "JS_ListView_EnsureVisible",
        "scope": "c",
        "description": "\n",
        "body": "JS_ListView_EnsureVisible(${1:void* listviewHWND},${2:int index},${3:bool partialOK})$0"
    },
    "REAPER.JS_LISTVIEW_ENSUREVISIBLE lua": {
        "prefix": "reaper.JS_ListView_EnsureVisible",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_ListView_EnsureVisible(${1:identifier listviewHWND},${2:integer index},${3:boolean partialOK})$0"
    },
    "JS_LISTVIEW_ENSUREVISIBLE python": {
        "prefix": "JS_ListView_EnsureVisible",
        "scope": "python",
        "description": "\n",
        "body": "JS_ListView_EnsureVisible(${1:void listviewHWND},${2:Int index},${3:Boolean partialOK})$0"
    },
    "JS_LISTVIEW_ENUMSELITEMS c": {
        "prefix": "JS_ListView_EnumSelItems",
        "scope": "c",
        "description": "Returns the index of the next selected list item with index greater that\nthe specified number. Returns -1 if no selected items left.\n",
        "body": "JS_ListView_EnumSelItems(${1:void* listviewHWND},${2:int index})$0"
    },
    "REAPER.JS_LISTVIEW_ENUMSELITEMS lua": {
        "prefix": "reaper.JS_ListView_EnumSelItems",
        "scope": "lua",
        "description": "Returns the index of the next selected list item with index greater that\nthe specified number. Returns -1 if no selected items left.\n",
        "body": "reaper.JS_ListView_EnumSelItems(${1:identifier listviewHWND},${2:integer index})$0"
    },
    "JS_LISTVIEW_ENUMSELITEMS python": {
        "prefix": "JS_ListView_EnumSelItems",
        "scope": "python",
        "description": "Returns the index of the next selected list item with index greater that\nthe specified number. Returns -1 if no selected items left.\n",
        "body": "JS_ListView_EnumSelItems(${1:void listviewHWND},${2:Int index})$0"
    },
    "JS_LISTVIEW_GETFOCUSEDITEM c": {
        "prefix": "JS_ListView_GetFocusedItem",
        "scope": "c",
        "description": "Returns the index and text of the focused item, if any.\n",
        "body": "JS_ListView_GetFocusedItem(${1:void* listviewHWND},${2:char* textOut},${3:int textOut_sz})$0"
    },
    "REAPER.JS_LISTVIEW_GETFOCUSEDITEM lua": {
        "prefix": "reaper.JS_ListView_GetFocusedItem",
        "scope": "lua",
        "description": "Returns the index and text of the focused item, if any.\n",
        "body": "reaper.JS_ListView_GetFocusedItem(${1:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_GETFOCUSEDITEM python": {
        "prefix": "JS_ListView_GetFocusedItem",
        "scope": "python",
        "description": "Returns the index and text of the focused item, if any.\n",
        "body": "JS_ListView_GetFocusedItem(${1:listviewHWND},${2:textOut},${3:textOut_sz})$0"
    },
    "JS_LISTVIEW_GETITEM c": {
        "prefix": "JS_ListView_GetItem",
        "scope": "c",
        "description": "Returns the text and state of specified item.\n",
        "body": "JS_ListView_GetItem(${1:void* listviewHWND},${2:int index},${3:int subItem},${4:char* textOut},${5:int textOut_sz},${6:int* stateOut})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEM lua": {
        "prefix": "reaper.JS_ListView_GetItem",
        "scope": "lua",
        "description": "Returns the text and state of specified item.\n",
        "body": "reaper.JS_ListView_GetItem(${1:identifier listviewHWND},${2:integer index},${3:integer subItem})$0"
    },
    "JS_LISTVIEW_GETITEM python": {
        "prefix": "JS_ListView_GetItem",
        "scope": "python",
        "description": "Returns the text and state of specified item.\n",
        "body": "JS_ListView_GetItem(${1:listviewHWND},${2:index},${3:subItem},${4:textOut},${5:textOut_sz},${6:stateOut})$0"
    },
    "JS_LISTVIEW_GETITEMCOUNT c": {
        "prefix": "JS_ListView_GetItemCount",
        "scope": "c",
        "description": "\n",
        "body": "JS_ListView_GetItemCount(${1:void* listviewHWND})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEMCOUNT lua": {
        "prefix": "reaper.JS_ListView_GetItemCount",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_ListView_GetItemCount(${1:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_GETITEMCOUNT python": {
        "prefix": "JS_ListView_GetItemCount",
        "scope": "python",
        "description": "\n",
        "body": "JS_ListView_GetItemCount(${1:void listviewHWND})$0"
    },
    "JS_LISTVIEW_GETITEMSTATE c": {
        "prefix": "JS_ListView_GetItemState",
        "scope": "c",
        "description": "\n",
        "body": "JS_ListView_GetItemState(${1:void* listviewHWND},${2:int index})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEMSTATE lua": {
        "prefix": "reaper.JS_ListView_GetItemState",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_ListView_GetItemState(${1:identifier listviewHWND},${2:integer index})$0"
    },
    "JS_LISTVIEW_GETITEMSTATE python": {
        "prefix": "JS_ListView_GetItemState",
        "scope": "python",
        "description": "\n",
        "body": "JS_ListView_GetItemState(${1:void listviewHWND},${2:Int index})$0"
    },
    "JS_LISTVIEW_GETITEMTEXT c": {
        "prefix": "JS_ListView_GetItemText",
        "scope": "c",
        "description": "\n",
        "body": "JS_ListView_GetItemText(${1:void* listviewHWND},${2:int index},${3:int subItem},${4:char* textOut},${5:int textOut_sz})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEMTEXT lua": {
        "prefix": "reaper.JS_ListView_GetItemText",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_ListView_GetItemText(${1:identifier listviewHWND},${2:integer index},${3:integer subItem})$0"
    },
    "JS_LISTVIEW_GETITEMTEXT python": {
        "prefix": "JS_ListView_GetItemText",
        "scope": "python",
        "description": "\n",
        "body": "JS_ListView_GetItemText(${1:listviewHWND},${2:index},${3:subItem},${4:textOut},${5:textOut_sz})$0"
    },
    "JS_LISTVIEW_GETSELECTEDCOUNT c": {
        "prefix": "JS_ListView_GetSelectedCount",
        "scope": "c",
        "description": "\n",
        "body": "JS_ListView_GetSelectedCount(${1:void* listviewHWND})$0"
    },
    "REAPER.JS_LISTVIEW_GETSELECTEDCOUNT lua": {
        "prefix": "reaper.JS_ListView_GetSelectedCount",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_ListView_GetSelectedCount(${1:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_GETSELECTEDCOUNT python": {
        "prefix": "JS_ListView_GetSelectedCount",
        "scope": "python",
        "description": "\n",
        "body": "JS_ListView_GetSelectedCount(${1:void listviewHWND})$0"
    },
    "JS_LISTVIEW_LISTALLSELITEMS c": {
        "prefix": "JS_ListView_ListAllSelItems",
        "scope": "c",
        "description": "Returns the indices of all selected items as a comma-separated list.\n* retval: Number of selected items found; negative or zero if an error occured.\n",
        "body": "JS_ListView_ListAllSelItems(${1:void* listviewHWND},${2:char* itemsOutNeedBig},${3:int itemsOutNeedBig_sz})$0"
    },
    "REAPER.JS_LISTVIEW_LISTALLSELITEMS lua": {
        "prefix": "reaper.JS_ListView_ListAllSelItems",
        "scope": "lua",
        "description": "Returns the indices of all selected items as a comma-separated list.\n* retval: Number of selected items found; negative or zero if an error occured.\n",
        "body": "reaper.JS_ListView_ListAllSelItems(${1:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_LISTALLSELITEMS python": {
        "prefix": "JS_ListView_ListAllSelItems",
        "scope": "python",
        "description": "Returns the indices of all selected items as a comma-separated list.\n* retval: Number of selected items found; negative or zero if an error occured.\n",
        "body": "JS_ListView_ListAllSelItems(${1:listviewHWND},${2:itemsOutNeedBig},${3:itemsOutNeedBig_sz})$0"
    },
    "JS_LOCALIZE c": {
        "prefix": "JS_Localize",
        "scope": "c",
        "description": "Returns the translation of the given US English text, according to the currently loaded Language Pack.\nParameters:\n* LangPackSection: Language Packs are divided into sections such as \"common\" or \"DLG_102\".\n* In Lua, by default, text of up to 1024 chars can be returned. To\nincrease (or reduce) the default buffer size, a string and size can be\nincluded as optional 3rd and 4th arguments.\nExample: reaper.JS_Localize(\"Actions\", \"common\", \"\", 20)\n",
        "body": "JS_Localize(${1:const char* USEnglish},${2:const char* LangPackSection},${3:char* translationOut},${4:int translationOut_sz})$0"
    },
    "REAPER.JS_LOCALIZE lua": {
        "prefix": "reaper.JS_Localize",
        "scope": "lua",
        "description": "Returns the translation of the given US English text, according to the currently loaded Language Pack.\nParameters:\n* LangPackSection: Language Packs are divided into sections such as \"common\" or \"DLG_102\".\n* In Lua, by default, text of up to 1024 chars can be returned. To\nincrease (or reduce) the default buffer size, a string and size can be\nincluded as optional 3rd and 4th arguments.\nExample: reaper.JS_Localize(\"Actions\", \"common\", \"\", 20)\n",
        "body": "reaper.JS_Localize(${1:string USEnglish},${2:string LangPackSection})$0"
    },
    "JS_LOCALIZE python": {
        "prefix": "JS_Localize",
        "scope": "python",
        "description": "Returns the translation of the given US English text, according to the currently loaded Language Pack.\nParameters:\n* LangPackSection: Language Packs are divided into sections such as \"common\" or \"DLG_102\".\n* In Lua, by default, text of up to 1024 chars can be returned. To\nincrease (or reduce) the default buffer size, a string and size can be\nincluded as optional 3rd and 4th arguments.\nExample: reaper.JS_Localize(\"Actions\", \"common\", \"\", 20)\n",
        "body": "JS_Localize(${1:USEnglish},${2:LangPackSection},${3:translationOut},${4:translationOut_sz})$0"
    },
    "JS_MIDIEDITOR_ARRAYALL c": {
        "prefix": "JS_MIDIEditor_ArrayAll",
        "scope": "c",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* The address of each MIDI editor window is stored in the provided\nreaper.array. Each address can be converted to a REAPER object (HWND) by\nthe function JS_Window_HandleFromAddress.\n",
        "body": "JS_MIDIEditor_ArrayAll(${1:void* reaperarray})$0"
    },
    "REAPER.JS_MIDIEDITOR_ARRAYALL lua": {
        "prefix": "reaper.JS_MIDIEditor_ArrayAll",
        "scope": "lua",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* The address of each MIDI editor window is stored in the provided\nreaper.array. Each address can be converted to a REAPER object (HWND) by\nthe function JS_Window_HandleFromAddress.\n",
        "body": "reaper.JS_MIDIEditor_ArrayAll(${1:identifier reaperarray})$0"
    },
    "JS_MIDIEDITOR_ARRAYALL python": {
        "prefix": "JS_MIDIEditor_ArrayAll",
        "scope": "python",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* The address of each MIDI editor window is stored in the provided\nreaper.array. Each address can be converted to a REAPER object (HWND) by\nthe function JS_Window_HandleFromAddress.\n",
        "body": "JS_MIDIEditor_ArrayAll(${1:void reaperarray})$0"
    },
    "JS_MIDIEDITOR_LISTALL c": {
        "prefix": "JS_MIDIEditor_ListAll",
        "scope": "c",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* list: Comma-separated string of hexadecimal values. Each value is an\naddress that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "JS_MIDIEditor_ListAll(${1:char* listOutNeedBig},${2:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_MIDIEDITOR_LISTALL lua": {
        "prefix": "reaper.JS_MIDIEditor_ListAll",
        "scope": "lua",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* list: Comma-separated string of hexadecimal values. Each value is an\naddress that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "reaper.JS_MIDIEditor_ListAll()$0"
    },
    "JS_MIDIEDITOR_LISTALL python": {
        "prefix": "JS_MIDIEditor_ListAll",
        "scope": "python",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* list: Comma-separated string of hexadecimal values. Each value is an\naddress that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "JS_MIDIEditor_ListAll(${1:listOutNeedBig},${2:listOutNeedBig_sz})$0"
    },
    "JS_MEM_ALLOC c": {
        "prefix": "JS_Mem_Alloc",
        "scope": "c",
        "description": "Allocates memory for general use by functions that require memory buffers.\n",
        "body": "JS_Mem_Alloc(${1:int sizeBytes})$0"
    },
    "REAPER.JS_MEM_ALLOC lua": {
        "prefix": "reaper.JS_Mem_Alloc",
        "scope": "lua",
        "description": "Allocates memory for general use by functions that require memory buffers.\n",
        "body": "reaper.JS_Mem_Alloc(${1:integer sizeBytes})$0"
    },
    "JS_MEM_ALLOC python": {
        "prefix": "JS_Mem_Alloc",
        "scope": "python",
        "description": "Allocates memory for general use by functions that require memory buffers.\n",
        "body": "JS_Mem_Alloc(${1:Int sizeBytes})$0"
    },
    "JS_MEM_FREE c": {
        "prefix": "JS_Mem_Free",
        "scope": "c",
        "description": "Frees memory that was previously allocated by JS_Mem_Alloc.\n",
        "body": "JS_Mem_Free(${1:void* mallocPointer})$0"
    },
    "REAPER.JS_MEM_FREE lua": {
        "prefix": "reaper.JS_Mem_Free",
        "scope": "lua",
        "description": "Frees memory that was previously allocated by JS_Mem_Alloc.\n",
        "body": "reaper.JS_Mem_Free(${1:identifier mallocPointer})$0"
    },
    "JS_MEM_FREE python": {
        "prefix": "JS_Mem_Free",
        "scope": "python",
        "description": "Frees memory that was previously allocated by JS_Mem_Alloc.\n",
        "body": "JS_Mem_Free(${1:void mallocPointer})$0"
    },
    "JS_MEM_FROMSTRING c": {
        "prefix": "JS_Mem_FromString",
        "scope": "c",
        "description": "Copies a packed string into a memory buffer.\n",
        "body": "JS_Mem_FromString(${1:void* mallocPointer},${2:int offset},${3:const char* packedString},${4:int stringLength})$0"
    },
    "REAPER.JS_MEM_FROMSTRING lua": {
        "prefix": "reaper.JS_Mem_FromString",
        "scope": "lua",
        "description": "Copies a packed string into a memory buffer.\n",
        "body": "reaper.JS_Mem_FromString(${1:identifier mallocPointer},${2:integer offset},${3:string packedString},${4:integer stringLength})$0"
    },
    "JS_MEM_FROMSTRING python": {
        "prefix": "JS_Mem_FromString",
        "scope": "python",
        "description": "Copies a packed string into a memory buffer.\n",
        "body": "JS_Mem_FromString(${1:void mallocPointer},${2:Int offset},${3:String packedString},${4:Int stringLength})$0"
    },
    "JS_MOUSE_GETCURSOR c": {
        "prefix": "JS_Mouse_GetCursor",
        "scope": "c",
        "description": "On Windows, retrieves a handle to the current mouse cursor.\nOn Linux and macOS, retrieves a handle to the last cursor set by REAPER or its extensions via SWELL.\n",
        "body": "JS_Mouse_GetCursor()$0"
    },
    "REAPER.JS_MOUSE_GETCURSOR lua": {
        "prefix": "reaper.JS_Mouse_GetCursor",
        "scope": "lua",
        "description": "On Windows, retrieves a handle to the current mouse cursor.\nOn Linux and macOS, retrieves a handle to the last cursor set by REAPER or its extensions via SWELL.\n",
        "body": "reaper.JS_Mouse_GetCursor()$0"
    },
    "JS_MOUSE_GETCURSOR python": {
        "prefix": "JS_Mouse_GetCursor",
        "scope": "python",
        "description": "On Windows, retrieves a handle to the current mouse cursor.\nOn Linux and macOS, retrieves a handle to the last cursor set by REAPER or its extensions via SWELL.\n",
        "body": "JS_Mouse_GetCursor()$0"
    },
    "JS_MOUSE_GETSTATE c": {
        "prefix": "JS_Mouse_GetState",
        "scope": "c",
        "description": "Retrieves the states of mouse buttons and modifiers keys.\nParameters:\n* flags, state: The parameter and the return value both use the same\nformat as gfx.mouse_cap. For example, to get the states of the left\nmouse button and the ctrl key, use flags = 0b00000101.\n",
        "body": "JS_Mouse_GetState(${1:int flags})$0"
    },
    "REAPER.JS_MOUSE_GETSTATE lua": {
        "prefix": "reaper.JS_Mouse_GetState",
        "scope": "lua",
        "description": "Retrieves the states of mouse buttons and modifiers keys.\nParameters:\n* flags, state: The parameter and the return value both use the same\nformat as gfx.mouse_cap. For example, to get the states of the left\nmouse button and the ctrl key, use flags = 0b00000101.\n",
        "body": "reaper.JS_Mouse_GetState(${1:integer flags})$0"
    },
    "JS_MOUSE_GETSTATE python": {
        "prefix": "JS_Mouse_GetState",
        "scope": "python",
        "description": "Retrieves the states of mouse buttons and modifiers keys.\nParameters:\n* flags, state: The parameter and the return value both use the same\nformat as gfx.mouse_cap. For example, to get the states of the left\nmouse button and the ctrl key, use flags = 0b00000101.\n",
        "body": "JS_Mouse_GetState(${1:Int flags})$0"
    },
    "JS_MOUSE_LOADCURSOR c": {
        "prefix": "JS_Mouse_LoadCursor",
        "scope": "c",
        "description": "Loads a cursor by number.\ncursorNumber: Same as used for gfx.setcursor, and includes some of\nWindows' predefined cursors (with numbers > 32000; refer to\ndocumentation for the Win32 C++ function LoadCursor), and REAPER's own\ncursors (with numbers < 2000).\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "JS_Mouse_LoadCursor(${1:int cursorNumber})$0"
    },
    "REAPER.JS_MOUSE_LOADCURSOR lua": {
        "prefix": "reaper.JS_Mouse_LoadCursor",
        "scope": "lua",
        "description": "Loads a cursor by number.\ncursorNumber: Same as used for gfx.setcursor, and includes some of\nWindows' predefined cursors (with numbers > 32000; refer to\ndocumentation for the Win32 C++ function LoadCursor), and REAPER's own\ncursors (with numbers < 2000).\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "reaper.JS_Mouse_LoadCursor(${1:integer cursorNumber})$0"
    },
    "JS_MOUSE_LOADCURSOR python": {
        "prefix": "JS_Mouse_LoadCursor",
        "scope": "python",
        "description": "Loads a cursor by number.\ncursorNumber: Same as used for gfx.setcursor, and includes some of\nWindows' predefined cursors (with numbers > 32000; refer to\ndocumentation for the Win32 C++ function LoadCursor), and REAPER's own\ncursors (with numbers < 2000).\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "JS_Mouse_LoadCursor(${1:Int cursorNumber})$0"
    },
    "JS_MOUSE_LOADCURSORFROMFILE c": {
        "prefix": "JS_Mouse_LoadCursorFromFile",
        "scope": "c",
        "description": "Loads a cursor from a .cur file.\nforceNewLoad is an optional boolean parameter:\n* If omitted or false, and if the .cur file has already been loaded\npreviously during the REAPER session, the file will not be re-loaded,\nand the previous handle will be returned, thereby (slightly) improving\nspeed and (slighty) lowering memory usage.\n* If true, the file will be re-loaded and a new handle will be returned.\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "JS_Mouse_LoadCursorFromFile(${1:const char* pathAndFileName},${2:bool* forceNewLoadOptional})$0"
    },
    "REAPER.JS_MOUSE_LOADCURSORFROMFILE lua": {
        "prefix": "reaper.JS_Mouse_LoadCursorFromFile",
        "scope": "lua",
        "description": "Loads a cursor from a .cur file.\nforceNewLoad is an optional boolean parameter:\n* If omitted or false, and if the .cur file has already been loaded\npreviously during the REAPER session, the file will not be re-loaded,\nand the previous handle will be returned, thereby (slightly) improving\nspeed and (slighty) lowering memory usage.\n* If true, the file will be re-loaded and a new handle will be returned.\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "reaper.JS_Mouse_LoadCursorFromFile(${1:string pathAndFileName},${2:unsupported forceNewLoad})$0"
    },
    "JS_MOUSE_LOADCURSORFROMFILE python": {
        "prefix": "JS_Mouse_LoadCursorFromFile",
        "scope": "python",
        "description": "Loads a cursor from a .cur file.\nforceNewLoad is an optional boolean parameter:\n* If omitted or false, and if the .cur file has already been loaded\npreviously during the REAPER session, the file will not be re-loaded,\nand the previous handle will be returned, thereby (slightly) improving\nspeed and (slighty) lowering memory usage.\n* If true, the file will be re-loaded and a new handle will be returned.\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "JS_Mouse_LoadCursorFromFile(${1:pathAndFileName},${2:forceNewLoadOptional})$0"
    },
    "JS_MOUSE_SETCURSOR c": {
        "prefix": "JS_Mouse_SetCursor",
        "scope": "c",
        "description": "Sets the mouse cursor.  (Only lasts while script is running, and for a single \"defer\" cycle.)\n",
        "body": "JS_Mouse_SetCursor(${1:void* cursorHandle})$0"
    },
    "REAPER.JS_MOUSE_SETCURSOR lua": {
        "prefix": "reaper.JS_Mouse_SetCursor",
        "scope": "lua",
        "description": "Sets the mouse cursor.  (Only lasts while script is running, and for a single \"defer\" cycle.)\n",
        "body": "reaper.JS_Mouse_SetCursor(${1:identifier cursorHandle})$0"
    },
    "JS_MOUSE_SETCURSOR python": {
        "prefix": "JS_Mouse_SetCursor",
        "scope": "python",
        "description": "Sets the mouse cursor.  (Only lasts while script is running, and for a single \"defer\" cycle.)\n",
        "body": "JS_Mouse_SetCursor(${1:void cursorHandle})$0"
    },
    "JS_MOUSE_SETPOSITION c": {
        "prefix": "JS_Mouse_SetPosition",
        "scope": "c",
        "description": "Moves the mouse cursor to the specified screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "JS_Mouse_SetPosition(${1:int x},${2:int y})$0"
    },
    "REAPER.JS_MOUSE_SETPOSITION lua": {
        "prefix": "reaper.JS_Mouse_SetPosition",
        "scope": "lua",
        "description": "Moves the mouse cursor to the specified screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "reaper.JS_Mouse_SetPosition(${1:integer x},${2:integer y})$0"
    },
    "JS_MOUSE_SETPOSITION python": {
        "prefix": "JS_Mouse_SetPosition",
        "scope": "python",
        "description": "Moves the mouse cursor to the specified screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "JS_Mouse_SetPosition(${1:Int x},${2:Int y})$0"
    },
    "JS_REASCRIPTAPI_VERSION c": {
        "prefix": "JS_ReaScriptAPI_Version",
        "scope": "c",
        "description": "Returns the version of the js_ReaScriptAPI extension.\n",
        "body": "JS_ReaScriptAPI_Version(${1:double* versionOut})$0"
    },
    "REAPER.JS_REASCRIPTAPI_VERSION lua": {
        "prefix": "reaper.JS_ReaScriptAPI_Version",
        "scope": "lua",
        "description": "Returns the version of the js_ReaScriptAPI extension.\n",
        "body": "reaper.JS_ReaScriptAPI_Version()$0"
    },
    "JS_REASCRIPTAPI_VERSION python": {
        "prefix": "JS_ReaScriptAPI_Version",
        "scope": "python",
        "description": "Returns the version of the js_ReaScriptAPI extension.\n",
        "body": "JS_ReaScriptAPI_Version(${1:versionOut})$0"
    },
    "JS_STRING c": {
        "prefix": "JS_String",
        "scope": "c",
        "description": "Returns the memory contents starting at address[offset] as a packed string. Offset is added as steps of 1 byte (char) each.\n",
        "body": "JS_String(${1:void* pointer},${2:int offset},${3:int lengthChars},${4:char* bufOutNeedBig},${5:int bufOutNeedBig_sz})$0"
    },
    "REAPER.JS_STRING lua": {
        "prefix": "reaper.JS_String",
        "scope": "lua",
        "description": "Returns the memory contents starting at address[offset] as a packed string. Offset is added as steps of 1 byte (char) each.\n",
        "body": "reaper.JS_String(${1:identifier pointer},${2:integer offset},${3:integer lengthChars})$0"
    },
    "JS_STRING python": {
        "prefix": "JS_String",
        "scope": "python",
        "description": "Returns the memory contents starting at address[offset] as a packed string. Offset is added as steps of 1 byte (char) each.\n",
        "body": "JS_String(${1:pointer},${2:offset},${3:lengthChars},${4:bufOutNeedBig},${5:bufOutNeedBig_sz})$0"
    },
    "JS_VKEYS_GETDOWN c": {
        "prefix": "JS_VKeys_GetDown",
        "scope": "c",
        "description": "Returns a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYDOWN messages since cutoffTime.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "JS_VKeys_GetDown(${1:double cutoffTime},${2:char* stateOutNeedBig},${3:int* stateOutNeedBig_sz})$0"
    },
    "REAPER.JS_VKEYS_GETDOWN lua": {
        "prefix": "reaper.JS_VKeys_GetDown",
        "scope": "lua",
        "description": "Returns a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYDOWN messages since cutoffTime.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "reaper.JS_VKeys_GetDown(${1:number cutoffTime})$0"
    },
    "JS_VKEYS_GETDOWN python": {
        "prefix": "JS_VKeys_GetDown",
        "scope": "python",
        "description": "Returns a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYDOWN messages since cutoffTime.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "JS_VKeys_GetDown(${1:cutoffTime},${2:stateOutNeedBig},${3:stateOutNeedBig_sz})$0"
    },
    "JS_VKEYS_GETSTATE c": {
        "prefix": "JS_VKeys_GetState",
        "scope": "c",
        "description": "Retrieves the current states (0 or 1) of all virtual keys, from 0x01 to 0xFF, in a 255-byte array.\ncutoffTime: A key is only regarded as down if it sent a KEYDOWN message\nafter the cut-off time, not followed by KEYUP. (This is useful for\nexcluding old KEYDOWN messages that weren't properly followed by KEYUP.)\nIf cutoffTime is positive, is it interpreted as absolute time in similar format as time_precise().\nIf cutoffTime is negative, it is relative to the current time.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "JS_VKeys_GetState(${1:double cutoffTime},${2:char* stateOutNeedBig},${3:int* stateOutNeedBig_sz})$0"
    },
    "REAPER.JS_VKEYS_GETSTATE lua": {
        "prefix": "reaper.JS_VKeys_GetState",
        "scope": "lua",
        "description": "Retrieves the current states (0 or 1) of all virtual keys, from 0x01 to 0xFF, in a 255-byte array.\ncutoffTime: A key is only regarded as down if it sent a KEYDOWN message\nafter the cut-off time, not followed by KEYUP. (This is useful for\nexcluding old KEYDOWN messages that weren't properly followed by KEYUP.)\nIf cutoffTime is positive, is it interpreted as absolute time in similar format as time_precise().\nIf cutoffTime is negative, it is relative to the current time.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "reaper.JS_VKeys_GetState(${1:number cutoffTime})$0"
    },
    "JS_VKEYS_GETSTATE python": {
        "prefix": "JS_VKeys_GetState",
        "scope": "python",
        "description": "Retrieves the current states (0 or 1) of all virtual keys, from 0x01 to 0xFF, in a 255-byte array.\ncutoffTime: A key is only regarded as down if it sent a KEYDOWN message\nafter the cut-off time, not followed by KEYUP. (This is useful for\nexcluding old KEYDOWN messages that weren't properly followed by KEYUP.)\nIf cutoffTime is positive, is it interpreted as absolute time in similar format as time_precise().\nIf cutoffTime is negative, it is relative to the current time.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "JS_VKeys_GetState(${1:cutoffTime},${2:stateOutNeedBig},${3:stateOutNeedBig_sz})$0"
    },
    "JS_VKEYS_GETUP c": {
        "prefix": "JS_VKeys_GetUp",
        "scope": "c",
        "description": "Return a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYUP messages since cutoffTime.\nNote: Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n",
        "body": "JS_VKeys_GetUp(${1:double cutoffTime},${2:char* stateOutNeedBig},${3:int* stateOutNeedBig_sz})$0"
    },
    "REAPER.JS_VKEYS_GETUP lua": {
        "prefix": "reaper.JS_VKeys_GetUp",
        "scope": "lua",
        "description": "Return a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYUP messages since cutoffTime.\nNote: Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n",
        "body": "reaper.JS_VKeys_GetUp(${1:number cutoffTime})$0"
    },
    "JS_VKEYS_GETUP python": {
        "prefix": "JS_VKeys_GetUp",
        "scope": "python",
        "description": "Return a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYUP messages since cutoffTime.\nNote: Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n",
        "body": "JS_VKeys_GetUp(${1:cutoffTime},${2:stateOutNeedBig},${3:stateOutNeedBig_sz})$0"
    },
    "JS_VKEYS_INTERCEPT c": {
        "prefix": "JS_VKeys_Intercept",
        "scope": "c",
        "description": "Intercepting (blocking) virtual keys work similar to the native function\nPreventUIRefresh:  Each key has a (non-negative) intercept state, and\nthe key is passed through as usual if the state equals 0, or blocked if\nthe state is greater than 0.\nkeyCode: The virtual key code of the key, or -1 to change the state of all keys.\nintercept: A script can increase the intercept state by passing +1, or\nlower the state by passing -1.  Multiple scripts can block the same key,\nand the intercept state may reach up to 255. If zero is passed, the\nintercept state is not changed, but the current state is returned.\nReturns: If keyCode refers to a single key, the intercept state of that\nkey is returned.  If keyCode = -1, the state of the key that is most\nstrongly blocked (highest intercept state) is returned.\n",
        "body": "JS_VKeys_Intercept(${1:int keyCode},${2:int intercept})$0"
    },
    "REAPER.JS_VKEYS_INTERCEPT lua": {
        "prefix": "reaper.JS_VKeys_Intercept",
        "scope": "lua",
        "description": "Intercepting (blocking) virtual keys work similar to the native function\nPreventUIRefresh:  Each key has a (non-negative) intercept state, and\nthe key is passed through as usual if the state equals 0, or blocked if\nthe state is greater than 0.\nkeyCode: The virtual key code of the key, or -1 to change the state of all keys.\nintercept: A script can increase the intercept state by passing +1, or\nlower the state by passing -1.  Multiple scripts can block the same key,\nand the intercept state may reach up to 255. If zero is passed, the\nintercept state is not changed, but the current state is returned.\nReturns: If keyCode refers to a single key, the intercept state of that\nkey is returned.  If keyCode = -1, the state of the key that is most\nstrongly blocked (highest intercept state) is returned.\n",
        "body": "reaper.JS_VKeys_Intercept(${1:integer keyCode},${2:integer intercept})$0"
    },
    "JS_VKEYS_INTERCEPT python": {
        "prefix": "JS_VKeys_Intercept",
        "scope": "python",
        "description": "Intercepting (blocking) virtual keys work similar to the native function\nPreventUIRefresh:  Each key has a (non-negative) intercept state, and\nthe key is passed through as usual if the state equals 0, or blocked if\nthe state is greater than 0.\nkeyCode: The virtual key code of the key, or -1 to change the state of all keys.\nintercept: A script can increase the intercept state by passing +1, or\nlower the state by passing -1.  Multiple scripts can block the same key,\nand the intercept state may reach up to 255. If zero is passed, the\nintercept state is not changed, but the current state is returned.\nReturns: If keyCode refers to a single key, the intercept state of that\nkey is returned.  If keyCode = -1, the state of the key that is most\nstrongly blocked (highest intercept state) is returned.\n",
        "body": "JS_VKeys_Intercept(${1:Int keyCode},${2:Int intercept})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPT c": {
        "prefix": "JS_WindowMessage_Intercept",
        "scope": "c",
        "description": "Begins intercepting a window message type to specified window.\nParameters:\n* message: a single message type to be intercepted, either in WM_ or\nhexadecimal format. For example \"WM_SETCURSOR\" or \"0x0020\".\n* passThrough: Whether message should be blocked (false) or passed through (true) to the window.\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process / window not valid.\n* -6: Could not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n* Mouse events are typically received by the child window under the mouse, not the parent window.\nKeyboard events are usually *not* received by any individual window. To intercept keyboard events, use the VKey functions.\n",
        "body": "JS_WindowMessage_Intercept(${1:void* windowHWND},${2:const char* message},${3:bool passThrough})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_INTERCEPT lua": {
        "prefix": "reaper.JS_WindowMessage_Intercept",
        "scope": "lua",
        "description": "Begins intercepting a window message type to specified window.\nParameters:\n* message: a single message type to be intercepted, either in WM_ or\nhexadecimal format. For example \"WM_SETCURSOR\" or \"0x0020\".\n* passThrough: Whether message should be blocked (false) or passed through (true) to the window.\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process / window not valid.\n* -6: Could not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n* Mouse events are typically received by the child window under the mouse, not the parent window.\nKeyboard events are usually *not* received by any individual window. To intercept keyboard events, use the VKey functions.\n",
        "body": "reaper.JS_WindowMessage_Intercept(${1:identifier windowHWND},${2:string message},${3:boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPT python": {
        "prefix": "JS_WindowMessage_Intercept",
        "scope": "python",
        "description": "Begins intercepting a window message type to specified window.\nParameters:\n* message: a single message type to be intercepted, either in WM_ or\nhexadecimal format. For example \"WM_SETCURSOR\" or \"0x0020\".\n* passThrough: Whether message should be blocked (false) or passed through (true) to the window.\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process / window not valid.\n* -6: Could not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n* Mouse events are typically received by the child window under the mouse, not the parent window.\nKeyboard events are usually *not* received by any individual window. To intercept keyboard events, use the VKey functions.\n",
        "body": "JS_WindowMessage_Intercept(${1:void windowHWND},${2:String message},${3:Boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPTLIST c": {
        "prefix": "JS_WindowMessage_InterceptList",
        "scope": "c",
        "description": "Begins intercepting window messages to specified window.\nParameters:\n* messages: comma-separated string of message types to be intercepted\n(either in WM_ or hexadecimal format), each with a \"block\" or\n\"passthrough\" modifier to specify whether the message should be blocked\nor passed through to the window. For example \"WM_SETCURSOR:block,\n0x0201:passthrough\".\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -1: windowHWND is not a valid window.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process.\n* -6: COuld not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n",
        "body": "JS_WindowMessage_InterceptList(${1:void* windowHWND},${2:const char* messages})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_INTERCEPTLIST lua": {
        "prefix": "reaper.JS_WindowMessage_InterceptList",
        "scope": "lua",
        "description": "Begins intercepting window messages to specified window.\nParameters:\n* messages: comma-separated string of message types to be intercepted\n(either in WM_ or hexadecimal format), each with a \"block\" or\n\"passthrough\" modifier to specify whether the message should be blocked\nor passed through to the window. For example \"WM_SETCURSOR:block,\n0x0201:passthrough\".\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -1: windowHWND is not a valid window.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process.\n* -6: COuld not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n",
        "body": "reaper.JS_WindowMessage_InterceptList(${1:identifier windowHWND},${2:string messages})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPTLIST python": {
        "prefix": "JS_WindowMessage_InterceptList",
        "scope": "python",
        "description": "Begins intercepting window messages to specified window.\nParameters:\n* messages: comma-separated string of message types to be intercepted\n(either in WM_ or hexadecimal format), each with a \"block\" or\n\"passthrough\" modifier to specify whether the message should be blocked\nor passed through to the window. For example \"WM_SETCURSOR:block,\n0x0201:passthrough\".\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -1: windowHWND is not a valid window.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process.\n* -6: COuld not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n",
        "body": "JS_WindowMessage_InterceptList(${1:void windowHWND},${2:String messages})$0"
    },
    "JS_WINDOWMESSAGE_LISTINTERCEPTS c": {
        "prefix": "JS_WindowMessage_ListIntercepts",
        "scope": "c",
        "description": "Returns a string with a list of all message types currently being intercepted for the specified window.\n",
        "body": "JS_WindowMessage_ListIntercepts(${1:void* windowHWND},${2:char* listOutNeedBig},${3:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_LISTINTERCEPTS lua": {
        "prefix": "reaper.JS_WindowMessage_ListIntercepts",
        "scope": "lua",
        "description": "Returns a string with a list of all message types currently being intercepted for the specified window.\n",
        "body": "reaper.JS_WindowMessage_ListIntercepts(${1:identifier windowHWND})$0"
    },
    "JS_WINDOWMESSAGE_LISTINTERCEPTS python": {
        "prefix": "JS_WindowMessage_ListIntercepts",
        "scope": "python",
        "description": "Returns a string with a list of all message types currently being intercepted for the specified window.\n",
        "body": "JS_WindowMessage_ListIntercepts(${1:windowHWND},${2:listOutNeedBig},${3:listOutNeedBig_sz})$0"
    },
    "JS_WINDOWMESSAGE_PASSTHROUGH c": {
        "prefix": "JS_WindowMessage_PassThrough",
        "scope": "c",
        "description": "Changes the passthrough setting of a message type that is already being intercepted.\nReturns 1 if successful, 0 if the message type is not yet being intercepted, or -2 if the argument could not be parsed.\n",
        "body": "JS_WindowMessage_PassThrough(${1:void* windowHWND},${2:const char* message},${3:bool passThrough})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_PASSTHROUGH lua": {
        "prefix": "reaper.JS_WindowMessage_PassThrough",
        "scope": "lua",
        "description": "Changes the passthrough setting of a message type that is already being intercepted.\nReturns 1 if successful, 0 if the message type is not yet being intercepted, or -2 if the argument could not be parsed.\n",
        "body": "reaper.JS_WindowMessage_PassThrough(${1:identifier windowHWND},${2:string message},${3:boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_PASSTHROUGH python": {
        "prefix": "JS_WindowMessage_PassThrough",
        "scope": "python",
        "description": "Changes the passthrough setting of a message type that is already being intercepted.\nReturns 1 if successful, 0 if the message type is not yet being intercepted, or -2 if the argument could not be parsed.\n",
        "body": "JS_WindowMessage_PassThrough(${1:void windowHWND},${2:String message},${3:Boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_PEEK c": {
        "prefix": "JS_WindowMessage_Peek",
        "scope": "c",
        "description": "Polls the state of an intercepted message.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\nReturns:\n* A retval of false indicates that the message type is not being intercepted in the specified window.\n* All messages are timestamped. A time of 0 indicates that no message if this type has been intercepted yet.\n* For more information about wParam and lParam for different message types, refer to Win32 C++ documentation.\n* For example, in the case of mousewheel, returns mousewheel delta, modifier keys, x position and y position.\n* wParamHigh, lParamLow and lParamHigh are signed, whereas wParamLow is unsigned.\n",
        "body": "JS_WindowMessage_Peek(${1:void* windowHWND},${2:const char* message},${3:bool* passedThroughOut},${4:double* timeOut},${5:int* wParamLowOut},${6:int* wParamHighOut},${7:int* lParamLowOut},${8:int* lParamHighOut})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_PEEK lua": {
        "prefix": "reaper.JS_WindowMessage_Peek",
        "scope": "lua",
        "description": "Polls the state of an intercepted message.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\nReturns:\n* A retval of false indicates that the message type is not being intercepted in the specified window.\n* All messages are timestamped. A time of 0 indicates that no message if this type has been intercepted yet.\n* For more information about wParam and lParam for different message types, refer to Win32 C++ documentation.\n* For example, in the case of mousewheel, returns mousewheel delta, modifier keys, x position and y position.\n* wParamHigh, lParamLow and lParamHigh are signed, whereas wParamLow is unsigned.\n",
        "body": "reaper.JS_WindowMessage_Peek(${1:identifier windowHWND},${2:string message})$0"
    },
    "JS_WINDOWMESSAGE_PEEK python": {
        "prefix": "JS_WindowMessage_Peek",
        "scope": "python",
        "description": "Polls the state of an intercepted message.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\nReturns:\n* A retval of false indicates that the message type is not being intercepted in the specified window.\n* All messages are timestamped. A time of 0 indicates that no message if this type has been intercepted yet.\n* For more information about wParam and lParam for different message types, refer to Win32 C++ documentation.\n* For example, in the case of mousewheel, returns mousewheel delta, modifier keys, x position and y position.\n* wParamHigh, lParamLow and lParamHigh are signed, whereas wParamLow is unsigned.\n",
        "body": "JS_WindowMessage_Peek(${1:windowHWND},${2:message},${3:passedThroughOut},${4:timeOut},${5:wParamLowOut},${6:wParamHighOut},${7:lParamLowOut},${8:lParamHighOut})$0"
    },
    "JS_WINDOWMESSAGE_POST c": {
        "prefix": "JS_WindowMessage_Post",
        "scope": "c",
        "description": "If the specified window and message type are not currently being\nintercepted by a script, this function will post the message in the\nmessage queue of the specified window, and return without waiting.\nIf the window and message type are currently being intercepted, the\nmessage will be sent directly to the original window process, similar to\nWindowMessage_Send, thereby skipping any intercepts.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter values, refer to documentation for the Win32 C++ function PostMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "JS_WindowMessage_Post(${1:void* windowHWND},${2:const char* message},${3:double wParam},${4:int wParamHighWord},${5:double lParam},${6:int lParamHighWord})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_POST lua": {
        "prefix": "reaper.JS_WindowMessage_Post",
        "scope": "lua",
        "description": "If the specified window and message type are not currently being\nintercepted by a script, this function will post the message in the\nmessage queue of the specified window, and return without waiting.\nIf the window and message type are currently being intercepted, the\nmessage will be sent directly to the original window process, similar to\nWindowMessage_Send, thereby skipping any intercepts.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter values, refer to documentation for the Win32 C++ function PostMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "reaper.JS_WindowMessage_Post(${1:identifier windowHWND},${2:string message},${3:number wParam},${4:integer wParamHighWord},${5:number lParam},${6:integer lParamHighWord})$0"
    },
    "JS_WINDOWMESSAGE_POST python": {
        "prefix": "JS_WindowMessage_Post",
        "scope": "python",
        "description": "If the specified window and message type are not currently being\nintercepted by a script, this function will post the message in the\nmessage queue of the specified window, and return without waiting.\nIf the window and message type are currently being intercepted, the\nmessage will be sent directly to the original window process, similar to\nWindowMessage_Send, thereby skipping any intercepts.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter values, refer to documentation for the Win32 C++ function PostMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "JS_WindowMessage_Post(${1:void windowHWND},${2:String message},${3:Float wParam},${4:Int wParamHighWord},${5:Float lParam},${6:Int lParamHighWord})$0"
    },
    "JS_WINDOWMESSAGE_RELEASE c": {
        "prefix": "JS_WindowMessage_Release",
        "scope": "c",
        "description": "Release intercepts of specified message types.\nParameters:\n* messages: \"WM_SETCURSOR,WM_MOUSEHWHEEL\" or \"0x0020,0x020E\", for example.\n",
        "body": "JS_WindowMessage_Release(${1:void* windowHWND},${2:const char* messages})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_RELEASE lua": {
        "prefix": "reaper.JS_WindowMessage_Release",
        "scope": "lua",
        "description": "Release intercepts of specified message types.\nParameters:\n* messages: \"WM_SETCURSOR,WM_MOUSEHWHEEL\" or \"0x0020,0x020E\", for example.\n",
        "body": "reaper.JS_WindowMessage_Release(${1:identifier windowHWND},${2:string messages})$0"
    },
    "JS_WINDOWMESSAGE_RELEASE python": {
        "prefix": "JS_WindowMessage_Release",
        "scope": "python",
        "description": "Release intercepts of specified message types.\nParameters:\n* messages: \"WM_SETCURSOR,WM_MOUSEHWHEEL\" or \"0x0020,0x020E\", for example.\n",
        "body": "JS_WindowMessage_Release(${1:void windowHWND},${2:String messages})$0"
    },
    "JS_WINDOWMESSAGE_RELEASEALL c": {
        "prefix": "JS_WindowMessage_ReleaseAll",
        "scope": "c",
        "description": "Release script intercepts of window messages for all windows.\n",
        "body": "JS_WindowMessage_ReleaseAll()$0"
    },
    "REAPER.JS_WINDOWMESSAGE_RELEASEALL lua": {
        "prefix": "reaper.JS_WindowMessage_ReleaseAll",
        "scope": "lua",
        "description": "Release script intercepts of window messages for all windows.\n",
        "body": "reaper.JS_WindowMessage_ReleaseAll()$0"
    },
    "JS_WINDOWMESSAGE_RELEASEALL python": {
        "prefix": "JS_WindowMessage_ReleaseAll",
        "scope": "python",
        "description": "Release script intercepts of window messages for all windows.\n",
        "body": "JS_WindowMessage_ReleaseAll()$0"
    },
    "JS_WINDOWMESSAGE_RELEASEWINDOW c": {
        "prefix": "JS_WindowMessage_ReleaseWindow",
        "scope": "c",
        "description": "Release script intercepts of window messages for specified window.\n",
        "body": "JS_WindowMessage_ReleaseWindow(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_RELEASEWINDOW lua": {
        "prefix": "reaper.JS_WindowMessage_ReleaseWindow",
        "scope": "lua",
        "description": "Release script intercepts of window messages for specified window.\n",
        "body": "reaper.JS_WindowMessage_ReleaseWindow(${1:identifier windowHWND})$0"
    },
    "JS_WINDOWMESSAGE_RELEASEWINDOW python": {
        "prefix": "JS_WindowMessage_ReleaseWindow",
        "scope": "python",
        "description": "Release script intercepts of window messages for specified window.\n",
        "body": "JS_WindowMessage_ReleaseWindow(${1:void windowHWND})$0"
    },
    "JS_WINDOWMESSAGE_SEND c": {
        "prefix": "JS_WindowMessage_Send",
        "scope": "c",
        "description": "Sends a message to the specified window by calling the window process\ndirectly, and only returns after the message has been processed. Any\nintercepts of the message by scripts will be skipped, and the message\ncan therefore not be blocked.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter and return values, refer to documentation for the Win32 C++ function SendMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "JS_WindowMessage_Send(${1:void* windowHWND},${2:const char* message},${3:double wParam},${4:int wParamHighWord},${5:double lParam},${6:int lParamHighWord})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_SEND lua": {
        "prefix": "reaper.JS_WindowMessage_Send",
        "scope": "lua",
        "description": "Sends a message to the specified window by calling the window process\ndirectly, and only returns after the message has been processed. Any\nintercepts of the message by scripts will be skipped, and the message\ncan therefore not be blocked.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter and return values, refer to documentation for the Win32 C++ function SendMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "reaper.JS_WindowMessage_Send(${1:identifier windowHWND},${2:string message},${3:number wParam},${4:integer wParamHighWord},${5:number lParam},${6:integer lParamHighWord})$0"
    },
    "JS_WINDOWMESSAGE_SEND python": {
        "prefix": "JS_WindowMessage_Send",
        "scope": "python",
        "description": "Sends a message to the specified window by calling the window process\ndirectly, and only returns after the message has been processed. Any\nintercepts of the message by scripts will be skipped, and the message\ncan therefore not be blocked.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter and return values, refer to documentation for the Win32 C++ function SendMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "JS_WindowMessage_Send(${1:void windowHWND},${2:String message},${3:Float wParam},${4:Int wParamHighWord},${5:Float lParam},${6:Int lParamHighWord})$0"
    },
    "JS_WINDOW_ADDRESSFROMHANDLE c": {
        "prefix": "JS_Window_AddressFromHandle",
        "scope": "c",
        "description": "\n",
        "body": "JS_Window_AddressFromHandle(${1:void* handle},${2:double* addressOut})$0"
    },
    "REAPER.JS_WINDOW_ADDRESSFROMHANDLE lua": {
        "prefix": "reaper.JS_Window_AddressFromHandle",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_Window_AddressFromHandle(${1:identifier handle})$0"
    },
    "JS_WINDOW_ADDRESSFROMHANDLE python": {
        "prefix": "JS_Window_AddressFromHandle",
        "scope": "python",
        "description": "\n",
        "body": "JS_Window_AddressFromHandle(${1:handle},${2:addressOut})$0"
    },
    "JS_WINDOW_ARRAYALLCHILD c": {
        "prefix": "JS_Window_ArrayAllChild",
        "scope": "c",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "JS_Window_ArrayAllChild(${1:void* parentHWND},${2:void* reaperarray})$0"
    },
    "REAPER.JS_WINDOW_ARRAYALLCHILD lua": {
        "prefix": "reaper.JS_Window_ArrayAllChild",
        "scope": "lua",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "reaper.JS_Window_ArrayAllChild(${1:identifier parentHWND},${2:identifier reaperarray})$0"
    },
    "JS_WINDOW_ARRAYALLCHILD python": {
        "prefix": "JS_Window_ArrayAllChild",
        "scope": "python",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "JS_Window_ArrayAllChild(${1:void parentHWND},${2:void reaperarray})$0"
    },
    "JS_WINDOW_ARRAYALLTOP c": {
        "prefix": "JS_Window_ArrayAllTop",
        "scope": "c",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "JS_Window_ArrayAllTop(${1:void* reaperarray})$0"
    },
    "REAPER.JS_WINDOW_ARRAYALLTOP lua": {
        "prefix": "reaper.JS_Window_ArrayAllTop",
        "scope": "lua",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "reaper.JS_Window_ArrayAllTop(${1:identifier reaperarray})$0"
    },
    "JS_WINDOW_ARRAYALLTOP python": {
        "prefix": "JS_Window_ArrayAllTop",
        "scope": "python",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "JS_Window_ArrayAllTop(${1:void reaperarray})$0"
    },
    "JS_WINDOW_ARRAYFIND c": {
        "prefix": "JS_Window_ArrayFind",
        "scope": "c",
        "description": "Finds all windows, whether top-level or child, whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "JS_Window_ArrayFind(${1:const char* title},${2:bool exact},${3:void* reaperarray})$0"
    },
    "REAPER.JS_WINDOW_ARRAYFIND lua": {
        "prefix": "reaper.JS_Window_ArrayFind",
        "scope": "lua",
        "description": "Finds all windows, whether top-level or child, whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "reaper.JS_Window_ArrayFind(${1:string title},${2:boolean exact},${3:identifier reaperarray})$0"
    },
    "JS_WINDOW_ARRAYFIND python": {
        "prefix": "JS_Window_ArrayFind",
        "scope": "python",
        "description": "Finds all windows, whether top-level or child, whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "JS_Window_ArrayFind(${1:String title},${2:Boolean exact},${3:void reaperarray})$0"
    },
    "JS_WINDOW_ATTACHRESIZEGRIP c": {
        "prefix": "JS_Window_AttachResizeGrip",
        "scope": "c",
        "description": "\n",
        "body": "JS_Window_AttachResizeGrip(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ATTACHRESIZEGRIP lua": {
        "prefix": "reaper.JS_Window_AttachResizeGrip",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_Window_AttachResizeGrip(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_ATTACHRESIZEGRIP python": {
        "prefix": "JS_Window_AttachResizeGrip",
        "scope": "python",
        "description": "\n",
        "body": "JS_Window_AttachResizeGrip(${1:void windowHWND})$0"
    },
    "JS_WINDOW_ATTACHTOPMOSTPIN c": {
        "prefix": "JS_Window_AttachTopmostPin",
        "scope": "c",
        "description": "Attaches a \"pin on top\" button to the window frame. The button should remember its state when closing and re-opening the window.\nWARNING: This function does not yet work on Linux.\n",
        "body": "JS_Window_AttachTopmostPin(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ATTACHTOPMOSTPIN lua": {
        "prefix": "reaper.JS_Window_AttachTopmostPin",
        "scope": "lua",
        "description": "Attaches a \"pin on top\" button to the window frame. The button should remember its state when closing and re-opening the window.\nWARNING: This function does not yet work on Linux.\n",
        "body": "reaper.JS_Window_AttachTopmostPin(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_ATTACHTOPMOSTPIN python": {
        "prefix": "JS_Window_AttachTopmostPin",
        "scope": "python",
        "description": "Attaches a \"pin on top\" button to the window frame. The button should remember its state when closing and re-opening the window.\nWARNING: This function does not yet work on Linux.\n",
        "body": "JS_Window_AttachTopmostPin(${1:void windowHWND})$0"
    },
    "JS_WINDOW_CLIENTTOSCREEN c": {
        "prefix": "JS_Window_ClientToScreen",
        "scope": "c",
        "description": "Converts the client-area coordinates of a specified point to screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "JS_Window_ClientToScreen(${1:void* windowHWND},${2:int x},${3:int y},${4:int* xOut},${5:int* yOut})$0"
    },
    "REAPER.JS_WINDOW_CLIENTTOSCREEN lua": {
        "prefix": "reaper.JS_Window_ClientToScreen",
        "scope": "lua",
        "description": "Converts the client-area coordinates of a specified point to screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "reaper.JS_Window_ClientToScreen(${1:identifier windowHWND},${2:integer x},${3:integer y})$0"
    },
    "JS_WINDOW_CLIENTTOSCREEN python": {
        "prefix": "JS_Window_ClientToScreen",
        "scope": "python",
        "description": "Converts the client-area coordinates of a specified point to screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "JS_Window_ClientToScreen(${1:windowHWND},${2:x},${3:y},${4:xOut},${5:yOut})$0"
    },
    "JS_WINDOW_CREATE c": {
        "prefix": "JS_Window_Create",
        "scope": "c",
        "description": "Creates a modeless window with WS_OVERLAPPEDWINDOW style and only\nrudimentary features. Scripts can paint into the window using GDI or\nLICE/Composite functions (and JS_Window_InvalidateRect to trigger\nre-painting).\nstyle: An optional parameter that overrides the default style. The\nstring may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implemented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\nclassName: On Windows, only standard ANSI characters are supported.\nownerHWND: Optional parameter, only available on WindowsOS.  Usually\neither the REAPER main window or another script window, and useful for\nensuring that the created window automatically closes when the owner is\nclosed.\nNOTE: On Linux and macOS, the window contents are only updated *between*\ndefer cycles, so the window cannot be animated by for/while loops\nwithin a single defer cycle.\n",
        "body": "JS_Window_Create(${1:const char* title},${2:const char* className},${3:int x},${4:int y},${5:int w},${6:int h},${7:char* styleOptional},${8:void* ownerHWNDOptional})$0"
    },
    "REAPER.JS_WINDOW_CREATE lua": {
        "prefix": "reaper.JS_Window_Create",
        "scope": "lua",
        "description": "Creates a modeless window with WS_OVERLAPPEDWINDOW style and only\nrudimentary features. Scripts can paint into the window using GDI or\nLICE/Composite functions (and JS_Window_InvalidateRect to trigger\nre-painting).\nstyle: An optional parameter that overrides the default style. The\nstring may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implemented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\nclassName: On Windows, only standard ANSI characters are supported.\nownerHWND: Optional parameter, only available on WindowsOS.  Usually\neither the REAPER main window or another script window, and useful for\nensuring that the created window automatically closes when the owner is\nclosed.\nNOTE: On Linux and macOS, the window contents are only updated *between*\ndefer cycles, so the window cannot be animated by for/while loops\nwithin a single defer cycle.\n",
        "body": "reaper.JS_Window_Create(${1:string title},${2:string className},${3:integer x},${4:integer y},${5:integer w},${6:integer h},${7:optional string style},${8:identifier ownerHWND})$0"
    },
    "JS_WINDOW_CREATE python": {
        "prefix": "JS_Window_Create",
        "scope": "python",
        "description": "Creates a modeless window with WS_OVERLAPPEDWINDOW style and only\nrudimentary features. Scripts can paint into the window using GDI or\nLICE/Composite functions (and JS_Window_InvalidateRect to trigger\nre-painting).\nstyle: An optional parameter that overrides the default style. The\nstring may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implemented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\nclassName: On Windows, only standard ANSI characters are supported.\nownerHWND: Optional parameter, only available on WindowsOS.  Usually\neither the REAPER main window or another script window, and useful for\nensuring that the created window automatically closes when the owner is\nclosed.\nNOTE: On Linux and macOS, the window contents are only updated *between*\ndefer cycles, so the window cannot be animated by for/while loops\nwithin a single defer cycle.\n",
        "body": "JS_Window_Create(${1:title},${2:className},${3:x},${4:y},${5:w},${6:h},${7:styleOptional},${8:ownerHWNDOptional})$0"
    },
    "JS_WINDOW_DESTROY c": {
        "prefix": "JS_Window_Destroy",
        "scope": "c",
        "description": "Destroys the specified window.\n",
        "body": "JS_Window_Destroy(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_DESTROY lua": {
        "prefix": "reaper.JS_Window_Destroy",
        "scope": "lua",
        "description": "Destroys the specified window.\n",
        "body": "reaper.JS_Window_Destroy(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_DESTROY python": {
        "prefix": "JS_Window_Destroy",
        "scope": "python",
        "description": "Destroys the specified window.\n",
        "body": "JS_Window_Destroy(${1:void windowHWND})$0"
    },
    "JS_WINDOW_ENABLE c": {
        "prefix": "JS_Window_Enable",
        "scope": "c",
        "description": "Enables or disables mouse and keyboard input to the specified window or control.\n",
        "body": "JS_Window_Enable(${1:void* windowHWND},${2:bool enable})$0"
    },
    "REAPER.JS_WINDOW_ENABLE lua": {
        "prefix": "reaper.JS_Window_Enable",
        "scope": "lua",
        "description": "Enables or disables mouse and keyboard input to the specified window or control.\n",
        "body": "reaper.JS_Window_Enable(${1:identifier windowHWND},${2:boolean enable})$0"
    },
    "JS_WINDOW_ENABLE python": {
        "prefix": "JS_Window_Enable",
        "scope": "python",
        "description": "Enables or disables mouse and keyboard input to the specified window or control.\n",
        "body": "JS_Window_Enable(${1:void windowHWND},${2:Boolean enable})$0"
    },
    "JS_WINDOW_ENABLEMETAL c": {
        "prefix": "JS_Window_EnableMetal",
        "scope": "c",
        "description": "On macOS, returns the Metal graphics setting:\n2 = Metal enabled and support GetDC()/ReleaseDC() for drawing (more overhead).\n1 = Metal enabled.\n0 = N/A (Windows and Linux).\n-1 = non-metal async layered mode.\n-2 = non-metal non-async layered mode.\nWARNING: If using mode -1, any BitBlt()/StretchBlt() MUST have the\nsource bitmap persist. If it is resized after Blit it could cause\ncrashes.\n",
        "body": "JS_Window_EnableMetal(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ENABLEMETAL lua": {
        "prefix": "reaper.JS_Window_EnableMetal",
        "scope": "lua",
        "description": "On macOS, returns the Metal graphics setting:\n2 = Metal enabled and support GetDC()/ReleaseDC() for drawing (more overhead).\n1 = Metal enabled.\n0 = N/A (Windows and Linux).\n-1 = non-metal async layered mode.\n-2 = non-metal non-async layered mode.\nWARNING: If using mode -1, any BitBlt()/StretchBlt() MUST have the\nsource bitmap persist. If it is resized after Blit it could cause\ncrashes.\n",
        "body": "reaper.JS_Window_EnableMetal(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_ENABLEMETAL python": {
        "prefix": "JS_Window_EnableMetal",
        "scope": "python",
        "description": "On macOS, returns the Metal graphics setting:\n2 = Metal enabled and support GetDC()/ReleaseDC() for drawing (more overhead).\n1 = Metal enabled.\n0 = N/A (Windows and Linux).\n-1 = non-metal async layered mode.\n-2 = non-metal non-async layered mode.\nWARNING: If using mode -1, any BitBlt()/StretchBlt() MUST have the\nsource bitmap persist. If it is resized after Blit it could cause\ncrashes.\n",
        "body": "JS_Window_EnableMetal(${1:void windowHWND})$0"
    },
    "JS_WINDOW_FIND c": {
        "prefix": "JS_Window_Find",
        "scope": "c",
        "description": "Returns a HWND to a window whose title matches the specified string.\n* Unlike the Win32 function FindWindow, this function searches\ntop-level as well as child windows, so that the target window can be\nfound irrespective of docked state.\n* In addition, the function can optionally match substrings of the title.\n* Matching is not case sensitive.\nParameters:\n* exact: Match entire title, or match substring of title.\n",
        "body": "JS_Window_Find(${1:const char* title},${2:bool exact})$0"
    },
    "REAPER.JS_WINDOW_FIND lua": {
        "prefix": "reaper.JS_Window_Find",
        "scope": "lua",
        "description": "Returns a HWND to a window whose title matches the specified string.\n* Unlike the Win32 function FindWindow, this function searches\ntop-level as well as child windows, so that the target window can be\nfound irrespective of docked state.\n* In addition, the function can optionally match substrings of the title.\n* Matching is not case sensitive.\nParameters:\n* exact: Match entire title, or match substring of title.\n",
        "body": "reaper.JS_Window_Find(${1:string title},${2:boolean exact})$0"
    },
    "JS_WINDOW_FIND python": {
        "prefix": "JS_Window_Find",
        "scope": "python",
        "description": "Returns a HWND to a window whose title matches the specified string.\n* Unlike the Win32 function FindWindow, this function searches\ntop-level as well as child windows, so that the target window can be\nfound irrespective of docked state.\n* In addition, the function can optionally match substrings of the title.\n* Matching is not case sensitive.\nParameters:\n* exact: Match entire title, or match substring of title.\n",
        "body": "JS_Window_Find(${1:String title},${2:Boolean exact})$0"
    },
    "JS_WINDOW_FINDCHILD c": {
        "prefix": "JS_Window_FindChild",
        "scope": "c",
        "description": "Returns a HWND to a child window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "JS_Window_FindChild(${1:void* parentHWND},${2:const char* title},${3:bool exact})$0"
    },
    "REAPER.JS_WINDOW_FINDCHILD lua": {
        "prefix": "reaper.JS_Window_FindChild",
        "scope": "lua",
        "description": "Returns a HWND to a child window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "reaper.JS_Window_FindChild(${1:identifier parentHWND},${2:string title},${3:boolean exact})$0"
    },
    "JS_WINDOW_FINDCHILD python": {
        "prefix": "JS_Window_FindChild",
        "scope": "python",
        "description": "Returns a HWND to a child window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "JS_Window_FindChild(${1:void parentHWND},${2:String title},${3:Boolean exact})$0"
    },
    "JS_WINDOW_FINDCHILDBYID c": {
        "prefix": "JS_Window_FindChildByID",
        "scope": "c",
        "description": "Similar to the C++ WIN32 function GetDlgItem, this function finds child windows by ID.\n(The ID of a window may be retrieved by JS_Window_GetLongPtr.)\n",
        "body": "JS_Window_FindChildByID(${1:void* parentHWND},${2:int ID})$0"
    },
    "REAPER.JS_WINDOW_FINDCHILDBYID lua": {
        "prefix": "reaper.JS_Window_FindChildByID",
        "scope": "lua",
        "description": "Similar to the C++ WIN32 function GetDlgItem, this function finds child windows by ID.\n(The ID of a window may be retrieved by JS_Window_GetLongPtr.)\n",
        "body": "reaper.JS_Window_FindChildByID(${1:identifier parentHWND},${2:integer ID})$0"
    },
    "JS_WINDOW_FINDCHILDBYID python": {
        "prefix": "JS_Window_FindChildByID",
        "scope": "python",
        "description": "Similar to the C++ WIN32 function GetDlgItem, this function finds child windows by ID.\n(The ID of a window may be retrieved by JS_Window_GetLongPtr.)\n",
        "body": "JS_Window_FindChildByID(${1:void parentHWND},${2:Int ID})$0"
    },
    "JS_WINDOW_FINDEX c": {
        "prefix": "JS_Window_FindEx",
        "scope": "c",
        "description": "Returns a handle to a child window whose class and title match the specified strings.\nParameters: * childWindow: The function searches child windows,\nbeginning with the window *after* the specified child window. If\nchildHWND is equal to parentHWND, the search begins with the first child\nwindow of parentHWND.\n* title: An empty string, \"\", will match all windows. (Search is not case sensitive.)\n",
        "body": "JS_Window_FindEx(${1:void* parentHWND},${2:void* childHWND},${3:const char* className},${4:const char* title})$0"
    },
    "REAPER.JS_WINDOW_FINDEX lua": {
        "prefix": "reaper.JS_Window_FindEx",
        "scope": "lua",
        "description": "Returns a handle to a child window whose class and title match the specified strings.\nParameters: * childWindow: The function searches child windows,\nbeginning with the window *after* the specified child window. If\nchildHWND is equal to parentHWND, the search begins with the first child\nwindow of parentHWND.\n* title: An empty string, \"\", will match all windows. (Search is not case sensitive.)\n",
        "body": "reaper.JS_Window_FindEx(${1:identifier parentHWND},${2:identifier childHWND},${3:string className},${4:string title})$0"
    },
    "JS_WINDOW_FINDEX python": {
        "prefix": "JS_Window_FindEx",
        "scope": "python",
        "description": "Returns a handle to a child window whose class and title match the specified strings.\nParameters: * childWindow: The function searches child windows,\nbeginning with the window *after* the specified child window. If\nchildHWND is equal to parentHWND, the search begins with the first child\nwindow of parentHWND.\n* title: An empty string, \"\", will match all windows. (Search is not case sensitive.)\n",
        "body": "JS_Window_FindEx(${1:void parentHWND},${2:void childHWND},${3:String className},${4:String title})$0"
    },
    "JS_WINDOW_FINDTOP c": {
        "prefix": "JS_Window_FindTop",
        "scope": "c",
        "description": "Returns a HWND to a top-level window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "JS_Window_FindTop(${1:const char* title},${2:bool exact})$0"
    },
    "REAPER.JS_WINDOW_FINDTOP lua": {
        "prefix": "reaper.JS_Window_FindTop",
        "scope": "lua",
        "description": "Returns a HWND to a top-level window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "reaper.JS_Window_FindTop(${1:string title},${2:boolean exact})$0"
    },
    "JS_WINDOW_FINDTOP python": {
        "prefix": "JS_Window_FindTop",
        "scope": "python",
        "description": "Returns a HWND to a top-level window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "JS_Window_FindTop(${1:String title},${2:Boolean exact})$0"
    },
    "JS_WINDOW_FROMPOINT c": {
        "prefix": "JS_Window_FromPoint",
        "scope": "c",
        "description": "Retrieves a HWND to the window that contains the specified point.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "JS_Window_FromPoint(${1:int x},${2:int y})$0"
    },
    "REAPER.JS_WINDOW_FROMPOINT lua": {
        "prefix": "reaper.JS_Window_FromPoint",
        "scope": "lua",
        "description": "Retrieves a HWND to the window that contains the specified point.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "reaper.JS_Window_FromPoint(${1:integer x},${2:integer y})$0"
    },
    "JS_WINDOW_FROMPOINT python": {
        "prefix": "JS_Window_FromPoint",
        "scope": "python",
        "description": "Retrieves a HWND to the window that contains the specified point.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "JS_Window_FromPoint(${1:Int x},${2:Int y})$0"
    },
    "JS_WINDOW_GETCLASSNAME c": {
        "prefix": "JS_Window_GetClassName",
        "scope": "c",
        "description": "WARNING: May not be fully implemented on macOS and Linux.\n",
        "body": "JS_Window_GetClassName(${1:void* windowHWND},${2:char* classOut},${3:int classOut_sz})$0"
    },
    "REAPER.JS_WINDOW_GETCLASSNAME lua": {
        "prefix": "reaper.JS_Window_GetClassName",
        "scope": "lua",
        "description": "WARNING: May not be fully implemented on macOS and Linux.\n",
        "body": "reaper.JS_Window_GetClassName(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETCLASSNAME python": {
        "prefix": "JS_Window_GetClassName",
        "scope": "python",
        "description": "WARNING: May not be fully implemented on macOS and Linux.\n",
        "body": "JS_Window_GetClassName(${1:windowHWND},${2:classOut},${3:classOut_sz})$0"
    },
    "JS_WINDOW_GETCLIENTRECT c": {
        "prefix": "JS_Window_GetClientRect",
        "scope": "c",
        "description": "Retrieves the screen coordinates of the client area rectangle of the specified window.\nNOTES:\n* Unlike the C++ function GetClientRect, this function returns the\nscreen coordinates, not the width and height. To get the client size,\nuse GetClientSize.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "JS_Window_GetClientRect(${1:void* windowHWND},${2:int* leftOut},${3:int* topOut},${4:int* rightOut},${5:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_GETCLIENTRECT lua": {
        "prefix": "reaper.JS_Window_GetClientRect",
        "scope": "lua",
        "description": "Retrieves the screen coordinates of the client area rectangle of the specified window.\nNOTES:\n* Unlike the C++ function GetClientRect, this function returns the\nscreen coordinates, not the width and height. To get the client size,\nuse GetClientSize.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "reaper.JS_Window_GetClientRect(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETCLIENTRECT python": {
        "prefix": "JS_Window_GetClientRect",
        "scope": "python",
        "description": "Retrieves the screen coordinates of the client area rectangle of the specified window.\nNOTES:\n* Unlike the C++ function GetClientRect, this function returns the\nscreen coordinates, not the width and height. To get the client size,\nuse GetClientSize.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "JS_Window_GetClientRect(${1:windowHWND},${2:leftOut},${3:topOut},${4:rightOut},${5:bottomOut})$0"
    },
    "JS_WINDOW_GETCLIENTSIZE c": {
        "prefix": "JS_Window_GetClientSize",
        "scope": "c",
        "description": "\n",
        "body": "JS_Window_GetClientSize(${1:void* windowHWND},${2:int* widthOut},${3:int* heightOut})$0"
    },
    "REAPER.JS_WINDOW_GETCLIENTSIZE lua": {
        "prefix": "reaper.JS_Window_GetClientSize",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.JS_Window_GetClientSize(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETCLIENTSIZE python": {
        "prefix": "JS_Window_GetClientSize",
        "scope": "python",
        "description": "\n",
        "body": "JS_Window_GetClientSize(${1:windowHWND},${2:widthOut},${3:heightOut})$0"
    },
    "JS_WINDOW_GETFOCUS c": {
        "prefix": "JS_Window_GetFocus",
        "scope": "c",
        "description": "Retrieves a HWND to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.\n",
        "body": "JS_Window_GetFocus()$0"
    },
    "REAPER.JS_WINDOW_GETFOCUS lua": {
        "prefix": "reaper.JS_Window_GetFocus",
        "scope": "lua",
        "description": "Retrieves a HWND to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.\n",
        "body": "reaper.JS_Window_GetFocus()$0"
    },
    "JS_WINDOW_GETFOCUS python": {
        "prefix": "JS_Window_GetFocus",
        "scope": "python",
        "description": "Retrieves a HWND to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.\n",
        "body": "JS_Window_GetFocus()$0"
    },
    "JS_WINDOW_GETFOREGROUND c": {
        "prefix": "JS_Window_GetForeground",
        "scope": "c",
        "description": "Retrieves a HWND to the top-level foreground window (the window with which the user is currently working).\n",
        "body": "JS_Window_GetForeground()$0"
    },
    "REAPER.JS_WINDOW_GETFOREGROUND lua": {
        "prefix": "reaper.JS_Window_GetForeground",
        "scope": "lua",
        "description": "Retrieves a HWND to the top-level foreground window (the window with which the user is currently working).\n",
        "body": "reaper.JS_Window_GetForeground()$0"
    },
    "JS_WINDOW_GETFOREGROUND python": {
        "prefix": "JS_Window_GetForeground",
        "scope": "python",
        "description": "Retrieves a HWND to the top-level foreground window (the window with which the user is currently working).\n",
        "body": "JS_Window_GetForeground()$0"
    },
    "JS_WINDOW_GETLONG c": {
        "prefix": "JS_Window_GetLong",
        "scope": "c",
        "description": "Similar to JS_Window_GetLongPtr, but returns the information as a number instead of a pointer.\nIn the case of \"DLGPROC\" and \"WINPROC\", the return values can be converted to pointers by JS_Window_HandleFromAddress.\nIf the function fails, the return value is 0.\n",
        "body": "JS_Window_GetLong(${1:void* windowHWND},${2:const char* info},${3:double* retvalOut})$0"
    },
    "REAPER.JS_WINDOW_GETLONG lua": {
        "prefix": "reaper.JS_Window_GetLong",
        "scope": "lua",
        "description": "Similar to JS_Window_GetLongPtr, but returns the information as a number instead of a pointer.\nIn the case of \"DLGPROC\" and \"WINPROC\", the return values can be converted to pointers by JS_Window_HandleFromAddress.\nIf the function fails, the return value is 0.\n",
        "body": "reaper.JS_Window_GetLong(${1:identifier windowHWND},${2:string info})$0"
    },
    "JS_WINDOW_GETLONG python": {
        "prefix": "JS_Window_GetLong",
        "scope": "python",
        "description": "Similar to JS_Window_GetLongPtr, but returns the information as a number instead of a pointer.\nIn the case of \"DLGPROC\" and \"WINPROC\", the return values can be converted to pointers by JS_Window_HandleFromAddress.\nIf the function fails, the return value is 0.\n",
        "body": "JS_Window_GetLong(${1:windowHWND},${2:info},${3:retvalOut})$0"
    },
    "JS_WINDOW_GETLONGPTR c": {
        "prefix": "JS_Window_GetLongPtr",
        "scope": "c",
        "description": "Returns information about the specified window.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\".\nFor documentation about the types of information returned, refer to the Win32 function GetWindowLongPtr.\nThe values returned by \"DLGPROC\" and \"WINPROC\" are typically used as-is,\nas pointers, whereas the others should first be converted to integers.\nIf the function fails, a null pointer is returned.\n",
        "body": "JS_Window_GetLongPtr(${1:void* windowHWND},${2:const char* info})$0"
    },
    "REAPER.JS_WINDOW_GETLONGPTR lua": {
        "prefix": "reaper.JS_Window_GetLongPtr",
        "scope": "lua",
        "description": "Returns information about the specified window.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\".\nFor documentation about the types of information returned, refer to the Win32 function GetWindowLongPtr.\nThe values returned by \"DLGPROC\" and \"WINPROC\" are typically used as-is,\nas pointers, whereas the others should first be converted to integers.\nIf the function fails, a null pointer is returned.\n",
        "body": "reaper.JS_Window_GetLongPtr(${1:identifier windowHWND},${2:string info})$0"
    },
    "JS_WINDOW_GETLONGPTR python": {
        "prefix": "JS_Window_GetLongPtr",
        "scope": "python",
        "description": "Returns information about the specified window.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\".\nFor documentation about the types of information returned, refer to the Win32 function GetWindowLongPtr.\nThe values returned by \"DLGPROC\" and \"WINPROC\" are typically used as-is,\nas pointers, whereas the others should first be converted to integers.\nIf the function fails, a null pointer is returned.\n",
        "body": "JS_Window_GetLongPtr(${1:void windowHWND},${2:String info})$0"
    },
    "JS_WINDOW_GETPARENT c": {
        "prefix": "JS_Window_GetParent",
        "scope": "c",
        "description": "Retrieves a HWND to the specified window's parent or owner.\nReturns NULL if the window is unowned or if the function otherwise fails.\n",
        "body": "JS_Window_GetParent(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_GETPARENT lua": {
        "prefix": "reaper.JS_Window_GetParent",
        "scope": "lua",
        "description": "Retrieves a HWND to the specified window's parent or owner.\nReturns NULL if the window is unowned or if the function otherwise fails.\n",
        "body": "reaper.JS_Window_GetParent(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETPARENT python": {
        "prefix": "JS_Window_GetParent",
        "scope": "python",
        "description": "Retrieves a HWND to the specified window's parent or owner.\nReturns NULL if the window is unowned or if the function otherwise fails.\n",
        "body": "JS_Window_GetParent(${1:void windowHWND})$0"
    },
    "JS_WINDOW_GETRECT c": {
        "prefix": "JS_Window_GetRect",
        "scope": "c",
        "description": "Retrieves the screen coordinates of the bounding rectangle of the specified window.\nNOTES:\n* On Windows and Linux, coordinates are relative to *upper* left corner\nof the primary display, and the positive Y-axis points downward.\n* On macOS, coordinates are relative to the *bottom* left corner of the primary display, and the positive Y-axis points upward.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n",
        "body": "JS_Window_GetRect(${1:void* windowHWND},${2:int* leftOut},${3:int* topOut},${4:int* rightOut},${5:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_GETRECT lua": {
        "prefix": "reaper.JS_Window_GetRect",
        "scope": "lua",
        "description": "Retrieves the screen coordinates of the bounding rectangle of the specified window.\nNOTES:\n* On Windows and Linux, coordinates are relative to *upper* left corner\nof the primary display, and the positive Y-axis points downward.\n* On macOS, coordinates are relative to the *bottom* left corner of the primary display, and the positive Y-axis points upward.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n",
        "body": "reaper.JS_Window_GetRect(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETRECT python": {
        "prefix": "JS_Window_GetRect",
        "scope": "python",
        "description": "Retrieves the screen coordinates of the bounding rectangle of the specified window.\nNOTES:\n* On Windows and Linux, coordinates are relative to *upper* left corner\nof the primary display, and the positive Y-axis points downward.\n* On macOS, coordinates are relative to the *bottom* left corner of the primary display, and the positive Y-axis points upward.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n",
        "body": "JS_Window_GetRect(${1:windowHWND},${2:leftOut},${3:topOut},${4:rightOut},${5:bottomOut})$0"
    },
    "JS_WINDOW_GETRELATED c": {
        "prefix": "JS_Window_GetRelated",
        "scope": "c",
        "description": "Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.\nrelation: \"LAST\", \"NEXT\", \"PREV\", \"OWNER\" or \"CHILD\".\n(Refer to documentation for Win32 C++ function GetWindow.)\n",
        "body": "JS_Window_GetRelated(${1:void* windowHWND},${2:const char* relation})$0"
    },
    "REAPER.JS_WINDOW_GETRELATED lua": {
        "prefix": "reaper.JS_Window_GetRelated",
        "scope": "lua",
        "description": "Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.\nrelation: \"LAST\", \"NEXT\", \"PREV\", \"OWNER\" or \"CHILD\".\n(Refer to documentation for Win32 C++ function GetWindow.)\n",
        "body": "reaper.JS_Window_GetRelated(${1:identifier windowHWND},${2:string relation})$0"
    },
    "JS_WINDOW_GETRELATED python": {
        "prefix": "JS_Window_GetRelated",
        "scope": "python",
        "description": "Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.\nrelation: \"LAST\", \"NEXT\", \"PREV\", \"OWNER\" or \"CHILD\".\n(Refer to documentation for Win32 C++ function GetWindow.)\n",
        "body": "JS_Window_GetRelated(${1:void windowHWND},${2:String relation})$0"
    },
    "JS_WINDOW_GETSCROLLINFO c": {
        "prefix": "JS_Window_GetScrollInfo",
        "scope": "c",
        "description": "Retrieves the scroll information of a window.\nParameters:\n* windowHWND: The window that contains the scrollbar. This is usually a child window, not a top-level, framed window.\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nReturns:\n* Leftmost or topmost visible pixel position, as well as the visible\npage size, the range minimum and maximum, and scroll box tracking\nposition.\n",
        "body": "JS_Window_GetScrollInfo(${1:void* windowHWND},${2:const char* scrollbar},${3:int* positionOut},${4:int* pageSizeOut},${5:int* minOut},${6:int* maxOut},${7:int* trackPosOut})$0"
    },
    "REAPER.JS_WINDOW_GETSCROLLINFO lua": {
        "prefix": "reaper.JS_Window_GetScrollInfo",
        "scope": "lua",
        "description": "Retrieves the scroll information of a window.\nParameters:\n* windowHWND: The window that contains the scrollbar. This is usually a child window, not a top-level, framed window.\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nReturns:\n* Leftmost or topmost visible pixel position, as well as the visible\npage size, the range minimum and maximum, and scroll box tracking\nposition.\n",
        "body": "reaper.JS_Window_GetScrollInfo(${1:identifier windowHWND},${2:string scrollbar})$0"
    },
    "JS_WINDOW_GETSCROLLINFO python": {
        "prefix": "JS_Window_GetScrollInfo",
        "scope": "python",
        "description": "Retrieves the scroll information of a window.\nParameters:\n* windowHWND: The window that contains the scrollbar. This is usually a child window, not a top-level, framed window.\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nReturns:\n* Leftmost or topmost visible pixel position, as well as the visible\npage size, the range minimum and maximum, and scroll box tracking\nposition.\n",
        "body": "JS_Window_GetScrollInfo(${1:windowHWND},${2:scrollbar},${3:positionOut},${4:pageSizeOut},${5:minOut},${6:maxOut},${7:trackPosOut})$0"
    },
    "JS_WINDOW_GETTITLE c": {
        "prefix": "JS_Window_GetTitle",
        "scope": "c",
        "description": "Returns the title (if any) of the specified window.\n",
        "body": "JS_Window_GetTitle(${1:void* windowHWND},${2:char* titleOutNeedBig},${3:int titleOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_GETTITLE lua": {
        "prefix": "reaper.JS_Window_GetTitle",
        "scope": "lua",
        "description": "Returns the title (if any) of the specified window.\n",
        "body": "reaper.JS_Window_GetTitle(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETTITLE python": {
        "prefix": "JS_Window_GetTitle",
        "scope": "python",
        "description": "Returns the title (if any) of the specified window.\n",
        "body": "JS_Window_GetTitle(${1:windowHWND},${2:titleOutNeedBig},${3:titleOutNeedBig_sz})$0"
    },
    "JS_WINDOW_GETVIEWPORTFROMRECT c": {
        "prefix": "JS_Window_GetViewportFromRect",
        "scope": "c",
        "description": "Retrieves the dimensions of the display monitor that has the largest area of intersection with the specified rectangle.\nIf the monitor is not the primary display, some of the rectangle's coordinates may be negative.\nwantWork: Returns the work area of the display, which excludes the system taskbar or application desktop toolbars.\n",
        "body": "JS_Window_GetViewportFromRect(${1:int x1},${2:int y1},${3:int x2},${4:int y2},${5:bool wantWork},${6:int* leftOut},${7:int* topOut},${8:int* rightOut},${9:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_GETVIEWPORTFROMRECT lua": {
        "prefix": "reaper.JS_Window_GetViewportFromRect",
        "scope": "lua",
        "description": "Retrieves the dimensions of the display monitor that has the largest area of intersection with the specified rectangle.\nIf the monitor is not the primary display, some of the rectangle's coordinates may be negative.\nwantWork: Returns the work area of the display, which excludes the system taskbar or application desktop toolbars.\n",
        "body": "reaper.JS_Window_GetViewportFromRect(${1:integer x1},${2:integer y1},${3:integer x2},${4:integer y2},${5:boolean wantWork})$0"
    },
    "JS_WINDOW_GETVIEWPORTFROMRECT python": {
        "prefix": "JS_Window_GetViewportFromRect",
        "scope": "python",
        "description": "Retrieves the dimensions of the display monitor that has the largest area of intersection with the specified rectangle.\nIf the monitor is not the primary display, some of the rectangle's coordinates may be negative.\nwantWork: Returns the work area of the display, which excludes the system taskbar or application desktop toolbars.\n",
        "body": "JS_Window_GetViewportFromRect(${1:x1},${2:y1},${3:x2},${4:y2},${5:wantWork},${6:leftOut},${7:topOut},${8:rightOut},${9:bottomOut})$0"
    },
    "JS_WINDOW_HANDLEFROMADDRESS c": {
        "prefix": "JS_Window_HandleFromAddress",
        "scope": "c",
        "description": "Converts an address to a handle (such as a HWND) that can be utilized by REAPER and other API functions.\n",
        "body": "JS_Window_HandleFromAddress(${1:double address})$0"
    },
    "REAPER.JS_WINDOW_HANDLEFROMADDRESS lua": {
        "prefix": "reaper.JS_Window_HandleFromAddress",
        "scope": "lua",
        "description": "Converts an address to a handle (such as a HWND) that can be utilized by REAPER and other API functions.\n",
        "body": "reaper.JS_Window_HandleFromAddress(${1:number address})$0"
    },
    "JS_WINDOW_HANDLEFROMADDRESS python": {
        "prefix": "JS_Window_HandleFromAddress",
        "scope": "python",
        "description": "Converts an address to a handle (such as a HWND) that can be utilized by REAPER and other API functions.\n",
        "body": "JS_Window_HandleFromAddress(${1:Float address})$0"
    },
    "JS_WINDOW_INVALIDATERECT c": {
        "prefix": "JS_Window_InvalidateRect",
        "scope": "c",
        "description": "Similar to the Win32 function InvalidateRect.\n",
        "body": "JS_Window_InvalidateRect(${1:void* windowHWND},${2:int left},${3:int top},${4:int right},${5:int bottom},${6:bool eraseBackground})$0"
    },
    "REAPER.JS_WINDOW_INVALIDATERECT lua": {
        "prefix": "reaper.JS_Window_InvalidateRect",
        "scope": "lua",
        "description": "Similar to the Win32 function InvalidateRect.\n",
        "body": "reaper.JS_Window_InvalidateRect(${1:identifier windowHWND},${2:integer left},${3:integer top},${4:integer right},${5:integer bottom},${6:boolean eraseBackground})$0"
    },
    "JS_WINDOW_INVALIDATERECT python": {
        "prefix": "JS_Window_InvalidateRect",
        "scope": "python",
        "description": "Similar to the Win32 function InvalidateRect.\n",
        "body": "JS_Window_InvalidateRect(${1:void windowHWND},${2:Int left},${3:Int top},${4:Int right},${5:Int bottom},${6:Boolean eraseBackground})$0"
    },
    "JS_WINDOW_ISCHILD c": {
        "prefix": "JS_Window_IsChild",
        "scope": "c",
        "description": "Determines whether a window is a child window or descendant window of a specified parent window.\n",
        "body": "JS_Window_IsChild(${1:void* parentHWND},${2:void* childHWND})$0"
    },
    "REAPER.JS_WINDOW_ISCHILD lua": {
        "prefix": "reaper.JS_Window_IsChild",
        "scope": "lua",
        "description": "Determines whether a window is a child window or descendant window of a specified parent window.\n",
        "body": "reaper.JS_Window_IsChild(${1:identifier parentHWND},${2:identifier childHWND})$0"
    },
    "JS_WINDOW_ISCHILD python": {
        "prefix": "JS_Window_IsChild",
        "scope": "python",
        "description": "Determines whether a window is a child window or descendant window of a specified parent window.\n",
        "body": "JS_Window_IsChild(${1:void parentHWND},${2:void childHWND})$0"
    },
    "JS_WINDOW_ISVISIBLE c": {
        "prefix": "JS_Window_IsVisible",
        "scope": "c",
        "description": "Determines the visibility state of the window.\n",
        "body": "JS_Window_IsVisible(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ISVISIBLE lua": {
        "prefix": "reaper.JS_Window_IsVisible",
        "scope": "lua",
        "description": "Determines the visibility state of the window.\n",
        "body": "reaper.JS_Window_IsVisible(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_ISVISIBLE python": {
        "prefix": "JS_Window_IsVisible",
        "scope": "python",
        "description": "Determines the visibility state of the window.\n",
        "body": "JS_Window_IsVisible(${1:void windowHWND})$0"
    },
    "JS_WINDOW_ISWINDOW c": {
        "prefix": "JS_Window_IsWindow",
        "scope": "c",
        "description": "Determines whether the specified window handle identifies an existing window.\nOn macOS and Linux, only windows that were created by WDL/swell will be\nidentified (and only such windows should be acted on by scripts).\nNOTE: Since REAPER v5.974, windows can be checked using the native function ValidatePtr(windowHWND, \"HWND\").\n",
        "body": "JS_Window_IsWindow(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ISWINDOW lua": {
        "prefix": "reaper.JS_Window_IsWindow",
        "scope": "lua",
        "description": "Determines whether the specified window handle identifies an existing window.\nOn macOS and Linux, only windows that were created by WDL/swell will be\nidentified (and only such windows should be acted on by scripts).\nNOTE: Since REAPER v5.974, windows can be checked using the native function ValidatePtr(windowHWND, \"HWND\").\n",
        "body": "reaper.JS_Window_IsWindow(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_ISWINDOW python": {
        "prefix": "JS_Window_IsWindow",
        "scope": "python",
        "description": "Determines whether the specified window handle identifies an existing window.\nOn macOS and Linux, only windows that were created by WDL/swell will be\nidentified (and only such windows should be acted on by scripts).\nNOTE: Since REAPER v5.974, windows can be checked using the native function ValidatePtr(windowHWND, \"HWND\").\n",
        "body": "JS_Window_IsWindow(${1:void windowHWND})$0"
    },
    "JS_WINDOW_LISTALLCHILD c": {
        "prefix": "JS_Window_ListAllChild",
        "scope": "c",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values.\nEach value is an address that can be converted to a HWND by the function Window_HandleFromAddress.\n",
        "body": "JS_Window_ListAllChild(${1:void* parentHWND},${2:char* listOutNeedBig},${3:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_LISTALLCHILD lua": {
        "prefix": "reaper.JS_Window_ListAllChild",
        "scope": "lua",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values.\nEach value is an address that can be converted to a HWND by the function Window_HandleFromAddress.\n",
        "body": "reaper.JS_Window_ListAllChild(${1:identifier parentHWND})$0"
    },
    "JS_WINDOW_LISTALLCHILD python": {
        "prefix": "JS_Window_ListAllChild",
        "scope": "python",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values.\nEach value is an address that can be converted to a HWND by the function Window_HandleFromAddress.\n",
        "body": "JS_Window_ListAllChild(${1:parentHWND},${2:listOutNeedBig},${3:listOutNeedBig_sz})$0"
    },
    "JS_WINDOW_LISTALLTOP c": {
        "prefix": "JS_Window_ListAllTop",
        "scope": "c",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "JS_Window_ListAllTop(${1:char* listOutNeedBig},${2:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_LISTALLTOP lua": {
        "prefix": "reaper.JS_Window_ListAllTop",
        "scope": "lua",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "reaper.JS_Window_ListAllTop()$0"
    },
    "JS_WINDOW_LISTALLTOP python": {
        "prefix": "JS_Window_ListAllTop",
        "scope": "python",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "JS_Window_ListAllTop(${1:listOutNeedBig},${2:listOutNeedBig_sz})$0"
    },
    "JS_WINDOW_LISTFIND c": {
        "prefix": "JS_Window_ListFind",
        "scope": "c",
        "description": "Finds all windows (whether top-level or child) whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "JS_Window_ListFind(${1:const char* title},${2:bool exact},${3:char* listOutNeedBig},${4:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_LISTFIND lua": {
        "prefix": "reaper.JS_Window_ListFind",
        "scope": "lua",
        "description": "Finds all windows (whether top-level or child) whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "reaper.JS_Window_ListFind(${1:string title},${2:boolean exact})$0"
    },
    "JS_WINDOW_LISTFIND python": {
        "prefix": "JS_Window_ListFind",
        "scope": "python",
        "description": "Finds all windows (whether top-level or child) whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "JS_Window_ListFind(${1:title},${2:exact},${3:listOutNeedBig},${4:listOutNeedBig_sz})$0"
    },
    "JS_WINDOW_MONITORFROMRECT c": {
        "prefix": "JS_Window_MonitorFromRect",
        "scope": "c",
        "description": "Deprecated - use GetViewportFromRect instead.\n",
        "body": "JS_Window_MonitorFromRect(${1:int x1},${2:int y1},${3:int x2},${4:int y2},${5:bool wantWork},${6:int* leftOut},${7:int* topOut},${8:int* rightOut},${9:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_MONITORFROMRECT lua": {
        "prefix": "reaper.JS_Window_MonitorFromRect",
        "scope": "lua",
        "description": "Deprecated - use GetViewportFromRect instead.\n",
        "body": "reaper.JS_Window_MonitorFromRect(${1:integer x1},${2:integer y1},${3:integer x2},${4:integer y2},${5:boolean wantWork})$0"
    },
    "JS_WINDOW_MONITORFROMRECT python": {
        "prefix": "JS_Window_MonitorFromRect",
        "scope": "python",
        "description": "Deprecated - use GetViewportFromRect instead.\n",
        "body": "JS_Window_MonitorFromRect(${1:x1},${2:y1},${3:x2},${4:y2},${5:wantWork},${6:leftOut},${7:topOut},${8:rightOut},${9:bottomOut})$0"
    },
    "JS_WINDOW_MOVE c": {
        "prefix": "JS_Window_Move",
        "scope": "c",
        "description": "Changes the position of the specified window, keeping its size constant.\nNOTES:\n* For top-level windows, position is relative to the primary display.\n* On Windows and Linux, position is calculated as the coordinates of\nthe upper left corner of the window, relative to upper left corner of\nthe primary display, and the positive Y-axis points downward.\n* On macOS, position is calculated as the coordinates of the bottom\nleft corner of the window, relative to bottom left corner of the\ndisplay, and the positive Y-axis points upward.\n* For a child window, on all platforms, position is relative to the upper-left corner of the parent window's client area.\n* Equivalent to calling JS_Window_SetPosition with NOSIZE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "JS_Window_Move(${1:void* windowHWND},${2:int left},${3:int top})$0"
    },
    "REAPER.JS_WINDOW_MOVE lua": {
        "prefix": "reaper.JS_Window_Move",
        "scope": "lua",
        "description": "Changes the position of the specified window, keeping its size constant.\nNOTES:\n* For top-level windows, position is relative to the primary display.\n* On Windows and Linux, position is calculated as the coordinates of\nthe upper left corner of the window, relative to upper left corner of\nthe primary display, and the positive Y-axis points downward.\n* On macOS, position is calculated as the coordinates of the bottom\nleft corner of the window, relative to bottom left corner of the\ndisplay, and the positive Y-axis points upward.\n* For a child window, on all platforms, position is relative to the upper-left corner of the parent window's client area.\n* Equivalent to calling JS_Window_SetPosition with NOSIZE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "reaper.JS_Window_Move(${1:identifier windowHWND},${2:integer left},${3:integer top})$0"
    },
    "JS_WINDOW_MOVE python": {
        "prefix": "JS_Window_Move",
        "scope": "python",
        "description": "Changes the position of the specified window, keeping its size constant.\nNOTES:\n* For top-level windows, position is relative to the primary display.\n* On Windows and Linux, position is calculated as the coordinates of\nthe upper left corner of the window, relative to upper left corner of\nthe primary display, and the positive Y-axis points downward.\n* On macOS, position is calculated as the coordinates of the bottom\nleft corner of the window, relative to bottom left corner of the\ndisplay, and the positive Y-axis points upward.\n* For a child window, on all platforms, position is relative to the upper-left corner of the parent window's client area.\n* Equivalent to calling JS_Window_SetPosition with NOSIZE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "JS_Window_Move(${1:void windowHWND},${2:Int left},${3:Int top})$0"
    },
    "JS_WINDOW_ONCOMMAND c": {
        "prefix": "JS_Window_OnCommand",
        "scope": "c",
        "description": "Sends a \"WM_COMMAND\" message to the specified window, which simulates a user selecting a command in the window menu.\nThis function is similar to Main_OnCommand and MIDIEditor_OnCommand, but can send commands to any window that has a menu.\nIn the case of windows that are listed among the Action list's contexts\n(such as the Media Explorer), the commandIDs of the actions in the\nActions list may be used.\n",
        "body": "JS_Window_OnCommand(${1:void* windowHWND},${2:int commandID})$0"
    },
    "REAPER.JS_WINDOW_ONCOMMAND lua": {
        "prefix": "reaper.JS_Window_OnCommand",
        "scope": "lua",
        "description": "Sends a \"WM_COMMAND\" message to the specified window, which simulates a user selecting a command in the window menu.\nThis function is similar to Main_OnCommand and MIDIEditor_OnCommand, but can send commands to any window that has a menu.\nIn the case of windows that are listed among the Action list's contexts\n(such as the Media Explorer), the commandIDs of the actions in the\nActions list may be used.\n",
        "body": "reaper.JS_Window_OnCommand(${1:identifier windowHWND},${2:integer commandID})$0"
    },
    "JS_WINDOW_ONCOMMAND python": {
        "prefix": "JS_Window_OnCommand",
        "scope": "python",
        "description": "Sends a \"WM_COMMAND\" message to the specified window, which simulates a user selecting a command in the window menu.\nThis function is similar to Main_OnCommand and MIDIEditor_OnCommand, but can send commands to any window that has a menu.\nIn the case of windows that are listed among the Action list's contexts\n(such as the Media Explorer), the commandIDs of the actions in the\nActions list may be used.\n",
        "body": "JS_Window_OnCommand(${1:void windowHWND},${2:Int commandID})$0"
    },
    "JS_WINDOW_RESIZE c": {
        "prefix": "JS_Window_Resize",
        "scope": "c",
        "description": "Changes the dimensions of the specified window, keeping the top left corner position constant.\n* If resizing script GUIs, call gfx.update() after resizing.\n* Equivalent to calling JS_Window_SetPosition with NOMOVE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "JS_Window_Resize(${1:void* windowHWND},${2:int width},${3:int height})$0"
    },
    "REAPER.JS_WINDOW_RESIZE lua": {
        "prefix": "reaper.JS_Window_Resize",
        "scope": "lua",
        "description": "Changes the dimensions of the specified window, keeping the top left corner position constant.\n* If resizing script GUIs, call gfx.update() after resizing.\n* Equivalent to calling JS_Window_SetPosition with NOMOVE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "reaper.JS_Window_Resize(${1:identifier windowHWND},${2:integer width},${3:integer height})$0"
    },
    "JS_WINDOW_RESIZE python": {
        "prefix": "JS_Window_Resize",
        "scope": "python",
        "description": "Changes the dimensions of the specified window, keeping the top left corner position constant.\n* If resizing script GUIs, call gfx.update() after resizing.\n* Equivalent to calling JS_Window_SetPosition with NOMOVE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "JS_Window_Resize(${1:void windowHWND},${2:Int width},${3:Int height})$0"
    },
    "JS_WINDOW_SCREENTOCLIENT c": {
        "prefix": "JS_Window_ScreenToClient",
        "scope": "c",
        "description": "Converts the screen coordinates of a specified point on the screen to client-area coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "JS_Window_ScreenToClient(${1:void* windowHWND},${2:int x},${3:int y},${4:int* xOut},${5:int* yOut})$0"
    },
    "REAPER.JS_WINDOW_SCREENTOCLIENT lua": {
        "prefix": "reaper.JS_Window_ScreenToClient",
        "scope": "lua",
        "description": "Converts the screen coordinates of a specified point on the screen to client-area coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "reaper.JS_Window_ScreenToClient(${1:identifier windowHWND},${2:integer x},${3:integer y})$0"
    },
    "JS_WINDOW_SCREENTOCLIENT python": {
        "prefix": "JS_Window_ScreenToClient",
        "scope": "python",
        "description": "Converts the screen coordinates of a specified point on the screen to client-area coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "JS_Window_ScreenToClient(${1:windowHWND},${2:x},${3:y},${4:xOut},${5:yOut})$0"
    },
    "JS_WINDOW_SETFOCUS c": {
        "prefix": "JS_Window_SetFocus",
        "scope": "c",
        "description": "Sets the keyboard focus to the specified window.\n",
        "body": "JS_Window_SetFocus(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_SETFOCUS lua": {
        "prefix": "reaper.JS_Window_SetFocus",
        "scope": "lua",
        "description": "Sets the keyboard focus to the specified window.\n",
        "body": "reaper.JS_Window_SetFocus(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_SETFOCUS python": {
        "prefix": "JS_Window_SetFocus",
        "scope": "python",
        "description": "Sets the keyboard focus to the specified window.\n",
        "body": "JS_Window_SetFocus(${1:void windowHWND})$0"
    },
    "JS_WINDOW_SETFOREGROUND c": {
        "prefix": "JS_Window_SetForeground",
        "scope": "c",
        "description": "Brings the specified window into the foreground, activates the window, and directs keyboard input to it.\n",
        "body": "JS_Window_SetForeground(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_SETFOREGROUND lua": {
        "prefix": "reaper.JS_Window_SetForeground",
        "scope": "lua",
        "description": "Brings the specified window into the foreground, activates the window, and directs keyboard input to it.\n",
        "body": "reaper.JS_Window_SetForeground(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_SETFOREGROUND python": {
        "prefix": "JS_Window_SetForeground",
        "scope": "python",
        "description": "Brings the specified window into the foreground, activates the window, and directs keyboard input to it.\n",
        "body": "JS_Window_SetForeground(${1:void windowHWND})$0"
    },
    "JS_WINDOW_SETLONG c": {
        "prefix": "JS_Window_SetLong",
        "scope": "c",
        "description": "Similar to the Win32 function SetWindowLongPtr.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\", and only on WindowOS, \"INSTANCE\" and \"PARENT\".\n",
        "body": "JS_Window_SetLong(${1:void* windowHWND},${2:const char* info},${3:double value},${4:double* retvalOut})$0"
    },
    "REAPER.JS_WINDOW_SETLONG lua": {
        "prefix": "reaper.JS_Window_SetLong",
        "scope": "lua",
        "description": "Similar to the Win32 function SetWindowLongPtr.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\", and only on WindowOS, \"INSTANCE\" and \"PARENT\".\n",
        "body": "reaper.JS_Window_SetLong(${1:identifier windowHWND},${2:string info},${3:number value})$0"
    },
    "JS_WINDOW_SETLONG python": {
        "prefix": "JS_Window_SetLong",
        "scope": "python",
        "description": "Similar to the Win32 function SetWindowLongPtr.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\", and only on WindowOS, \"INSTANCE\" and \"PARENT\".\n",
        "body": "JS_Window_SetLong(${1:windowHWND},${2:info},${3:value},${4:retvalOut})$0"
    },
    "JS_WINDOW_SETOPACITY c": {
        "prefix": "JS_Window_SetOpacity",
        "scope": "c",
        "description": "Sets the window opacity.\nParameters:\nmode: either \"ALPHA\" or \"COLOR\".\nvalue: If ALPHA, the specified value may range from zero to one, and will apply to the entire window, frame included.\nIf COLOR, value specifies a 0xRRGGBB color, and all pixels of this color\nwill be made transparent. (All mouse clicks over transparent pixels\nwill pass through, too).  WARNING:\nCOLOR mode is only available in Windows, not Linux or macOS.\nTransparency can only be applied to top-level windows. If windowHWND\nrefers to a child window, the entire top-level window that contains\nwindowHWND will be made transparent.\n",
        "body": "JS_Window_SetOpacity(${1:void* windowHWND},${2:const char* mode},${3:double value})$0"
    },
    "REAPER.JS_WINDOW_SETOPACITY lua": {
        "prefix": "reaper.JS_Window_SetOpacity",
        "scope": "lua",
        "description": "Sets the window opacity.\nParameters:\nmode: either \"ALPHA\" or \"COLOR\".\nvalue: If ALPHA, the specified value may range from zero to one, and will apply to the entire window, frame included.\nIf COLOR, value specifies a 0xRRGGBB color, and all pixels of this color\nwill be made transparent. (All mouse clicks over transparent pixels\nwill pass through, too).  WARNING:\nCOLOR mode is only available in Windows, not Linux or macOS.\nTransparency can only be applied to top-level windows. If windowHWND\nrefers to a child window, the entire top-level window that contains\nwindowHWND will be made transparent.\n",
        "body": "reaper.JS_Window_SetOpacity(${1:identifier windowHWND},${2:string mode},${3:number value})$0"
    },
    "JS_WINDOW_SETOPACITY python": {
        "prefix": "JS_Window_SetOpacity",
        "scope": "python",
        "description": "Sets the window opacity.\nParameters:\nmode: either \"ALPHA\" or \"COLOR\".\nvalue: If ALPHA, the specified value may range from zero to one, and will apply to the entire window, frame included.\nIf COLOR, value specifies a 0xRRGGBB color, and all pixels of this color\nwill be made transparent. (All mouse clicks over transparent pixels\nwill pass through, too).  WARNING:\nCOLOR mode is only available in Windows, not Linux or macOS.\nTransparency can only be applied to top-level windows. If windowHWND\nrefers to a child window, the entire top-level window that contains\nwindowHWND will be made transparent.\n",
        "body": "JS_Window_SetOpacity(${1:void windowHWND},${2:String mode},${3:Float value})$0"
    },
    "JS_WINDOW_SETPARENT c": {
        "prefix": "JS_Window_SetParent",
        "scope": "c",
        "description": "If successful, returns a handle to the previous parent window.\n",
        "body": "JS_Window_SetParent(${1:void* childHWND},${2:void* parentHWND})$0"
    },
    "REAPER.JS_WINDOW_SETPARENT lua": {
        "prefix": "reaper.JS_Window_SetParent",
        "scope": "lua",
        "description": "If successful, returns a handle to the previous parent window.\n",
        "body": "reaper.JS_Window_SetParent(${1:identifier childHWND},${2:identifier parentHWND})$0"
    },
    "JS_WINDOW_SETPARENT python": {
        "prefix": "JS_Window_SetParent",
        "scope": "python",
        "description": "If successful, returns a handle to the previous parent window.\n",
        "body": "JS_Window_SetParent(${1:void childHWND},${2:void parentHWND})$0"
    },
    "JS_WINDOW_SETPOSITION c": {
        "prefix": "JS_Window_SetPosition",
        "scope": "c",
        "description": "Interface to the Win32/swell function SetWindowPos, with which window\nposition, size, Z-order and visibility can be set, and new frame styles\ncan be applied.\nZOrder and flags are optional parameters. If no arguments are supplied,\nthe window will simply be moved and resized, as if the NOACTIVATE,\nNOZORDER, NOOWNERZORDER flags were set.\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\" or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* flags: Any combination of the standard flags, of which \"NOMOVE\",\n\"NOSIZE\", \"NOZORDER\", \"NOACTIVATE\", \"SHOWWINDOW\", \"FRAMECHANGED\" and\n\"NOCOPYBITS\" should be valid cross-platform.\n",
        "body": "JS_Window_SetPosition(${1:void* windowHWND},${2:int left},${3:int top},${4:int width},${5:int height},${6:char* ZOrderOptional},${7:char* flagsOptional})$0"
    },
    "REAPER.JS_WINDOW_SETPOSITION lua": {
        "prefix": "reaper.JS_Window_SetPosition",
        "scope": "lua",
        "description": "Interface to the Win32/swell function SetWindowPos, with which window\nposition, size, Z-order and visibility can be set, and new frame styles\ncan be applied.\nZOrder and flags are optional parameters. If no arguments are supplied,\nthe window will simply be moved and resized, as if the NOACTIVATE,\nNOZORDER, NOOWNERZORDER flags were set.\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\" or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* flags: Any combination of the standard flags, of which \"NOMOVE\",\n\"NOSIZE\", \"NOZORDER\", \"NOACTIVATE\", \"SHOWWINDOW\", \"FRAMECHANGED\" and\n\"NOCOPYBITS\" should be valid cross-platform.\n",
        "body": "reaper.JS_Window_SetPosition(${1:identifier windowHWND},${2:integer left},${3:integer top},${4:integer width},${5:integer height},${6:optional string ZOrder},${7:optional string flags})$0"
    },
    "JS_WINDOW_SETPOSITION python": {
        "prefix": "JS_Window_SetPosition",
        "scope": "python",
        "description": "Interface to the Win32/swell function SetWindowPos, with which window\nposition, size, Z-order and visibility can be set, and new frame styles\ncan be applied.\nZOrder and flags are optional parameters. If no arguments are supplied,\nthe window will simply be moved and resized, as if the NOACTIVATE,\nNOZORDER, NOOWNERZORDER flags were set.\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\" or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* flags: Any combination of the standard flags, of which \"NOMOVE\",\n\"NOSIZE\", \"NOZORDER\", \"NOACTIVATE\", \"SHOWWINDOW\", \"FRAMECHANGED\" and\n\"NOCOPYBITS\" should be valid cross-platform.\n",
        "body": "JS_Window_SetPosition(${1:windowHWND},${2:left},${3:top},${4:width},${5:height},${6:ZOrderOptional},${7:flagsOptional})$0"
    },
    "JS_WINDOW_SETSCROLLPOS c": {
        "prefix": "JS_Window_SetScrollPos",
        "scope": "c",
        "description": "Parameters:\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nNOTE: API functions can scroll REAPER's windows, but cannot zoom them.\nInstead, use actions such as \"View: Zoom to one loop iteration\".\n",
        "body": "JS_Window_SetScrollPos(${1:void* windowHWND},${2:const char* scrollbar},${3:int position})$0"
    },
    "REAPER.JS_WINDOW_SETSCROLLPOS lua": {
        "prefix": "reaper.JS_Window_SetScrollPos",
        "scope": "lua",
        "description": "Parameters:\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nNOTE: API functions can scroll REAPER's windows, but cannot zoom them.\nInstead, use actions such as \"View: Zoom to one loop iteration\".\n",
        "body": "reaper.JS_Window_SetScrollPos(${1:identifier windowHWND},${2:string scrollbar},${3:integer position})$0"
    },
    "JS_WINDOW_SETSCROLLPOS python": {
        "prefix": "JS_Window_SetScrollPos",
        "scope": "python",
        "description": "Parameters:\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nNOTE: API functions can scroll REAPER's windows, but cannot zoom them.\nInstead, use actions such as \"View: Zoom to one loop iteration\".\n",
        "body": "JS_Window_SetScrollPos(${1:void windowHWND},${2:String scrollbar},${3:Int position})$0"
    },
    "JS_WINDOW_SETSTYLE c": {
        "prefix": "JS_Window_SetStyle",
        "scope": "c",
        "description": "Sets and applies a window style.\nstyle may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implmented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\n",
        "body": "JS_Window_SetStyle(${1:void* windowHWND},${2:char* style})$0"
    },
    "REAPER.JS_WINDOW_SETSTYLE lua": {
        "prefix": "reaper.JS_Window_SetStyle",
        "scope": "lua",
        "description": "Sets and applies a window style.\nstyle may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implmented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\n",
        "body": "reaper.JS_Window_SetStyle(${1:identifier windowHWND},${2:string style})$0"
    },
    "JS_WINDOW_SETSTYLE python": {
        "prefix": "JS_Window_SetStyle",
        "scope": "python",
        "description": "Sets and applies a window style.\nstyle may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implmented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\n",
        "body": "JS_Window_SetStyle(${1:windowHWND},${2:style})$0"
    },
    "JS_WINDOW_SETTITLE c": {
        "prefix": "JS_Window_SetTitle",
        "scope": "c",
        "description": "Changes the title of the specified window. Returns true if successful.\n",
        "body": "JS_Window_SetTitle(${1:void* windowHWND},${2:const char* title})$0"
    },
    "REAPER.JS_WINDOW_SETTITLE lua": {
        "prefix": "reaper.JS_Window_SetTitle",
        "scope": "lua",
        "description": "Changes the title of the specified window. Returns true if successful.\n",
        "body": "reaper.JS_Window_SetTitle(${1:identifier windowHWND},${2:string title})$0"
    },
    "JS_WINDOW_SETTITLE python": {
        "prefix": "JS_Window_SetTitle",
        "scope": "python",
        "description": "Changes the title of the specified window. Returns true if successful.\n",
        "body": "JS_Window_SetTitle(${1:void windowHWND},${2:String title})$0"
    },
    "JS_WINDOW_SETZORDER c": {
        "prefix": "JS_Window_SetZOrder",
        "scope": "c",
        "description": "Sets the window Z order.\n* Equivalent to calling JS_Window_SetPos with flags NOMOVE | NOSIZE.\n* Not all the Z orders have been implemented in Linux yet.\nParameters:\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\", or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* InsertAfterHWND: For compatibility with older versions, this parameter\nis still available, and is optional. If ZOrder is \"INSERTAFTER\",\ninsertAfterHWND must be a handle to the window behind which windowHWND\nwill be placed in the Z order, equivalent to setting ZOrder to this\nHWND; otherwise, insertAfterHWND is ignored and can be left out (or it\ncan simply be set to the same value as windowHWND).\n",
        "body": "JS_Window_SetZOrder(${1:void* windowHWND},${2:const char* ZOrder},${3:void* insertAfterHWNDOptional})$0"
    },
    "REAPER.JS_WINDOW_SETZORDER lua": {
        "prefix": "reaper.JS_Window_SetZOrder",
        "scope": "lua",
        "description": "Sets the window Z order.\n* Equivalent to calling JS_Window_SetPos with flags NOMOVE | NOSIZE.\n* Not all the Z orders have been implemented in Linux yet.\nParameters:\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\", or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* InsertAfterHWND: For compatibility with older versions, this parameter\nis still available, and is optional. If ZOrder is \"INSERTAFTER\",\ninsertAfterHWND must be a handle to the window behind which windowHWND\nwill be placed in the Z order, equivalent to setting ZOrder to this\nHWND; otherwise, insertAfterHWND is ignored and can be left out (or it\ncan simply be set to the same value as windowHWND).\n",
        "body": "reaper.JS_Window_SetZOrder(${1:identifier windowHWND},${2:string ZOrder},${3:identifier insertAfterHWND})$0"
    },
    "JS_WINDOW_SETZORDER python": {
        "prefix": "JS_Window_SetZOrder",
        "scope": "python",
        "description": "Sets the window Z order.\n* Equivalent to calling JS_Window_SetPos with flags NOMOVE | NOSIZE.\n* Not all the Z orders have been implemented in Linux yet.\nParameters:\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\", or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* InsertAfterHWND: For compatibility with older versions, this parameter\nis still available, and is optional. If ZOrder is \"INSERTAFTER\",\ninsertAfterHWND must be a handle to the window behind which windowHWND\nwill be placed in the Z order, equivalent to setting ZOrder to this\nHWND; otherwise, insertAfterHWND is ignored and can be left out (or it\ncan simply be set to the same value as windowHWND).\n",
        "body": "JS_Window_SetZOrder(${1:void windowHWND},${2:String ZOrder},${3:void insertAfterHWNDOptional})$0"
    },
    "JS_WINDOW_SHOW c": {
        "prefix": "JS_Window_Show",
        "scope": "c",
        "description": "Sets the specified window's show state.\nParameters:\n* state: One of the following options: \"SHOW\", \"SHOWNA\" (or\n\"SHOWNOACTIVATE\"), \"SHOWMINIMIZED\", \"HIDE\", \"NORMAL\", \"SHOWNORMAL\",\n\"SHOWMAXIMIZED\", \"SHOWDEFAULT\" or \"RESTORE\". On Linux and macOS, only\nthe first four options are fully implemented.\n",
        "body": "JS_Window_Show(${1:void* windowHWND},${2:const char* state})$0"
    },
    "REAPER.JS_WINDOW_SHOW lua": {
        "prefix": "reaper.JS_Window_Show",
        "scope": "lua",
        "description": "Sets the specified window's show state.\nParameters:\n* state: One of the following options: \"SHOW\", \"SHOWNA\" (or\n\"SHOWNOACTIVATE\"), \"SHOWMINIMIZED\", \"HIDE\", \"NORMAL\", \"SHOWNORMAL\",\n\"SHOWMAXIMIZED\", \"SHOWDEFAULT\" or \"RESTORE\". On Linux and macOS, only\nthe first four options are fully implemented.\n",
        "body": "reaper.JS_Window_Show(${1:identifier windowHWND},${2:string state})$0"
    },
    "JS_WINDOW_SHOW python": {
        "prefix": "JS_Window_Show",
        "scope": "python",
        "description": "Sets the specified window's show state.\nParameters:\n* state: One of the following options: \"SHOW\", \"SHOWNA\" (or\n\"SHOWNOACTIVATE\"), \"SHOWMINIMIZED\", \"HIDE\", \"NORMAL\", \"SHOWNORMAL\",\n\"SHOWMAXIMIZED\", \"SHOWDEFAULT\" or \"RESTORE\". On Linux and macOS, only\nthe first four options are fully implemented.\n",
        "body": "JS_Window_Show(${1:void windowHWND},${2:String state})$0"
    },
    "JS_WINDOW_UPDATE c": {
        "prefix": "JS_Window_Update",
        "scope": "c",
        "description": "Similar to the Win32 function UpdateWindow.\n",
        "body": "JS_Window_Update(${1:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_UPDATE lua": {
        "prefix": "reaper.JS_Window_Update",
        "scope": "lua",
        "description": "Similar to the Win32 function UpdateWindow.\n",
        "body": "reaper.JS_Window_Update(${1:identifier windowHWND})$0"
    },
    "JS_WINDOW_UPDATE python": {
        "prefix": "JS_Window_Update",
        "scope": "python",
        "description": "Similar to the Win32 function UpdateWindow.\n",
        "body": "JS_Window_Update(${1:void windowHWND})$0"
    },
    "NF_ANALYZEMEDIAITEMPEAKANDRMS c": {
        "prefix": "NF_AnalyzeMediaItemPeakAndRMS",
        "scope": "c",
        "description": "This function combines all other NF_Peak/RMS functions in a single one\nand additionally returns peak RMS positions. Lua example code here.\nNote: It's recommended to use this function with ReaScript/Lua as it\nprovides reaper.array objects. If using this function with other\nscripting languages, you must provide arrays in the reaper.array format.\n",
        "body": "NF_AnalyzeMediaItemPeakAndRMS(${1:MediaItem* item},${2:double windowSize},${3:void* reaper_array_peaks},${4:void* reaper_array_peakpositions},${5:void* reaper_array_RMSs},${6:void* reaper_array_RMSpositions})$0"
    },
    "REAPER.NF_ANALYZEMEDIAITEMPEAKANDRMS lua": {
        "prefix": "reaper.NF_AnalyzeMediaItemPeakAndRMS",
        "scope": "lua",
        "description": "This function combines all other NF_Peak/RMS functions in a single one\nand additionally returns peak RMS positions. Lua example code here.\nNote: It's recommended to use this function with ReaScript/Lua as it\nprovides reaper.array objects. If using this function with other\nscripting languages, you must provide arrays in the reaper.array format.\n",
        "body": "reaper.NF_AnalyzeMediaItemPeakAndRMS(${1:MediaItem item},${2:number windowSize},${3:identifier reaper_array_peaks},${4:identifier reaper_array_peakpositions},${5:identifier reaper_array_RMSs},${6:identifier reaper_array_RMSpositions})$0"
    },
    "NF_ANALYZEMEDIAITEMPEAKANDRMS python": {
        "prefix": "NF_AnalyzeMediaItemPeakAndRMS",
        "scope": "python",
        "description": "This function combines all other NF_Peak/RMS functions in a single one\nand additionally returns peak RMS positions. Lua example code here.\nNote: It's recommended to use this function with ReaScript/Lua as it\nprovides reaper.array objects. If using this function with other\nscripting languages, you must provide arrays in the reaper.array format.\n",
        "body": "NF_AnalyzeMediaItemPeakAndRMS(${1:MediaItem item},${2:Float windowSize},${3:void reaper_array_peaks},${4:void reaper_array_peakpositions},${5:void reaper_array_RMSs},${6:void reaper_array_RMSpositions})$0"
    },
    "NF_ANALYZETAKELOUDNESS c": {
        "prefix": "NF_AnalyzeTakeLoudness",
        "scope": "c",
        "description": "Full loudness analysis. retval: returns true on successful analysis,\nfalse on MIDI take or when analysis failed for some reason.\nanalyzeTruePeak=true: Also do true peak analysis. Returns true peak\nvalue and true peak position (relative to item position). Considerably\nslower than without true peak analysis (since it uses oversampling).\nNote: Short term uses a time window of 3 sec. for calculation. So for\nitems shorter than this shortTermMaxOut can't be calculated correctly.\nMomentary uses a time window of 0.4 sec.\n",
        "body": "NF_AnalyzeTakeLoudness(${1:MediaItem_Take* take},${2:bool analyzeTruePeak},${3:double* lufsIntegratedOut},${4:double* rangeOut},${5:double*  truePeakOut},${6:double* truePeakPosOut},${7:double* shortTermMaxOut},${8:double* momentaryMaxOut})$0"
    },
    "REAPER.NF_ANALYZETAKELOUDNESS lua": {
        "prefix": "reaper.NF_AnalyzeTakeLoudness",
        "scope": "lua",
        "description": "Full loudness analysis. retval: returns true on successful analysis,\nfalse on MIDI take or when analysis failed for some reason.\nanalyzeTruePeak=true: Also do true peak analysis. Returns true peak\nvalue and true peak position (relative to item position). Considerably\nslower than without true peak analysis (since it uses oversampling).\nNote: Short term uses a time window of 3 sec. for calculation. So for\nitems shorter than this shortTermMaxOut can't be calculated correctly.\nMomentary uses a time window of 0.4 sec.\n",
        "body": "reaper.NF_AnalyzeTakeLoudness(${1:MediaItem_Take take},${2:boolean analyzeTruePeak})$0"
    },
    "NF_ANALYZETAKELOUDNESS python": {
        "prefix": "NF_AnalyzeTakeLoudness",
        "scope": "python",
        "description": "Full loudness analysis. retval: returns true on successful analysis,\nfalse on MIDI take or when analysis failed for some reason.\nanalyzeTruePeak=true: Also do true peak analysis. Returns true peak\nvalue and true peak position (relative to item position). Considerably\nslower than without true peak analysis (since it uses oversampling).\nNote: Short term uses a time window of 3 sec. for calculation. So for\nitems shorter than this shortTermMaxOut can't be calculated correctly.\nMomentary uses a time window of 0.4 sec.\n",
        "body": "NF_AnalyzeTakeLoudness(${1:take},${2:analyzeTruePeak},${3:lufsIntegratedOut},${4:rangeOut},${5: truePeakOut},${6:truePeakPosOut},${7:shortTermMaxOut},${8:momentaryMaxOut})$0"
    },
    "NF_ANALYZETAKELOUDNESS2 c": {
        "prefix": "NF_AnalyzeTakeLoudness2",
        "scope": "c",
        "description": "Same as NF_AnalyzeTakeLoudness but\nadditionally returns shortTermMaxPos and momentaryMaxPos (in absolute\nproject time). Note: shortTermMaxPos and momentaryMaxPos actaully\nindicate the beginning of time intervalls, (3 sec. and 0.4 sec. resp.).\n",
        "body": "NF_AnalyzeTakeLoudness2(${1:MediaItem_Take* take},${2:bool analyzeTruePeak},${3:double* lufsIntegratedOut},${4:double* rangeOut},${5:double*  truePeakOut},${6:double* truePeakPosOut},${7:double* shortTermMaxOut},${8:double* momentaryMaxOut},${9:double* shortTermMaxPosOut},${10:double* momentaryMaxPosOut})$0"
    },
    "REAPER.NF_ANALYZETAKELOUDNESS2 lua": {
        "prefix": "reaper.NF_AnalyzeTakeLoudness2",
        "scope": "lua",
        "description": "Same as NF_AnalyzeTakeLoudness but\nadditionally returns shortTermMaxPos and momentaryMaxPos (in absolute\nproject time). Note: shortTermMaxPos and momentaryMaxPos actaully\nindicate the beginning of time intervalls, (3 sec. and 0.4 sec. resp.).\n",
        "body": "reaper.NF_AnalyzeTakeLoudness2(${1:MediaItem_Take take},${2:boolean analyzeTruePeak})$0"
    },
    "NF_ANALYZETAKELOUDNESS2 python": {
        "prefix": "NF_AnalyzeTakeLoudness2",
        "scope": "python",
        "description": "Same as NF_AnalyzeTakeLoudness but\nadditionally returns shortTermMaxPos and momentaryMaxPos (in absolute\nproject time). Note: shortTermMaxPos and momentaryMaxPos actaully\nindicate the beginning of time intervalls, (3 sec. and 0.4 sec. resp.).\n",
        "body": "NF_AnalyzeTakeLoudness2(${1:take},${2:analyzeTruePeak},${3:lufsIntegratedOut},${4:rangeOut},${5: truePeakOut},${6:truePeakPosOut},${7:shortTermMaxOut},${8:momentaryMaxOut},${9:shortTermMaxPosOut},${10:momentaryMaxPosOut})$0"
    },
    "NF_ANALYZETAKELOUDNESS_INTEGRATEDONLY c": {
        "prefix": "NF_AnalyzeTakeLoudness_IntegratedOnly",
        "scope": "c",
        "description": "Does LUFS integrated analysis only. Faster than full loudness analysis (NF_AnalyzeTakeLoudness) . Use this if only LUFS integrated is required. Take vol. env. is taken into account. See: Signal flow\n",
        "body": "NF_AnalyzeTakeLoudness_IntegratedOnly(${1:MediaItem_Take* take},${2:double* lufsIntegratedOut})$0"
    },
    "REAPER.NF_ANALYZETAKELOUDNESS_INTEGRATEDONLY lua": {
        "prefix": "reaper.NF_AnalyzeTakeLoudness_IntegratedOnly",
        "scope": "lua",
        "description": "Does LUFS integrated analysis only. Faster than full loudness analysis (NF_AnalyzeTakeLoudness) . Use this if only LUFS integrated is required. Take vol. env. is taken into account. See: Signal flow\n",
        "body": "reaper.NF_AnalyzeTakeLoudness_IntegratedOnly(${1:MediaItem_Take take})$0"
    },
    "NF_ANALYZETAKELOUDNESS_INTEGRATEDONLY python": {
        "prefix": "NF_AnalyzeTakeLoudness_IntegratedOnly",
        "scope": "python",
        "description": "Does LUFS integrated analysis only. Faster than full loudness analysis (NF_AnalyzeTakeLoudness) . Use this if only LUFS integrated is required. Take vol. env. is taken into account. See: Signal flow\n",
        "body": "NF_AnalyzeTakeLoudness_IntegratedOnly(${1:take},${2:lufsIntegratedOut})$0"
    },
    "NF_GETMEDIAITEMAVERAGERMS c": {
        "prefix": "NF_GetMediaItemAverageRMS",
        "scope": "c",
        "description": "Returns the average overall (non-windowed) RMS level of active channels\nof an audio item active take, post item gain, post take volume envelope,\npost-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "NF_GetMediaItemAverageRMS(${1:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMAVERAGERMS lua": {
        "prefix": "reaper.NF_GetMediaItemAverageRMS",
        "scope": "lua",
        "description": "Returns the average overall (non-windowed) RMS level of active channels\nof an audio item active take, post item gain, post take volume envelope,\npost-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "reaper.NF_GetMediaItemAverageRMS(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMAVERAGERMS python": {
        "prefix": "NF_GetMediaItemAverageRMS",
        "scope": "python",
        "description": "Returns the average overall (non-windowed) RMS level of active channels\nof an audio item active take, post item gain, post take volume envelope,\npost-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "NF_GetMediaItemAverageRMS(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAK c": {
        "prefix": "NF_GetMediaItemMaxPeak",
        "scope": "c",
        "description": "Returns the greatest max. peak value of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "NF_GetMediaItemMaxPeak(${1:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMMAXPEAK lua": {
        "prefix": "reaper.NF_GetMediaItemMaxPeak",
        "scope": "lua",
        "description": "Returns the greatest max. peak value of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "reaper.NF_GetMediaItemMaxPeak(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAK python": {
        "prefix": "NF_GetMediaItemMaxPeak",
        "scope": "python",
        "description": "Returns the greatest max. peak value of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "NF_GetMediaItemMaxPeak(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAKANDMAXPEAKPOS c": {
        "prefix": "NF_GetMediaItemMaxPeakAndMaxPeakPos",
        "scope": "c",
        "description": "See NF_GetMediaItemMaxPeak, additionally returns maxPeakPos (relative to item position).\n",
        "body": "NF_GetMediaItemMaxPeakAndMaxPeakPos(${1:MediaItem* item},${2:double* maxPeakPosOut})$0"
    },
    "REAPER.NF_GETMEDIAITEMMAXPEAKANDMAXPEAKPOS lua": {
        "prefix": "reaper.NF_GetMediaItemMaxPeakAndMaxPeakPos",
        "scope": "lua",
        "description": "See NF_GetMediaItemMaxPeak, additionally returns maxPeakPos (relative to item position).\n",
        "body": "reaper.NF_GetMediaItemMaxPeakAndMaxPeakPos(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAKANDMAXPEAKPOS python": {
        "prefix": "NF_GetMediaItemMaxPeakAndMaxPeakPos",
        "scope": "python",
        "description": "See NF_GetMediaItemMaxPeak, additionally returns maxPeakPos (relative to item position).\n",
        "body": "NF_GetMediaItemMaxPeakAndMaxPeakPos(${1:item},${2:maxPeakPosOut})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_NONWINDOWED c": {
        "prefix": "NF_GetMediaItemPeakRMS_NonWindowed",
        "scope": "c",
        "description": "Returns the greatest overall (non-windowed) RMS peak level of all active\nchannels of an audio item active take, post item gain, post take volume\nenvelope, post-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "NF_GetMediaItemPeakRMS_NonWindowed(${1:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMPEAKRMS_NONWINDOWED lua": {
        "prefix": "reaper.NF_GetMediaItemPeakRMS_NonWindowed",
        "scope": "lua",
        "description": "Returns the greatest overall (non-windowed) RMS peak level of all active\nchannels of an audio item active take, post item gain, post take volume\nenvelope, post-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "reaper.NF_GetMediaItemPeakRMS_NonWindowed(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_NONWINDOWED python": {
        "prefix": "NF_GetMediaItemPeakRMS_NonWindowed",
        "scope": "python",
        "description": "Returns the greatest overall (non-windowed) RMS peak level of all active\nchannels of an audio item active take, post item gain, post take volume\nenvelope, post-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "NF_GetMediaItemPeakRMS_NonWindowed(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_WINDOWED c": {
        "prefix": "NF_GetMediaItemPeakRMS_Windowed",
        "scope": "c",
        "description": "Returns the average RMS peak level of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nObeys 'Window size for peak RMS' setting in 'SWS: Set RMS\nanalysis/normalize options' for calculation. Returns -150.0 if MIDI take\nor empty item.\n",
        "body": "NF_GetMediaItemPeakRMS_Windowed(${1:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMPEAKRMS_WINDOWED lua": {
        "prefix": "reaper.NF_GetMediaItemPeakRMS_Windowed",
        "scope": "lua",
        "description": "Returns the average RMS peak level of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nObeys 'Window size for peak RMS' setting in 'SWS: Set RMS\nanalysis/normalize options' for calculation. Returns -150.0 if MIDI take\nor empty item.\n",
        "body": "reaper.NF_GetMediaItemPeakRMS_Windowed(${1:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_WINDOWED python": {
        "prefix": "NF_GetMediaItemPeakRMS_Windowed",
        "scope": "python",
        "description": "Returns the average RMS peak level of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nObeys 'Window size for peak RMS' setting in 'SWS: Set RMS\nanalysis/normalize options' for calculation. Returns -150.0 if MIDI take\nor empty item.\n",
        "body": "NF_GetMediaItemPeakRMS_Windowed(${1:MediaItem item})$0"
    },
    "NF_GETSWSMARKERREGIONSUB c": {
        "prefix": "NF_GetSWSMarkerRegionSub",
        "scope": "c",
        "description": "Returns SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns empty string if\nmarker/region with specified index not found or marker/region subtitle\nnot set. Lua code example here.\n",
        "body": "NF_GetSWSMarkerRegionSub(${1:int markerRegionIdx})$0"
    },
    "REAPER.NF_GETSWSMARKERREGIONSUB lua": {
        "prefix": "reaper.NF_GetSWSMarkerRegionSub",
        "scope": "lua",
        "description": "Returns SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns empty string if\nmarker/region with specified index not found or marker/region subtitle\nnot set. Lua code example here.\n",
        "body": "reaper.NF_GetSWSMarkerRegionSub(${1:integer markerRegionIdx})$0"
    },
    "NF_GETSWSMARKERREGIONSUB python": {
        "prefix": "NF_GetSWSMarkerRegionSub",
        "scope": "python",
        "description": "Returns SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns empty string if\nmarker/region with specified index not found or marker/region subtitle\nnot set. Lua code example here.\n",
        "body": "NF_GetSWSMarkerRegionSub(${1:Int markerRegionIdx})$0"
    },
    "NF_GETSWSTRACKNOTES c": {
        "prefix": "NF_GetSWSTrackNotes",
        "scope": "c",
        "description": "\n",
        "body": "NF_GetSWSTrackNotes(${1:MediaTrack* track})$0"
    },
    "REAPER.NF_GETSWSTRACKNOTES lua": {
        "prefix": "reaper.NF_GetSWSTrackNotes",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.NF_GetSWSTrackNotes(${1:MediaTrack track})$0"
    },
    "NF_GETSWSTRACKNOTES python": {
        "prefix": "NF_GetSWSTrackNotes",
        "scope": "python",
        "description": "\n",
        "body": "NF_GetSWSTrackNotes(${1:MediaTrack track})$0"
    },
    "NF_SETSWSMARKERREGIONSUB c": {
        "prefix": "NF_SetSWSMarkerRegionSub",
        "scope": "c",
        "description": "Set SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns true if subtitle is set\nsuccessfully (i.e. marker/region with specified index is present in\nproject). Lua code example here.\n",
        "body": "NF_SetSWSMarkerRegionSub(${1:const char* markerRegionSub},${2:int markerRegionIdx})$0"
    },
    "REAPER.NF_SETSWSMARKERREGIONSUB lua": {
        "prefix": "reaper.NF_SetSWSMarkerRegionSub",
        "scope": "lua",
        "description": "Set SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns true if subtitle is set\nsuccessfully (i.e. marker/region with specified index is present in\nproject). Lua code example here.\n",
        "body": "reaper.NF_SetSWSMarkerRegionSub(${1:string markerRegionSub},${2:integer markerRegionIdx})$0"
    },
    "NF_SETSWSMARKERREGIONSUB python": {
        "prefix": "NF_SetSWSMarkerRegionSub",
        "scope": "python",
        "description": "Set SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns true if subtitle is set\nsuccessfully (i.e. marker/region with specified index is present in\nproject). Lua code example here.\n",
        "body": "NF_SetSWSMarkerRegionSub(${1:String markerRegionSub},${2:Int markerRegionIdx})$0"
    },
    "NF_SETSWSTRACKNOTES c": {
        "prefix": "NF_SetSWSTrackNotes",
        "scope": "c",
        "description": "\n",
        "body": "NF_SetSWSTrackNotes(${1:MediaTrack* track},${2:const char* str})$0"
    },
    "REAPER.NF_SETSWSTRACKNOTES lua": {
        "prefix": "reaper.NF_SetSWSTrackNotes",
        "scope": "lua",
        "description": "\n",
        "body": "reaper.NF_SetSWSTrackNotes(${1:MediaTrack track},${2:string str})$0"
    },
    "NF_SETSWSTRACKNOTES python": {
        "prefix": "NF_SetSWSTrackNotes",
        "scope": "python",
        "description": "\n",
        "body": "NF_SetSWSTrackNotes(${1:MediaTrack track},${2:String str})$0"
    },
    "NF_UPDATESWSMARKERREGIONSUBWINDOW c": {
        "prefix": "NF_UpdateSWSMarkerRegionSubWindow",
        "scope": "c",
        "description": "Redraw the Notes window (call if you've changed a subtitle via NF_SetSWSMarkerRegionSub which is currently displayed in the Notes window and you want to appear the new subtitle immediately.)\n",
        "body": "NF_UpdateSWSMarkerRegionSubWindow()$0"
    },
    "REAPER.NF_UPDATESWSMARKERREGIONSUBWINDOW lua": {
        "prefix": "reaper.NF_UpdateSWSMarkerRegionSubWindow",
        "scope": "lua",
        "description": "Redraw the Notes window (call if you've changed a subtitle via NF_SetSWSMarkerRegionSub which is currently displayed in the Notes window and you want to appear the new subtitle immediately.)\n",
        "body": "reaper.NF_UpdateSWSMarkerRegionSubWindow()$0"
    },
    "NF_UPDATESWSMARKERREGIONSUBWINDOW python": {
        "prefix": "NF_UpdateSWSMarkerRegionSubWindow",
        "scope": "python",
        "description": "Redraw the Notes window (call if you've changed a subtitle via NF_SetSWSMarkerRegionSub which is currently displayed in the Notes window and you want to appear the new subtitle immediately.)\n",
        "body": "NF_UpdateSWSMarkerRegionSubWindow()$0"
    },
    "REAPACK_ABOUTINSTALLEDPACKAGE c": {
        "prefix": "ReaPack_AboutInstalledPackage",
        "scope": "c",
        "description": "Show the about dialog of the given package entry.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "ReaPack_AboutInstalledPackage(${1:PackageEntry* entry})$0"
    },
    "REAPER.REAPACK_ABOUTINSTALLEDPACKAGE lua": {
        "prefix": "reaper.ReaPack_AboutInstalledPackage",
        "scope": "lua",
        "description": "Show the about dialog of the given package entry.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "reaper.ReaPack_AboutInstalledPackage(${1:PackageEntry entry})$0"
    },
    "REAPACK_ABOUTINSTALLEDPACKAGE python": {
        "prefix": "ReaPack_AboutInstalledPackage",
        "scope": "python",
        "description": "Show the about dialog of the given package entry.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "ReaPack_AboutInstalledPackage(${1:PackageEntry entry})$0"
    },
    "REAPACK_ABOUTREPOSITORY c": {
        "prefix": "ReaPack_AboutRepository",
        "scope": "c",
        "description": "Show the about dialog of the given repository. Returns true if the repository exists in the user configuration.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "ReaPack_AboutRepository(${1:const char* repoName})$0"
    },
    "REAPER.REAPACK_ABOUTREPOSITORY lua": {
        "prefix": "reaper.ReaPack_AboutRepository",
        "scope": "lua",
        "description": "Show the about dialog of the given repository. Returns true if the repository exists in the user configuration.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "reaper.ReaPack_AboutRepository(${1:string repoName})$0"
    },
    "REAPACK_ABOUTREPOSITORY python": {
        "prefix": "ReaPack_AboutRepository",
        "scope": "python",
        "description": "Show the about dialog of the given repository. Returns true if the repository exists in the user configuration.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "ReaPack_AboutRepository(${1:String repoName})$0"
    },
    "REAPACK_ADDSETREPOSITORY c": {
        "prefix": "ReaPack_AddSetRepository",
        "scope": "c",
        "description": "Add or modify a repository. Set url to nullptr (or empty string in Lua) to keep the existing URL. Call ReaPack_ProcessQueue(true) when done to process the new list and update the GUI.\nautoInstall: usually set to 2 (obey user setting).\n",
        "body": "ReaPack_AddSetRepository(${1:const char* name},${2:const char* url},${3:bool enable},${4:int autoInstall},${5:char* errorOut},${6:int errorOut_sz})$0"
    },
    "REAPER.REAPACK_ADDSETREPOSITORY lua": {
        "prefix": "reaper.ReaPack_AddSetRepository",
        "scope": "lua",
        "description": "Add or modify a repository. Set url to nullptr (or empty string in Lua) to keep the existing URL. Call ReaPack_ProcessQueue(true) when done to process the new list and update the GUI.\nautoInstall: usually set to 2 (obey user setting).\n",
        "body": "reaper.ReaPack_AddSetRepository(${1:string name},${2:string url},${3:boolean enable},${4:integer autoInstall})$0"
    },
    "REAPACK_ADDSETREPOSITORY python": {
        "prefix": "ReaPack_AddSetRepository",
        "scope": "python",
        "description": "Add or modify a repository. Set url to nullptr (or empty string in Lua) to keep the existing URL. Call ReaPack_ProcessQueue(true) when done to process the new list and update the GUI.\nautoInstall: usually set to 2 (obey user setting).\n",
        "body": "ReaPack_AddSetRepository(${1:name},${2:url},${3:enable},${4:autoInstall},${5:errorOut},${6:errorOut_sz})$0"
    },
    "REAPACK_BROWSEPACKAGES c": {
        "prefix": "ReaPack_BrowsePackages",
        "scope": "c",
        "description": "Opens the package browser with the given filter string.\n",
        "body": "ReaPack_BrowsePackages(${1:const char* filter})$0"
    },
    "REAPER.REAPACK_BROWSEPACKAGES lua": {
        "prefix": "reaper.ReaPack_BrowsePackages",
        "scope": "lua",
        "description": "Opens the package browser with the given filter string.\n",
        "body": "reaper.ReaPack_BrowsePackages(${1:string filter})$0"
    },
    "REAPACK_BROWSEPACKAGES python": {
        "prefix": "ReaPack_BrowsePackages",
        "scope": "python",
        "description": "Opens the package browser with the given filter string.\n",
        "body": "ReaPack_BrowsePackages(${1:String filter})$0"
    },
    "REAPACK_COMPAREVERSIONS c": {
        "prefix": "ReaPack_CompareVersions",
        "scope": "c",
        "description": "Returns 0 if both versions are equal, a positive value if ver1 is higher than ver2 and a negative value otherwise.\n",
        "body": "ReaPack_CompareVersions(${1:const char* ver1},${2:const char* ver2},${3:char* errorOut},${4:int errorOut_sz})$0"
    },
    "REAPER.REAPACK_COMPAREVERSIONS lua": {
        "prefix": "reaper.ReaPack_CompareVersions",
        "scope": "lua",
        "description": "Returns 0 if both versions are equal, a positive value if ver1 is higher than ver2 and a negative value otherwise.\n",
        "body": "reaper.ReaPack_CompareVersions(${1:string ver1},${2:string ver2})$0"
    },
    "REAPACK_COMPAREVERSIONS python": {
        "prefix": "ReaPack_CompareVersions",
        "scope": "python",
        "description": "Returns 0 if both versions are equal, a positive value if ver1 is higher than ver2 and a negative value otherwise.\n",
        "body": "ReaPack_CompareVersions(${1:ver1},${2:ver2},${3:errorOut},${4:errorOut_sz})$0"
    },
    "REAPACK_ENUMOWNEDFILES c": {
        "prefix": "ReaPack_EnumOwnedFiles",
        "scope": "c",
        "description": "Enumerate the files owned by the given package. Returns false when there is no more data.\nsections: 0=not in action list, &1=main, &2=midi editor, &4=midi inline editor\ntype: see ReaPack_GetEntryInfo.\n",
        "body": "ReaPack_EnumOwnedFiles(${1:PackageEntry* entry},${2:int index},${3:char* pathOut},${4:int pathOut_sz},${5:int* sectionsOut},${6:int* typeOut})$0"
    },
    "REAPER.REAPACK_ENUMOWNEDFILES lua": {
        "prefix": "reaper.ReaPack_EnumOwnedFiles",
        "scope": "lua",
        "description": "Enumerate the files owned by the given package. Returns false when there is no more data.\nsections: 0=not in action list, &1=main, &2=midi editor, &4=midi inline editor\ntype: see ReaPack_GetEntryInfo.\n",
        "body": "reaper.ReaPack_EnumOwnedFiles(${1:PackageEntry entry},${2:integer index})$0"
    },
    "REAPACK_ENUMOWNEDFILES python": {
        "prefix": "ReaPack_EnumOwnedFiles",
        "scope": "python",
        "description": "Enumerate the files owned by the given package. Returns false when there is no more data.\nsections: 0=not in action list, &1=main, &2=midi editor, &4=midi inline editor\ntype: see ReaPack_GetEntryInfo.\n",
        "body": "ReaPack_EnumOwnedFiles(${1:entry},${2:index},${3:pathOut},${4:pathOut_sz},${5:sectionsOut},${6:typeOut})$0"
    },
    "REAPACK_FREEENTRY c": {
        "prefix": "ReaPack_FreeEntry",
        "scope": "c",
        "description": "Free resources allocated for the given package entry.\n",
        "body": "ReaPack_FreeEntry(${1:PackageEntry* entry})$0"
    },
    "REAPER.REAPACK_FREEENTRY lua": {
        "prefix": "reaper.ReaPack_FreeEntry",
        "scope": "lua",
        "description": "Free resources allocated for the given package entry.\n",
        "body": "reaper.ReaPack_FreeEntry(${1:PackageEntry entry})$0"
    },
    "REAPACK_FREEENTRY python": {
        "prefix": "ReaPack_FreeEntry",
        "scope": "python",
        "description": "Free resources allocated for the given package entry.\n",
        "body": "ReaPack_FreeEntry(${1:PackageEntry entry})$0"
    },
    "REAPACK_GETENTRYINFO c": {
        "prefix": "ReaPack_GetEntryInfo",
        "scope": "c",
        "description": "Get the repository name, category, package name, package description,\npackage type, the currently installed version, author name, pinned\nstatus and how many files are owned by the given package entry.\ntype: 1=script, 2=extension, 3=effect, 4=data, 5=theme, 6=langpack, 7=webinterface\n",
        "body": "ReaPack_GetEntryInfo(${1:PackageEntry* entry},${2:char* repoOut},${3:int repoOut_sz},${4:char* catOut},${5:int catOut_sz},${6:char* pkgOut},${7:int pkgOut_sz},${8:char* descOut},${9:int descOut_sz},${10:int* typeOut},${11:char* verOut},${12:int verOut_sz},${13:char* authorOut},${14:int authorOut_sz},${15:bool* pinnedOut},${16:int* fileCountOut})$0"
    },
    "REAPER.REAPACK_GETENTRYINFO lua": {
        "prefix": "reaper.ReaPack_GetEntryInfo",
        "scope": "lua",
        "description": "Get the repository name, category, package name, package description,\npackage type, the currently installed version, author name, pinned\nstatus and how many files are owned by the given package entry.\ntype: 1=script, 2=extension, 3=effect, 4=data, 5=theme, 6=langpack, 7=webinterface\n",
        "body": "reaper.ReaPack_GetEntryInfo(${1:PackageEntry entry})$0"
    },
    "REAPACK_GETENTRYINFO python": {
        "prefix": "ReaPack_GetEntryInfo",
        "scope": "python",
        "description": "Get the repository name, category, package name, package description,\npackage type, the currently installed version, author name, pinned\nstatus and how many files are owned by the given package entry.\ntype: 1=script, 2=extension, 3=effect, 4=data, 5=theme, 6=langpack, 7=webinterface\n",
        "body": "ReaPack_GetEntryInfo(${1:entry},${2:repoOut},${3:repoOut_sz},${4:catOut},${5:catOut_sz},${6:pkgOut},${7:pkgOut_sz},${8:descOut},${9:descOut_sz},${10:typeOut},${11:verOut},${12:verOut_sz},${13:authorOut},${14:authorOut_sz},${15:pinnedOut},${16:fileCountOut})$0"
    },
    "REAPACK_GETOWNER c": {
        "prefix": "ReaPack_GetOwner",
        "scope": "c",
        "description": "Returns the package entry owning the given file.\nDelete the returned object from memory after use with ReaPack_FreeEntry.\n",
        "body": "ReaPack_GetOwner(${1:const char* fn},${2:char* errorOut},${3:int errorOut_sz})$0"
    },
    "REAPER.REAPACK_GETOWNER lua": {
        "prefix": "reaper.ReaPack_GetOwner",
        "scope": "lua",
        "description": "Returns the package entry owning the given file.\nDelete the returned object from memory after use with ReaPack_FreeEntry.\n",
        "body": "reaper.ReaPack_GetOwner(${1:string fn})$0"
    },
    "REAPACK_GETOWNER python": {
        "prefix": "ReaPack_GetOwner",
        "scope": "python",
        "description": "Returns the package entry owning the given file.\nDelete the returned object from memory after use with ReaPack_FreeEntry.\n",
        "body": "ReaPack_GetOwner(${1:fn},${2:errorOut},${3:errorOut_sz})$0"
    },
    "REAPACK_GETREPOSITORYINFO c": {
        "prefix": "ReaPack_GetRepositoryInfo",
        "scope": "c",
        "description": "Get the infos of the given repository.\nautoInstall: 0=manual, 1=when sychronizing, 2=obey user setting\n",
        "body": "ReaPack_GetRepositoryInfo(${1:const char* name},${2:char* urlOut},${3:int urlOut_sz},${4:bool* enabledOut},${5:int* autoInstallOut})$0"
    },
    "REAPER.REAPACK_GETREPOSITORYINFO lua": {
        "prefix": "reaper.ReaPack_GetRepositoryInfo",
        "scope": "lua",
        "description": "Get the infos of the given repository.\nautoInstall: 0=manual, 1=when sychronizing, 2=obey user setting\n",
        "body": "reaper.ReaPack_GetRepositoryInfo(${1:string name})$0"
    },
    "REAPACK_GETREPOSITORYINFO python": {
        "prefix": "ReaPack_GetRepositoryInfo",
        "scope": "python",
        "description": "Get the infos of the given repository.\nautoInstall: 0=manual, 1=when sychronizing, 2=obey user setting\n",
        "body": "ReaPack_GetRepositoryInfo(${1:name},${2:urlOut},${3:urlOut_sz},${4:enabledOut},${5:autoInstallOut})$0"
    },
    "REAPACK_PROCESSQUEUE c": {
        "prefix": "ReaPack_ProcessQueue",
        "scope": "c",
        "description": "Run pending operations and save the configuration file. If refreshUI is\ntrue the browser and manager windows are guaranteed to be refreshed\n(otherwise it depends on which operations are in the queue).\n",
        "body": "ReaPack_ProcessQueue(${1:bool refreshUI})$0"
    },
    "REAPER.REAPACK_PROCESSQUEUE lua": {
        "prefix": "reaper.ReaPack_ProcessQueue",
        "scope": "lua",
        "description": "Run pending operations and save the configuration file. If refreshUI is\ntrue the browser and manager windows are guaranteed to be refreshed\n(otherwise it depends on which operations are in the queue).\n",
        "body": "reaper.ReaPack_ProcessQueue(${1:boolean refreshUI})$0"
    },
    "REAPACK_PROCESSQUEUE python": {
        "prefix": "ReaPack_ProcessQueue",
        "scope": "python",
        "description": "Run pending operations and save the configuration file. If refreshUI is\ntrue the browser and manager windows are guaranteed to be refreshed\n(otherwise it depends on which operations are in the queue).\n",
        "body": "ReaPack_ProcessQueue(${1:Boolean refreshUI})$0"
    },
    "SNM_ADDRECEIVE c": {
        "prefix": "SNM_AddReceive",
        "scope": "c",
        "description": "[S&M] Deprecated, see CreateTrackSend (v5.15pre1+). Adds a receive. Returns false if nothing updated.\ntype -1=Default type (user preferences), 0=Post-Fader (Post-Pan), 1=Pre-FX, 2=deprecated, 3=Pre-Fader (Post-FX).\nNote: obeys default sends preferences, supports frozen tracks, etc..\n",
        "body": "SNM_AddReceive(${1:MediaTrack* src},${2:MediaTrack* dest},${3:int type})$0"
    },
    "REAPER.SNM_ADDRECEIVE lua": {
        "prefix": "reaper.SNM_AddReceive",
        "scope": "lua",
        "description": "[S&M] Deprecated, see CreateTrackSend (v5.15pre1+). Adds a receive. Returns false if nothing updated.\ntype -1=Default type (user preferences), 0=Post-Fader (Post-Pan), 1=Pre-FX, 2=deprecated, 3=Pre-Fader (Post-FX).\nNote: obeys default sends preferences, supports frozen tracks, etc..\n",
        "body": "reaper.SNM_AddReceive(${1:MediaTrack src},${2:MediaTrack dest},${3:integer type})$0"
    },
    "SNM_ADDRECEIVE python": {
        "prefix": "SNM_AddReceive",
        "scope": "python",
        "description": "[S&M] Deprecated, see CreateTrackSend (v5.15pre1+). Adds a receive. Returns false if nothing updated.\ntype -1=Default type (user preferences), 0=Post-Fader (Post-Pan), 1=Pre-FX, 2=deprecated, 3=Pre-Fader (Post-FX).\nNote: obeys default sends preferences, supports frozen tracks, etc..\n",
        "body": "SNM_AddReceive(${1:MediaTrack src},${2:MediaTrack dest},${3:Int type})$0"
    },
    "SNM_ADDTCPFXPARM c": {
        "prefix": "SNM_AddTCPFXParm",
        "scope": "c",
        "description": "[S&M] Add an FX parameter knob in the TCP. Returns false if nothing\nupdated (invalid parameters, knob already present, etc..)\n",
        "body": "SNM_AddTCPFXParm(${1:MediaTrack* tr},${2:int fxId},${3:int prmId})$0"
    },
    "REAPER.SNM_ADDTCPFXPARM lua": {
        "prefix": "reaper.SNM_AddTCPFXParm",
        "scope": "lua",
        "description": "[S&M] Add an FX parameter knob in the TCP. Returns false if nothing\nupdated (invalid parameters, knob already present, etc..)\n",
        "body": "reaper.SNM_AddTCPFXParm(${1:MediaTrack tr},${2:integer fxId},${3:integer prmId})$0"
    },
    "SNM_ADDTCPFXPARM python": {
        "prefix": "SNM_AddTCPFXParm",
        "scope": "python",
        "description": "[S&M] Add an FX parameter knob in the TCP. Returns false if nothing\nupdated (invalid parameters, knob already present, etc..)\n",
        "body": "SNM_AddTCPFXParm(${1:MediaTrack tr},${2:Int fxId},${3:Int prmId})$0"
    },
    "SNM_CREATEFASTSTRING c": {
        "prefix": "SNM_CreateFastString",
        "scope": "c",
        "description": "[S&M] Instantiates a new \"fast string\". You must delete this string, see SNM_DeleteFastString.\n",
        "body": "SNM_CreateFastString(${1:const char* str})$0"
    },
    "REAPER.SNM_CREATEFASTSTRING lua": {
        "prefix": "reaper.SNM_CreateFastString",
        "scope": "lua",
        "description": "[S&M] Instantiates a new \"fast string\". You must delete this string, see SNM_DeleteFastString.\n",
        "body": "reaper.SNM_CreateFastString(${1:string str})$0"
    },
    "SNM_CREATEFASTSTRING python": {
        "prefix": "SNM_CreateFastString",
        "scope": "python",
        "description": "[S&M] Instantiates a new \"fast string\". You must delete this string, see SNM_DeleteFastString.\n",
        "body": "SNM_CreateFastString(${1:String str})$0"
    },
    "SNM_DELETEFASTSTRING c": {
        "prefix": "SNM_DeleteFastString",
        "scope": "c",
        "description": "[S&M] Deletes a \"fast string\" instance.\n",
        "body": "SNM_DeleteFastString(${1:WDL_FastString* str})$0"
    },
    "REAPER.SNM_DELETEFASTSTRING lua": {
        "prefix": "reaper.SNM_DeleteFastString",
        "scope": "lua",
        "description": "[S&M] Deletes a \"fast string\" instance.\n",
        "body": "reaper.SNM_DeleteFastString(${1:WDL_FastString str})$0"
    },
    "SNM_DELETEFASTSTRING python": {
        "prefix": "SNM_DeleteFastString",
        "scope": "python",
        "description": "[S&M] Deletes a \"fast string\" instance.\n",
        "body": "SNM_DeleteFastString(${1:WDL_FastString str})$0"
    },
    "SNM_GETDOUBLECONFIGVAR c": {
        "prefix": "SNM_GetDoubleConfigVar",
        "scope": "c",
        "description": "[S&M] Returns a double preference (look in project prefs first, then\nin general prefs). Returns errvalue if failed (e.g. varname not found).\n",
        "body": "SNM_GetDoubleConfigVar(${1:const char* varname},${2:double errvalue})$0"
    },
    "REAPER.SNM_GETDOUBLECONFIGVAR lua": {
        "prefix": "reaper.SNM_GetDoubleConfigVar",
        "scope": "lua",
        "description": "[S&M] Returns a double preference (look in project prefs first, then\nin general prefs). Returns errvalue if failed (e.g. varname not found).\n",
        "body": "reaper.SNM_GetDoubleConfigVar(${1:string varname},${2:number errvalue})$0"
    },
    "SNM_GETDOUBLECONFIGVAR python": {
        "prefix": "SNM_GetDoubleConfigVar",
        "scope": "python",
        "description": "[S&M] Returns a double preference (look in project prefs first, then\nin general prefs). Returns errvalue if failed (e.g. varname not found).\n",
        "body": "SNM_GetDoubleConfigVar(${1:String varname},${2:Float errvalue})$0"
    },
    "SNM_GETFASTSTRING c": {
        "prefix": "SNM_GetFastString",
        "scope": "c",
        "description": "[S&M] Gets the \"fast string\" content.\n",
        "body": "SNM_GetFastString(${1:WDL_FastString* str})$0"
    },
    "REAPER.SNM_GETFASTSTRING lua": {
        "prefix": "reaper.SNM_GetFastString",
        "scope": "lua",
        "description": "[S&M] Gets the \"fast string\" content.\n",
        "body": "reaper.SNM_GetFastString(${1:WDL_FastString str})$0"
    },
    "SNM_GETFASTSTRING python": {
        "prefix": "SNM_GetFastString",
        "scope": "python",
        "description": "[S&M] Gets the \"fast string\" content.\n",
        "body": "SNM_GetFastString(${1:WDL_FastString str})$0"
    },
    "SNM_GETFASTSTRINGLENGTH c": {
        "prefix": "SNM_GetFastStringLength",
        "scope": "c",
        "description": "[S&M] Gets the \"fast string\" length.\n",
        "body": "SNM_GetFastStringLength(${1:WDL_FastString* str})$0"
    },
    "REAPER.SNM_GETFASTSTRINGLENGTH lua": {
        "prefix": "reaper.SNM_GetFastStringLength",
        "scope": "lua",
        "description": "[S&M] Gets the \"fast string\" length.\n",
        "body": "reaper.SNM_GetFastStringLength(${1:WDL_FastString str})$0"
    },
    "SNM_GETFASTSTRINGLENGTH python": {
        "prefix": "SNM_GetFastStringLength",
        "scope": "python",
        "description": "[S&M] Gets the \"fast string\" length.\n",
        "body": "SNM_GetFastStringLength(${1:WDL_FastString str})$0"
    },
    "SNM_GETINTCONFIGVAR c": {
        "prefix": "SNM_GetIntConfigVar",
        "scope": "c",
        "description": "[S&M] Returns an integer preference (look in project prefs first,\nthen in general prefs). Returns errvalue if failed (e.g. varname not\nfound).\n",
        "body": "SNM_GetIntConfigVar(${1:const char* varname},${2:int errvalue})$0"
    },
    "REAPER.SNM_GETINTCONFIGVAR lua": {
        "prefix": "reaper.SNM_GetIntConfigVar",
        "scope": "lua",
        "description": "[S&M] Returns an integer preference (look in project prefs first,\nthen in general prefs). Returns errvalue if failed (e.g. varname not\nfound).\n",
        "body": "reaper.SNM_GetIntConfigVar(${1:string varname},${2:integer errvalue})$0"
    },
    "SNM_GETINTCONFIGVAR python": {
        "prefix": "SNM_GetIntConfigVar",
        "scope": "python",
        "description": "[S&M] Returns an integer preference (look in project prefs first,\nthen in general prefs). Returns errvalue if failed (e.g. varname not\nfound).\n",
        "body": "SNM_GetIntConfigVar(${1:String varname},${2:Int errvalue})$0"
    },
    "SNM_GETMEDIAITEMTAKEBYGUID c": {
        "prefix": "SNM_GetMediaItemTakeByGUID",
        "scope": "c",
        "description": "[S&M] Gets a take by GUID as string. The GUID must be enclosed in braces {}. To get take GUID as string, see BR_GetMediaItemTakeGUID\n",
        "body": "SNM_GetMediaItemTakeByGUID(${1:ReaProject* project},${2:const char* guid})$0"
    },
    "REAPER.SNM_GETMEDIAITEMTAKEBYGUID lua": {
        "prefix": "reaper.SNM_GetMediaItemTakeByGUID",
        "scope": "lua",
        "description": "[S&M] Gets a take by GUID as string. The GUID must be enclosed in braces {}. To get take GUID as string, see BR_GetMediaItemTakeGUID\n",
        "body": "reaper.SNM_GetMediaItemTakeByGUID(${1:ReaProject project},${2:string guid})$0"
    },
    "SNM_GETMEDIAITEMTAKEBYGUID python": {
        "prefix": "SNM_GetMediaItemTakeByGUID",
        "scope": "python",
        "description": "[S&M] Gets a take by GUID as string. The GUID must be enclosed in braces {}. To get take GUID as string, see BR_GetMediaItemTakeGUID\n",
        "body": "SNM_GetMediaItemTakeByGUID(${1:ReaProject project},${2:String guid})$0"
    },
    "SNM_GETPROJECTMARKERNAME c": {
        "prefix": "SNM_GetProjectMarkerName",
        "scope": "c",
        "description": "[S&M] Gets a marker/region name. Returns true if marker/region found.\n",
        "body": "SNM_GetProjectMarkerName(${1:ReaProject* proj},${2:int num},${3:bool isrgn},${4:WDL_FastString* name})$0"
    },
    "REAPER.SNM_GETPROJECTMARKERNAME lua": {
        "prefix": "reaper.SNM_GetProjectMarkerName",
        "scope": "lua",
        "description": "[S&M] Gets a marker/region name. Returns true if marker/region found.\n",
        "body": "reaper.SNM_GetProjectMarkerName(${1:ReaProject proj},${2:integer num},${3:boolean isrgnWDL_FastString name})$0"
    },
    "SNM_GETPROJECTMARKERNAME python": {
        "prefix": "SNM_GetProjectMarkerName",
        "scope": "python",
        "description": "[S&M] Gets a marker/region name. Returns true if marker/region found.\n",
        "body": "SNM_GetProjectMarkerName(${1:ReaProject proj},${2:Int num},${3:Boolean isrgn},${4:WDL_FastString name})$0"
    },
    "SNM_GETSETOBJECTSTATE c": {
        "prefix": "SNM_GetSetObjectState",
        "scope": "c",
        "description": "[S&M] Gets or sets the state of a track, an item or an envelope. The state chunk size is unlimited. Returns false if failed.\nWhen getting a track state (and when you are not interested in FX data),\nyou can use wantminimalstate=true to radically reduce the length of the\nstate. Do not set such minimal states back though, this is for\nread-only applications!\nNote: unlike the native GetSetObjectState, calling to FreeHeapPtr() is not required.\n",
        "body": "SNM_GetSetObjectState(${1:void* obj},${2:WDL_FastString* state},${3:bool setnewvalue},${4:bool wantminimalstate})$0"
    },
    "REAPER.SNM_GETSETOBJECTSTATE lua": {
        "prefix": "reaper.SNM_GetSetObjectState",
        "scope": "lua",
        "description": "[S&M] Gets or sets the state of a track, an item or an envelope. The state chunk size is unlimited. Returns false if failed.\nWhen getting a track state (and when you are not interested in FX data),\nyou can use wantminimalstate=true to radically reduce the length of the\nstate. Do not set such minimal states back though, this is for\nread-only applications!\nNote: unlike the native GetSetObjectState, calling to FreeHeapPtr() is not required.\n",
        "body": "reaper.SNM_GetSetObjectState(${1:identifier objWDL_FastString state},${2:boolean setnewvalue},${3:boolean wantminimalstate})$0"
    },
    "SNM_GETSETOBJECTSTATE python": {
        "prefix": "SNM_GetSetObjectState",
        "scope": "python",
        "description": "[S&M] Gets or sets the state of a track, an item or an envelope. The state chunk size is unlimited. Returns false if failed.\nWhen getting a track state (and when you are not interested in FX data),\nyou can use wantminimalstate=true to radically reduce the length of the\nstate. Do not set such minimal states back though, this is for\nread-only applications!\nNote: unlike the native GetSetObjectState, calling to FreeHeapPtr() is not required.\n",
        "body": "SNM_GetSetObjectState(${1:void obj},${2:WDL_FastString state},${3:Boolean setnewvalue},${4:Boolean wantminimalstate})$0"
    },
    "SNM_GETSETSOURCESTATE c": {
        "prefix": "SNM_GetSetSourceState",
        "scope": "c",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed. Use takeidx=-1 to get/alter the active take.\nNote: this function does not use a MediaItem_Take* param in order to\nmanage empty takes (i.e. takes with MediaItem_Take*==NULL), see SNM_GetSetSourceState2.\n",
        "body": "SNM_GetSetSourceState(${1:MediaItem* item},${2:int takeidx},${3:WDL_FastString* state},${4:bool setnewvalue})$0"
    },
    "REAPER.SNM_GETSETSOURCESTATE lua": {
        "prefix": "reaper.SNM_GetSetSourceState",
        "scope": "lua",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed. Use takeidx=-1 to get/alter the active take.\nNote: this function does not use a MediaItem_Take* param in order to\nmanage empty takes (i.e. takes with MediaItem_Take*==NULL), see SNM_GetSetSourceState2.\n",
        "body": "reaper.SNM_GetSetSourceState(${1:MediaItem item},${2:integer takeidxWDL_FastString state},${3:boolean setnewvalue})$0"
    },
    "SNM_GETSETSOURCESTATE python": {
        "prefix": "SNM_GetSetSourceState",
        "scope": "python",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed. Use takeidx=-1 to get/alter the active take.\nNote: this function does not use a MediaItem_Take* param in order to\nmanage empty takes (i.e. takes with MediaItem_Take*==NULL), see SNM_GetSetSourceState2.\n",
        "body": "SNM_GetSetSourceState(${1:MediaItem item},${2:Int takeidx},${3:WDL_FastString state},${4:Boolean setnewvalue})$0"
    },
    "SNM_GETSETSOURCESTATE2 c": {
        "prefix": "SNM_GetSetSourceState2",
        "scope": "c",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed.\nNote: this function cannot deal with empty takes, see SNM_GetSetSourceState.\n",
        "body": "SNM_GetSetSourceState2(${1:MediaItem_Take* take},${2:WDL_FastString* state},${3:bool setnewvalue})$0"
    },
    "REAPER.SNM_GETSETSOURCESTATE2 lua": {
        "prefix": "reaper.SNM_GetSetSourceState2",
        "scope": "lua",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed.\nNote: this function cannot deal with empty takes, see SNM_GetSetSourceState.\n",
        "body": "reaper.SNM_GetSetSourceState2(${1:MediaItem_Take takeWDL_FastString state},${2:boolean setnewvalue})$0"
    },
    "SNM_GETSETSOURCESTATE2 python": {
        "prefix": "SNM_GetSetSourceState2",
        "scope": "python",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed.\nNote: this function cannot deal with empty takes, see SNM_GetSetSourceState.\n",
        "body": "SNM_GetSetSourceState2(${1:MediaItem_Take take},${2:WDL_FastString state},${3:Boolean setnewvalue})$0"
    },
    "SNM_GETSOURCETYPE c": {
        "prefix": "SNM_GetSourceType",
        "scope": "c",
        "description": "[S&M] Gets the source type of a take. Returns false if failed (e.g. take with empty source, etc..)\n",
        "body": "SNM_GetSourceType(${1:MediaItem_Take* take},${2:WDL_FastString* type})$0"
    },
    "REAPER.SNM_GETSOURCETYPE lua": {
        "prefix": "reaper.SNM_GetSourceType",
        "scope": "lua",
        "description": "[S&M] Gets the source type of a take. Returns false if failed (e.g. take with empty source, etc..)\n",
        "body": "reaper.SNM_GetSourceType(${1:MediaItem_Take takeWDL_FastString type})$0"
    },
    "SNM_GETSOURCETYPE python": {
        "prefix": "SNM_GetSourceType",
        "scope": "python",
        "description": "[S&M] Gets the source type of a take. Returns false if failed (e.g. take with empty source, etc..)\n",
        "body": "SNM_GetSourceType(${1:MediaItem_Take take},${2:WDL_FastString type})$0"
    },
    "SNM_MOVEORREMOVETRACKFX c": {
        "prefix": "SNM_MoveOrRemoveTrackFX",
        "scope": "c",
        "description": "[S&M] Deprecated, see TakeFX_/TrackFX_ CopyToTrack/Take,\nTrackFX/TakeFX _Delete (v5.95pre2+). Move or removes a track FX. Returns\ntrue if tr has been updated.\nfxId: fx index in chain or -1 for the selected fx. what: 0 to remove, -1 to move fx up in chain, 1 to move fx down in chain.\n",
        "body": "SNM_MoveOrRemoveTrackFX(${1:MediaTrack* tr},${2:int fxId},${3:int what})$0"
    },
    "REAPER.SNM_MOVEORREMOVETRACKFX lua": {
        "prefix": "reaper.SNM_MoveOrRemoveTrackFX",
        "scope": "lua",
        "description": "[S&M] Deprecated, see TakeFX_/TrackFX_ CopyToTrack/Take,\nTrackFX/TakeFX _Delete (v5.95pre2+). Move or removes a track FX. Returns\ntrue if tr has been updated.\nfxId: fx index in chain or -1 for the selected fx. what: 0 to remove, -1 to move fx up in chain, 1 to move fx down in chain.\n",
        "body": "reaper.SNM_MoveOrRemoveTrackFX(${1:MediaTrack tr},${2:integer fxId},${3:integer what})$0"
    },
    "SNM_MOVEORREMOVETRACKFX python": {
        "prefix": "SNM_MoveOrRemoveTrackFX",
        "scope": "python",
        "description": "[S&M] Deprecated, see TakeFX_/TrackFX_ CopyToTrack/Take,\nTrackFX/TakeFX _Delete (v5.95pre2+). Move or removes a track FX. Returns\ntrue if tr has been updated.\nfxId: fx index in chain or -1 for the selected fx. what: 0 to remove, -1 to move fx up in chain, 1 to move fx down in chain.\n",
        "body": "SNM_MoveOrRemoveTrackFX(${1:MediaTrack tr},${2:Int fxId},${3:Int what})$0"
    },
    "SNM_READMEDIAFILETAG c": {
        "prefix": "SNM_ReadMediaFileTag",
        "scope": "c",
        "description": "[S&M] Reads a media file tag. Supported tags: \"artist\", \"album\",\n\"genre\", \"comment\", \"title\", or \"year\". Returns false if tag was not\nfound. See SNM_TagMediaFile.\n",
        "body": "SNM_ReadMediaFileTag(${1:const char* fn},${2:const char* tag},${3:char* tagval},${4:int tagval_sz})$0"
    },
    "REAPER.SNM_READMEDIAFILETAG lua": {
        "prefix": "reaper.SNM_ReadMediaFileTag",
        "scope": "lua",
        "description": "[S&M] Reads a media file tag. Supported tags: \"artist\", \"album\",\n\"genre\", \"comment\", \"title\", or \"year\". Returns false if tag was not\nfound. See SNM_TagMediaFile.\n",
        "body": "reaper.SNM_ReadMediaFileTag(${1:string fn},${2:string tag},${3:string tagval})$0"
    },
    "SNM_READMEDIAFILETAG python": {
        "prefix": "SNM_ReadMediaFileTag",
        "scope": "python",
        "description": "[S&M] Reads a media file tag. Supported tags: \"artist\", \"album\",\n\"genre\", \"comment\", \"title\", or \"year\". Returns false if tag was not\nfound. See SNM_TagMediaFile.\n",
        "body": "SNM_ReadMediaFileTag(${1:fn},${2:tag},${3:tagval},${4:tagval_sz})$0"
    },
    "SNM_REMOVERECEIVE c": {
        "prefix": "SNM_RemoveReceive",
        "scope": "c",
        "description": "[S&M] Deprecated, see RemoveTrackSend (v5.15pre1+). Removes a receive. Returns false if nothing updated.\n",
        "body": "SNM_RemoveReceive(${1:MediaTrack* tr},${2:int rcvidx})$0"
    },
    "REAPER.SNM_REMOVERECEIVE lua": {
        "prefix": "reaper.SNM_RemoveReceive",
        "scope": "lua",
        "description": "[S&M] Deprecated, see RemoveTrackSend (v5.15pre1+). Removes a receive. Returns false if nothing updated.\n",
        "body": "reaper.SNM_RemoveReceive(${1:MediaTrack tr},${2:integer rcvidx})$0"
    },
    "SNM_REMOVERECEIVE python": {
        "prefix": "SNM_RemoveReceive",
        "scope": "python",
        "description": "[S&M] Deprecated, see RemoveTrackSend (v5.15pre1+). Removes a receive. Returns false if nothing updated.\n",
        "body": "SNM_RemoveReceive(${1:MediaTrack tr},${2:Int rcvidx})$0"
    },
    "SNM_REMOVERECEIVESFROM c": {
        "prefix": "SNM_RemoveReceivesFrom",
        "scope": "c",
        "description": "[S&M] Removes all receives from srctr. Returns false if nothing updated.\n",
        "body": "SNM_RemoveReceivesFrom(${1:MediaTrack* tr},${2:MediaTrack* srctr})$0"
    },
    "REAPER.SNM_REMOVERECEIVESFROM lua": {
        "prefix": "reaper.SNM_RemoveReceivesFrom",
        "scope": "lua",
        "description": "[S&M] Removes all receives from srctr. Returns false if nothing updated.\n",
        "body": "reaper.SNM_RemoveReceivesFrom(${1:MediaTrack tr},${2:MediaTrack srctr})$0"
    },
    "SNM_REMOVERECEIVESFROM python": {
        "prefix": "SNM_RemoveReceivesFrom",
        "scope": "python",
        "description": "[S&M] Removes all receives from srctr. Returns false if nothing updated.\n",
        "body": "SNM_RemoveReceivesFrom(${1:MediaTrack tr},${2:MediaTrack srctr})$0"
    },
    "SNM_SELECTRESOURCEBOOKMARK c": {
        "prefix": "SNM_SelectResourceBookmark",
        "scope": "c",
        "description": "[S&M] Select a bookmark of the Resources window. Returns the related bookmark id (or -1 if failed).\n",
        "body": "SNM_SelectResourceBookmark(${1:const char* name})$0"
    },
    "REAPER.SNM_SELECTRESOURCEBOOKMARK lua": {
        "prefix": "reaper.SNM_SelectResourceBookmark",
        "scope": "lua",
        "description": "[S&M] Select a bookmark of the Resources window. Returns the related bookmark id (or -1 if failed).\n",
        "body": "reaper.SNM_SelectResourceBookmark(${1:string name})$0"
    },
    "SNM_SELECTRESOURCEBOOKMARK python": {
        "prefix": "SNM_SelectResourceBookmark",
        "scope": "python",
        "description": "[S&M] Select a bookmark of the Resources window. Returns the related bookmark id (or -1 if failed).\n",
        "body": "SNM_SelectResourceBookmark(${1:String name})$0"
    },
    "SNM_SETDOUBLECONFIGVAR c": {
        "prefix": "SNM_SetDoubleConfigVar",
        "scope": "c",
        "description": "[S&M] Sets a double preference (look in project prefs first, then in\ngeneral prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "SNM_SetDoubleConfigVar(${1:const char* varname},${2:double newvalue})$0"
    },
    "REAPER.SNM_SETDOUBLECONFIGVAR lua": {
        "prefix": "reaper.SNM_SetDoubleConfigVar",
        "scope": "lua",
        "description": "[S&M] Sets a double preference (look in project prefs first, then in\ngeneral prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "reaper.SNM_SetDoubleConfigVar(${1:string varname},${2:number newvalue})$0"
    },
    "SNM_SETDOUBLECONFIGVAR python": {
        "prefix": "SNM_SetDoubleConfigVar",
        "scope": "python",
        "description": "[S&M] Sets a double preference (look in project prefs first, then in\ngeneral prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "SNM_SetDoubleConfigVar(${1:String varname},${2:Float newvalue})$0"
    },
    "SNM_SETFASTSTRING c": {
        "prefix": "SNM_SetFastString",
        "scope": "c",
        "description": "[S&M] Sets the \"fast string\" content. Returns str for facility.\n",
        "body": "SNM_SetFastString(${1:WDL_FastString* str},${2:const char* newstr})$0"
    },
    "REAPER.SNM_SETFASTSTRING lua": {
        "prefix": "reaper.SNM_SetFastString",
        "scope": "lua",
        "description": "[S&M] Sets the \"fast string\" content. Returns str for facility.\n",
        "body": "reaper.SNM_SetFastString(${1:WDL_FastString str},${2:string newstr})$0"
    },
    "SNM_SETFASTSTRING python": {
        "prefix": "SNM_SetFastString",
        "scope": "python",
        "description": "[S&M] Sets the \"fast string\" content. Returns str for facility.\n",
        "body": "SNM_SetFastString(${1:WDL_FastString str},${2:String newstr})$0"
    },
    "SNM_SETINTCONFIGVAR c": {
        "prefix": "SNM_SetIntConfigVar",
        "scope": "c",
        "description": "[S&M] Sets an integer preference (look in project prefs first, then\nin general prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "SNM_SetIntConfigVar(${1:const char* varname},${2:int newvalue})$0"
    },
    "REAPER.SNM_SETINTCONFIGVAR lua": {
        "prefix": "reaper.SNM_SetIntConfigVar",
        "scope": "lua",
        "description": "[S&M] Sets an integer preference (look in project prefs first, then\nin general prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "reaper.SNM_SetIntConfigVar(${1:string varname},${2:integer newvalue})$0"
    },
    "SNM_SETINTCONFIGVAR python": {
        "prefix": "SNM_SetIntConfigVar",
        "scope": "python",
        "description": "[S&M] Sets an integer preference (look in project prefs first, then\nin general prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "SNM_SetIntConfigVar(${1:String varname},${2:Int newvalue})$0"
    },
    "SNM_SETPROJECTMARKER c": {
        "prefix": "SNM_SetProjectMarker",
        "scope": "c",
        "description": "[S&M] Deprecated, see SetProjectMarker4 -- Same function as SetProjectMarker3() except it can set empty names \"\".\n",
        "body": "SNM_SetProjectMarker(${1:ReaProject* proj},${2:int num},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:const char* name},${7:int color})$0"
    },
    "REAPER.SNM_SETPROJECTMARKER lua": {
        "prefix": "reaper.SNM_SetProjectMarker",
        "scope": "lua",
        "description": "[S&M] Deprecated, see SetProjectMarker4 -- Same function as SetProjectMarker3() except it can set empty names \"\".\n",
        "body": "reaper.SNM_SetProjectMarker(${1:ReaProject proj},${2:integer num},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:string name},${7:integer color})$0"
    },
    "SNM_SETPROJECTMARKER python": {
        "prefix": "SNM_SetProjectMarker",
        "scope": "python",
        "description": "[S&M] Deprecated, see SetProjectMarker4 -- Same function as SetProjectMarker3() except it can set empty names \"\".\n",
        "body": "SNM_SetProjectMarker(${1:ReaProject proj},${2:Int num},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:String name},${7:Int color})$0"
    },
    "SNM_TAGMEDIAFILE c": {
        "prefix": "SNM_TagMediaFile",
        "scope": "c",
        "description": "[S&M] Tags a media file thanks to TagLib.\nSupported tags: \"artist\", \"album\", \"genre\", \"comment\", \"title\", or\n\"year\". Use an empty tagval to clear a tag. When a file is opened in\nREAPER, turn it offline before using this function. Returns false if\nnothing updated. See SNM_ReadMediaFileTag.\n",
        "body": "SNM_TagMediaFile(${1:const char* fn},${2:const char* tag},${3:const char* tagval})$0"
    },
    "REAPER.SNM_TAGMEDIAFILE lua": {
        "prefix": "reaper.SNM_TagMediaFile",
        "scope": "lua",
        "description": "[S&M] Tags a media file thanks to TagLib.\nSupported tags: \"artist\", \"album\", \"genre\", \"comment\", \"title\", or\n\"year\". Use an empty tagval to clear a tag. When a file is opened in\nREAPER, turn it offline before using this function. Returns false if\nnothing updated. See SNM_ReadMediaFileTag.\n",
        "body": "reaper.SNM_TagMediaFile(${1:string fn},${2:string tag},${3:string tagval})$0"
    },
    "SNM_TAGMEDIAFILE python": {
        "prefix": "SNM_TagMediaFile",
        "scope": "python",
        "description": "[S&M] Tags a media file thanks to TagLib.\nSupported tags: \"artist\", \"album\", \"genre\", \"comment\", \"title\", or\n\"year\". Use an empty tagval to clear a tag. When a file is opened in\nREAPER, turn it offline before using this function. Returns false if\nnothing updated. See SNM_ReadMediaFileTag.\n",
        "body": "SNM_TagMediaFile(${1:String fn},${2:String tag},${3:String tagval})$0"
    },
    "SNM_TIERESOURCESLOTACTIONS c": {
        "prefix": "SNM_TieResourceSlotActions",
        "scope": "c",
        "description": "[S&M] Attach Resources slot actions to a given bookmark.\n",
        "body": "SNM_TieResourceSlotActions(${1:int bookmarkId})$0"
    },
    "REAPER.SNM_TIERESOURCESLOTACTIONS lua": {
        "prefix": "reaper.SNM_TieResourceSlotActions",
        "scope": "lua",
        "description": "[S&M] Attach Resources slot actions to a given bookmark.\n",
        "body": "reaper.SNM_TieResourceSlotActions(${1:integer bookmarkId})$0"
    },
    "SNM_TIERESOURCESLOTACTIONS python": {
        "prefix": "SNM_TieResourceSlotActions",
        "scope": "python",
        "description": "[S&M] Attach Resources slot actions to a given bookmark.\n",
        "body": "SNM_TieResourceSlotActions(${1:Int bookmarkId})$0"
    },
    "SN_FOCUSMIDIEDITOR c": {
        "prefix": "SN_FocusMIDIEditor",
        "scope": "c",
        "description": "Focuses the active/open MIDI editor.\n",
        "body": "SN_FocusMIDIEditor()$0"
    },
    "REAPER.SN_FOCUSMIDIEDITOR lua": {
        "prefix": "reaper.SN_FocusMIDIEditor",
        "scope": "lua",
        "description": "Focuses the active/open MIDI editor.\n",
        "body": "reaper.SN_FocusMIDIEditor()$0"
    },
    "SN_FOCUSMIDIEDITOR python": {
        "prefix": "SN_FocusMIDIEditor",
        "scope": "python",
        "description": "Focuses the active/open MIDI editor.\n",
        "body": "SN_FocusMIDIEditor()$0"
    },
    "ULT_GETMEDIAITEMNOTE c": {
        "prefix": "ULT_GetMediaItemNote",
        "scope": "c",
        "description": "[ULT] Get item notes.\n",
        "body": "ULT_GetMediaItemNote(${1:MediaItem* item})$0"
    },
    "REAPER.ULT_GETMEDIAITEMNOTE lua": {
        "prefix": "reaper.ULT_GetMediaItemNote",
        "scope": "lua",
        "description": "[ULT] Get item notes.\n",
        "body": "reaper.ULT_GetMediaItemNote(${1:MediaItem item})$0"
    },
    "ULT_GETMEDIAITEMNOTE python": {
        "prefix": "ULT_GetMediaItemNote",
        "scope": "python",
        "description": "[ULT] Get item notes.\n",
        "body": "ULT_GetMediaItemNote(${1:MediaItem item})$0"
    },
    "ULT_SETMEDIAITEMNOTE c": {
        "prefix": "ULT_SetMediaItemNote",
        "scope": "c",
        "description": "[ULT] Set item notes.\n",
        "body": "ULT_SetMediaItemNote(${1:MediaItem* item},${2:const char* note})$0"
    },
    "REAPER.ULT_SETMEDIAITEMNOTE lua": {
        "prefix": "reaper.ULT_SetMediaItemNote",
        "scope": "lua",
        "description": "[ULT] Set item notes.\n",
        "body": "reaper.ULT_SetMediaItemNote(${1:MediaItem item},${2:string note})$0"
    },
    "ULT_SETMEDIAITEMNOTE python": {
        "prefix": "ULT_SetMediaItemNote",
        "scope": "python",
        "description": "[ULT] Set item notes.\n",
        "body": "ULT_SetMediaItemNote(${1:MediaItem item},${2:String note})$0"
    },
    "XEN_AUDIOWRITER_CREATE c": {
        "prefix": "Xen_AudioWriter_Create",
        "scope": "c",
        "description": "Creates writer for 32 bit floating point WAV\n",
        "body": "Xen_AudioWriter_Create(${1:const char* filename},${2:int numchans},${3:int samplerate})$0"
    },
    "REAPER.XEN_AUDIOWRITER_CREATE lua": {
        "prefix": "reaper.Xen_AudioWriter_Create",
        "scope": "lua",
        "description": "Creates writer for 32 bit floating point WAV\n",
        "body": "reaper.Xen_AudioWriter_Create(${1:string filename},${2:integer numchans},${3:integer samplerate})$0"
    },
    "XEN_AUDIOWRITER_CREATE python": {
        "prefix": "Xen_AudioWriter_Create",
        "scope": "python",
        "description": "Creates writer for 32 bit floating point WAV\n",
        "body": "Xen_AudioWriter_Create(${1:String filename},${2:Int numchans},${3:Int samplerate})$0"
    },
    "XEN_AUDIOWRITER_DESTROY c": {
        "prefix": "Xen_AudioWriter_Destroy",
        "scope": "c",
        "description": "Destroys writer\n",
        "body": "Xen_AudioWriter_Destroy(${1:AudioWriter* writer})$0"
    },
    "REAPER.XEN_AUDIOWRITER_DESTROY lua": {
        "prefix": "reaper.Xen_AudioWriter_Destroy",
        "scope": "lua",
        "description": "Destroys writer\n",
        "body": "reaper.Xen_AudioWriter_Destroy(${1:AudioWriter writer})$0"
    },
    "XEN_AUDIOWRITER_DESTROY python": {
        "prefix": "Xen_AudioWriter_Destroy",
        "scope": "python",
        "description": "Destroys writer\n",
        "body": "Xen_AudioWriter_Destroy(${1:AudioWriter writer})$0"
    },
    "XEN_AUDIOWRITER_WRITE c": {
        "prefix": "Xen_AudioWriter_Write",
        "scope": "c",
        "description": "Write interleaved audio data to disk\n",
        "body": "Xen_AudioWriter_Write(${1:AudioWriter* writer},${2:int numframes},${3:void* data},${4:int offset})$0"
    },
    "REAPER.XEN_AUDIOWRITER_WRITE lua": {
        "prefix": "reaper.Xen_AudioWriter_Write",
        "scope": "lua",
        "description": "Write interleaved audio data to disk\n",
        "body": "reaper.Xen_AudioWriter_Write(${1:AudioWriter writer},${2:integer numframes},${3:identifier data},${4:integer offset})$0"
    },
    "XEN_AUDIOWRITER_WRITE python": {
        "prefix": "Xen_AudioWriter_Write",
        "scope": "python",
        "description": "Write interleaved audio data to disk\n",
        "body": "Xen_AudioWriter_Write(${1:AudioWriter writer},${2:Int numframes},${3:void data},${4:Int offset})$0"
    },
    "XEN_GETMEDIASOURCESAMPLES c": {
        "prefix": "Xen_GetMediaSourceSamples",
        "scope": "c",
        "description": "Get interleaved audio data from media source\n",
        "body": "Xen_GetMediaSourceSamples(${1:PCM_source* src},${2:void* destbuf},${3:int destbufoffset},${4:int numframes},${5:int numchans},${6:double samplerate},${7:double sourceposition})$0"
    },
    "REAPER.XEN_GETMEDIASOURCESAMPLES lua": {
        "prefix": "reaper.Xen_GetMediaSourceSamples",
        "scope": "lua",
        "description": "Get interleaved audio data from media source\n",
        "body": "reaper.Xen_GetMediaSourceSamples(${1:PCM_source src},${2:identifier destbuf},${3:integer destbufoffset},${4:integer numframes},${5:integer numchans},${6:number samplerate},${7:number sourceposition})$0"
    },
    "XEN_GETMEDIASOURCESAMPLES python": {
        "prefix": "Xen_GetMediaSourceSamples",
        "scope": "python",
        "description": "Get interleaved audio data from media source\n",
        "body": "Xen_GetMediaSourceSamples(${1:PCM_source src},${2:void destbuf},${3:Int destbufoffset},${4:Int numframes},${5:Int numchans},${6:Float samplerate},${7:Float sourceposition})$0"
    },
    "XEN_STARTSOURCEPREVIEW c": {
        "prefix": "Xen_StartSourcePreview",
        "scope": "c",
        "description": "Start audio preview of a PCM_source. Returns id of a preview handle that can be provided to Xen_StopSourcePreview.\nIf the given PCM_source does not belong to an existing MediaItem/Take,\nit will be deleted by the preview system when the preview is stopped.\n",
        "body": "Xen_StartSourcePreview(${1:PCM_source* source},${2:double gain},${3:bool loop},${4:int* outputchanindexInOptional})$0"
    },
    "REAPER.XEN_STARTSOURCEPREVIEW lua": {
        "prefix": "reaper.Xen_StartSourcePreview",
        "scope": "lua",
        "description": "Start audio preview of a PCM_source. Returns id of a preview handle that can be provided to Xen_StopSourcePreview.\nIf the given PCM_source does not belong to an existing MediaItem/Take,\nit will be deleted by the preview system when the preview is stopped.\n",
        "body": "reaper.Xen_StartSourcePreview(${1:PCM_source source},${2:number gain},${3:boolean loop},${4:optional number outputchanindexIn})$0"
    },
    "XEN_STARTSOURCEPREVIEW python": {
        "prefix": "Xen_StartSourcePreview",
        "scope": "python",
        "description": "Start audio preview of a PCM_source. Returns id of a preview handle that can be provided to Xen_StopSourcePreview.\nIf the given PCM_source does not belong to an existing MediaItem/Take,\nit will be deleted by the preview system when the preview is stopped.\n",
        "body": "Xen_StartSourcePreview(${1:source},${2:gain},${3:loop},${4:outputchanindexInOptional})$0"
    },
    "XEN_STOPSOURCEPREVIEW c": {
        "prefix": "Xen_StopSourcePreview",
        "scope": "c",
        "description": "Stop audio preview. id -1 stops all.\n",
        "body": "Xen_StopSourcePreview(${1:int preview_id})$0"
    },
    "REAPER.XEN_STOPSOURCEPREVIEW lua": {
        "prefix": "reaper.Xen_StopSourcePreview",
        "scope": "lua",
        "description": "Stop audio preview. id -1 stops all.\n",
        "body": "reaper.Xen_StopSourcePreview(${1:integer preview_id})$0"
    },
    "XEN_STOPSOURCEPREVIEW python": {
        "prefix": "Xen_StopSourcePreview",
        "scope": "python",
        "description": "Stop audio preview. id -1 stops all.\n",
        "body": "Xen_StopSourcePreview(${1:Int preview_id})$0"
    },
    "ABS eel2": {
        "prefix": "abs",
        "scope": "eel2",
        "description": "Returns the absolute value of the parameter.\n",
        "body": "abs(${1:value})$0"
    },
    "ACOS eel2": {
        "prefix": "acos",
        "scope": "eel2",
        "description": "Returns the arc cosine of the value\nspecified (return value is in radians). If the parameter is not between\n-1.0 and 1.0 inclusive, the return value is undefined.\n",
        "body": "acos(${1:value})$0"
    },
    "ASIN eel2": {
        "prefix": "asin",
        "scope": "eel2",
        "description": "Returns the arc sine of the value\nspecified (return value is in radians). If the parameter is not between\n-1.0 and 1.0 inclusive, the return value is undefined.\n",
        "body": "asin(${1:value})$0"
    },
    "ATAN eel2": {
        "prefix": "atan",
        "scope": "eel2",
        "description": "Returns the arc tangent of the\nvalue specified (return value is in radians). If the parameter is not\nbetween -1.0 and 1.0 inclusive, the return value is undefined.\n",
        "body": "atan(${1:value})$0"
    },
    "ATAN2 eel2": {
        "prefix": "atan2",
        "scope": "eel2",
        "description": "Returns the arc\ntangent of the numerator divided by the denominator, allowing the\ndenominator to be 0, and using their signs to produce a more meaningful\nresult.\n",
        "body": "atan2(${1:numerator},${2:denominator})$0"
    },
    "ATEXIT eel2": {
        "prefix": "atexit",
        "scope": "eel2",
        "description": "Adds code to be executed when\nthe script finishes or is ended by the user. Typically used to clean up\nafter the user terminates defer() or runloop() code.\n",
        "body": "atexit(${1:\"code\"})$0"
    },
    "CEIL eel2": {
        "prefix": "ceil",
        "scope": "eel2",
        "description": "Returns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).\n",
        "body": "ceil(${1:value})$0"
    },
    "CONVOLVE_C eel2": {
        "prefix": "convolve_c",
        "scope": "eel2",
        "description": "Multiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.\n",
        "body": "convolve_c(${1:dest},${2:src},${3:size})$0"
    },
    "COS eel2": {
        "prefix": "cos",
        "scope": "eel2",
        "description": "Returns the cosine of the angle specified (specified in radians).\n",
        "body": "cos(${1:angle})$0"
    },
    "DEFER eel2": {
        "prefix": "defer",
        "scope": "eel2",
        "description": "Adds code to be called back by\nREAPER. Used to create persistent ReaScripts that continue to run and\nrespond to input, while the user does other tasks. Identical to\nrunloop().\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n",
        "body": "defer(${1:\"code\"})$0"
    },
    "EVAL eel2": {
        "prefix": "eval",
        "scope": "eel2",
        "description": "Executes code passed in. Code can use functions, but functions created in code can't be used elsewhere.\n",
        "body": "eval(${1:\"code\"})$0"
    },
    "EXP eel2": {
        "prefix": "exp",
        "scope": "eel2",
        "description": "Returns the number e ($e,\napproximately 2.718) raised to the parameter-th power. This function is\nsignificantly faster than pow() or the ^ operator.\n",
        "body": "exp(${1:exponent})$0"
    },
    "FCLOSE eel2": {
        "prefix": "fclose",
        "scope": "eel2",
        "description": "Closes a file previously opened with fopen().\n",
        "body": "fclose(${1:fp})$0"
    },
    "FEOF eel2": {
        "prefix": "feof",
        "scope": "eel2",
        "description": "Returns nonzero if the file fp is at the end of file.\n",
        "body": "feof(${1:fp})$0"
    },
    "FFLUSH eel2": {
        "prefix": "fflush",
        "scope": "eel2",
        "description": "If file fp is open for writing, flushes out any buffered data to disk.\n",
        "body": "fflush(${1:fp})$0"
    },
    "FFT eel2": {
        "prefix": "fft",
        "scope": "eel2",
        "description": "Performs a FFT on the data in\nthe local memory buffer at the offset specified by the first parameter.\nThe size of the FFT is specified by the second parameter, which must be\n16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The\noutputs are permuted, so if you plan to use them in-order, call\nfft_permute(buffer, size) before and fft_ipermute(buffer,size) after\nyour in-order use. Your inputs or outputs will need to be scaled down by\n1/size, if used.\nNote that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.\nNote that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.\n",
        "body": "fft(${1:buffer},${2:size})$0"
    },
    "FFT_IPERMUTE eel2": {
        "prefix": "fft_ipermute",
        "scope": "eel2",
        "description": "Permute the input for ifft(), taking bands from in-order to the order ifft() requires. See fft() for more information.\n",
        "body": "fft_ipermute(${1:buffer},${2:size})$0"
    },
    "FFT_PERMUTE eel2": {
        "prefix": "fft_permute",
        "scope": "eel2",
        "description": "Permute the output of fft() to have bands in-order. See fft() for more information.\n",
        "body": "fft_permute(${1:buffer},${2:size})$0"
    },
    "FFT_REAL eel2": {
        "prefix": "fft_real",
        "scope": "eel2",
        "description": "Performs an FFT, but\ntakes size input samples and produces size/2 complex output pairs.\nUsually used along with fft_permute(size/2). Inputs/outputs will need to\nbe scaled by 0.5/size.\n",
        "body": "fft_real(${1:buffer},${2:size})$0"
    },
    "FGETC eel2": {
        "prefix": "fgetc",
        "scope": "eel2",
        "description": "Reads a character from file fp, returns -1 if EOF.\n",
        "body": "fgetc(${1:fp})$0"
    },
    "FGETS eel2": {
        "prefix": "fgets",
        "scope": "eel2",
        "description": "Reads a line from file fp into #str. Returns length of #str read.\n",
        "body": "fgets(${1:fp},${2:#str})$0"
    },
    "FLOOR eel2": {
        "prefix": "floor",
        "scope": "eel2",
        "description": "Returns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).\n",
        "body": "floor(${1:value})$0"
    },
    "FOPEN eel2": {
        "prefix": "fopen",
        "scope": "eel2",
        "description": "Opens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.\n",
        "body": "fopen(${1:\"fn\"},${2:\"mode\"})$0"
    },
    "FPRINTF eel2": {
        "prefix": "fprintf",
        "scope": "eel2",
        "description": "Formats a string and writes it to file fp. For more information on format specifiers, see sprintf(). Returns bytes written to file.\n",
        "body": "fprintf(${1:fp},${2:\"format\"},${3:...})$0"
    },
    "FREAD eel2": {
        "prefix": "fread",
        "scope": "eel2",
        "description": "Reads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.\n",
        "body": "fread(${1:fp},${2:#str},${3:length})$0"
    },
    "FREEMBUF eel2": {
        "prefix": "freembuf",
        "scope": "eel2",
        "description": "Hints the runtime that memory\nabove the address specified may no longer be used. The runtime may, at\nits leisure, choose to lose the contents of memory above the address\nspecified.\n",
        "body": "freembuf(${1:address})$0"
    },
    "FSEEK eel2": {
        "prefix": "fseek",
        "scope": "eel2",
        "description": "Seeks file fp, offset\nbytes from whence reference. Whence negative specifies start of file,\npositive whence specifies end of file, and zero whence specifies current\nfile position.\n",
        "body": "fseek(${1:fp},${2:offset},${3:whence})$0"
    },
    "FTELL eel2": {
        "prefix": "ftell",
        "scope": "eel2",
        "description": "Retunrs the current file position.\n",
        "body": "ftell(${1:fp})$0"
    },
    "FWRITE eel2": {
        "prefix": "fwrite",
        "scope": "eel2",
        "description": "Writes up to len characters\nof #str to file fp. If len is less than 1, the full contents of #str\nwill be written. Returns the number of bytes written to file.\n",
        "body": "fwrite(${1:fp},${2:#str},${3:len})$0"
    },
    "GET_ACTION_CONTEXT eel2": {
        "prefix": "get_action_context",
        "scope": "eel2",
        "description": "Queries contextual information about the script, typically MIDI/OSC input values.\nReturns true if a new value has been updated.\nval\nwill be set to a relative or absolute value depending on mode (=0:\nabsolute mode, >0: relative modes). resolution=127 for 7-bit\nresolution, =16383 for 14-bit resolution.\nNotes: sectionID, and cmdID\nwill be set to -1 if the script is not part of the action list. mode,\nresolution and val will be set to -1 if the script was not triggered via\nMIDI/OSC.\n",
        "body": "get_action_context(${1:#filename},${2:sectionID},${3:cmdID},${4:mode},${5:resolution},${6:val})$0"
    },
    "GFX_ARC eel2": {
        "prefix": "gfx_arc",
        "scope": "eel2",
        "description": "Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n",
        "body": "gfx_arc(${1:x},${2:y},${3:r},${4:ang1},${5:ang2},${6:antialias})$0"
    },
    "GFX_BLIT eel2": {
        "prefix": "gfx_blit",
        "scope": "eel2",
        "body": "gfx_blit",
        "description": "These are set to the current width and height of the UI framebuffer. \n\n"
    },
    "GFX_BLITEXT eel2": {
        "prefix": "gfx_blitext",
        "scope": "eel2",
        "description": "Deprecated, use gfx_blit instead.\n",
        "body": "gfx_blitext(${1:source},${2:coordinatelist},${3:rotation})$0"
    },
    "GFX_BLURTO eel2": {
        "prefix": "gfx_blurto",
        "scope": "eel2",
        "description": "Blurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.\n",
        "body": "gfx_blurto(${1:x},${2:y})$0"
    },
    "GFX_CIRCLE eel2": {
        "prefix": "gfx_circle",
        "scope": "eel2",
        "description": "Draws a circle, optionally filling/antialiasing.\n",
        "body": "gfx_circle(${1:x},${2:y},${3:r},${4:fill},${5:antialias})$0"
    },
    "GFX_CLIENTTOSCREEN eel2": {
        "prefix": "gfx_clienttoscreen",
        "scope": "eel2",
        "description": "Converts client coordinates x,y to screen coordinates.\n",
        "body": "gfx_clienttoscreen(${1:x},${2:y})$0"
    },
    "GFX_DELTABLIT eel2": {
        "prefix": "gfx_deltablit",
        "scope": "eel2",
        "description": "Blits\nfrom srcimg(srcx,srcy,srcw,srch) to destination\n(destx,desty,destw,desth). Source texture coordinates are s/t, dsdx\nrepresents the change in s coordinate for each x pixel, dtdy represents\nthe change in t coordinate for each y pixel, etc. dsdxdy represents the\nchange in dsdx for each line. If usecliprect is specified and 0, then\nsrcw/srch are ignored.\n",
        "body": "gfx_deltablit(${1:srcimg},${2:srcs},${3:srct},${4:srcw},${5:srch},${6:destx},${7:desty},${8:destw},${9:desth},${10:dsdx},${11:dtdx},${12:dsdy},${13:dtdy},${14:dsdxdy},${15:dtdxdy},${16:usecliprect=1})$0"
    },
    "GFX_DOCK eel2": {
        "prefix": "gfx_dock",
        "scope": "eel2",
        "description": "Call with v=-1 to\nquery docked state, otherwise v>=0 to set docked state. State is\n&1 if docked, second byte is docker index (or last docker index if\nundocked). If wx-wh are specified, they will be filled with the undocked\nwindow position/size\n",
        "body": "gfx_dock(${1:v},${2:wx},${3:wy},${4:ww},${5:wh})$0"
    },
    "GFX_DRAWCHAR eel2": {
        "prefix": "gfx_drawchar",
        "scope": "eel2",
        "description": "Draws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.\n",
        "body": "gfx_drawchar(${1:char})$0"
    },
    "GFX_DRAWNUMBER eel2": {
        "prefix": "gfx_drawnumber",
        "scope": "eel2",
        "description": "Draws the number n\nwith ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the\nright side of the drawing. The text height is gfx_texth.\n",
        "body": "gfx_drawnumber(${1:n},${2:ndigits})$0"
    },
    "GFX_DRAWSTR eel2": {
        "prefix": "gfx_drawstr",
        "scope": "eel2",
        "description": "Draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.\nIf flags, right ,bottom passed in:\nflags&1: center horizontallyflags&2: right justifyflags&4: center verticallyflags&8: bottom justifyflags&256: ignore right/bottom, otherwise text is clipped to (gfx_x, gfx_y, right, bottom)\nEEL: gfx_getchar([char])If char is 0 or omitted,\nreturns a character from the keyboard queue, or 0 if no character is\navailable, or -1 if the graphics window is not open. If char is\nspecified and nonzero, that character's status will be checked, and the\nfunction will return greater than 0 if it is pressed.Common\nvalues are standard ASCII, such as 'a', 'A', '=' and '1', but for many\nkeys multi-byte values are used, including 'home', 'up', 'down', 'left',\n'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. Modified and special keys can also be returned, including:Ctrl/Cmd+A..Ctrl+Z as 1..26Ctrl/Cmd+Alt+A..Z as 257..282Alt+A..Z as 'A'+256..'Z'+25627 for ESC13 for Enter' ' for space65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible\nEEL: gfx_getdropfile(idx[,#str])Enumerates any\ndrag/dropped files. call gfx_dropfile(-1) to clear the list when\nfinished. Returns 1 if idx is valid, 0 if idx is out of range.\nEEL: gfx_getfont([#str])Returns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\nEEL: gfx_getimgdim(image,w,h)Retreives the\ndimensions of image (representing a filename: index number) into w and\nh. Sets these values to 0 if an image failed loading (or if the filename\nindex is invalid).\nEEL: gfx_getpixel(r,g,b)Gets the value of the pixel at gfx_x,gfx_y into r,g,b.\nEEL: gfx_gradrect(x,y,w,h, r,g,b,a[, drdx, dgdx, dbdx, dadx, drdy, dgdy, dbdy, dady])Fills\na gradient rectangle with the color and alpha specified. drdx-dadx\nreflect the adjustment (per-pixel) applied for each pixel moved to the\nright, drdy-dady are the adjustment applied for each pixel moved toward\nthe bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\nEEL: gfx_init(\"name\"[,width,height,dockstate,xpos,ypos])Initializes the graphics window with title name. Suggested width and height can be specified.Once the graphics window is open, gfx_update() should be called periodically.\nEEL: gfx_line(x,y,x2,y2[,aa])Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased.\nEEL: gfx_lineto(x,y[,aa])Draws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\nEEL: gfx_loadimg(image,\"filename\")Load image from\nfilename into slot 0..1024-1 specified by image. Returns the image index\nif success, otherwise -1 if failure. The image will be resized to the\ndimensions of the image file.\nEEL: gfx_measurechar(character,&w,&h)Measures the drawing dimensions of a character with the current font (as set by gfx_setfont).\nEEL: gfx_measurestr(\"str\",&w,&h)Measures the drawing dimensions of a string with the current font (as set by gfx_setfont).\nEEL: gfx_muladdrect(x,y,w,h,mul_r,mul_g,mul_b[,mul_a,add_r,add_g,add_b,add_a])Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\nEEL: gfx_printf(\"format\"[, ...])Formats and draws a\nstring at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter\nonly if the formatted string contains newline). For more information on\nformat strings, see sprintf()\nEEL: gfx_quit()Closes the graphics window.\nEEL: gfx_rect(x,y,w,h[,filled])Fills a rectangle at x,y, w,h pixels in dimension, filled by default.\nEEL: gfx_rectto(x,y)Fills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y.\nEEL: gfx_roundrect(x,y,w,h,radius[,antialias])Draws a rectangle with rounded corners.\nEEL: gfx_screentoclient(x,y)Converts screen coordinates x,y to client coordinates.\nEEL: gfx_set(r[,g,b,a,mode,dest,a2])Sets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode/gfx_a2, sets gfx_dest if final parameter specified\nEEL: gfx_setcursor(resource_id,custom_cursor_name)Sets\nthe mouse cursor. resource_id is a value like 32512 (for an arrow\ncursor), custom_cursor_name is a string like \"arrow\" (for the REAPER\ncustom arrow cursor). resource_id must be nonzero, but\ncustom_cursor_name is optional.\nEEL: gfx_setfont(idx[,\"fontface\", sz, flags])Can\nselect a font and optionally configure it. idx=0 for default bitmapped\nfont, no configuration is possible for this font. idx=1..16 for a\nconfigurable font, specify fontface such as \"Arial\", sz of 8-100, and\noptionally specify flags, which is a multibyte character, which can\ninclude 'i' for italics, 'u' for underline, or 'b' for bold. These flags\nmay or may not be supported depending on the font and OS. After calling\ngfx_setfont(), gfx_texth may be updated to reflect the new average line\nheight.\nEEL: gfx_setimgdim(image,w,h)Resize image\nreferenced by index 0..1024-1, width and height must be 0-2048. The\ncontents of the image will be undefined after the resize.\nEEL: gfx_setpixel(r,g,b)Writes a pixel of r,g,b to gfx_x,gfx_y.\nEEL: gfx_showmenu(\"str\")Shows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.Fields can start with special characters:# : grayed out! : checked> : this menu item shows a submenu< : last item in the current submenuAn\nempty field will appear as a separator in the menu. gfx_showmenu\nreturns 0 if the user selected nothing from the menu, 1 if the first\nfield is selected, etc.Example:gfx_showmenu(\"first item,\nfollowed by separator||!second item, checked|>third item which spawns\na submenu|#first item in submenu, grayed out|<second and last item\nin submenu|fourth item in top menu\")\nEEL: gfx_transformblit(srcimg,destx,desty,destw,desth,div_w,div_h,table)Blits\nto destination at (destx,desty), size (destw,desth). div_w and div_h\nshould be 2..64, and table should point to a table of 2*div_w*div_h\nvalues (this table must not cross a 65536 item boundary). Each pair in\nthe table represents a S,T coordinate in the source image, and the table\nis treated as a left-right, top-bottom list of texture coordinates,\nwhich will then be rendered to the destination.\nEEL: gfx_triangle(x1,y1,x2,y2,x3,y3[x4,y4...])Draws a filled triangle, or any convex polygon.\nEEL: gfx_update()Updates the graphics display, if opened\nEEL: ifft(buffer,size)Perform an inverse FFT. For more information see fft().\nEEL: ifft_real(buffer,size)Performs an inverse FFT,\nbut takes size/2 complex input pairs and produces size real output\nvalues. Usually used along with fft_ipermute(size/2).\nEEL: invsqrt(value)Returns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\nEEL: log(value)Returns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\nEEL: log10(value)Returns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\nEEL: loop(count,expression)Evaluates count once, and then executes expression count, but not more than 1048576, times.\nEEL: match(\"needle\",\"haystack\"[, ...])Searches for the first parameter in the second parameter, using a simplified regular expression syntax.* = match 0 or more characters*? = match 0 or more characters, lazy+ = match 1 or more characters+? = match 1 or more characters, lazy? = match one characterYou can also use format specifiers to match certain types of data, and optionally put that into a variable:%s means 1 or more chars%0s means 0 or more chars%5s means exactly 5 chars%5-s means 5 or more chars%-10s means 1-10 chars%3-5s means 3-5 chars%0-5s means 0-5 chars%x, %d, %u, and %f are available for use similarly%c can be used, but can't take any length modifiersUse uppercase (%S, %D, etc) for lazy matchingSee also sprintf() for other notes, including specifying direct variable references via {}.\nEEL: matchi(\"needle\",\"haystack\"[, ...])Case-insensitive version of match().\nEEL: max(&value,&value)Returns (by\nreference) the maximum value of the two parameters. Since max() returns\nby reference, expressions such as max(x,y) = 5 are possible.\nEEL: mem_get_values(offset, ...)Reads values from\nmemory starting at offset into variables specified. Slower than regular\nmemory reads for less than a few variables, faster for more than a few.\nUndefined behavior if used with more than 32767 variables.\nEEL: mem_set_values(offset, ...)Writes values to\nmemory starting at offset from variables specified. Slower than regular\nmemory writes for less than a few variables, faster for more than a few.\nUndefined behavior if used with more than 32767 variables.\nEEL: memcpy(dest,src,length)Copies length items of memory from src to dest. Regions are permitted to overlap.\nEEL: memset(offset,value,length)Sets length items of memory at offset to value.\nEEL: min(&value,&value)Returns (by\nreference) the minimum value of the two parameters. Since min() returns\nby reference, expressions such as min(x,y) = 5 are possible.\nEEL: printf(\"format\"[, ...])Output formatted string to system-specific destination, see sprintf() for more information\nEEL: rand([max])Returns a psuedorandom real number\nbetween 0 and the parameter, inclusive. If the parameter is omitted or\nless than 1.0, 1.0 is used as a maximum instead.\nEEL: runloop(\"code\")Adds code to be called back by\nREAPER. Used to create persistent ReaScripts that continue to run and\nrespond to input, while the user does other tasks. Identical to defer().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.\nEEL: sign(value)Returns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\nEEL: sin(angle)Returns the sine of the angle\nspecified (specified in radians -- to convert from degrees to radians,\nmultiply by $pi/180, or 0.017453).\nEEL: sleep(ms)Yields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\nEEL: sprintf(#dest,\"format\"[, ...])Formats a string and stores it in #dest. Format specifiers begin with %, and may include: %% = % %s = string from parameter %d = parameter as integer %i = parameter as integer %u = parameter as unsigned integer %x = parameter as hex (lowercase) integer %X = parameter as hex (uppercase) integer %c = parameter as character %f = parameter as floating point %e = parameter as floating point (scientific notation, lowercase) %E = parameter as floating point (scientific notation, uppercase) %g = parameter as floating point (shortest representation, lowercase) %G = parameter as floating point (shortest representation, uppercase)Many standard C printf() modifiers can be used, including: %.10s = string, but only print up to 10 characters %-10s = string, left justified to 10 characters %10s = string, right justified to 10 characters %+f = floating point, always show sign %.4f = floating point, minimum of 4 digits after decimal point %10d = integer, minimum of 10 digits (space padded) %010f = integer, minimum of 10 digits (zero padded)Values\nfor format specifiers can be specified as additional parameters to\nsprintf, or within {} in the format specifier (such as %{varname}d, in\nthat case a global variable is always used).\nEEL: sqr(value)Returns the square of the parameter (similar to value*value, but only evaluating value once).\nEEL: sqrt(value)Returns the square root of the parameter. If the parameter is negative, the return value is undefined.\nEEL: stack_exch(&value)Exchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\nEEL: stack_peek(index)Returns a reference to the\nitem on the top of the stack (if index is 0), or to the Nth item on the\nstack if index is greater than 0.\nEEL: stack_pop(&value)Pops a value from the\nuser stack into value, or into a temporary buffer if value is not\nspecified, and returns a reference to where the stack was popped. Note\nthat no checking is done to determine if the stack is empty, and as such\nstack_pop() will never fail.\nEEL: stack_push(&value)Pushes value onto the user stack, returns a reference to the parameter.\nEEL: str_delsub(#str,pos,len)Deletes len characters at offset pos from #str, and returns #str.\nEEL: str_getchar(\"str\",offset[,type])Returns the\ndata at byte-offset offset of str. If offset is negative, position is\nrelative to end of string.type defaults to signed char, but can be\nspecified to read raw binary data in other formats (note the single\nquotes, these are single/multi-byte characters):'c' - signed char'cu' - unsigned char's' - signed short'S' - signed short, big endian'su' - unsigned short'Su' - unsigned short, big endian'i' - signed int'I' - signed int, big endian'iu' - unsigned int'Iu' - unsigned int, big endian'f' - float'F' - float, big endian'd' - double'D' - double, big endian\nEEL: str_insert(#str,\"srcstr\",pos)Inserts srcstr into #str at offset pos. Returns #str\nEEL: str_setchar(#str,offset,val[,type]))Sets value\nat offset offset, type optional. offset may be negative to refer to\noffset relative to end of string, or between 0 and length, inclusive,\nand if set to length it will lengthen string. See str_getchar() for more information on types.\nEEL: str_setlen(#str,len)Sets length of #str (if increasing, will be space-padded), and returns #str.\nEEL: strcat(#str,\"srcstr\")Appends srcstr to #str, and returns #str\nEEL: strcmp(\"str\",\"str2\")Compares strings, returning 0 if equal\nEEL: strcpy(#str,\"srcstr\")Copies the contents of srcstr to #str, and returns #str\nEEL: strcpy_from(#str,\"srcstr\",offset)Copies srcstr to #str, but starts reading srcstr at offset offset\nEEL: strcpy_substr(#str,\"srcstr\",offs,ml))PHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\nEEL: stricmp(\"str\",\"str2\")Compares strings ignoring case, returning 0 if equal\nEEL: strlen(\"str\")Returns the length of the string passed as a parameter\nEEL: strncat(#str,\"srcstr\",maxlen)Appends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\nEEL: strncmp(\"str\",\"str2\",maxlen)Compares strings giving up after maxlen characters, returning 0 if equal\nEEL: strncpy(#str,\"srcstr\",maxlen)Copies srcstr to #str, stopping after maxlen characters. Returns #str.\nEEL: strnicmp(\"str\",\"str2\",maxlen)Compares strings giving up after maxlen characters, ignoring case, returning 0 if equal\nEEL: tan(angle)Returns the tangent of the angle specified (specified in radians).\nEEL: tcp_close(connection)Closes a TCP connection created by tcp_listen() or tcp_connect().\nEEL: tcp_connect(\"address\",port[,block])Create a\nnew TCP connection to address:port. If block is specified and 0,\nconnection will be made nonblocking. Returns TCP connection ID greater\nthan 0 on success.\nEEL: tcp_listen(port[,\"interface\",#ip_out])Listens\non port specified. Returns less than 0 if could not listen, 0 if no new\nconnection available, or greater than 0 (as a TCP connection ID) if a\nnew connection was made. If a connection made and #ip_out specified, it\nwill be set to the remote IP. interface can be empty for all interfaces,\notherwise an interface IP as a string.\nEEL: tcp_listen_end(port)Ends listening on port specified.\nEEL: tcp_recv(connection,#str[,maxlen])Receives\ndata from a connection to #str. If maxlen is specified, no more than\nmaxlen bytes will be received. If non-blocking, 0 will be returned if\nwould block. Returns less than 0 if error.\nEEL: tcp_send(connection,\"str\"[,len])Sends a string\nto connection. Returns -1 on error, 0 if connection is non-blocking and\nwould block, otherwise returns length sent. If len is specified and not\nless than 1, only the first len bytes of the string parameter will be\nsent.\nEEL: tcp_set_block(connection,block)Sets whether a connection blocks.\nEEL: time([&val])Sets the parameter (or a\ntemporary buffer if omitted) to the number of seconds since January 1,\n1970, and returns a reference to that value. The granularity of the\nvalue returned is 1 second.\nEEL: time_precise([&val])Sets the parameter (or\na temporary buffer if omitted) to a system-local timestamp in seconds,\nand returns a reference to that value. The granularity of the value\nreturned is system defined (but generally significantly smaller than one\nsecond).\nEEL: while(expression)Executes expression until\nexpression evaluates to zero, or until 1048576iterations occur. An\nalternate and more useful syntax is while (expression) ( statements ),\nwhich evaluates statements after every non-zero evaluation of\nexpression.\n",
        "body": "gfx_drawstr(${1:\"str\"},${2:flags},${3:right},${4:bottom})$0"
    },
    "GFX_GETCHAR eel2": {
        "prefix": "gfx_getchar",
        "scope": "eel2",
        "description": "If char is 0 or omitted,\nreturns a character from the keyboard queue, or 0 if no character is\navailable, or -1 if the graphics window is not open. If char is\nspecified and nonzero, that character's status will be checked, and the\nfunction will return greater than 0 if it is pressed.\nCommon\nvalues are standard ASCII, such as 'a', 'A', '=' and '1', but for many\nkeys multi-byte values are used, including 'home', 'up', 'down', 'left',\n'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'.\nModified and special keys can also be returned, including:\n>>\n>> Ctrl/Cmd+A..Ctrl+Z as 1..26\n>> Ctrl/Cmd+Alt+A..Z as 257..282\n>> Alt+A..Z as 'A'+256..'Z'+256\n>> 27 for ESC\n>> 13 for Enter\n>> ' ' for space\n>> 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible\n",
        "body": "gfx_getchar(${1:char})$0"
    },
    "GFX_GETDROPFILE eel2": {
        "prefix": "gfx_getdropfile",
        "scope": "eel2",
        "description": "Enumerates any\ndrag/dropped files. call gfx_dropfile(-1) to clear the list when\nfinished. Returns 1 if idx is valid, 0 if idx is out of range.\n",
        "body": "gfx_getdropfile(${1:idx},${2:#str})$0"
    },
    "GFX_GETFONT eel2": {
        "prefix": "gfx_getfont",
        "scope": "eel2",
        "description": "Returns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\n",
        "body": "gfx_getfont(${1:#str})$0"
    },
    "GFX_GETIMGDIM eel2": {
        "prefix": "gfx_getimgdim",
        "scope": "eel2",
        "description": "Retreives the\ndimensions of image (representing a filename: index number) into w and\nh. Sets these values to 0 if an image failed loading (or if the filename\nindex is invalid).\n",
        "body": "gfx_getimgdim(${1:image},${2:w},${3:h})$0"
    },
    "GFX_GETPIXEL eel2": {
        "prefix": "gfx_getpixel",
        "scope": "eel2",
        "description": "Gets the value of the pixel at gfx_x,gfx_y into r,g,b.\n",
        "body": "gfx_getpixel(${1:r},${2:g},${3:b})$0"
    },
    "GFX_GRADRECT eel2": {
        "prefix": "gfx_gradrect",
        "scope": "eel2",
        "description": "Fills\na gradient rectangle with the color and alpha specified. drdx-dadx\nreflect the adjustment (per-pixel) applied for each pixel moved to the\nright, drdy-dady are the adjustment applied for each pixel moved toward\nthe bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n",
        "body": "gfx_gradrect(${1:x},${2:y},${3:w},${4:h},${5:r},${6:g},${7:b},${8:a},${9:drdx},${10:dgdx},${11:dbdx},${12:dadx},${13:drdy},${14:dgdy},${15:dbdy},${16:dady})$0"
    },
    "GFX_INIT eel2": {
        "prefix": "gfx_init",
        "scope": "eel2",
        "description": "Initializes the graphics window with title name. Suggested width and height can be specified.\nOnce the graphics window is open, gfx_update() should be called periodically.\n",
        "body": "gfx_init(${1:\"name\"},${2:width},${3:height},${4:dockstate},${5:xpos},${6:ypos})$0"
    },
    "GFX_LINE eel2": {
        "prefix": "gfx_line",
        "scope": "eel2",
        "description": "Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased.\n",
        "body": "gfx_line(${1:x},${2:y},${3:x2},${4:y2},${5:aa})$0"
    },
    "GFX_LINETO eel2": {
        "prefix": "gfx_lineto",
        "scope": "eel2",
        "description": "Draws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\n",
        "body": "gfx_lineto(${1:x},${2:y},${3:aa})$0"
    },
    "GFX_LOADIMG eel2": {
        "prefix": "gfx_loadimg",
        "scope": "eel2",
        "description": "Load image from\nfilename into slot 0..1024-1 specified by image. Returns the image index\nif success, otherwise -1 if failure. The image will be resized to the\ndimensions of the image file.\n",
        "body": "gfx_loadimg(${1:image},${2:\"filename\"})$0"
    },
    "GFX_MEASURECHAR eel2": {
        "prefix": "gfx_measurechar",
        "scope": "eel2",
        "description": "Measures the drawing dimensions of a character with the current font (as set by gfx_setfont).\n",
        "body": "gfx_measurechar(${1:character},${2:&w},${3:&h})$0"
    },
    "GFX_MEASURESTR eel2": {
        "prefix": "gfx_measurestr",
        "scope": "eel2",
        "description": "Measures the drawing dimensions of a string with the current font (as set by gfx_setfont).\n",
        "body": "gfx_measurestr(${1:\"str\"},${2:&w},${3:&h})$0"
    },
    "GFX_MULADDRECT eel2": {
        "prefix": "gfx_muladdrect",
        "scope": "eel2",
        "description": "Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n",
        "body": "gfx_muladdrect(${1:x},${2:y},${3:w},${4:h},${5:mul_r},${6:mul_g},${7:mul_b},${8:mul_a},${9:add_r},${10:add_g},${11:add_b},${12:add_a})$0"
    },
    "GFX_PRINTF eel2": {
        "prefix": "gfx_printf",
        "scope": "eel2",
        "description": "Formats and draws a\nstring at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter\nonly if the formatted string contains newline). For more information on\nformat strings, see sprintf()\n",
        "body": "gfx_printf(${1:\"format\"},${2:...})$0"
    },
    "GFX_QUIT eel2": {
        "prefix": "gfx_quit",
        "scope": "eel2",
        "description": "Closes the graphics window.\n",
        "body": "gfx_quit()$0"
    },
    "GFX_RECT eel2": {
        "prefix": "gfx_rect",
        "scope": "eel2",
        "description": "Fills a rectangle at x,y, w,h pixels in dimension, filled by default.\n",
        "body": "gfx_rect(${1:x},${2:y},${3:w},${4:h},${5:filled})$0"
    },
    "GFX_RECTTO eel2": {
        "prefix": "gfx_rectto",
        "scope": "eel2",
        "description": "Fills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y.\n",
        "body": "gfx_rectto(${1:x},${2:y})$0"
    },
    "GFX_ROUNDRECT eel2": {
        "prefix": "gfx_roundrect",
        "scope": "eel2",
        "description": "Draws a rectangle with rounded corners.\n",
        "body": "gfx_roundrect(${1:x},${2:y},${3:w},${4:h},${5:radius},${6:antialias})$0"
    },
    "GFX_SCREENTOCLIENT eel2": {
        "prefix": "gfx_screentoclient",
        "scope": "eel2",
        "description": "Converts screen coordinates x,y to client coordinates.\n",
        "body": "gfx_screentoclient(${1:x},${2:y})$0"
    },
    "GFX_SET eel2": {
        "prefix": "gfx_set",
        "scope": "eel2",
        "description": "Sets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode/gfx_a2, sets gfx_dest if final parameter specified\n",
        "body": "gfx_set(${1:r},${2:g},${3:b},${4:a},${5:mode},${6:dest},${7:a2})$0"
    },
    "GFX_SETCURSOR eel2": {
        "prefix": "gfx_setcursor",
        "scope": "eel2",
        "description": "Sets\nthe mouse cursor. resource_id is a value like 32512 (for an arrow\ncursor), custom_cursor_name is a string like \"arrow\" (for the REAPER\ncustom arrow cursor). resource_id must be nonzero, but\ncustom_cursor_name is optional.\n",
        "body": "gfx_setcursor(${1:resource_id},${2:custom_cursor_name})$0"
    },
    "GFX_SETFONT eel2": {
        "prefix": "gfx_setfont",
        "scope": "eel2",
        "description": "Can\nselect a font and optionally configure it. idx=0 for default bitmapped\nfont, no configuration is possible for this font. idx=1..16 for a\nconfigurable font, specify fontface such as \"Arial\", sz of 8-100, and\noptionally specify flags, which is a multibyte character, which can\ninclude 'i' for italics, 'u' for underline, or 'b' for bold. These flags\nmay or may not be supported depending on the font and OS. After calling\ngfx_setfont(), gfx_texth may be updated to reflect the new average line\nheight.\n",
        "body": "gfx_setfont(${1:idx},${2:\"fontface\"},${3:sz},${4:flags})$0"
    },
    "GFX_SETIMGDIM eel2": {
        "prefix": "gfx_setimgdim",
        "scope": "eel2",
        "description": "Resize image\nreferenced by index 0..1024-1, width and height must be 0-2048. The\ncontents of the image will be undefined after the resize.\n",
        "body": "gfx_setimgdim(${1:image},${2:w},${3:h})$0"
    },
    "GFX_SETPIXEL eel2": {
        "prefix": "gfx_setpixel",
        "scope": "eel2",
        "description": "Writes a pixel of r,g,b to gfx_x,gfx_y.\n",
        "body": "gfx_setpixel(${1:r},${2:g},${3:b})$0"
    },
    "GFX_SHOWMENU eel2": {
        "prefix": "gfx_showmenu",
        "scope": "eel2",
        "description": "Shows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.\nFields can start with special characters:\n# : grayed out\n! : checked\n> : this menu item shows a submenu\n< : last item in the current submenu\nAn\nempty field will appear as a separator in the menu. gfx_showmenu\nreturns 0 if the user selected nothing from the menu, 1 if the first\nfield is selected, etc.\nExample:\ngfx_showmenu(\"first item,\nfollowed by separator||!second item, checked|>third item which spawns\na submenu|#first item in submenu, grayed out|<second and last item\nin submenu|fourth item in top menu\")\n",
        "body": "gfx_showmenu(${1:\"str\"})$0"
    },
    "GFX_TRANSFORMBLIT eel2": {
        "prefix": "gfx_transformblit",
        "scope": "eel2",
        "description": "Blits\nto destination at (destx,desty), size (destw,desth). div_w and div_h\nshould be 2..64, and table should point to a table of 2*div_w*div_h\nvalues (this table must not cross a 65536 item boundary). Each pair in\nthe table represents a S,T coordinate in the source image, and the table\nis treated as a left-right, top-bottom list of texture coordinates,\nwhich will then be rendered to the destination.\n",
        "body": "gfx_transformblit(${1:srcimg},${2:destx},${3:desty},${4:destw},${5:desth},${6:div_w},${7:div_h},${8:table})$0"
    },
    "GFX_TRIANGLE eel2": {
        "prefix": "gfx_triangle",
        "scope": "eel2",
        "description": "Draws a filled triangle, or any convex polygon.\n",
        "body": "gfx_triangle(${1:x1},${2:y1},${3:x2},${4:y2},${5:x3},${6:y3x4},${7:y4...})$0"
    },
    "GFX_UPDATE eel2": {
        "prefix": "gfx_update",
        "scope": "eel2",
        "description": "Updates the graphics display, if opened\n",
        "body": "gfx_update()$0"
    },
    "IFFT eel2": {
        "prefix": "ifft",
        "scope": "eel2",
        "description": "Perform an inverse FFT. For more information see fft().\n",
        "body": "ifft(${1:buffer},${2:size})$0"
    },
    "IFFT_REAL eel2": {
        "prefix": "ifft_real",
        "scope": "eel2",
        "description": "Performs an inverse FFT,\nbut takes size/2 complex input pairs and produces size real output\nvalues. Usually used along with fft_ipermute(size/2).\n",
        "body": "ifft_real(${1:buffer},${2:size})$0"
    },
    "INVSQRT eel2": {
        "prefix": "invsqrt",
        "scope": "eel2",
        "description": "Returns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\n",
        "body": "invsqrt(${1:value})$0"
    },
    "LOG eel2": {
        "prefix": "log",
        "scope": "eel2",
        "description": "Returns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\n",
        "body": "log(${1:value})$0"
    },
    "LOG10 eel2": {
        "prefix": "log10",
        "scope": "eel2",
        "description": "Returns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\n",
        "body": "log10(${1:value})$0"
    },
    "LOOP eel2": {
        "prefix": "loop",
        "scope": "eel2",
        "description": "Evaluates count once, and then executes expression count, but not more than 1048576, times.\n",
        "body": "loop(${1:count},${2:expression})$0"
    },
    "MATCH eel2": {
        "prefix": "match",
        "scope": "eel2",
        "description": "Searches for the first parameter in the second parameter, using a simplified regular expression syntax.\n>>\n>> * = match 0 or more characters\n>> *? = match 0 or more characters, lazy\n>> + = match 1 or more characters\n>> +? = match 1 or more characters, lazy\n>> ? = match one character\nYou can also use format specifiers to match certain types of data, and optionally put that into a variable:\n>>\n>> %s means 1 or more chars\n>> %0s means 0 or more chars\n>> %5s means exactly 5 chars\n>> %5-s means 5 or more chars\n>> %-10s means 1-10 chars\n>> %3-5s means 3-5 chars\n>> %0-5s means 0-5 chars\n>> %x, %d, %u, and %f are available for use similarly\n>> %c can be used, but can't take any length modifiers\n>> Use uppercase (%S, %D, etc) for lazy matching\nSee also sprintf() for other notes, including specifying direct variable references via {}.\n",
        "body": "match(${1:\"needle\"},${2:\"haystack\"},${3:...})$0"
    },
    "MATCHI eel2": {
        "prefix": "matchi",
        "scope": "eel2",
        "description": "Case-insensitive version of match().\n",
        "body": "matchi(${1:\"needle\"},${2:\"haystack\"},${3:...})$0"
    },
    "MAX eel2": {
        "prefix": "max",
        "scope": "eel2",
        "description": "Returns (by\nreference) the maximum value of the two parameters. Since max() returns\nby reference, expressions such as max(x,y) = 5 are possible.\n",
        "body": "max(${1:&value},${2:&value})$0"
    },
    "MEM_GET_VALUES eel2": {
        "prefix": "mem_get_values",
        "scope": "eel2",
        "description": "Reads values from\nmemory starting at offset into variables specified. Slower than regular\nmemory reads for less than a few variables, faster for more than a few.\nUndefined behavior if used with more than 32767 variables.\n",
        "body": "mem_get_values(${1:offset},${2:...})$0"
    },
    "MEM_SET_VALUES eel2": {
        "prefix": "mem_set_values",
        "scope": "eel2",
        "description": "Writes values to\nmemory starting at offset from variables specified. Slower than regular\nmemory writes for less than a few variables, faster for more than a few.\nUndefined behavior if used with more than 32767 variables.\n",
        "body": "mem_set_values(${1:offset},${2:...})$0"
    },
    "MEMCPY eel2": {
        "prefix": "memcpy",
        "scope": "eel2",
        "description": "Copies length items of memory from src to dest. Regions are permitted to overlap.\n",
        "body": "memcpy(${1:dest},${2:src},${3:length})$0"
    },
    "MEMSET eel2": {
        "prefix": "memset",
        "scope": "eel2",
        "description": "Sets length items of memory at offset to value.\n",
        "body": "memset(${1:offset},${2:value},${3:length})$0"
    },
    "MIN eel2": {
        "prefix": "min",
        "scope": "eel2",
        "description": "Returns (by\nreference) the minimum value of the two parameters. Since min() returns\nby reference, expressions such as min(x,y) = 5 are possible.\n",
        "body": "min(${1:&value},${2:&value})$0"
    },
    "PRINTF eel2": {
        "prefix": "printf",
        "scope": "eel2",
        "description": "Output formatted string to system-specific destination, see sprintf() for more information\n",
        "body": "printf(${1:\"format\"},${2:...})$0"
    },
    "RAND eel2": {
        "prefix": "rand",
        "scope": "eel2",
        "description": "Returns a psuedorandom real number\nbetween 0 and the parameter, inclusive. If the parameter is omitted or\nless than 1.0, 1.0 is used as a maximum instead.\n",
        "body": "rand(${1:max})$0"
    },
    "RUNLOOP eel2": {
        "prefix": "runloop",
        "scope": "eel2",
        "description": "Adds code to be called back by\nREAPER. Used to create persistent ReaScripts that continue to run and\nrespond to input, while the user does other tasks. Identical to defer().\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n",
        "body": "runloop(${1:\"code\"})$0"
    },
    "SIGN eel2": {
        "prefix": "sign",
        "scope": "eel2",
        "description": "Returns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\n",
        "body": "sign(${1:value})$0"
    },
    "SIN eel2": {
        "prefix": "sin",
        "scope": "eel2",
        "description": "Returns the sine of the angle\nspecified (specified in radians -- to convert from degrees to radians,\nmultiply by $pi/180, or 0.017453).\n",
        "body": "sin(${1:angle})$0"
    },
    "SLEEP eel2": {
        "prefix": "sleep",
        "scope": "eel2",
        "description": "Yields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\n",
        "body": "sleep(${1:ms})$0"
    },
    "SPRINTF eel2": {
        "prefix": "sprintf",
        "scope": "eel2",
        "description": "Formats a string and stores it in #dest. Format specifiers begin with %, and may include:\n>>\n>>  %% = %\n>>  %s = string from parameter\n>>  %d = parameter as integer\n>>  %i = parameter as integer\n>>  %u = parameter as unsigned integer\n>>  %x = parameter as hex (lowercase) integer\n>>  %X = parameter as hex (uppercase) integer\n>>  %c = parameter as character\n>>  %f = parameter as floating point\n>>  %e = parameter as floating point (scientific notation, lowercase)\n>>  %E = parameter as floating point (scientific notation, uppercase)\n>>  %g = parameter as floating point (shortest representation, lowercase)\n>>  %G = parameter as floating point (shortest representation, uppercase)\nMany standard C printf() modifiers can be used, including:\n>>\n>>  %.10s = string, but only print up to 10 characters\n>>  %-10s = string, left justified to 10 characters\n>>  %10s = string, right justified to 10 characters\n>>  %+f = floating point, always show sign\n>>  %.4f = floating point, minimum of 4 digits after decimal point\n>>  %10d = integer, minimum of 10 digits (space padded)\n>>  %010f = integer, minimum of 10 digits (zero padded)\nValues\nfor format specifiers can be specified as additional parameters to\nsprintf, or within {} in the format specifier (such as %{varname}d, in\nthat case a global variable is always used).\n",
        "body": "sprintf(${1:#dest},${2:\"format\"},${3:...})$0"
    },
    "SQR eel2": {
        "prefix": "sqr",
        "scope": "eel2",
        "description": "Returns the square of the parameter (similar to value*value, but only evaluating value once).\n",
        "body": "sqr(${1:value})$0"
    },
    "SQRT eel2": {
        "prefix": "sqrt",
        "scope": "eel2",
        "description": "Returns the square root of the parameter. If the parameter is negative, the return value is undefined.\n",
        "body": "sqrt(${1:value})$0"
    },
    "STACK_EXCH eel2": {
        "prefix": "stack_exch",
        "scope": "eel2",
        "description": "Exchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\n",
        "body": "stack_exch(${1:&value})$0"
    },
    "STACK_PEEK eel2": {
        "prefix": "stack_peek",
        "scope": "eel2",
        "description": "Returns a reference to the\nitem on the top of the stack (if index is 0), or to the Nth item on the\nstack if index is greater than 0.\n",
        "body": "stack_peek(${1:index})$0"
    },
    "STACK_POP eel2": {
        "prefix": "stack_pop",
        "scope": "eel2",
        "description": "Pops a value from the\nuser stack into value, or into a temporary buffer if value is not\nspecified, and returns a reference to where the stack was popped. Note\nthat no checking is done to determine if the stack is empty, and as such\nstack_pop() will never fail.\n",
        "body": "stack_pop(${1:&value})$0"
    },
    "STACK_PUSH eel2": {
        "prefix": "stack_push",
        "scope": "eel2",
        "description": "Pushes value onto the user stack, returns a reference to the parameter.\n",
        "body": "stack_push(${1:&value})$0"
    },
    "STR_DELSUB eel2": {
        "prefix": "str_delsub",
        "scope": "eel2",
        "description": "Deletes len characters at offset pos from #str, and returns #str.\n",
        "body": "str_delsub(${1:#str},${2:pos},${3:len})$0"
    },
    "STR_GETCHAR eel2": {
        "prefix": "str_getchar",
        "scope": "eel2",
        "description": "Returns the\ndata at byte-offset offset of str. If offset is negative, position is\nrelative to end of string.type defaults to signed char, but can be\nspecified to read raw binary data in other formats (note the single\nquotes, these are single/multi-byte characters):\n>>\n>> 'c' - signed char\n>> 'cu' - unsigned char\n>> 's' - signed short\n>> 'S' - signed short, big endian\n>> 'su' - unsigned short\n>> 'Su' - unsigned short, big endian\n>> 'i' - signed int\n>> 'I' - signed int, big endian\n>> 'iu' - unsigned int\n>> 'Iu' - unsigned int, big endian\n>> 'f' - float\n>> 'F' - float, big endian\n>> 'd' - double\n>> 'D' - double, big endian\n",
        "body": "str_getchar(${1:\"str\"},${2:offset},${3:type})$0"
    },
    "STR_INSERT eel2": {
        "prefix": "str_insert",
        "scope": "eel2",
        "description": "Inserts srcstr into #str at offset pos. Returns #str\n",
        "body": "str_insert(${1:#str},${2:\"srcstr\"},${3:pos})$0"
    },
    "STR_SETCHAR eel2": {
        "prefix": "str_setchar",
        "scope": "eel2",
        "description": "Sets value\nat offset offset, type optional. offset may be negative to refer to\noffset relative to end of string, or between 0 and length, inclusive,\nand if set to length it will lengthen string. See str_getchar() for more information on types.\n",
        "body": "str_setchar(${1:#str},${2:offset},${3:val},${4:type})$0"
    },
    "STR_SETLEN eel2": {
        "prefix": "str_setlen",
        "scope": "eel2",
        "description": "Sets length of #str (if increasing, will be space-padded), and returns #str.\n",
        "body": "str_setlen(${1:#str},${2:len})$0"
    },
    "STRCAT eel2": {
        "prefix": "strcat",
        "scope": "eel2",
        "description": "Appends srcstr to #str, and returns #str\n",
        "body": "strcat(${1:#str},${2:\"srcstr\"})$0"
    },
    "STRCMP eel2": {
        "prefix": "strcmp",
        "scope": "eel2",
        "description": "Compares strings, returning 0 if equal\n",
        "body": "strcmp(${1:\"str\"},${2:\"str2\"})$0"
    },
    "STRCPY eel2": {
        "prefix": "strcpy",
        "scope": "eel2",
        "description": "Copies the contents of srcstr to #str, and returns #str\n",
        "body": "strcpy(${1:#str},${2:\"srcstr\"})$0"
    },
    "STRCPY_FROM eel2": {
        "prefix": "strcpy_from",
        "scope": "eel2",
        "description": "Copies srcstr to #str, but starts reading srcstr at offset offset\n",
        "body": "strcpy_from(${1:#str},${2:\"srcstr\"},${3:offset})$0"
    },
    "STRCPY_SUBSTR eel2": {
        "prefix": "strcpy_substr",
        "scope": "eel2",
        "description": "PHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\n",
        "body": "strcpy_substr(${1:#str},${2:\"srcstr\"},${3:offs},${4:ml})$0"
    },
    "STRICMP eel2": {
        "prefix": "stricmp",
        "scope": "eel2",
        "description": "Compares strings ignoring case, returning 0 if equal\n",
        "body": "stricmp(${1:\"str\"},${2:\"str2\"})$0"
    },
    "STRLEN eel2": {
        "prefix": "strlen",
        "scope": "eel2",
        "description": "Returns the length of the string passed as a parameter\n",
        "body": "strlen(${1:\"str\"})$0"
    },
    "STRNCAT eel2": {
        "prefix": "strncat",
        "scope": "eel2",
        "description": "Appends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\n",
        "body": "strncat(${1:#str},${2:\"srcstr\"},${3:maxlen})$0"
    },
    "STRNCMP eel2": {
        "prefix": "strncmp",
        "scope": "eel2",
        "description": "Compares strings giving up after maxlen characters, returning 0 if equal\n",
        "body": "strncmp(${1:\"str\"},${2:\"str2\"},${3:maxlen})$0"
    },
    "STRNCPY eel2": {
        "prefix": "strncpy",
        "scope": "eel2",
        "description": "Copies srcstr to #str, stopping after maxlen characters. Returns #str.\n",
        "body": "strncpy(${1:#str},${2:\"srcstr\"},${3:maxlen})$0"
    },
    "STRNICMP eel2": {
        "prefix": "strnicmp",
        "scope": "eel2",
        "description": "Compares strings giving up after maxlen characters, ignoring case, returning 0 if equal\n",
        "body": "strnicmp(${1:\"str\"},${2:\"str2\"},${3:maxlen})$0"
    },
    "TAN eel2": {
        "prefix": "tan",
        "scope": "eel2",
        "description": "Returns the tangent of the angle specified (specified in radians).\n",
        "body": "tan(${1:angle})$0"
    },
    "TCP_CLOSE eel2": {
        "prefix": "tcp_close",
        "scope": "eel2",
        "description": "Closes a TCP connection created by tcp_listen() or tcp_connect().\n",
        "body": "tcp_close(${1:connection})$0"
    },
    "TCP_CONNECT eel2": {
        "prefix": "tcp_connect",
        "scope": "eel2",
        "description": "Create a\nnew TCP connection to address:port. If block is specified and 0,\nconnection will be made nonblocking. Returns TCP connection ID greater\nthan 0 on success.\n",
        "body": "tcp_connect(${1:\"address\"},${2:port},${3:block})$0"
    },
    "TCP_LISTEN eel2": {
        "prefix": "tcp_listen",
        "scope": "eel2",
        "description": "Listens\non port specified. Returns less than 0 if could not listen, 0 if no new\nconnection available, or greater than 0 (as a TCP connection ID) if a\nnew connection was made. If a connection made and #ip_out specified, it\nwill be set to the remote IP. interface can be empty for all interfaces,\notherwise an interface IP as a string.\n",
        "body": "tcp_listen(${1:port},${2:\"interface\"},${3:#ip_out})$0"
    },
    "TCP_LISTEN_END eel2": {
        "prefix": "tcp_listen_end",
        "scope": "eel2",
        "description": "Ends listening on port specified.\n",
        "body": "tcp_listen_end(${1:port})$0"
    },
    "TCP_RECV eel2": {
        "prefix": "tcp_recv",
        "scope": "eel2",
        "description": "Receives\ndata from a connection to #str. If maxlen is specified, no more than\nmaxlen bytes will be received. If non-blocking, 0 will be returned if\nwould block. Returns less than 0 if error.\n",
        "body": "tcp_recv(${1:connection},${2:#str},${3:maxlen})$0"
    },
    "TCP_SEND eel2": {
        "prefix": "tcp_send",
        "scope": "eel2",
        "description": "Sends a string\nto connection. Returns -1 on error, 0 if connection is non-blocking and\nwould block, otherwise returns length sent. If len is specified and not\nless than 1, only the first len bytes of the string parameter will be\nsent.\n",
        "body": "tcp_send(${1:connection},${2:\"str\"},${3:len})$0"
    },
    "TCP_SET_BLOCK eel2": {
        "prefix": "tcp_set_block",
        "scope": "eel2",
        "description": "Sets whether a connection blocks.\n",
        "body": "tcp_set_block(${1:connection},${2:block})$0"
    },
    "TIME eel2": {
        "prefix": "time",
        "scope": "eel2",
        "description": "Sets the parameter (or a\ntemporary buffer if omitted) to the number of seconds since January 1,\n1970, and returns a reference to that value. The granularity of the\nvalue returned is 1 second.\n",
        "body": "time(${1:&val})$0"
    },
    "TIME_PRECISE eel2": {
        "prefix": "time_precise",
        "scope": "eel2",
        "description": "Sets the parameter (or\na temporary buffer if omitted) to a system-local timestamp in seconds,\nand returns a reference to that value. The granularity of the value\nreturned is system defined (but generally significantly smaller than one\nsecond).\n",
        "body": "time_precise(${1:&val})$0"
    },
    "WHILE eel2": {
        "prefix": "while",
        "scope": "eel2",
        "description": "Executes expression until\nexpression evaluates to zero, or until 1048576iterations occur. An\nalternate and more useful syntax is while (expression) ( statements ),\nwhich evaluates statements after every non-zero evaluation of\nexpression.\n",
        "body": "while(${1:expression})$0"
    },
    "REAPER.ATEXIT lua": {
        "prefix": "reaper.atexit",
        "scope": "lua",
        "description": "Adds code to be executed when the script finishes or is ended by the\nuser. Typically used to clean up after the user terminates defer() or\nrunloop() code.\n",
        "body": "reaper.atexit(${1:function})$0"
    },
    "REAPER.DEFER lua": {
        "prefix": "reaper.defer",
        "scope": "lua",
        "description": "Adds code to be called back by REAPER. Used to create persistent\nReaScripts that continue to run and respond to input, while the user\ndoes other tasks. Identical to runloop().\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n",
        "body": "reaper.defer(${1:function})$0"
    },
    "REAPER.GET_ACTION_CONTEXT lua": {
        "prefix": "reaper.get_action_context",
        "scope": "lua",
        "description": "is_new_value,filename,sectionID,cmdID,mode,resolution,val = reaper.get_action_context()\nReturns contextual information about the script, typically MIDI/OSC input values.\nval\nwill be set to a relative or absolute value depending on mode (=0:\nabsolute mode, >0: relative modes). resolution=127 for 7-bit\nresolution, =16383 for 14-bit resolution.\nNotes: sectionID, and cmdID\nwill be set to -1 if the script is not part of the action list. mode,\nresolution and val will be set to -1 if the script was not triggered via\nMIDI/OSC.\n",
        "body": "reaper.get_action_context()$0"
    },
    "GFX.ARC lua": {
        "prefix": "gfx.arc",
        "scope": "lua",
        "description": "Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n",
        "body": "gfx.arc(${1:x},${2:y},${3:r},${4:ang1},${5:ang2},${6:antialias})$0"
    },
    "GFX.BLIT lua": {
        "prefix": "gfx.blit",
        "scope": "lua",
        "body": "gfx.blit",
        "description": "These are set to the current width and height of the UI framebuffer. \n\n"
    },
    "GFX.BLITEXT lua": {
        "prefix": "gfx.blitext",
        "scope": "lua",
        "description": "Deprecated, use gfx.blit instead.\n",
        "body": "gfx.blitext(${1:source},${2:coordinatelist},${3:rotation})$0"
    },
    "GFX.BLURTO lua": {
        "prefix": "gfx.blurto",
        "scope": "lua",
        "description": "Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.\n",
        "body": "gfx.blurto(${1:x},${2:y})$0"
    },
    "GFX.CIRCLE lua": {
        "prefix": "gfx.circle",
        "scope": "lua",
        "description": "Draws a circle, optionally filling/antialiasing.\n",
        "body": "gfx.circle(${1:x},${2:y},${3:r},${4:fill},${5:antialias})$0"
    },
    "GFX.CLIENTTOSCREEN lua": {
        "prefix": "gfx.clienttoscreen",
        "scope": "lua",
        "description": "Converts the coordinates x,y to screen coordinates, returns those values.\n",
        "body": "gfx.clienttoscreen(${1:x},${2:y})$0"
    },
    "GFX.DELTABLIT lua": {
        "prefix": "gfx.deltablit",
        "scope": "lua",
        "description": "Blits from srcimg(srcx,srcy,srcw,srch) to destination\n(destx,desty,destw,desth). Source texture coordinates are s/t, dsdx\nrepresents the change in s coordinate for each x pixel, dtdy represents\nthe change in t coordinate for each y pixel, etc. dsdxdy represents the\nchange in dsdx for each line. If usecliprect is specified and 0, then\nsrcw/srch are ignored.\n",
        "body": "gfx.deltablit(${1:srcimg},${2:srcs},${3:srct},${4:srcw},${5:srch},${6:destx},${7:desty},${8:destw},${9:desth},${10:dsdx},${11:dtdx},${12:dsdy},${13:dtdy},${14:dsdxdy},${15:dtdxdy},${16:usecliprect=1})$0"
    },
    "GFX.DOCK lua": {
        "prefix": "gfx.dock",
        "scope": "lua",
        "description": "Call with v=-1 to query docked state, otherwise v>=0 to set docked\nstate. State is &1 if docked, second byte is docker index (or last\ndocker index if undocked). If wx-wh specified, additional values will be\nreturned with the undocked window position/size\n",
        "body": "gfx.dock(${1:v},${2:wx},${3:wy},${4:ww},${5:wh})$0"
    },
    "GFX.DRAWCHAR lua": {
        "prefix": "gfx.drawchar",
        "scope": "lua",
        "description": "Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.\n",
        "body": "gfx.drawchar(${1:char})$0"
    },
    "GFX.DRAWNUMBER lua": {
        "prefix": "gfx.drawnumber",
        "scope": "lua",
        "description": "Draws the number n with ndigits of precision to gfx.x, gfx.y, and\nupdates gfx.x to the right side of the drawing. The text height is\ngfx.texth.\n",
        "body": "gfx.drawnumber(${1:n},${2:ndigits})$0"
    },
    "GFX.DRAWSTR lua": {
        "prefix": "gfx.drawstr",
        "scope": "lua",
        "description": "Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.\nIf flags, right ,bottom passed in:\nflags&1: center horizontallyflags&2: right justifyflags&4: center verticallyflags&8: bottom justifyflags&256: ignore right/bottom, otherwise text is clipped to (gfx.x, gfx.y, right, bottom)\nLua: gfx.getchar([char])\nIf char is 0 or omitted, returns a character from the keyboard queue, or\n0 if no character is available, or -1 if the graphics window is not\nopen. If char is specified and nonzero, that character's status will be\nchecked, and the function will return greater than 0 if it is pressed.Common\nvalues are standard ASCII, such as 'a', 'A', '=' and '1', but for many\nkeys multi-byte values are used, including 'home', 'up', 'down', 'left',\n'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. Modified and special keys can also be returned, including:Ctrl/Cmd+A..Ctrl+Z as 1..26Ctrl/Cmd+Alt+A..Z as 257..282Alt+A..Z as 'A'+256..'Z'+25627 for ESC13 for Enter' ' for space65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible\nLua: gfx.getdropfile(idx)\nReturns success,string for dropped file index idx. call gfx.dropfile(-1) to clear the list when finished.\nLua: gfx.getfont()\nReturns current font index, and the actual font face used by this font (if available).\nLua: gfx.getimgdim(handle)\nRetreives the dimensions of an image specified by handle, returns w, h pair.\nLua: gfx.getpixel()\nReturns r,g,b values [0..1] of the pixel at (gfx.x,gfx.y)\nLua: gfx.gradrect(x,y,w,h, r,g,b,a[, drdx, dgdx, dbdx, dadx, drdy, dgdy, dbdy, dady])\nFills a gradient rectangle with the color and alpha specified. drdx-dadx\nreflect the adjustment (per-pixel) applied for each pixel moved to the\nright, drdy-dady are the adjustment applied for each pixel moved toward\nthe bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\nLua: gfx.init(\"name\"[,width,height,dockstate,xpos,ypos])\nInitializes the graphics window with title name. Suggested width and height can be specified.Once the graphics window is open, gfx.update() should be called periodically.\nLua: gfx.line(x,y,x2,y2[,aa])\nDraws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased.\nLua: gfx.lineto(x,y[,aa])\nDraws a line from gfx.x,gfx.y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx.x and gfx.y to x,y.\nLua: gfx.loadimg(image,\"filename\")\nLoad image from filename into slot 0..1024-1 specified by image. Returns\nthe image index if success, otherwise -1 if failure. The image will be\nresized to the dimensions of the image file.\nLua: gfx.measurechar(char)\nMeasures the drawing dimensions of a character with the current font (as\nset by gfx.setfont). Returns width and height of character.\nLua: gfx.measurestr(\"str\")\nMeasures the drawing dimensions of a string with the current font (as set by gfx.setfont). Returns width and height of string.\nLua: gfx.muladdrect(x,y,w,h,mul_r,mul_g,mul_b[,mul_a,add_r,add_g,add_b,add_a])\nMultiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\nLua: gfx.printf(\"format\"[, ...])\nFormats and draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y\naccordingly (the latter only if the formatted string contains newline).\nFor more information on format strings, see sprintf()\nLua: gfx.quit()\nCloses the graphics window.\nLua: gfx.rect(x,y,w,h[,filled])\nFills a rectangle at x,y, w,h pixels in dimension, filled by default.\nLua: gfx.rectto(x,y)\nFills a rectangle from gfx.x,gfx.y to x,y. Updates gfx.x,gfx.y to x,y.\nLua: gfx.roundrect(x,y,w,h,radius[,antialias])\nDraws a rectangle with rounded corners.\nLua: gfx.screentoclient(x,y)\nConverts the screen coordinates x,y to client coordinates, returns those values.\nLua: gfx.set(r[,g,b,a,mode,dest,a2])\nSets gfx.r/gfx.g/gfx.b/gfx.a/gfx.mode/gfx.a2, sets gfx.dest if final parameter specified\nLua: gfx.setcursor(resource_id,custom_cursor_name)\nSets the mouse cursor. resource_id is a value like 32512 (for an arrow\ncursor), custom_cursor_name is a string like \"arrow\" (for the REAPER\ncustom arrow cursor). resource_id must be nonzero, but\ncustom_cursor_name is optional.\nLua: gfx.setfont(idx[,\"fontface\", sz, flags])\nCan select a font and optionally configure it. idx=0 for default\nbitmapped font, no configuration is possible for this font. idx=1..16\nfor a configurable font, specify fontface such as \"Arial\", sz of 8-100,\nand optionally specify flags, which is a multibyte character, which can\ninclude 'i' for italics, 'u' for underline, or 'b' for bold. These flags\nmay or may not be supported depending on the font and OS. After calling\ngfx.setfont(), gfx.texth may be updated to reflect the new average line\nheight.\nLua: gfx.setimgdim(image,w,h)\nResize image referenced by index 0..1024-1, width and height must be\n0-2048. The contents of the image will be undefined after the resize.\nLua: gfx.setpixel(r,g,b)\nWrites a pixel of r,g,b to gfx.x,gfx.y.\nLua: gfx.showmenu(\"str\")\nShows a popup menu at gfx.x,gfx.y. str is a list of fields separated by | characters. Each field represents a menu item.Fields can start with special characters:# : grayed out! : checked> : this menu item shows a submenu< : last item in the current submenuAn\nempty field will appear as a separator in the menu. gfx.showmenu\nreturns 0 if the user selected nothing from the menu, 1 if the first\nfield is selected, etc.Example:gfx.showmenu(\"first item,\nfollowed by separator||!second item, checked|>third item which spawns\na submenu|#first item in submenu, grayed out|<second and last item\nin submenu|fourth item in top menu\")\nLua: gfx.transformblit(srcimg,destx,desty,destw,desth,div_w,div_h,table)\nBlits to destination at (destx,desty), size (destw,desth). div_w and\ndiv_h should be 2..64, and table should point to a table of\n2*div_w*div_h values (table can be a regular table or (for less\noverhead) a reaper.array). Each pair in the table represents a S,T\ncoordinate in the source image, and the table is treated as a\nleft-right, top-bottom list of texture coordinates, which will then be\nrendered to the destination.\nLua: gfx.triangle(x1,y1,x2,y2,x3,y3[x4,y4...])\nDraws a filled triangle, or any convex polygon.\nLua: gfx.update()\nUpdates the graphics display, if opened\nLua: reaper.gmem_attach(sharedMemoryName)\nCauses gmem_read()/gmem_write() to read EEL2/JSFX/Video shared memory segment named by parameter. Set to empty string to detach.\nLua: reaper.gmem_read(index)\nRead (number) value from shared memory attached-to by gmem_attach(). index can be [0..1<<25).\nLua: reaper.gmem_write(index,value)\nWrite (number) value to shared memory attached-to by gmem_attach(). index can be [0..1<<25).\nLua: reaper.new_array([table|array][size])\nCreates a new reaper.array object of maximum and initial size size, if\nspecified, or from the size/values of a table/array. Both size and\ntable/array can be specified, the size parameter will override the\ntable/array size.\nLua: reaper.runloop(function)\nAdds code to be called back by REAPER. Used to create persistent\nReaScripts that continue to run and respond to input, while the user\ndoes other tasks. Identical to defer().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.\nLua: {reaper.array}.clear([value, offset, size])\nSets the value of zero or more items in the array. If value not\nspecified, 0.0 is used. offset is 1-based, if size omitted then the\nmaximum amount available will be set.\nLua: {reaper.array}.convolve([src, srcoffs, size, destoffs])\nConvolves complex value pairs from reaper.array, starting at 1-based\nsrcoffs, reading/writing to 1-based destoffs. size is in normal items\n(so it must be even)\nLua: {reaper.array}.copy([src, srcoffs, size, destoffs])\nCopies values from reaper.array or table, starting at 1-based srcoffs, writing to 1-based destoffs.\nLua: {reaper.array}.fft(size[, permute, offset])\nPerforms a forward FFT of size. size must be a power of two between 4\nand 32768 inclusive. If permute is specified and true, the values will\nbe shuffled following the FFT to be in normal order.\nLua: {reaper.array}.fft_real(size[, permute, offset])\nPerforms a forward real->complex FFT of size. size must be a power of\ntwo between 4 and 32768 inclusive. If permute is specified and true,\nthe values will be shuffled following the FFT to be in normal order.\nLua: {reaper.array}.get_alloc()\nReturns the maximum (allocated) size of the array.\nLua: {reaper.array}.ifft(size[, permute, offset])\nPerforms a backwards FFT of size. size must be a power of two between 4\nand 32768 inclusive. If permute is specified and true, the values will\nbe shuffled before the IFFT to be in fft-order.\nLua: {reaper.array}.ifft_real(size[, permute, offset])\nPerforms a backwards complex->real FFT of size. size must be a power\nof two between 4 and 32768 inclusive. If permute is specified and true,\nthe values will be shuffled before the IFFT to be in fft-order.\nLua: {reaper.array}.multiply([src, srcoffs, size, destoffs])\nMultiplies values from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs.\nLua: {reaper.array}.resize(size)\nResizes an array object to size. size must be [0..max_size].\nLua: {reaper.array}.table([offset, size])\nReturns a new table with values from items in the array. Offset is 1-based and if size is omitted all available values are used.\n",
        "body": "gfx.drawstr(${1:\"str\"},${2:flags},${3:right},${4:bottom})$0"
    },
    "GFX.GETCHAR lua": {
        "prefix": "gfx.getchar",
        "scope": "lua",
        "description": "If char is 0 or omitted, returns a character from the keyboard queue, or\n0 if no character is available, or -1 if the graphics window is not\nopen. If char is specified and nonzero, that character's status will be\nchecked, and the function will return greater than 0 if it is pressed.\nCommon\nvalues are standard ASCII, such as 'a', 'A', '=' and '1', but for many\nkeys multi-byte values are used, including 'home', 'up', 'down', 'left',\n'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'.\nModified and special keys can also be returned, including:\n>>\n>> Ctrl/Cmd+A..Ctrl+Z as 1..26\n>> Ctrl/Cmd+Alt+A..Z as 257..282\n>> Alt+A..Z as 'A'+256..'Z'+256\n>> 27 for ESC\n>> 13 for Enter\n>> ' ' for space\n>> 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible\n",
        "body": "gfx.getchar(${1:char})$0"
    },
    "GFX.GETDROPFILE lua": {
        "prefix": "gfx.getdropfile",
        "scope": "lua",
        "description": "Returns success,string for dropped file index idx. call gfx.dropfile(-1) to clear the list when finished.\n",
        "body": "gfx.getdropfile(${1:idx})$0"
    },
    "GFX.GETFONT lua": {
        "prefix": "gfx.getfont",
        "scope": "lua",
        "description": "Returns current font index, and the actual font face used by this font (if available).\n",
        "body": "gfx.getfont()$0"
    },
    "GFX.GETIMGDIM lua": {
        "prefix": "gfx.getimgdim",
        "scope": "lua",
        "description": "Retreives the dimensions of an image specified by handle, returns w, h pair.\n",
        "body": "gfx.getimgdim(${1:handle})$0"
    },
    "GFX.GETPIXEL lua": {
        "prefix": "gfx.getpixel",
        "scope": "lua",
        "description": "Returns r,g,b values [0..1] of the pixel at (gfx.x,gfx.y)\n",
        "body": "gfx.getpixel()$0"
    },
    "GFX.GRADRECT lua": {
        "prefix": "gfx.gradrect",
        "scope": "lua",
        "description": "Fills a gradient rectangle with the color and alpha specified. drdx-dadx\nreflect the adjustment (per-pixel) applied for each pixel moved to the\nright, drdy-dady are the adjustment applied for each pixel moved toward\nthe bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n",
        "body": "gfx.gradrect(${1:x},${2:y},${3:w},${4:h},${5:r},${6:g},${7:b},${8:a},${9:drdx},${10:dgdx},${11:dbdx},${12:dadx},${13:drdy},${14:dgdy},${15:dbdy},${16:dady})$0"
    },
    "GFX.INIT lua": {
        "prefix": "gfx.init",
        "scope": "lua",
        "description": "Initializes the graphics window with title name. Suggested width and height can be specified.\nOnce the graphics window is open, gfx.update() should be called periodically.\n",
        "body": "gfx.init(${1:\"name\"},${2:width},${3:height},${4:dockstate},${5:xpos},${6:ypos})$0"
    },
    "GFX.LINE lua": {
        "prefix": "gfx.line",
        "scope": "lua",
        "description": "Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased.\n",
        "body": "gfx.line(${1:x},${2:y},${3:x2},${4:y2},${5:aa})$0"
    },
    "GFX.LINETO lua": {
        "prefix": "gfx.lineto",
        "scope": "lua",
        "description": "Draws a line from gfx.x,gfx.y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx.x and gfx.y to x,y.\n",
        "body": "gfx.lineto(${1:x},${2:y},${3:aa})$0"
    },
    "GFX.LOADIMG lua": {
        "prefix": "gfx.loadimg",
        "scope": "lua",
        "description": "Load image from filename into slot 0..1024-1 specified by image. Returns\nthe image index if success, otherwise -1 if failure. The image will be\nresized to the dimensions of the image file.\n",
        "body": "gfx.loadimg(${1:image},${2:\"filename\"})$0"
    },
    "GFX.MEASURECHAR lua": {
        "prefix": "gfx.measurechar",
        "scope": "lua",
        "description": "Measures the drawing dimensions of a character with the current font (as\nset by gfx.setfont). Returns width and height of character.\n",
        "body": "gfx.measurechar(${1:char})$0"
    },
    "GFX.MEASURESTR lua": {
        "prefix": "gfx.measurestr",
        "scope": "lua",
        "description": "Measures the drawing dimensions of a string with the current font (as set by gfx.setfont). Returns width and height of string.\n",
        "body": "gfx.measurestr(${1:\"str\"})$0"
    },
    "GFX.MULADDRECT lua": {
        "prefix": "gfx.muladdrect",
        "scope": "lua",
        "description": "Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n",
        "body": "gfx.muladdrect(${1:x},${2:y},${3:w},${4:h},${5:mul_r},${6:mul_g},${7:mul_b},${8:mul_a},${9:add_r},${10:add_g},${11:add_b},${12:add_a})$0"
    },
    "GFX.PRINTF lua": {
        "prefix": "gfx.printf",
        "scope": "lua",
        "description": "Formats and draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y\naccordingly (the latter only if the formatted string contains newline).\nFor more information on format strings, see sprintf()\n",
        "body": "gfx.printf(${1:\"format\"},${2:...})$0"
    },
    "GFX.QUIT lua": {
        "prefix": "gfx.quit",
        "scope": "lua",
        "description": "Closes the graphics window.\n",
        "body": "gfx.quit()$0"
    },
    "GFX.RECT lua": {
        "prefix": "gfx.rect",
        "scope": "lua",
        "description": "Fills a rectangle at x,y, w,h pixels in dimension, filled by default.\n",
        "body": "gfx.rect(${1:x},${2:y},${3:w},${4:h},${5:filled})$0"
    },
    "GFX.RECTTO lua": {
        "prefix": "gfx.rectto",
        "scope": "lua",
        "description": "Fills a rectangle from gfx.x,gfx.y to x,y. Updates gfx.x,gfx.y to x,y.\n",
        "body": "gfx.rectto(${1:x},${2:y})$0"
    },
    "GFX.ROUNDRECT lua": {
        "prefix": "gfx.roundrect",
        "scope": "lua",
        "description": "Draws a rectangle with rounded corners.\n",
        "body": "gfx.roundrect(${1:x},${2:y},${3:w},${4:h},${5:radius},${6:antialias})$0"
    },
    "GFX.SCREENTOCLIENT lua": {
        "prefix": "gfx.screentoclient",
        "scope": "lua",
        "description": "Converts the screen coordinates x,y to client coordinates, returns those values.\n",
        "body": "gfx.screentoclient(${1:x},${2:y})$0"
    },
    "GFX.SET lua": {
        "prefix": "gfx.set",
        "scope": "lua",
        "description": "Sets gfx.r/gfx.g/gfx.b/gfx.a/gfx.mode/gfx.a2, sets gfx.dest if final parameter specified\n",
        "body": "gfx.set(${1:r},${2:g},${3:b},${4:a},${5:mode},${6:dest},${7:a2})$0"
    },
    "GFX.SETCURSOR lua": {
        "prefix": "gfx.setcursor",
        "scope": "lua",
        "description": "Sets the mouse cursor. resource_id is a value like 32512 (for an arrow\ncursor), custom_cursor_name is a string like \"arrow\" (for the REAPER\ncustom arrow cursor). resource_id must be nonzero, but\ncustom_cursor_name is optional.\n",
        "body": "gfx.setcursor(${1:resource_id},${2:custom_cursor_name})$0"
    },
    "GFX.SETFONT lua": {
        "prefix": "gfx.setfont",
        "scope": "lua",
        "description": "Can select a font and optionally configure it. idx=0 for default\nbitmapped font, no configuration is possible for this font. idx=1..16\nfor a configurable font, specify fontface such as \"Arial\", sz of 8-100,\nand optionally specify flags, which is a multibyte character, which can\ninclude 'i' for italics, 'u' for underline, or 'b' for bold. These flags\nmay or may not be supported depending on the font and OS. After calling\ngfx.setfont(), gfx.texth may be updated to reflect the new average line\nheight.\n",
        "body": "gfx.setfont(${1:idx},${2:\"fontface\"},${3:sz},${4:flags})$0"
    },
    "GFX.SETIMGDIM lua": {
        "prefix": "gfx.setimgdim",
        "scope": "lua",
        "description": "Resize image referenced by index 0..1024-1, width and height must be\n0-2048. The contents of the image will be undefined after the resize.\n",
        "body": "gfx.setimgdim(${1:image},${2:w},${3:h})$0"
    },
    "GFX.SETPIXEL lua": {
        "prefix": "gfx.setpixel",
        "scope": "lua",
        "description": "Writes a pixel of r,g,b to gfx.x,gfx.y.\n",
        "body": "gfx.setpixel(${1:r},${2:g},${3:b})$0"
    },
    "GFX.SHOWMENU lua": {
        "prefix": "gfx.showmenu",
        "scope": "lua",
        "description": "Shows a popup menu at gfx.x,gfx.y. str is a list of fields separated by | characters. Each field represents a menu item.\nFields can start with special characters:\n# : grayed out\n! : checked\n> : this menu item shows a submenu\n< : last item in the current submenu\nAn\nempty field will appear as a separator in the menu. gfx.showmenu\nreturns 0 if the user selected nothing from the menu, 1 if the first\nfield is selected, etc.\nExample:\ngfx.showmenu(\"first item,\nfollowed by separator||!second item, checked|>third item which spawns\na submenu|#first item in submenu, grayed out|<second and last item\nin submenu|fourth item in top menu\")\n",
        "body": "gfx.showmenu(${1:\"str\"})$0"
    },
    "GFX.TRANSFORMBLIT lua": {
        "prefix": "gfx.transformblit",
        "scope": "lua",
        "description": "Blits to destination at (destx,desty), size (destw,desth). div_w and\ndiv_h should be 2..64, and table should point to a table of\n2*div_w*div_h values (table can be a regular table or (for less\noverhead) a reaper.array). Each pair in the table represents a S,T\ncoordinate in the source image, and the table is treated as a\nleft-right, top-bottom list of texture coordinates, which will then be\nrendered to the destination.\n",
        "body": "gfx.transformblit(${1:srcimg},${2:destx},${3:desty},${4:destw},${5:desth},${6:div_w},${7:div_h},${8:table})$0"
    },
    "GFX.TRIANGLE lua": {
        "prefix": "gfx.triangle",
        "scope": "lua",
        "description": "Draws a filled triangle, or any convex polygon.\n",
        "body": "gfx.triangle(${1:x1},${2:y1},${3:x2},${4:y2},${5:x3},${6:y3x4},${7:y4...})$0"
    },
    "GFX.UPDATE lua": {
        "prefix": "gfx.update",
        "scope": "lua",
        "description": "Updates the graphics display, if opened\n",
        "body": "gfx.update()$0"
    },
    "REAPER.GMEM_ATTACH lua": {
        "prefix": "reaper.gmem_attach",
        "scope": "lua",
        "description": "Causes gmem_read()/gmem_write() to read EEL2/JSFX/Video shared memory segment named by parameter. Set to empty string to detach.\n",
        "body": "reaper.gmem_attach(${1:sharedMemoryName})$0"
    },
    "REAPER.GMEM_READ lua": {
        "prefix": "reaper.gmem_read",
        "scope": "lua",
        "description": "Read (number) value from shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n",
        "body": "reaper.gmem_read(${1:index})$0"
    },
    "REAPER.GMEM_WRITE lua": {
        "prefix": "reaper.gmem_write",
        "scope": "lua",
        "description": "Write (number) value to shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n",
        "body": "reaper.gmem_write(${1:index},${2:value})$0"
    },
    "REAPER.NEW_ARRAY lua": {
        "prefix": "reaper.new_array",
        "scope": "lua",
        "description": "Creates a new reaper.array object of maximum and initial size size, if\nspecified, or from the size/values of a table/array. Both size and\ntable/array can be specified, the size parameter will override the\ntable/array size.\n",
        "body": "reaper.new_array(${1:table|arraysize})$0"
    },
    "REAPER.RUNLOOP lua": {
        "prefix": "reaper.runloop",
        "scope": "lua",
        "description": "Adds code to be called back by REAPER. Used to create persistent\nReaScripts that continue to run and respond to input, while the user\ndoes other tasks. Identical to defer().\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n",
        "body": "reaper.runloop(${1:function})$0"
    },
    "REAPER_ARRAY.CLEAR lua": {
        "prefix": "reaper_array.clear",
        "scope": "lua",
        "description": "Sets the value of zero or more items in the array. If value not\nspecified, 0.0 is used. offset is 1-based, if size omitted then the\nmaximum amount available will be set.\n",
        "body": "reaper_array.clear(${1:value},${2:offset},${3:size})$0"
    },
    "REAPER_ARRAY.CONVOLVE lua": {
        "prefix": "reaper_array.convolve",
        "scope": "lua",
        "description": "Convolves complex value pairs from reaper.array, starting at 1-based\nsrcoffs, reading/writing to 1-based destoffs. size is in normal items\n(so it must be even)\n",
        "body": "reaper_array.convolve(${1:src},${2:srcoffs},${3:size},${4:destoffs})$0"
    },
    "REAPER_ARRAY.COPY lua": {
        "prefix": "reaper_array.copy",
        "scope": "lua",
        "description": "Copies values from reaper.array or table, starting at 1-based srcoffs, writing to 1-based destoffs.\n",
        "body": "reaper_array.copy(${1:src},${2:srcoffs},${3:size},${4:destoffs})$0"
    },
    "REAPER_ARRAY.FFT lua": {
        "prefix": "reaper_array.fft",
        "scope": "lua",
        "description": "Performs a forward FFT of size. size must be a power of two between 4\nand 32768 inclusive. If permute is specified and true, the values will\nbe shuffled following the FFT to be in normal order.\n",
        "body": "reaper_array.fft(${1:size},${2:permute},${3:offset})$0"
    },
    "REAPER_ARRAY.FFT_REAL lua": {
        "prefix": "reaper_array.fft_real",
        "scope": "lua",
        "description": "Performs a forward real->complex FFT of size. size must be a power of\ntwo between 4 and 32768 inclusive. If permute is specified and true,\nthe values will be shuffled following the FFT to be in normal order.\n",
        "body": "reaper_array.fft_real(${1:size},${2:permute},${3:offset})$0"
    },
    "REAPER_ARRAY.GET_ALLOC lua": {
        "prefix": "reaper_array.get_alloc",
        "scope": "lua",
        "description": "Returns the maximum (allocated) size of the array.\n",
        "body": "reaper_array.get_alloc()$0"
    },
    "REAPER_ARRAY.IFFT lua": {
        "prefix": "reaper_array.ifft",
        "scope": "lua",
        "description": "Performs a backwards FFT of size. size must be a power of two between 4\nand 32768 inclusive. If permute is specified and true, the values will\nbe shuffled before the IFFT to be in fft-order.\n",
        "body": "reaper_array.ifft(${1:size},${2:permute},${3:offset})$0"
    },
    "REAPER_ARRAY.IFFT_REAL lua": {
        "prefix": "reaper_array.ifft_real",
        "scope": "lua",
        "description": "Performs a backwards complex->real FFT of size. size must be a power\nof two between 4 and 32768 inclusive. If permute is specified and true,\nthe values will be shuffled before the IFFT to be in fft-order.\n",
        "body": "reaper_array.ifft_real(${1:size},${2:permute},${3:offset})$0"
    },
    "REAPER_ARRAY.MULTIPLY lua": {
        "prefix": "reaper_array.multiply",
        "scope": "lua",
        "description": "Multiplies values from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs.\n",
        "body": "reaper_array.multiply(${1:src},${2:srcoffs},${3:size},${4:destoffs})$0"
    },
    "REAPER_ARRAY.RESIZE lua": {
        "prefix": "reaper_array.resize",
        "scope": "lua",
        "description": "Resizes an array object to size. size must be [0..max_size].\n",
        "body": "reaper_array.resize(${1:size})$0"
    },
    "REAPER_ARRAY.TABLE lua": {
        "prefix": "reaper_array.table",
        "scope": "lua",
        "description": "Returns a new table with values from items in the array. Offset is 1-based and if size is omitted all available values are used.\n",
        "body": "reaper_array.table(${1:offset},${2:size})$0"
    },
    "RPR_ATEXIT python": {
        "prefix": "RPR_atexit",
        "scope": "python",
        "description": "Adds code to be executed when the script finishes or is ended by the\nuser. Typically used to clean up after the user terminates defer() or\nrunloop() code.\n",
        "body": "RPR_atexit(${1:String})$0"
    },
    "RPR_DEFER python": {
        "prefix": "RPR_defer",
        "scope": "python",
        "description": "Adds code to be called back by REAPER. Used to create persistent\nReaScripts that continue to run and respond to input, while the user\ndoes other tasks. Identical to runloop().\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n",
        "body": "RPR_defer(${1:String code})$0"
    },
    "RPR_RUNLOOP python": {
        "prefix": "RPR_runloop",
        "scope": "python",
        "description": "Adds code to be called back by REAPER. Used to create persistent\nReaScripts that continue to run and respond to input, while the user\ndoes other tasks. Identical to defer().\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n",
        "body": "RPR_runloop(${1:String code})$0"
    },
    "ADDMEDIAITEMTOTRACK_WR c": {
        "prefix": "WR_AddMediaItemToTrack",
        "scope": "c",
        "description": "creates a new media item.\n",
        "body": "${1:MediaItem*} = AddMediaItemToTrack(${2:MediaTrack* tr})$0"
    },
    "ADDMEDIAITEMTOTRACK_WR eel2": {
        "prefix": "WR_AddMediaItemToTrack",
        "scope": "eel2",
        "description": "creates a new media item.\n",
        "body": "${1:MediaItem} = AddMediaItemToTrack(${2:MediaTrack tr})$0"
    },
    "REAPER.ADDMEDIAITEMTOTRACK_WR lua": {
        "prefix": "reaperwr.AddMediaItemToTrack",
        "scope": "lua",
        "description": "creates a new media item.\n",
        "body": "${1:local }${2:MediaItem} = reaper.AddMediaItemToTrack(${3:MediaTrack tr})$0"
    },
    "RPR_ADDMEDIAITEMTOTRACK_WR python": {
        "prefix": "WR_RPR_AddMediaItemToTrack",
        "scope": "python",
        "description": "creates a new media item.\n",
        "body": "${1:MediaItem} = RPR_AddMediaItemToTrack(${2:MediaTrack tr})$0"
    },
    "ADDPROJECTMARKER_WR c": {
        "prefix": "WR_AddProjectMarker",
        "scope": "c",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "${1:int} = AddProjectMarker(${2:ReaProject* proj},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:const char* name},${7:int wantidx})$0"
    },
    "ADDPROJECTMARKER_WR eel2": {
        "prefix": "WR_AddProjectMarker",
        "scope": "eel2",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "${1:int} = AddProjectMarker(${2:ReaProject proj},${3:bool isrgn},${4:pos},${5:rgnend},${6:\"name\"},${7:int wantidx})$0"
    },
    "REAPER.ADDPROJECTMARKER_WR lua": {
        "prefix": "reaperwr.AddProjectMarker",
        "scope": "lua",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "${1:local }${2:integer} = reaper.AddProjectMarker(${3:ReaProject proj},${4:boolean isrgn},${5:number pos},${6:number rgnend},${7:string name},${8:integer wantidx})$0"
    },
    "RPR_ADDPROJECTMARKER_WR python": {
        "prefix": "WR_RPR_AddProjectMarker",
        "scope": "python",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use.\n",
        "body": "${1:Int} = RPR_AddProjectMarker(${2:ReaProject proj},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:String name},${7:Int wantidx})$0"
    },
    "ADDPROJECTMARKER2_WR c": {
        "prefix": "WR_AddProjectMarker2",
        "scope": "c",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "${1:int} = AddProjectMarker2(${2:ReaProject* proj},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:const char* name},${7:int wantidx},${8:int color})$0"
    },
    "ADDPROJECTMARKER2_WR eel2": {
        "prefix": "WR_AddProjectMarker2",
        "scope": "eel2",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "${1:int} = AddProjectMarker2(${2:ReaProject proj},${3:bool isrgn},${4:pos},${5:rgnend},${6:\"name\"},${7:int wantidx},${8:int color})$0"
    },
    "REAPER.ADDPROJECTMARKER2_WR lua": {
        "prefix": "reaperwr.AddProjectMarker2",
        "scope": "lua",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "${1:local }${2:integer} = reaper.AddProjectMarker2(${3:ReaProject proj},${4:boolean isrgn},${5:number pos},${6:number rgnend},${7:string name},${8:integer wantidx},${9:integer color})$0"
    },
    "RPR_ADDPROJECTMARKER2_WR python": {
        "prefix": "WR_RPR_AddProjectMarker2",
        "scope": "python",
        "description": "Returns the index of the created marker/region, or -1 on failure. Supply\nwantidx>=0 if you want a particular index number, but you'll get a\ndifferent index number a region and wantidx is already in use. color\nshould be 0 (default color), or ColorToNative(r,g,b)|0x1000000\n",
        "body": "${1:Int} = RPR_AddProjectMarker2(${2:ReaProject proj},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:String name},${7:Int wantidx},${8:Int color})$0"
    },
    "ADDREMOVEREASCRIPT_WR c": {
        "prefix": "WR_AddRemoveReaScript",
        "scope": "c",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "${1:int} = AddRemoveReaScript(${2:bool add},${3:int sectionID},${4:const char* scriptfn},${5:bool commit})$0"
    },
    "ADDREMOVEREASCRIPT_WR eel2": {
        "prefix": "WR_AddRemoveReaScript",
        "scope": "eel2",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "${1:int} = AddRemoveReaScript(${2:bool add},${3:int sectionID},${4:\"scriptfn\"},${5:bool commit})$0"
    },
    "REAPER.ADDREMOVEREASCRIPT_WR lua": {
        "prefix": "reaperwr.AddRemoveReaScript",
        "scope": "lua",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "${1:local }${2:integer} = reaper.AddRemoveReaScript(${3:boolean add},${4:integer sectionID},${5:string scriptfn},${6:boolean commit})$0"
    },
    "RPR_ADDREMOVEREASCRIPT_WR python": {
        "prefix": "WR_RPR_AddRemoveReaScript",
        "scope": "python",
        "description": "Add a ReaScript (return the new command ID, or 0 if failed) or remove a\nReaScript (return >0 on success). Use commit==true when\nadding/removing a single script. When bulk adding/removing n scripts,\nyou can optimize the n-1 first calls with commit==false and commit==true\nfor the last call.\n",
        "body": "${1:Int} = RPR_AddRemoveReaScript(${2:Boolean add},${3:Int sectionID},${4:String scriptfn},${5:Boolean commit})$0"
    },
    "ADDTAKETOMEDIAITEM_WR c": {
        "prefix": "WR_AddTakeToMediaItem",
        "scope": "c",
        "description": "creates a new take in an item\n",
        "body": "${1:MediaItem_Take*} = AddTakeToMediaItem(${2:MediaItem* item})$0"
    },
    "ADDTAKETOMEDIAITEM_WR eel2": {
        "prefix": "WR_AddTakeToMediaItem",
        "scope": "eel2",
        "description": "creates a new take in an item\n",
        "body": "${1:MediaItem_Take} = AddTakeToMediaItem(${2:MediaItem item})$0"
    },
    "REAPER.ADDTAKETOMEDIAITEM_WR lua": {
        "prefix": "reaperwr.AddTakeToMediaItem",
        "scope": "lua",
        "description": "creates a new take in an item\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.AddTakeToMediaItem(${3:MediaItem item})$0"
    },
    "RPR_ADDTAKETOMEDIAITEM_WR python": {
        "prefix": "WR_RPR_AddTakeToMediaItem",
        "scope": "python",
        "description": "creates a new take in an item\n",
        "body": "${1:MediaItem_Take} = RPR_AddTakeToMediaItem(${2:MediaItem item})$0"
    },
    "ADDTEMPOTIMESIGMARKER_WR c": {
        "prefix": "WR_AddTempoTimeSigMarker",
        "scope": "c",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "${1:bool} = AddTempoTimeSigMarker(${2:ReaProject* proj},${3:double timepos},${4:double bpm},${5:int timesig_num},${6:int timesig_denom},${7:bool lineartempochange})$0"
    },
    "ADDTEMPOTIMESIGMARKER_WR eel2": {
        "prefix": "WR_AddTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "${1:bool} = AddTempoTimeSigMarker(${2:ReaProject proj},${3:timepos},${4:bpm},${5:int timesig_num},${6:int timesig_denom},${7:bool lineartempochange})$0"
    },
    "REAPER.ADDTEMPOTIMESIGMARKER_WR lua": {
        "prefix": "reaperwr.AddTempoTimeSigMarker",
        "scope": "lua",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "${1:local }${2:boolean} = reaper.AddTempoTimeSigMarker(${3:ReaProject proj},${4:number timepos},${5:number bpm},${6:integer timesig_num},${7:integer timesig_denom},${8:boolean lineartempochange})$0"
    },
    "RPR_ADDTEMPOTIMESIGMARKER_WR python": {
        "prefix": "WR_RPR_AddTempoTimeSigMarker",
        "scope": "python",
        "description": "Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.\n",
        "body": "${1:Boolean} = RPR_AddTempoTimeSigMarker(${2:ReaProject proj},${3:Float timepos},${4:Float bpm},${5:Int timesig_num},${6:Int timesig_denom},${7:Boolean lineartempochange})$0"
    },
    "ADJUSTZOOM_WR c": {
        "prefix": "WR_adjustZoom",
        "scope": "c",
        "description": "forceset=0,doupd=true,centermode=-1 for default\n",
        "body": "${1:void} = adjustZoom(${2:double amt},${3:int forceset},${4:bool doupd},${5:int centermode})$0"
    },
    "ANYTRACKSOLO_WR c": {
        "prefix": "WR_AnyTrackSolo",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = AnyTrackSolo(${2:ReaProject* proj})$0"
    },
    "ANYTRACKSOLO_WR eel2": {
        "prefix": "WR_AnyTrackSolo",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = AnyTrackSolo(${2:ReaProject proj})$0"
    },
    "REAPER.ANYTRACKSOLO_WR lua": {
        "prefix": "reaperwr.AnyTrackSolo",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.AnyTrackSolo(${3:ReaProject proj})$0"
    },
    "RPR_ANYTRACKSOLO_WR python": {
        "prefix": "WR_RPR_AnyTrackSolo",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_AnyTrackSolo(${2:ReaProject proj})$0"
    },
    "APIEXISTS_WR c": {
        "prefix": "WR_APIExists",
        "scope": "c",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "${1:bool} = APIExists(${2:const char* function_name})$0"
    },
    "APIEXISTS_WR eel2": {
        "prefix": "WR_APIExists",
        "scope": "eel2",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "${1:bool} = APIExists(${2:\"function_name\"})$0"
    },
    "REAPER.APIEXISTS_WR lua": {
        "prefix": "reaperwr.APIExists",
        "scope": "lua",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "${1:local }${2:boolean} = reaper.APIExists(${3:string function_name})$0"
    },
    "RPR_APIEXISTS_WR python": {
        "prefix": "WR_RPR_APIExists",
        "scope": "python",
        "description": "Returns true if function_name exists in the REAPER API\n",
        "body": "${1:Boolean} = RPR_APIExists(${2:String function_name})$0"
    },
    "APITEST_WR c": {
        "prefix": "WR_APITest",
        "scope": "c",
        "description": "Displays a message window if the API was successfully called.\n",
        "body": "${1:void} = APITest()$0"
    },
    "APPLYNUDGE_WR c": {
        "prefix": "WR_ApplyNudge",
        "scope": "c",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "${1:bool} = ApplyNudge(${2:ReaProject* project},${3:int nudgeflag},${4:int nudgewhat},${5:int nudgeunits},${6:double value},${7:bool reverse},${8:int copies})$0"
    },
    "APPLYNUDGE_WR eel2": {
        "prefix": "WR_ApplyNudge",
        "scope": "eel2",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "${1:bool} = ApplyNudge(${2:ReaProject project},${3:int nudgeflag},${4:int nudgewhat},${5:int nudgeunits},${6:value},${7:bool reverse},${8:int copies})$0"
    },
    "REAPER.APPLYNUDGE_WR lua": {
        "prefix": "reaperwr.ApplyNudge",
        "scope": "lua",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "${1:local }${2:boolean} = reaper.ApplyNudge(${3:ReaProject project},${4:integer nudgeflag},${5:integer nudgewhat},${6:integer nudgeunits},${7:number value},${8:boolean reverse},${9:integer copies})$0"
    },
    "RPR_APPLYNUDGE_WR python": {
        "prefix": "WR_RPR_ApplyNudge",
        "scope": "python",
        "description": "nudgeflag: &1=set to value (otherwise nudge by value), &2=snap\nnudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor\nnudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes,\n16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames,\n19=pixels, 20=item lengths, 21=item selections\nvalue: amount to nudge by, or value to set to\nreverse: in nudge mode, nudges left (otherwise ignored)\ncopies: in nudge duplicate mode, number of copies (otherwise ignored)\n",
        "body": "${1:Boolean} = RPR_ApplyNudge(${2:ReaProject project},${3:Int nudgeflag},${4:Int nudgewhat},${5:Int nudgeunits},${6:Float value},${7:Boolean reverse},${8:Int copies})$0"
    },
    "ARMCOMMAND_WR c": {
        "prefix": "WR_ArmCommand",
        "scope": "c",
        "description": "arms a command (or disarms if 0 passed) in section sectionname (empty string for main)\n",
        "body": "${1:void} = ArmCommand(${2:int cmd},${3:const char* sectionname})$0"
    },
    "AUDIO_INIT_WR c": {
        "prefix": "WR_Audio_Init",
        "scope": "c",
        "description": "open all audio and MIDI devices, if not open\n",
        "body": "${1:void} = Audio_Init()$0"
    },
    "AUDIO_ISPREBUFFER_WR c": {
        "prefix": "WR_Audio_IsPreBuffer",
        "scope": "c",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "${1:int} = Audio_IsPreBuffer()$0"
    },
    "AUDIO_ISPREBUFFER_WR eel2": {
        "prefix": "WR_Audio_IsPreBuffer",
        "scope": "eel2",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "${1:int} = Audio_IsPreBuffer()$0"
    },
    "REAPER.AUDIO_ISPREBUFFER_WR lua": {
        "prefix": "reaperwr.Audio_IsPreBuffer",
        "scope": "lua",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "${1:local }${2:integer} = reaper.Audio_IsPreBuffer()$0"
    },
    "RPR_AUDIO_ISPREBUFFER_WR python": {
        "prefix": "WR_RPR_Audio_IsPreBuffer",
        "scope": "python",
        "description": "is in pre-buffer? threadsafe\n",
        "body": "${1:Int} = RPR_Audio_IsPreBuffer()$0"
    },
    "AUDIO_ISRUNNING_WR c": {
        "prefix": "WR_Audio_IsRunning",
        "scope": "c",
        "description": "is audio running at all? threadsafe\n",
        "body": "${1:int} = Audio_IsRunning()$0"
    },
    "AUDIO_ISRUNNING_WR eel2": {
        "prefix": "WR_Audio_IsRunning",
        "scope": "eel2",
        "description": "is audio running at all? threadsafe\n",
        "body": "${1:int} = Audio_IsRunning()$0"
    },
    "REAPER.AUDIO_ISRUNNING_WR lua": {
        "prefix": "reaperwr.Audio_IsRunning",
        "scope": "lua",
        "description": "is audio running at all? threadsafe\n",
        "body": "${1:local }${2:integer} = reaper.Audio_IsRunning()$0"
    },
    "RPR_AUDIO_ISRUNNING_WR python": {
        "prefix": "WR_RPR_Audio_IsRunning",
        "scope": "python",
        "description": "is audio running at all? threadsafe\n",
        "body": "${1:Int} = RPR_Audio_IsRunning()$0"
    },
    "AUDIO_QUIT_WR c": {
        "prefix": "WR_Audio_Quit",
        "scope": "c",
        "description": "close all audio and MIDI devices, if open\n",
        "body": "${1:void} = Audio_Quit()$0"
    },
    "AUDIOACCESSORSTATECHANGED_WR c": {
        "prefix": "WR_AudioAccessorStateChanged",
        "scope": "c",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:bool} = AudioAccessorStateChanged(${2:AudioAccessor* accessor})$0"
    },
    "AUDIOACCESSORSTATECHANGED_WR eel2": {
        "prefix": "WR_AudioAccessorStateChanged",
        "scope": "eel2",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:bool} = AudioAccessorStateChanged(${2:AudioAccessor accessor})$0"
    },
    "REAPER.AUDIOACCESSORSTATECHANGED_WR lua": {
        "prefix": "reaperwr.AudioAccessorStateChanged",
        "scope": "lua",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:local }${2:boolean} = reaper.AudioAccessorStateChanged(${3:AudioAccessor accessor})$0"
    },
    "RPR_AUDIOACCESSORSTATECHANGED_WR python": {
        "prefix": "WR_RPR_AudioAccessorStateChanged",
        "scope": "python",
        "description": "Returns true if the underlying samples (track or media item take) have\nchanged, but does not update the audio accessor, so the user can\nselectively call AudioAccessorValidateState only when needed. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:Boolean} = RPR_AudioAccessorStateChanged(${2:AudioAccessor accessor})$0"
    },
    "AUDIOACCESSORUPDATE_WR c": {
        "prefix": "WR_AudioAccessorUpdate",
        "scope": "c",
        "description": "Force the accessor to reload its state from the underlying track or media item take. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:void} = AudioAccessorUpdate(${2:AudioAccessor* accessor})$0"
    },
    "AUDIOACCESSORVALIDATESTATE_WR c": {
        "prefix": "WR_AudioAccessorValidateState",
        "scope": "c",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "${1:bool} = AudioAccessorValidateState(${2:AudioAccessor* accessor})$0"
    },
    "AUDIOACCESSORVALIDATESTATE_WR eel2": {
        "prefix": "WR_AudioAccessorValidateState",
        "scope": "eel2",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "${1:bool} = AudioAccessorValidateState(${2:AudioAccessor accessor})$0"
    },
    "REAPER.AUDIOACCESSORVALIDATESTATE_WR lua": {
        "prefix": "reaperwr.AudioAccessorValidateState",
        "scope": "lua",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "${1:local }${2:boolean} = reaper.AudioAccessorValidateState(${3:AudioAccessor accessor})$0"
    },
    "RPR_AUDIOACCESSORVALIDATESTATE_WR python": {
        "prefix": "WR_RPR_AudioAccessorValidateState",
        "scope": "python",
        "description": "Validates the current state of the audio accessor -- must ONLY call this\nfrom the main thread. Returns true if the state changed.\n",
        "body": "${1:Boolean} = RPR_AudioAccessorValidateState(${2:AudioAccessor accessor})$0"
    },
    "BYPASSFXALLTRACKS_WR c": {
        "prefix": "WR_BypassFxAllTracks",
        "scope": "c",
        "description": "-1 = bypass all if not all bypassed,otherwise unbypass all\n",
        "body": "${1:void} = BypassFxAllTracks(${2:int bypass})$0"
    },
    "CLEARALLRECARMED_WR c": {
        "prefix": "WR_ClearAllRecArmed",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = ClearAllRecArmed()$0"
    },
    "CLEARCONSOLE_WR c": {
        "prefix": "WR_ClearConsole",
        "scope": "c",
        "description": "Clear the ReaScript console. See ShowConsoleMsg\n",
        "body": "${1:void} = ClearConsole()$0"
    },
    "CLEARPEAKCACHE_WR c": {
        "prefix": "WR_ClearPeakCache",
        "scope": "c",
        "description": "resets the global peak caches\n",
        "body": "${1:void} = ClearPeakCache()$0"
    },
    "COLORFROMNATIVE_WR c": {
        "prefix": "WR_ColorFromNative",
        "scope": "c",
        "description": "Extract RGB values from an OS dependent color. See ColorToNative.\n",
        "body": "${1:void} = ColorFromNative(${2:int col},${3:int* rOut},${4:int* gOut},${5:int* bOut})$0"
    },
    "REAPER.COLORFROMNATIVE_WR lua": {
        "prefix": "reaperwr.ColorFromNative",
        "scope": "lua",
        "description": "Extract RGB values from an OS dependent color. See ColorToNative.\n",
        "body": "${1:local }${2:number r},${3:number g},${4:number b} = reaper.ColorFromNative(${5:integer col})$0"
    },
    "RPR_COLORFROMNATIVE_WR python": {
        "prefix": "WR_RPR_ColorFromNative",
        "scope": "python",
        "description": "Extract RGB values from an OS dependent color. See ColorToNative.\n",
        "body": "${1:Int col},${2:Int rOut},${3:Int gOut},${4:Int bOut} = RPR_ColorFromNative(${5:col},${6:rOut},${7:gOut},${8:bOut})$0"
    },
    "COLORTONATIVE_WR c": {
        "prefix": "WR_ColorToNative",
        "scope": "c",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "${1:int} = ColorToNative(${2:int r},${3:int g},${4:int b})$0"
    },
    "COLORTONATIVE_WR eel2": {
        "prefix": "WR_ColorToNative",
        "scope": "eel2",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "${1:int} = ColorToNative(${2:int r},${3:int g},${4:int b})$0"
    },
    "REAPER.COLORTONATIVE_WR lua": {
        "prefix": "reaperwr.ColorToNative",
        "scope": "lua",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "${1:local }${2:integer} = reaper.ColorToNative(${3:integer r},${4:integer g},${5:integer b})$0"
    },
    "RPR_COLORTONATIVE_WR python": {
        "prefix": "WR_RPR_ColorToNative",
        "scope": "python",
        "description": "Make an OS dependent color from RGB values (e.g. RGB() macro on Windows). r,g and b are in [0..255]. See ColorFromNative.\n",
        "body": "${1:Int} = RPR_ColorToNative(${2:Int r},${3:Int g},${4:Int b})$0"
    },
    "COUNTAUTOMATIONITEMS_WR c": {
        "prefix": "WR_CountAutomationItems",
        "scope": "c",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "${1:int} = CountAutomationItems(${2:TrackEnvelope* env})$0"
    },
    "COUNTAUTOMATIONITEMS_WR eel2": {
        "prefix": "WR_CountAutomationItems",
        "scope": "eel2",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "${1:int} = CountAutomationItems(${2:TrackEnvelope env})$0"
    },
    "REAPER.COUNTAUTOMATIONITEMS_WR lua": {
        "prefix": "reaperwr.CountAutomationItems",
        "scope": "lua",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "${1:local }${2:integer} = reaper.CountAutomationItems(${3:TrackEnvelope env})$0"
    },
    "RPR_COUNTAUTOMATIONITEMS_WR python": {
        "prefix": "WR_RPR_CountAutomationItems",
        "scope": "python",
        "description": "Returns the number of automation items on this envelope. See GetSetAutomationItemInfo\n",
        "body": "${1:Int} = RPR_CountAutomationItems(${2:TrackEnvelope env})$0"
    },
    "COUNTENVELOPEPOINTS_WR c": {
        "prefix": "WR_CountEnvelopePoints",
        "scope": "c",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "${1:int} = CountEnvelopePoints(${2:TrackEnvelope* envelope})$0"
    },
    "COUNTENVELOPEPOINTS_WR eel2": {
        "prefix": "WR_CountEnvelopePoints",
        "scope": "eel2",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "${1:int} = CountEnvelopePoints(${2:TrackEnvelope envelope})$0"
    },
    "REAPER.COUNTENVELOPEPOINTS_WR lua": {
        "prefix": "reaperwr.CountEnvelopePoints",
        "scope": "lua",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "${1:local }${2:integer} = reaper.CountEnvelopePoints(${3:TrackEnvelope envelope})$0"
    },
    "RPR_COUNTENVELOPEPOINTS_WR python": {
        "prefix": "WR_RPR_CountEnvelopePoints",
        "scope": "python",
        "description": "Returns the number of points in the envelope. See CountEnvelopePointsEx.\n",
        "body": "${1:Int} = RPR_CountEnvelopePoints(${2:TrackEnvelope envelope})$0"
    },
    "COUNTENVELOPEPOINTSEX_WR c": {
        "prefix": "WR_CountEnvelopePointsEx",
        "scope": "c",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:int} = CountEnvelopePointsEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx})$0"
    },
    "COUNTENVELOPEPOINTSEX_WR eel2": {
        "prefix": "WR_CountEnvelopePointsEx",
        "scope": "eel2",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:int} = CountEnvelopePointsEx(${2:TrackEnvelope envelope},${3:int autoitem_idx})$0"
    },
    "REAPER.COUNTENVELOPEPOINTSEX_WR lua": {
        "prefix": "reaperwr.CountEnvelopePointsEx",
        "scope": "lua",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:local }${2:integer} = reaper.CountEnvelopePointsEx(${3:TrackEnvelope envelope},${4:integer autoitem_idx})$0"
    },
    "RPR_COUNTENVELOPEPOINTSEX_WR python": {
        "prefix": "WR_RPR_CountEnvelopePointsEx",
        "scope": "python",
        "description": "Returns the number of points in the envelope.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:Int} = RPR_CountEnvelopePointsEx(${2:TrackEnvelope envelope},${3:Int autoitem_idx})$0"
    },
    "COUNTMEDIAITEMS_WR c": {
        "prefix": "WR_CountMediaItems",
        "scope": "c",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "${1:int} = CountMediaItems(${2:ReaProject* proj})$0"
    },
    "COUNTMEDIAITEMS_WR eel2": {
        "prefix": "WR_CountMediaItems",
        "scope": "eel2",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "${1:int} = CountMediaItems(${2:ReaProject proj})$0"
    },
    "REAPER.COUNTMEDIAITEMS_WR lua": {
        "prefix": "reaperwr.CountMediaItems",
        "scope": "lua",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "${1:local }${2:integer} = reaper.CountMediaItems(${3:ReaProject proj})$0"
    },
    "RPR_COUNTMEDIAITEMS_WR python": {
        "prefix": "WR_RPR_CountMediaItems",
        "scope": "python",
        "description": "count the number of items in the project (proj=0 for active project)\n",
        "body": "${1:Int} = RPR_CountMediaItems(${2:ReaProject proj})$0"
    },
    "COUNTPROJECTMARKERS_WR c": {
        "prefix": "WR_CountProjectMarkers",
        "scope": "c",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "${1:int} = CountProjectMarkers(${2:ReaProject* proj},${3:int* num_markersOut},${4:int* num_regionsOut})$0"
    },
    "COUNTPROJECTMARKERS_WR eel2": {
        "prefix": "WR_CountProjectMarkers",
        "scope": "eel2",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "${1:int} = CountProjectMarkers(${2:ReaProject proj},${3:int &num_markers},${4:int &num_regions})$0"
    },
    "REAPER.COUNTPROJECTMARKERS_WR lua": {
        "prefix": "reaperwr.CountProjectMarkers",
        "scope": "lua",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "${1:local }${2:integer retval},${3:number num_markers},${4:number num_regions} = reaper.CountProjectMarkers(${5:ReaProject proj})$0"
    },
    "RPR_COUNTPROJECTMARKERS_WR python": {
        "prefix": "WR_RPR_CountProjectMarkers",
        "scope": "python",
        "description": "num_markersOut and num_regionsOut may be NULL.\n",
        "body": "${1:Int retval},${2:ReaProject proj},${3:Int num_markersOut},${4:Int num_regionsOut} = RPR_CountProjectMarkers(${5:proj},${6:num_markersOut},${7:num_regionsOut})$0"
    },
    "COUNTSELECTEDMEDIAITEMS_WR c": {
        "prefix": "WR_CountSelectedMediaItems",
        "scope": "c",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "${1:int} = CountSelectedMediaItems(${2:ReaProject* proj})$0"
    },
    "COUNTSELECTEDMEDIAITEMS_WR eel2": {
        "prefix": "WR_CountSelectedMediaItems",
        "scope": "eel2",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "${1:int} = CountSelectedMediaItems(${2:ReaProject proj})$0"
    },
    "REAPER.COUNTSELECTEDMEDIAITEMS_WR lua": {
        "prefix": "reaperwr.CountSelectedMediaItems",
        "scope": "lua",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "${1:local }${2:integer} = reaper.CountSelectedMediaItems(${3:ReaProject proj})$0"
    },
    "RPR_COUNTSELECTEDMEDIAITEMS_WR python": {
        "prefix": "WR_RPR_CountSelectedMediaItems",
        "scope": "python",
        "description": "count the number of selected items in the project (proj=0 for active project)\n",
        "body": "${1:Int} = RPR_CountSelectedMediaItems(${2:ReaProject proj})$0"
    },
    "COUNTSELECTEDTRACKS_WR c": {
        "prefix": "WR_CountSelectedTracks",
        "scope": "c",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "${1:int} = CountSelectedTracks(${2:ReaProject* proj})$0"
    },
    "COUNTSELECTEDTRACKS_WR eel2": {
        "prefix": "WR_CountSelectedTracks",
        "scope": "eel2",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "${1:int} = CountSelectedTracks(${2:ReaProject proj})$0"
    },
    "REAPER.COUNTSELECTEDTRACKS_WR lua": {
        "prefix": "reaperwr.CountSelectedTracks",
        "scope": "lua",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "${1:local }${2:integer} = reaper.CountSelectedTracks(${3:ReaProject proj})$0"
    },
    "RPR_COUNTSELECTEDTRACKS_WR python": {
        "prefix": "WR_RPR_CountSelectedTracks",
        "scope": "python",
        "description": "Count the number of selected tracks in the project (proj=0 for active project). This function ignores the master track, see CountSelectedTracks2.\n",
        "body": "${1:Int} = RPR_CountSelectedTracks(${2:ReaProject proj})$0"
    },
    "COUNTSELECTEDTRACKS2_WR c": {
        "prefix": "WR_CountSelectedTracks2",
        "scope": "c",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "${1:int} = CountSelectedTracks2(${2:ReaProject* proj},${3:bool wantmaster})$0"
    },
    "COUNTSELECTEDTRACKS2_WR eel2": {
        "prefix": "WR_CountSelectedTracks2",
        "scope": "eel2",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "${1:int} = CountSelectedTracks2(${2:ReaProject proj},${3:bool wantmaster})$0"
    },
    "REAPER.COUNTSELECTEDTRACKS2_WR lua": {
        "prefix": "reaperwr.CountSelectedTracks2",
        "scope": "lua",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "${1:local }${2:integer} = reaper.CountSelectedTracks2(${3:ReaProject proj},${4:boolean wantmaster})$0"
    },
    "RPR_COUNTSELECTEDTRACKS2_WR python": {
        "prefix": "WR_RPR_CountSelectedTracks2",
        "scope": "python",
        "description": "Count the number of selected tracks in the project (proj=0 for active project).\n",
        "body": "${1:Int} = RPR_CountSelectedTracks2(${2:ReaProject proj},${3:Boolean wantmaster})$0"
    },
    "COUNTTAKEENVELOPES_WR c": {
        "prefix": "WR_CountTakeEnvelopes",
        "scope": "c",
        "description": "See GetTakeEnvelope\n",
        "body": "${1:int} = CountTakeEnvelopes(${2:MediaItem_Take* take})$0"
    },
    "COUNTTAKEENVELOPES_WR eel2": {
        "prefix": "WR_CountTakeEnvelopes",
        "scope": "eel2",
        "description": "See GetTakeEnvelope\n",
        "body": "${1:int} = CountTakeEnvelopes(${2:MediaItem_Take take})$0"
    },
    "REAPER.COUNTTAKEENVELOPES_WR lua": {
        "prefix": "reaperwr.CountTakeEnvelopes",
        "scope": "lua",
        "description": "See GetTakeEnvelope\n",
        "body": "${1:local }${2:integer} = reaper.CountTakeEnvelopes(${3:MediaItem_Take take})$0"
    },
    "RPR_COUNTTAKEENVELOPES_WR python": {
        "prefix": "WR_RPR_CountTakeEnvelopes",
        "scope": "python",
        "description": "See GetTakeEnvelope\n",
        "body": "${1:Int} = RPR_CountTakeEnvelopes(${2:MediaItem_Take take})$0"
    },
    "COUNTTAKES_WR c": {
        "prefix": "WR_CountTakes",
        "scope": "c",
        "description": "count the number of takes in the item\n",
        "body": "${1:int} = CountTakes(${2:MediaItem* item})$0"
    },
    "COUNTTAKES_WR eel2": {
        "prefix": "WR_CountTakes",
        "scope": "eel2",
        "description": "count the number of takes in the item\n",
        "body": "${1:int} = CountTakes(${2:MediaItem item})$0"
    },
    "REAPER.COUNTTAKES_WR lua": {
        "prefix": "reaperwr.CountTakes",
        "scope": "lua",
        "description": "count the number of takes in the item\n",
        "body": "${1:local }${2:integer} = reaper.CountTakes(${3:MediaItem item})$0"
    },
    "RPR_COUNTTAKES_WR python": {
        "prefix": "WR_RPR_CountTakes",
        "scope": "python",
        "description": "count the number of takes in the item\n",
        "body": "${1:Int} = RPR_CountTakes(${2:MediaItem item})$0"
    },
    "COUNTTCPFXPARMS_WR c": {
        "prefix": "WR_CountTCPFXParms",
        "scope": "c",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "${1:int} = CountTCPFXParms(${2:ReaProject* project},${3:MediaTrack* track})$0"
    },
    "COUNTTCPFXPARMS_WR eel2": {
        "prefix": "WR_CountTCPFXParms",
        "scope": "eel2",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "${1:int} = CountTCPFXParms(${2:ReaProject project},${3:MediaTrack track})$0"
    },
    "REAPER.COUNTTCPFXPARMS_WR lua": {
        "prefix": "reaperwr.CountTCPFXParms",
        "scope": "lua",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "${1:local }${2:integer} = reaper.CountTCPFXParms(${3:ReaProject project},${4:MediaTrack track})$0"
    },
    "RPR_COUNTTCPFXPARMS_WR python": {
        "prefix": "WR_RPR_CountTCPFXParms",
        "scope": "python",
        "description": "Count the number of FX parameter knobs displayed on the track control panel.\n",
        "body": "${1:Int} = RPR_CountTCPFXParms(${2:ReaProject project},${3:MediaTrack track})$0"
    },
    "COUNTTEMPOTIMESIGMARKERS_WR c": {
        "prefix": "WR_CountTempoTimeSigMarkers",
        "scope": "c",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:int} = CountTempoTimeSigMarkers(${2:ReaProject* proj})$0"
    },
    "COUNTTEMPOTIMESIGMARKERS_WR eel2": {
        "prefix": "WR_CountTempoTimeSigMarkers",
        "scope": "eel2",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:int} = CountTempoTimeSigMarkers(${2:ReaProject proj})$0"
    },
    "REAPER.COUNTTEMPOTIMESIGMARKERS_WR lua": {
        "prefix": "reaperwr.CountTempoTimeSigMarkers",
        "scope": "lua",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:local }${2:integer} = reaper.CountTempoTimeSigMarkers(${3:ReaProject proj})$0"
    },
    "RPR_COUNTTEMPOTIMESIGMARKERS_WR python": {
        "prefix": "WR_RPR_CountTempoTimeSigMarkers",
        "scope": "python",
        "description": "Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:Int} = RPR_CountTempoTimeSigMarkers(${2:ReaProject proj})$0"
    },
    "COUNTTRACKENVELOPES_WR c": {
        "prefix": "WR_CountTrackEnvelopes",
        "scope": "c",
        "description": "see GetTrackEnvelope\n",
        "body": "${1:int} = CountTrackEnvelopes(${2:MediaTrack* track})$0"
    },
    "COUNTTRACKENVELOPES_WR eel2": {
        "prefix": "WR_CountTrackEnvelopes",
        "scope": "eel2",
        "description": "see GetTrackEnvelope\n",
        "body": "${1:int} = CountTrackEnvelopes(${2:MediaTrack track})$0"
    },
    "REAPER.COUNTTRACKENVELOPES_WR lua": {
        "prefix": "reaperwr.CountTrackEnvelopes",
        "scope": "lua",
        "description": "see GetTrackEnvelope\n",
        "body": "${1:local }${2:integer} = reaper.CountTrackEnvelopes(${3:MediaTrack track})$0"
    },
    "RPR_COUNTTRACKENVELOPES_WR python": {
        "prefix": "WR_RPR_CountTrackEnvelopes",
        "scope": "python",
        "description": "see GetTrackEnvelope\n",
        "body": "${1:Int} = RPR_CountTrackEnvelopes(${2:MediaTrack track})$0"
    },
    "COUNTTRACKMEDIAITEMS_WR c": {
        "prefix": "WR_CountTrackMediaItems",
        "scope": "c",
        "description": "count the number of items in the track\n",
        "body": "${1:int} = CountTrackMediaItems(${2:MediaTrack* track})$0"
    },
    "COUNTTRACKMEDIAITEMS_WR eel2": {
        "prefix": "WR_CountTrackMediaItems",
        "scope": "eel2",
        "description": "count the number of items in the track\n",
        "body": "${1:int} = CountTrackMediaItems(${2:MediaTrack track})$0"
    },
    "REAPER.COUNTTRACKMEDIAITEMS_WR lua": {
        "prefix": "reaperwr.CountTrackMediaItems",
        "scope": "lua",
        "description": "count the number of items in the track\n",
        "body": "${1:local }${2:integer} = reaper.CountTrackMediaItems(${3:MediaTrack track})$0"
    },
    "RPR_COUNTTRACKMEDIAITEMS_WR python": {
        "prefix": "WR_RPR_CountTrackMediaItems",
        "scope": "python",
        "description": "count the number of items in the track\n",
        "body": "${1:Int} = RPR_CountTrackMediaItems(${2:MediaTrack track})$0"
    },
    "COUNTTRACKS_WR c": {
        "prefix": "WR_CountTracks",
        "scope": "c",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "${1:int} = CountTracks(${2:ReaProject* proj})$0"
    },
    "COUNTTRACKS_WR eel2": {
        "prefix": "WR_CountTracks",
        "scope": "eel2",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "${1:int} = CountTracks(${2:ReaProject proj})$0"
    },
    "REAPER.COUNTTRACKS_WR lua": {
        "prefix": "reaperwr.CountTracks",
        "scope": "lua",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "${1:local }${2:integer} = reaper.CountTracks(${3:ReaProject proj})$0"
    },
    "RPR_COUNTTRACKS_WR python": {
        "prefix": "WR_RPR_CountTracks",
        "scope": "python",
        "description": "count the number of tracks in the project (proj=0 for active project)\n",
        "body": "${1:Int} = RPR_CountTracks(${2:ReaProject proj})$0"
    },
    "CREATENEWMIDIITEMINPROJ_WR c": {
        "prefix": "WR_CreateNewMIDIItemInProj",
        "scope": "c",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "${1:MediaItem*} = CreateNewMIDIItemInProj(${2:MediaTrack* track},${3:double starttime},${4:double endtime},${5:const bool* qnInOptional})$0"
    },
    "CREATENEWMIDIITEMINPROJ_WR eel2": {
        "prefix": "WR_CreateNewMIDIItemInProj",
        "scope": "eel2",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "${1:MediaItem} = CreateNewMIDIItemInProj(${2:MediaTrack track},${3:starttime},${4:endtime},${5:optional bool qnIn})$0"
    },
    "REAPER.CREATENEWMIDIITEMINPROJ_WR lua": {
        "prefix": "reaperwr.CreateNewMIDIItemInProj",
        "scope": "lua",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "${1:local }${2:MediaItem} = reaper.CreateNewMIDIItemInProj(${3:MediaTrack track},${4:number starttime},${5:number endtime},${6:optional boolean qnIn})$0"
    },
    "RPR_CREATENEWMIDIITEMINPROJ_WR python": {
        "prefix": "WR_RPR_CreateNewMIDIItemInProj",
        "scope": "python",
        "description": "Create a new MIDI media item, containing no MIDI events. Time is in seconds unless qn is set.\n",
        "body": "${1:MediaItem} = RPR_CreateNewMIDIItemInProj(${2:MediaTrack track},${3:Float starttime},${4:Float endtime},${5:const bool qnInOptional})$0"
    },
    "CREATETAKEAUDIOACCESSOR_WR c": {
        "prefix": "WR_CreateTakeAudioAccessor",
        "scope": "c",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:AudioAccessor*} = CreateTakeAudioAccessor(${2:MediaItem_Take* take})$0"
    },
    "CREATETAKEAUDIOACCESSOR_WR eel2": {
        "prefix": "WR_CreateTakeAudioAccessor",
        "scope": "eel2",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:AudioAccessor} = CreateTakeAudioAccessor(${2:MediaItem_Take take})$0"
    },
    "REAPER.CREATETAKEAUDIOACCESSOR_WR lua": {
        "prefix": "reaperwr.CreateTakeAudioAccessor",
        "scope": "lua",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:local }${2:AudioAccessor} = reaper.CreateTakeAudioAccessor(${3:MediaItem_Take take})$0"
    },
    "RPR_CREATETAKEAUDIOACCESSOR_WR python": {
        "prefix": "WR_RPR_CreateTakeAudioAccessor",
        "scope": "python",
        "description": "Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:AudioAccessor} = RPR_CreateTakeAudioAccessor(${2:MediaItem_Take take})$0"
    },
    "CREATETRACKAUDIOACCESSOR_WR c": {
        "prefix": "WR_CreateTrackAudioAccessor",
        "scope": "c",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:AudioAccessor*} = CreateTrackAudioAccessor(${2:MediaTrack* track})$0"
    },
    "CREATETRACKAUDIOACCESSOR_WR eel2": {
        "prefix": "WR_CreateTrackAudioAccessor",
        "scope": "eel2",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:AudioAccessor} = CreateTrackAudioAccessor(${2:MediaTrack track})$0"
    },
    "REAPER.CREATETRACKAUDIOACCESSOR_WR lua": {
        "prefix": "reaperwr.CreateTrackAudioAccessor",
        "scope": "lua",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:local }${2:AudioAccessor} = reaper.CreateTrackAudioAccessor(${3:MediaTrack track})$0"
    },
    "RPR_CREATETRACKAUDIOACCESSOR_WR python": {
        "prefix": "WR_RPR_CreateTrackAudioAccessor",
        "scope": "python",
        "description": "Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:AudioAccessor} = RPR_CreateTrackAudioAccessor(${2:MediaTrack track})$0"
    },
    "CREATETRACKSEND_WR c": {
        "prefix": "WR_CreateTrackSend",
        "scope": "c",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "${1:int} = CreateTrackSend(${2:MediaTrack* tr},${3:MediaTrack* desttrInOptional})$0"
    },
    "CREATETRACKSEND_WR eel2": {
        "prefix": "WR_CreateTrackSend",
        "scope": "eel2",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "${1:int} = CreateTrackSend(${2:MediaTrack tr},${3:MediaTrack desttrIn})$0"
    },
    "REAPER.CREATETRACKSEND_WR lua": {
        "prefix": "reaperwr.CreateTrackSend",
        "scope": "lua",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "${1:local }${2:integer} = reaper.CreateTrackSend(${3:MediaTrack tr},${4:MediaTrack desttrIn})$0"
    },
    "RPR_CREATETRACKSEND_WR python": {
        "prefix": "WR_RPR_CreateTrackSend",
        "scope": "python",
        "description": "Create a send/receive (desttrInOptional!=NULL), or a hardware output\n(desttrInOptional==NULL) with default properties, return >=0 on\nsuccess (== new send/receive index). See RemoveTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value.\n",
        "body": "${1:Int} = RPR_CreateTrackSend(${2:MediaTrack tr},${3:MediaTrack desttrInOptional})$0"
    },
    "CSURF_FLUSHUNDO_WR c": {
        "prefix": "WR_CSurf_FlushUndo",
        "scope": "c",
        "description": "call this to force flushing of the undo states after using CSurf_On*Change()\n",
        "body": "${1:void} = CSurf_FlushUndo(${2:bool force})$0"
    },
    "CSURF_GETTOUCHSTATE_WR c": {
        "prefix": "WR_CSurf_GetTouchState",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_GetTouchState(${2:MediaTrack* trackid},${3:int isPan})$0"
    },
    "CSURF_GETTOUCHSTATE_WR eel2": {
        "prefix": "WR_CSurf_GetTouchState",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_GetTouchState(${2:MediaTrack trackid},${3:int isPan})$0"
    },
    "REAPER.CSURF_GETTOUCHSTATE_WR lua": {
        "prefix": "reaperwr.CSurf_GetTouchState",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_GetTouchState(${3:MediaTrack trackid},${4:integer isPan})$0"
    },
    "RPR_CSURF_GETTOUCHSTATE_WR python": {
        "prefix": "WR_RPR_CSurf_GetTouchState",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_GetTouchState(${2:MediaTrack trackid},${3:Int isPan})$0"
    },
    "CSURF_GOEND_WR c": {
        "prefix": "WR_CSurf_GoEnd",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_GoEnd()$0"
    },
    "CSURF_GOSTART_WR c": {
        "prefix": "WR_CSurf_GoStart",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_GoStart()$0"
    },
    "CSURF_NUMTRACKS_WR c": {
        "prefix": "WR_CSurf_NumTracks",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = CSurf_NumTracks(${2:bool mcpView})$0"
    },
    "CSURF_NUMTRACKS_WR eel2": {
        "prefix": "WR_CSurf_NumTracks",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = CSurf_NumTracks(${2:bool mcpView})$0"
    },
    "REAPER.CSURF_NUMTRACKS_WR lua": {
        "prefix": "reaperwr.CSurf_NumTracks",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.CSurf_NumTracks(${3:boolean mcpView})$0"
    },
    "RPR_CSURF_NUMTRACKS_WR python": {
        "prefix": "WR_RPR_CSurf_NumTracks",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_CSurf_NumTracks(${2:Boolean mcpView})$0"
    },
    "CSURF_ONARROW_WR c": {
        "prefix": "WR_CSurf_OnArrow",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnArrow(${2:int whichdir},${3:bool wantzoom})$0"
    },
    "CSURF_ONFWD_WR c": {
        "prefix": "WR_CSurf_OnFwd",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnFwd(${2:int seekplay})$0"
    },
    "CSURF_ONFXCHANGE_WR c": {
        "prefix": "WR_CSurf_OnFXChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnFXChange(${2:MediaTrack* trackid},${3:int en})$0"
    },
    "CSURF_ONFXCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnFXChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnFXChange(${2:MediaTrack trackid},${3:int en})$0"
    },
    "REAPER.CSURF_ONFXCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnFXChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnFXChange(${3:MediaTrack trackid},${4:integer en})$0"
    },
    "RPR_CSURF_ONFXCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnFXChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnFXChange(${2:MediaTrack trackid},${3:Int en})$0"
    },
    "CSURF_ONINPUTMONITORCHANGE_WR c": {
        "prefix": "WR_CSurf_OnInputMonitorChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = CSurf_OnInputMonitorChange(${2:MediaTrack* trackid},${3:int monitor})$0"
    },
    "CSURF_ONINPUTMONITORCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnInputMonitorChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = CSurf_OnInputMonitorChange(${2:MediaTrack trackid},${3:int monitor})$0"
    },
    "REAPER.CSURF_ONINPUTMONITORCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnInputMonitorChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.CSurf_OnInputMonitorChange(${3:MediaTrack trackid},${4:integer monitor})$0"
    },
    "RPR_CSURF_ONINPUTMONITORCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnInputMonitorChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_CSurf_OnInputMonitorChange(${2:MediaTrack trackid},${3:Int monitor})$0"
    },
    "CSURF_ONINPUTMONITORCHANGEEX_WR c": {
        "prefix": "WR_CSurf_OnInputMonitorChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = CSurf_OnInputMonitorChangeEx(${2:MediaTrack* trackid},${3:int monitor},${4:bool allowgang})$0"
    },
    "CSURF_ONINPUTMONITORCHANGEEX_WR eel2": {
        "prefix": "WR_CSurf_OnInputMonitorChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = CSurf_OnInputMonitorChangeEx(${2:MediaTrack trackid},${3:int monitor},${4:bool allowgang})$0"
    },
    "REAPER.CSURF_ONINPUTMONITORCHANGEEX_WR lua": {
        "prefix": "reaperwr.CSurf_OnInputMonitorChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.CSurf_OnInputMonitorChangeEx(${3:MediaTrack trackid},${4:integer monitor},${5:boolean allowgang})$0"
    },
    "RPR_CSURF_ONINPUTMONITORCHANGEEX_WR python": {
        "prefix": "WR_RPR_CSurf_OnInputMonitorChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_CSurf_OnInputMonitorChangeEx(${2:MediaTrack trackid},${3:Int monitor},${4:Boolean allowgang})$0"
    },
    "CSURF_ONMUTECHANGE_WR c": {
        "prefix": "WR_CSurf_OnMuteChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnMuteChange(${2:MediaTrack* trackid},${3:int mute})$0"
    },
    "CSURF_ONMUTECHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnMuteChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnMuteChange(${2:MediaTrack trackid},${3:int mute})$0"
    },
    "REAPER.CSURF_ONMUTECHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnMuteChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnMuteChange(${3:MediaTrack trackid},${4:integer mute})$0"
    },
    "RPR_CSURF_ONMUTECHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnMuteChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnMuteChange(${2:MediaTrack trackid},${3:Int mute})$0"
    },
    "CSURF_ONMUTECHANGEEX_WR c": {
        "prefix": "WR_CSurf_OnMuteChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnMuteChangeEx(${2:MediaTrack* trackid},${3:int mute},${4:bool allowgang})$0"
    },
    "CSURF_ONMUTECHANGEEX_WR eel2": {
        "prefix": "WR_CSurf_OnMuteChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnMuteChangeEx(${2:MediaTrack trackid},${3:int mute},${4:bool allowgang})$0"
    },
    "REAPER.CSURF_ONMUTECHANGEEX_WR lua": {
        "prefix": "reaperwr.CSurf_OnMuteChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnMuteChangeEx(${3:MediaTrack trackid},${4:integer mute},${5:boolean allowgang})$0"
    },
    "RPR_CSURF_ONMUTECHANGEEX_WR python": {
        "prefix": "WR_RPR_CSurf_OnMuteChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnMuteChangeEx(${2:MediaTrack trackid},${3:Int mute},${4:Boolean allowgang})$0"
    },
    "CSURF_ONPANCHANGE_WR c": {
        "prefix": "WR_CSurf_OnPanChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnPanChange(${2:MediaTrack* trackid},${3:double pan},${4:bool relative})$0"
    },
    "CSURF_ONPANCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnPanChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnPanChange(${2:MediaTrack trackid},${3:pan},${4:bool relative})$0"
    },
    "REAPER.CSURF_ONPANCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnPanChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnPanChange(${3:MediaTrack trackid},${4:number pan},${5:boolean relative})$0"
    },
    "RPR_CSURF_ONPANCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnPanChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnPanChange(${2:MediaTrack trackid},${3:Float pan},${4:Boolean relative})$0"
    },
    "CSURF_ONPANCHANGEEX_WR c": {
        "prefix": "WR_CSurf_OnPanChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnPanChangeEx(${2:MediaTrack* trackid},${3:double pan},${4:bool relative},${5:bool allowGang})$0"
    },
    "CSURF_ONPANCHANGEEX_WR eel2": {
        "prefix": "WR_CSurf_OnPanChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnPanChangeEx(${2:MediaTrack trackid},${3:pan},${4:bool relative},${5:bool allowGang})$0"
    },
    "REAPER.CSURF_ONPANCHANGEEX_WR lua": {
        "prefix": "reaperwr.CSurf_OnPanChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnPanChangeEx(${3:MediaTrack trackid},${4:number pan},${5:boolean relative},${6:boolean allowGang})$0"
    },
    "RPR_CSURF_ONPANCHANGEEX_WR python": {
        "prefix": "WR_RPR_CSurf_OnPanChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnPanChangeEx(${2:MediaTrack trackid},${3:Float pan},${4:Boolean relative},${5:Boolean allowGang})$0"
    },
    "CSURF_ONPAUSE_WR c": {
        "prefix": "WR_CSurf_OnPause",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnPause()$0"
    },
    "CSURF_ONPLAY_WR c": {
        "prefix": "WR_CSurf_OnPlay",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnPlay()$0"
    },
    "CSURF_ONPLAYRATECHANGE_WR c": {
        "prefix": "WR_CSurf_OnPlayRateChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnPlayRateChange(${2:double playrate})$0"
    },
    "CSURF_ONRECARMCHANGE_WR c": {
        "prefix": "WR_CSurf_OnRecArmChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnRecArmChange(${2:MediaTrack* trackid},${3:int recarm})$0"
    },
    "CSURF_ONRECARMCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnRecArmChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnRecArmChange(${2:MediaTrack trackid},${3:int recarm})$0"
    },
    "REAPER.CSURF_ONRECARMCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnRecArmChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnRecArmChange(${3:MediaTrack trackid},${4:integer recarm})$0"
    },
    "RPR_CSURF_ONRECARMCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnRecArmChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnRecArmChange(${2:MediaTrack trackid},${3:Int recarm})$0"
    },
    "CSURF_ONRECARMCHANGEEX_WR c": {
        "prefix": "WR_CSurf_OnRecArmChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnRecArmChangeEx(${2:MediaTrack* trackid},${3:int recarm},${4:bool allowgang})$0"
    },
    "CSURF_ONRECARMCHANGEEX_WR eel2": {
        "prefix": "WR_CSurf_OnRecArmChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnRecArmChangeEx(${2:MediaTrack trackid},${3:int recarm},${4:bool allowgang})$0"
    },
    "REAPER.CSURF_ONRECARMCHANGEEX_WR lua": {
        "prefix": "reaperwr.CSurf_OnRecArmChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnRecArmChangeEx(${3:MediaTrack trackid},${4:integer recarm},${5:boolean allowgang})$0"
    },
    "RPR_CSURF_ONRECARMCHANGEEX_WR python": {
        "prefix": "WR_RPR_CSurf_OnRecArmChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnRecArmChangeEx(${2:MediaTrack trackid},${3:Int recarm},${4:Boolean allowgang})$0"
    },
    "CSURF_ONRECORD_WR c": {
        "prefix": "WR_CSurf_OnRecord",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnRecord()$0"
    },
    "CSURF_ONRECVPANCHANGE_WR c": {
        "prefix": "WR_CSurf_OnRecvPanChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnRecvPanChange(${2:MediaTrack* trackid},${3:int recv_index},${4:double pan},${5:bool relative})$0"
    },
    "CSURF_ONRECVPANCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnRecvPanChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnRecvPanChange(${2:MediaTrack trackid},${3:int recv_index},${4:pan},${5:bool relative})$0"
    },
    "REAPER.CSURF_ONRECVPANCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnRecvPanChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnRecvPanChange(${3:MediaTrack trackid},${4:integer recv_index},${5:number pan},${6:boolean relative})$0"
    },
    "RPR_CSURF_ONRECVPANCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnRecvPanChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnRecvPanChange(${2:MediaTrack trackid},${3:Int recv_index},${4:Float pan},${5:Boolean relative})$0"
    },
    "CSURF_ONRECVVOLUMECHANGE_WR c": {
        "prefix": "WR_CSurf_OnRecvVolumeChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnRecvVolumeChange(${2:MediaTrack* trackid},${3:int recv_index},${4:double volume},${5:bool relative})$0"
    },
    "CSURF_ONRECVVOLUMECHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnRecvVolumeChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnRecvVolumeChange(${2:MediaTrack trackid},${3:int recv_index},${4:volume},${5:bool relative})$0"
    },
    "REAPER.CSURF_ONRECVVOLUMECHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnRecvVolumeChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnRecvVolumeChange(${3:MediaTrack trackid},${4:integer recv_index},${5:number volume},${6:boolean relative})$0"
    },
    "RPR_CSURF_ONRECVVOLUMECHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnRecvVolumeChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnRecvVolumeChange(${2:MediaTrack trackid},${3:Int recv_index},${4:Float volume},${5:Boolean relative})$0"
    },
    "CSURF_ONREW_WR c": {
        "prefix": "WR_CSurf_OnRew",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnRew(${2:int seekplay})$0"
    },
    "CSURF_ONREWFWD_WR c": {
        "prefix": "WR_CSurf_OnRewFwd",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnRewFwd(${2:int seekplay},${3:int dir})$0"
    },
    "CSURF_ONSCROLL_WR c": {
        "prefix": "WR_CSurf_OnScroll",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnScroll(${2:int xdir},${3:int ydir})$0"
    },
    "CSURF_ONSELECTEDCHANGE_WR c": {
        "prefix": "WR_CSurf_OnSelectedChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnSelectedChange(${2:MediaTrack* trackid},${3:int selected})$0"
    },
    "CSURF_ONSELECTEDCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnSelectedChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnSelectedChange(${2:MediaTrack trackid},${3:int selected})$0"
    },
    "REAPER.CSURF_ONSELECTEDCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnSelectedChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnSelectedChange(${3:MediaTrack trackid},${4:integer selected})$0"
    },
    "RPR_CSURF_ONSELECTEDCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnSelectedChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnSelectedChange(${2:MediaTrack trackid},${3:Int selected})$0"
    },
    "CSURF_ONSENDPANCHANGE_WR c": {
        "prefix": "WR_CSurf_OnSendPanChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnSendPanChange(${2:MediaTrack* trackid},${3:int send_index},${4:double pan},${5:bool relative})$0"
    },
    "CSURF_ONSENDPANCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnSendPanChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnSendPanChange(${2:MediaTrack trackid},${3:int send_index},${4:pan},${5:bool relative})$0"
    },
    "REAPER.CSURF_ONSENDPANCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnSendPanChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnSendPanChange(${3:MediaTrack trackid},${4:integer send_index},${5:number pan},${6:boolean relative})$0"
    },
    "RPR_CSURF_ONSENDPANCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnSendPanChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnSendPanChange(${2:MediaTrack trackid},${3:Int send_index},${4:Float pan},${5:Boolean relative})$0"
    },
    "CSURF_ONSENDVOLUMECHANGE_WR c": {
        "prefix": "WR_CSurf_OnSendVolumeChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnSendVolumeChange(${2:MediaTrack* trackid},${3:int send_index},${4:double volume},${5:bool relative})$0"
    },
    "CSURF_ONSENDVOLUMECHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnSendVolumeChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnSendVolumeChange(${2:MediaTrack trackid},${3:int send_index},${4:volume},${5:bool relative})$0"
    },
    "REAPER.CSURF_ONSENDVOLUMECHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnSendVolumeChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnSendVolumeChange(${3:MediaTrack trackid},${4:integer send_index},${5:number volume},${6:boolean relative})$0"
    },
    "RPR_CSURF_ONSENDVOLUMECHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnSendVolumeChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnSendVolumeChange(${2:MediaTrack trackid},${3:Int send_index},${4:Float volume},${5:Boolean relative})$0"
    },
    "CSURF_ONSOLOCHANGE_WR c": {
        "prefix": "WR_CSurf_OnSoloChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnSoloChange(${2:MediaTrack* trackid},${3:int solo})$0"
    },
    "CSURF_ONSOLOCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnSoloChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnSoloChange(${2:MediaTrack trackid},${3:int solo})$0"
    },
    "REAPER.CSURF_ONSOLOCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnSoloChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnSoloChange(${3:MediaTrack trackid},${4:integer solo})$0"
    },
    "RPR_CSURF_ONSOLOCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnSoloChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnSoloChange(${2:MediaTrack trackid},${3:Int solo})$0"
    },
    "CSURF_ONSOLOCHANGEEX_WR c": {
        "prefix": "WR_CSurf_OnSoloChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnSoloChangeEx(${2:MediaTrack* trackid},${3:int solo},${4:bool allowgang})$0"
    },
    "CSURF_ONSOLOCHANGEEX_WR eel2": {
        "prefix": "WR_CSurf_OnSoloChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = CSurf_OnSoloChangeEx(${2:MediaTrack trackid},${3:int solo},${4:bool allowgang})$0"
    },
    "REAPER.CSURF_ONSOLOCHANGEEX_WR lua": {
        "prefix": "reaperwr.CSurf_OnSoloChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.CSurf_OnSoloChangeEx(${3:MediaTrack trackid},${4:integer solo},${5:boolean allowgang})$0"
    },
    "RPR_CSURF_ONSOLOCHANGEEX_WR python": {
        "prefix": "WR_RPR_CSurf_OnSoloChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_CSurf_OnSoloChangeEx(${2:MediaTrack trackid},${3:Int solo},${4:Boolean allowgang})$0"
    },
    "CSURF_ONSTOP_WR c": {
        "prefix": "WR_CSurf_OnStop",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnStop()$0"
    },
    "CSURF_ONTEMPOCHANGE_WR c": {
        "prefix": "WR_CSurf_OnTempoChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnTempoChange(${2:double bpm})$0"
    },
    "CSURF_ONTRACKSELECTION_WR c": {
        "prefix": "WR_CSurf_OnTrackSelection",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnTrackSelection(${2:MediaTrack* trackid})$0"
    },
    "CSURF_ONVOLUMECHANGE_WR c": {
        "prefix": "WR_CSurf_OnVolumeChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnVolumeChange(${2:MediaTrack* trackid},${3:double volume},${4:bool relative})$0"
    },
    "CSURF_ONVOLUMECHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnVolumeChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnVolumeChange(${2:MediaTrack trackid},${3:volume},${4:bool relative})$0"
    },
    "REAPER.CSURF_ONVOLUMECHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnVolumeChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnVolumeChange(${3:MediaTrack trackid},${4:number volume},${5:boolean relative})$0"
    },
    "RPR_CSURF_ONVOLUMECHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnVolumeChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnVolumeChange(${2:MediaTrack trackid},${3:Float volume},${4:Boolean relative})$0"
    },
    "CSURF_ONVOLUMECHANGEEX_WR c": {
        "prefix": "WR_CSurf_OnVolumeChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnVolumeChangeEx(${2:MediaTrack* trackid},${3:double volume},${4:bool relative},${5:bool allowGang})$0"
    },
    "CSURF_ONVOLUMECHANGEEX_WR eel2": {
        "prefix": "WR_CSurf_OnVolumeChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnVolumeChangeEx(${2:MediaTrack trackid},${3:volume},${4:bool relative},${5:bool allowGang})$0"
    },
    "REAPER.CSURF_ONVOLUMECHANGEEX_WR lua": {
        "prefix": "reaperwr.CSurf_OnVolumeChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnVolumeChangeEx(${3:MediaTrack trackid},${4:number volume},${5:boolean relative},${6:boolean allowGang})$0"
    },
    "RPR_CSURF_ONVOLUMECHANGEEX_WR python": {
        "prefix": "WR_RPR_CSurf_OnVolumeChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnVolumeChangeEx(${2:MediaTrack trackid},${3:Float volume},${4:Boolean relative},${5:Boolean allowGang})$0"
    },
    "CSURF_ONWIDTHCHANGE_WR c": {
        "prefix": "WR_CSurf_OnWidthChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnWidthChange(${2:MediaTrack* trackid},${3:double width},${4:bool relative})$0"
    },
    "CSURF_ONWIDTHCHANGE_WR eel2": {
        "prefix": "WR_CSurf_OnWidthChange",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnWidthChange(${2:MediaTrack trackid},${3:width},${4:bool relative})$0"
    },
    "REAPER.CSURF_ONWIDTHCHANGE_WR lua": {
        "prefix": "reaperwr.CSurf_OnWidthChange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnWidthChange(${3:MediaTrack trackid},${4:number width},${5:boolean relative})$0"
    },
    "RPR_CSURF_ONWIDTHCHANGE_WR python": {
        "prefix": "WR_RPR_CSurf_OnWidthChange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnWidthChange(${2:MediaTrack trackid},${3:Float width},${4:Boolean relative})$0"
    },
    "CSURF_ONWIDTHCHANGEEX_WR c": {
        "prefix": "WR_CSurf_OnWidthChangeEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = CSurf_OnWidthChangeEx(${2:MediaTrack* trackid},${3:double width},${4:bool relative},${5:bool allowGang})$0"
    },
    "CSURF_ONWIDTHCHANGEEX_WR eel2": {
        "prefix": "WR_CSurf_OnWidthChangeEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = CSurf_OnWidthChangeEx(${2:MediaTrack trackid},${3:width},${4:bool relative},${5:bool allowGang})$0"
    },
    "REAPER.CSURF_ONWIDTHCHANGEEX_WR lua": {
        "prefix": "reaperwr.CSurf_OnWidthChangeEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.CSurf_OnWidthChangeEx(${3:MediaTrack trackid},${4:number width},${5:boolean relative},${6:boolean allowGang})$0"
    },
    "RPR_CSURF_ONWIDTHCHANGEEX_WR python": {
        "prefix": "WR_RPR_CSurf_OnWidthChangeEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_CSurf_OnWidthChangeEx(${2:MediaTrack trackid},${3:Float width},${4:Boolean relative},${5:Boolean allowGang})$0"
    },
    "CSURF_ONZOOM_WR c": {
        "prefix": "WR_CSurf_OnZoom",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_OnZoom(${2:int xdir},${3:int ydir})$0"
    },
    "CSURF_RESETALLCACHEDVOLPANSTATES_WR c": {
        "prefix": "WR_CSurf_ResetAllCachedVolPanStates",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_ResetAllCachedVolPanStates()$0"
    },
    "CSURF_SCRUBAMT_WR c": {
        "prefix": "WR_CSurf_ScrubAmt",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_ScrubAmt(${2:double amt})$0"
    },
    "CSURF_SETAUTOMODE_WR c": {
        "prefix": "WR_CSurf_SetAutoMode",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetAutoMode(${2:int mode},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETPLAYSTATE_WR c": {
        "prefix": "WR_CSurf_SetPlayState",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetPlayState(${2:bool play},${3:bool pause},${4:bool rec},${5:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETREPEATSTATE_WR c": {
        "prefix": "WR_CSurf_SetRepeatState",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetRepeatState(${2:bool rep},${3:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACEMUTE_WR c": {
        "prefix": "WR_CSurf_SetSurfaceMute",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetSurfaceMute(${2:MediaTrack* trackid},${3:bool mute},${4:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACEPAN_WR c": {
        "prefix": "WR_CSurf_SetSurfacePan",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetSurfacePan(${2:MediaTrack* trackid},${3:double pan},${4:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACERECARM_WR c": {
        "prefix": "WR_CSurf_SetSurfaceRecArm",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetSurfaceRecArm(${2:MediaTrack* trackid},${3:bool recarm},${4:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACESELECTED_WR c": {
        "prefix": "WR_CSurf_SetSurfaceSelected",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetSurfaceSelected(${2:MediaTrack* trackid},${3:bool selected},${4:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACESOLO_WR c": {
        "prefix": "WR_CSurf_SetSurfaceSolo",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetSurfaceSolo(${2:MediaTrack* trackid},${3:bool solo},${4:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETSURFACEVOLUME_WR c": {
        "prefix": "WR_CSurf_SetSurfaceVolume",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetSurfaceVolume(${2:MediaTrack* trackid},${3:double volume},${4:IReaperControlSurface* ignoresurf})$0"
    },
    "CSURF_SETTRACKLISTCHANGE_WR c": {
        "prefix": "WR_CSurf_SetTrackListChange",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = CSurf_SetTrackListChange()$0"
    },
    "CSURF_TRACKFROMID_WR c": {
        "prefix": "WR_CSurf_TrackFromID",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaTrack*} = CSurf_TrackFromID(${2:int idx},${3:bool mcpView})$0"
    },
    "CSURF_TRACKFROMID_WR eel2": {
        "prefix": "WR_CSurf_TrackFromID",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaTrack} = CSurf_TrackFromID(${2:int idx},${3:bool mcpView})$0"
    },
    "REAPER.CSURF_TRACKFROMID_WR lua": {
        "prefix": "reaperwr.CSurf_TrackFromID",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaTrack} = reaper.CSurf_TrackFromID(${3:integer idx},${4:boolean mcpView})$0"
    },
    "RPR_CSURF_TRACKFROMID_WR python": {
        "prefix": "WR_RPR_CSurf_TrackFromID",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaTrack} = RPR_CSurf_TrackFromID(${2:Int idx},${3:Boolean mcpView})$0"
    },
    "CSURF_TRACKTOID_WR c": {
        "prefix": "WR_CSurf_TrackToID",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = CSurf_TrackToID(${2:MediaTrack* track},${3:bool mcpView})$0"
    },
    "CSURF_TRACKTOID_WR eel2": {
        "prefix": "WR_CSurf_TrackToID",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = CSurf_TrackToID(${2:MediaTrack track},${3:bool mcpView})$0"
    },
    "REAPER.CSURF_TRACKTOID_WR lua": {
        "prefix": "reaperwr.CSurf_TrackToID",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.CSurf_TrackToID(${3:MediaTrack track},${4:boolean mcpView})$0"
    },
    "RPR_CSURF_TRACKTOID_WR python": {
        "prefix": "WR_RPR_CSurf_TrackToID",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_CSurf_TrackToID(${2:MediaTrack track},${3:Boolean mcpView})$0"
    },
    "DB2SLIDER_WR c": {
        "prefix": "WR_DB2SLIDER",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = DB2SLIDER(${2:double x})$0"
    },
    "DB2SLIDER_WR eel2": {
        "prefix": "WR_DB2SLIDER",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = DB2SLIDER(${2:x})$0"
    },
    "REAPER.DB2SLIDER_WR lua": {
        "prefix": "reaperwr.DB2SLIDER",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.DB2SLIDER(${3:number x})$0"
    },
    "RPR_DB2SLIDER_WR python": {
        "prefix": "WR_RPR_DB2SLIDER",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_DB2SLIDER(${2:Float x})$0"
    },
    "DELETEENVELOPEPOINTEX_WR c": {
        "prefix": "WR_DeleteEnvelopePointEx",
        "scope": "c",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "${1:bool} = DeleteEnvelopePointEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx},${4:int ptidx})$0"
    },
    "DELETEENVELOPEPOINTEX_WR eel2": {
        "prefix": "WR_DeleteEnvelopePointEx",
        "scope": "eel2",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "${1:bool} = DeleteEnvelopePointEx(${2:TrackEnvelope envelope},${3:int autoitem_idx},${4:int ptidx})$0"
    },
    "REAPER.DELETEENVELOPEPOINTEX_WR lua": {
        "prefix": "reaperwr.DeleteEnvelopePointEx",
        "scope": "lua",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean} = reaper.DeleteEnvelopePointEx(${3:TrackEnvelope envelope},${4:integer autoitem_idx},${5:integer ptidx})$0"
    },
    "RPR_DELETEENVELOPEPOINTEX_WR python": {
        "prefix": "WR_RPR_DeleteEnvelopePointEx",
        "scope": "python",
        "description": "Delete an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx.\n",
        "body": "${1:Boolean} = RPR_DeleteEnvelopePointEx(${2:TrackEnvelope envelope},${3:Int autoitem_idx},${4:Int ptidx})$0"
    },
    "DELETEENVELOPEPOINTRANGE_WR c": {
        "prefix": "WR_DeleteEnvelopePointRange",
        "scope": "c",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = DeleteEnvelopePointRange(${2:TrackEnvelope* envelope},${3:double time_start},${4:double time_end})$0"
    },
    "DELETEENVELOPEPOINTRANGE_WR eel2": {
        "prefix": "WR_DeleteEnvelopePointRange",
        "scope": "eel2",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = DeleteEnvelopePointRange(${2:TrackEnvelope envelope},${3:time_start},${4:time_end})$0"
    },
    "REAPER.DELETEENVELOPEPOINTRANGE_WR lua": {
        "prefix": "reaperwr.DeleteEnvelopePointRange",
        "scope": "lua",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean} = reaper.DeleteEnvelopePointRange(${3:TrackEnvelope envelope},${4:number time_start},${5:number time_end})$0"
    },
    "RPR_DELETEENVELOPEPOINTRANGE_WR python": {
        "prefix": "WR_RPR_DeleteEnvelopePointRange",
        "scope": "python",
        "description": "Delete a range of envelope points. See DeleteEnvelopePointRangeEx, DeleteEnvelopePointEx.\n",
        "body": "${1:Boolean} = RPR_DeleteEnvelopePointRange(${2:TrackEnvelope envelope},${3:Float time_start},${4:Float time_end})$0"
    },
    "DELETEENVELOPEPOINTRANGEEX_WR c": {
        "prefix": "WR_DeleteEnvelopePointRangeEx",
        "scope": "c",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "${1:bool} = DeleteEnvelopePointRangeEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx},${4:double time_start},${5:double time_end})$0"
    },
    "DELETEENVELOPEPOINTRANGEEX_WR eel2": {
        "prefix": "WR_DeleteEnvelopePointRangeEx",
        "scope": "eel2",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "${1:bool} = DeleteEnvelopePointRangeEx(${2:TrackEnvelope envelope},${3:int autoitem_idx},${4:time_start},${5:time_end})$0"
    },
    "REAPER.DELETEENVELOPEPOINTRANGEEX_WR lua": {
        "prefix": "reaperwr.DeleteEnvelopePointRangeEx",
        "scope": "lua",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "${1:local }${2:boolean} = reaper.DeleteEnvelopePointRangeEx(${3:TrackEnvelope envelope},${4:integer autoitem_idx},${5:number time_start},${6:number time_end})$0"
    },
    "RPR_DELETEENVELOPEPOINTRANGEEX_WR python": {
        "prefix": "WR_RPR_DeleteEnvelopePointRangeEx",
        "scope": "python",
        "description": "Delete a range of envelope points. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc.\n",
        "body": "${1:Boolean} = RPR_DeleteEnvelopePointRangeEx(${2:TrackEnvelope envelope},${3:Int autoitem_idx},${4:Float time_start},${5:Float time_end})$0"
    },
    "DELETEEXTSTATE_WR c": {
        "prefix": "WR_DeleteExtState",
        "scope": "c",
        "description": "Delete the extended state value for a specific section and key.\npersist=true means the value should remain deleted the next time REAPER\nis opened. See SetExtState, GetExtState, HasExtState.\n",
        "body": "${1:void} = DeleteExtState(${2:const char* section},${3:const char* key},${4:bool persist})$0"
    },
    "DELETEPROJECTMARKER_WR c": {
        "prefix": "WR_DeleteProjectMarker",
        "scope": "c",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "${1:bool} = DeleteProjectMarker(${2:ReaProject* proj},${3:int markrgnindexnumber},${4:bool isrgn})$0"
    },
    "DELETEPROJECTMARKER_WR eel2": {
        "prefix": "WR_DeleteProjectMarker",
        "scope": "eel2",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "${1:bool} = DeleteProjectMarker(${2:ReaProject proj},${3:int markrgnindexnumber},${4:bool isrgn})$0"
    },
    "REAPER.DELETEPROJECTMARKER_WR lua": {
        "prefix": "reaperwr.DeleteProjectMarker",
        "scope": "lua",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "${1:local }${2:boolean} = reaper.DeleteProjectMarker(${3:ReaProject proj},${4:integer markrgnindexnumber},${5:boolean isrgn})$0"
    },
    "RPR_DELETEPROJECTMARKER_WR python": {
        "prefix": "WR_RPR_DeleteProjectMarker",
        "scope": "python",
        "description": "Delete a marker.  proj==NULL for the active project.\n",
        "body": "${1:Boolean} = RPR_DeleteProjectMarker(${2:ReaProject proj},${3:Int markrgnindexnumber},${4:Boolean isrgn})$0"
    },
    "DELETEPROJECTMARKERBYINDEX_WR c": {
        "prefix": "WR_DeleteProjectMarkerByIndex",
        "scope": "c",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "${1:bool} = DeleteProjectMarkerByIndex(${2:ReaProject* proj},${3:int markrgnidx})$0"
    },
    "DELETEPROJECTMARKERBYINDEX_WR eel2": {
        "prefix": "WR_DeleteProjectMarkerByIndex",
        "scope": "eel2",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "${1:bool} = DeleteProjectMarkerByIndex(${2:ReaProject proj},${3:int markrgnidx})$0"
    },
    "REAPER.DELETEPROJECTMARKERBYINDEX_WR lua": {
        "prefix": "reaperwr.DeleteProjectMarkerByIndex",
        "scope": "lua",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "${1:local }${2:boolean} = reaper.DeleteProjectMarkerByIndex(${3:ReaProject proj},${4:integer markrgnidx})$0"
    },
    "RPR_DELETEPROJECTMARKERBYINDEX_WR python": {
        "prefix": "WR_RPR_DeleteProjectMarkerByIndex",
        "scope": "python",
        "description": "Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).\n",
        "body": "${1:Boolean} = RPR_DeleteProjectMarkerByIndex(${2:ReaProject proj},${3:Int markrgnidx})$0"
    },
    "DELETETAKESTRETCHMARKERS_WR c": {
        "prefix": "WR_DeleteTakeStretchMarkers",
        "scope": "c",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "${1:int} = DeleteTakeStretchMarkers(${2:MediaItem_Take* take},${3:int idx},${4:const int* countInOptional})$0"
    },
    "DELETETAKESTRETCHMARKERS_WR eel2": {
        "prefix": "WR_DeleteTakeStretchMarkers",
        "scope": "eel2",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "${1:int} = DeleteTakeStretchMarkers(${2:MediaItem_Take take},${3:int idx},${4:optional int countIn})$0"
    },
    "REAPER.DELETETAKESTRETCHMARKERS_WR lua": {
        "prefix": "reaperwr.DeleteTakeStretchMarkers",
        "scope": "lua",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "${1:local }${2:integer} = reaper.DeleteTakeStretchMarkers(${3:MediaItem_Take take},${4:integer idx},${5:optional number countIn})$0"
    },
    "RPR_DELETETAKESTRETCHMARKERS_WR python": {
        "prefix": "WR_RPR_DeleteTakeStretchMarkers",
        "scope": "python",
        "description": "Deletes one or more stretch markers. Returns number of stretch markers deleted.\n",
        "body": "${1:Int} = RPR_DeleteTakeStretchMarkers(${2:MediaItem_Take take},${3:Int idx},${4:const int countInOptional})$0"
    },
    "DELETETEMPOTIMESIGMARKER_WR c": {
        "prefix": "WR_DeleteTempoTimeSigMarker",
        "scope": "c",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "${1:bool} = DeleteTempoTimeSigMarker(${2:ReaProject* project},${3:int markerindex})$0"
    },
    "DELETETEMPOTIMESIGMARKER_WR eel2": {
        "prefix": "WR_DeleteTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "${1:bool} = DeleteTempoTimeSigMarker(${2:ReaProject project},${3:int markerindex})$0"
    },
    "REAPER.DELETETEMPOTIMESIGMARKER_WR lua": {
        "prefix": "reaperwr.DeleteTempoTimeSigMarker",
        "scope": "lua",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "${1:local }${2:boolean} = reaper.DeleteTempoTimeSigMarker(${3:ReaProject project},${4:integer markerindex})$0"
    },
    "RPR_DELETETEMPOTIMESIGMARKER_WR python": {
        "prefix": "WR_RPR_DeleteTempoTimeSigMarker",
        "scope": "python",
        "description": "Delete a tempo/time signature marker.\n",
        "body": "${1:Boolean} = RPR_DeleteTempoTimeSigMarker(${2:ReaProject project},${3:Int markerindex})$0"
    },
    "DELETETRACK_WR c": {
        "prefix": "WR_DeleteTrack",
        "scope": "c",
        "description": "deletes a track\n",
        "body": "${1:void} = DeleteTrack(${2:MediaTrack* tr})$0"
    },
    "DELETETRACKMEDIAITEM_WR c": {
        "prefix": "WR_DeleteTrackMediaItem",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = DeleteTrackMediaItem(${2:MediaTrack* tr},${3:MediaItem* it})$0"
    },
    "DELETETRACKMEDIAITEM_WR eel2": {
        "prefix": "WR_DeleteTrackMediaItem",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = DeleteTrackMediaItem(${2:MediaTrack tr},${3:MediaItem it})$0"
    },
    "REAPER.DELETETRACKMEDIAITEM_WR lua": {
        "prefix": "reaperwr.DeleteTrackMediaItem",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.DeleteTrackMediaItem(${3:MediaTrack tr},${4:MediaItem it})$0"
    },
    "RPR_DELETETRACKMEDIAITEM_WR python": {
        "prefix": "WR_RPR_DeleteTrackMediaItem",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_DeleteTrackMediaItem(${2:MediaTrack tr},${3:MediaItem it})$0"
    },
    "DESTROYAUDIOACCESSOR_WR c": {
        "prefix": "WR_DestroyAudioAccessor",
        "scope": "c",
        "description": "Destroy an audio accessor. Must only call from the main thread. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:void} = DestroyAudioAccessor(${2:AudioAccessor* accessor})$0"
    },
    "DOCK_UPDATEDOCKID_WR c": {
        "prefix": "WR_Dock_UpdateDockID",
        "scope": "c",
        "description": "updates preference for docker window ident_str to be in dock whichDock on next open\n",
        "body": "${1:void} = Dock_UpdateDockID(${2:const char* ident_str},${3:int whichDock})$0"
    },
    "DOCKGETPOSITION_WR c": {
        "prefix": "WR_DockGetPosition",
        "scope": "c",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "${1:int} = DockGetPosition(${2:int whichDock})$0"
    },
    "DOCKGETPOSITION_WR eel2": {
        "prefix": "WR_DockGetPosition",
        "scope": "eel2",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "${1:int} = DockGetPosition(${2:int whichDock})$0"
    },
    "REAPER.DOCKGETPOSITION_WR lua": {
        "prefix": "reaperwr.DockGetPosition",
        "scope": "lua",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "${1:local }${2:integer} = reaper.DockGetPosition(${3:integer whichDock})$0"
    },
    "RPR_DOCKGETPOSITION_WR python": {
        "prefix": "WR_RPR_DockGetPosition",
        "scope": "python",
        "description": "-1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating\n",
        "body": "${1:Int} = RPR_DockGetPosition(${2:Int whichDock})$0"
    },
    "DOCKISCHILDOFDOCK_WR c": {
        "prefix": "WR_DockIsChildOfDock",
        "scope": "c",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "${1:int} = DockIsChildOfDock(${2:HWND hwnd},${3:bool* isFloatingDockerOut})$0"
    },
    "DOCKISCHILDOFDOCK_WR eel2": {
        "prefix": "WR_DockIsChildOfDock",
        "scope": "eel2",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "${1:int} = DockIsChildOfDock(${2:HWND hwnd},${3:bool &isFloatingDocker})$0"
    },
    "REAPER.DOCKISCHILDOFDOCK_WR lua": {
        "prefix": "reaperwr.DockIsChildOfDock",
        "scope": "lua",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "${1:local }${2:integer retval},${3:boolean isFloatingDocker} = reaper.DockIsChildOfDock(${4:HWND hwnd})$0"
    },
    "RPR_DOCKISCHILDOFDOCK_WR python": {
        "prefix": "WR_RPR_DockIsChildOfDock",
        "scope": "python",
        "description": "returns dock index that contains hwnd, or -1\n",
        "body": "${1:Int retval},${2:HWND hwnd},${3:Boolean isFloatingDockerOut} = RPR_DockIsChildOfDock(${4:hwnd},${5:isFloatingDockerOut})$0"
    },
    "DOCKWINDOWACTIVATE_WR c": {
        "prefix": "WR_DockWindowActivate",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = DockWindowActivate(${2:HWND hwnd})$0"
    },
    "DOCKWINDOWADD_WR c": {
        "prefix": "WR_DockWindowAdd",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = DockWindowAdd(${2:HWND hwnd},${3:const char* name},${4:int pos},${5:bool allowShow})$0"
    },
    "DOCKWINDOWADDEX_WR c": {
        "prefix": "WR_DockWindowAddEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = DockWindowAddEx(${2:HWND hwnd},${3:const char* name},${4:const char* identstr},${5:bool allowShow})$0"
    },
    "DOCKWINDOWREFRESH_WR c": {
        "prefix": "WR_DockWindowRefresh",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = DockWindowRefresh()$0"
    },
    "DOCKWINDOWREFRESHFORHWND_WR c": {
        "prefix": "WR_DockWindowRefreshForHWND",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = DockWindowRefreshForHWND(${2:HWND hwnd})$0"
    },
    "DOCKWINDOWREMOVE_WR c": {
        "prefix": "WR_DockWindowRemove",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = DockWindowRemove(${2:HWND hwnd})$0"
    },
    "EDITTEMPOTIMESIGMARKER_WR c": {
        "prefix": "WR_EditTempoTimeSigMarker",
        "scope": "c",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "${1:bool} = EditTempoTimeSigMarker(${2:ReaProject* project},${3:int markerindex})$0"
    },
    "EDITTEMPOTIMESIGMARKER_WR eel2": {
        "prefix": "WR_EditTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "${1:bool} = EditTempoTimeSigMarker(${2:ReaProject project},${3:int markerindex})$0"
    },
    "REAPER.EDITTEMPOTIMESIGMARKER_WR lua": {
        "prefix": "reaperwr.EditTempoTimeSigMarker",
        "scope": "lua",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "${1:local }${2:boolean} = reaper.EditTempoTimeSigMarker(${3:ReaProject project},${4:integer markerindex})$0"
    },
    "RPR_EDITTEMPOTIMESIGMARKER_WR python": {
        "prefix": "WR_RPR_EditTempoTimeSigMarker",
        "scope": "python",
        "description": "Open the tempo/time signature marker editor dialog.\n",
        "body": "${1:Boolean} = RPR_EditTempoTimeSigMarker(${2:ReaProject project},${3:Int markerindex})$0"
    },
    "ENSURENOTCOMPLETELYOFFSCREEN_WR c": {
        "prefix": "WR_EnsureNotCompletelyOffscreen",
        "scope": "c",
        "description": "call with a saved window rect for your window and it'll correct any positioning info.\n",
        "body": "${1:void} = EnsureNotCompletelyOffscreen(${2:RECT* rInOut})$0"
    },
    "REAPER.ENSURENOTCOMPLETELYOFFSCREEN_WR lua": {
        "prefix": "reaperwr.EnsureNotCompletelyOffscreen",
        "scope": "lua",
        "description": "call with a saved window rect for your window and it'll correct any positioning info.\n",
        "body": "${1:local }${2:numberr.left},${3:numberr.top},${4:numberr.right},${5:numberr.bot} = reaper.EnsureNotCompletelyOffscreen(${6:numberr.left},${7:numberr.top},${8:numberr.right},${9:numberr.bot})$0"
    },
    "ENUMERATEFILES_WR c": {
        "prefix": "WR_EnumerateFiles",
        "scope": "c",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "${1:const char*} = EnumerateFiles(${2:const char* path},${3:int fileindex})$0"
    },
    "ENUMERATEFILES_WR eel2": {
        "prefix": "WR_EnumerateFiles",
        "scope": "eel2",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "${1:bool} = EnumerateFiles(${2:#retval},${3:\"path\"},${4:int fileindex})$0"
    },
    "REAPER.ENUMERATEFILES_WR lua": {
        "prefix": "reaperwr.EnumerateFiles",
        "scope": "lua",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "${1:local }${2:string} = reaper.EnumerateFiles(${3:string path},${4:integer fileindex})$0"
    },
    "RPR_ENUMERATEFILES_WR python": {
        "prefix": "WR_RPR_EnumerateFiles",
        "scope": "python",
        "description": "List the files in the \"path\" directory. Returns NULL (or empty string, in Lua) when all files have been listed. See EnumerateSubdirectories\n",
        "body": "${1:String} = RPR_EnumerateFiles(${2:String path},${3:Int fileindex})$0"
    },
    "ENUMERATESUBDIRECTORIES_WR c": {
        "prefix": "WR_EnumerateSubdirectories",
        "scope": "c",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "${1:const char*} = EnumerateSubdirectories(${2:const char* path},${3:int subdirindex})$0"
    },
    "ENUMERATESUBDIRECTORIES_WR eel2": {
        "prefix": "WR_EnumerateSubdirectories",
        "scope": "eel2",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "${1:bool} = EnumerateSubdirectories(${2:#retval},${3:\"path\"},${4:int subdirindex})$0"
    },
    "REAPER.ENUMERATESUBDIRECTORIES_WR lua": {
        "prefix": "reaperwr.EnumerateSubdirectories",
        "scope": "lua",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "${1:local }${2:string} = reaper.EnumerateSubdirectories(${3:string path},${4:integer subdirindex})$0"
    },
    "RPR_ENUMERATESUBDIRECTORIES_WR python": {
        "prefix": "WR_RPR_EnumerateSubdirectories",
        "scope": "python",
        "description": "List the subdirectories in the \"path\" directory. Returns NULL (or empty\nstring, in Lua) when all subdirectories have been listed. See EnumerateFiles\n",
        "body": "${1:String} = RPR_EnumerateSubdirectories(${2:String path},${3:Int subdirindex})$0"
    },
    "ENUMPITCHSHIFTMODES_WR c": {
        "prefix": "WR_EnumPitchShiftModes",
        "scope": "c",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "${1:bool} = EnumPitchShiftModes(${2:int mode},${3:const char** strOut})$0"
    },
    "ENUMPITCHSHIFTMODES_WR eel2": {
        "prefix": "WR_EnumPitchShiftModes",
        "scope": "eel2",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "${1:bool} = EnumPitchShiftModes(${2:int mode},${3:#str})$0"
    },
    "REAPER.ENUMPITCHSHIFTMODES_WR lua": {
        "prefix": "reaperwr.EnumPitchShiftModes",
        "scope": "lua",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.EnumPitchShiftModes(${4:integer mode})$0"
    },
    "RPR_ENUMPITCHSHIFTMODES_WR python": {
        "prefix": "WR_RPR_EnumPitchShiftModes",
        "scope": "python",
        "description": "Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported\n",
        "body": "${1:Boolean} = RPR_EnumPitchShiftModes(${2:Int mode},${3:String strOut})$0"
    },
    "ENUMPITCHSHIFTSUBMODES_WR c": {
        "prefix": "WR_EnumPitchShiftSubModes",
        "scope": "c",
        "description": "Returns submode name, or NULL\n",
        "body": "${1:const char*} = EnumPitchShiftSubModes(${2:int mode},${3:int submode})$0"
    },
    "ENUMPITCHSHIFTSUBMODES_WR eel2": {
        "prefix": "WR_EnumPitchShiftSubModes",
        "scope": "eel2",
        "description": "Returns submode name, or NULL\n",
        "body": "${1:bool} = EnumPitchShiftSubModes(${2:#retval},${3:int mode},${4:int submode})$0"
    },
    "REAPER.ENUMPITCHSHIFTSUBMODES_WR lua": {
        "prefix": "reaperwr.EnumPitchShiftSubModes",
        "scope": "lua",
        "description": "Returns submode name, or NULL\n",
        "body": "${1:local }${2:string} = reaper.EnumPitchShiftSubModes(${3:integer mode},${4:integer submode})$0"
    },
    "RPR_ENUMPITCHSHIFTSUBMODES_WR python": {
        "prefix": "WR_RPR_EnumPitchShiftSubModes",
        "scope": "python",
        "description": "Returns submode name, or NULL\n",
        "body": "${1:String} = RPR_EnumPitchShiftSubModes(${2:Int mode},${3:Int submode})$0"
    },
    "ENUMPROJECTMARKERS_WR c": {
        "prefix": "WR_EnumProjectMarkers",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = EnumProjectMarkers(${2:int idx},${3:bool* isrgnOut},${4:double* posOut},${5:double* rgnendOut},${6:const char** nameOut},${7:int* markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS_WR eel2": {
        "prefix": "WR_EnumProjectMarkers",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = EnumProjectMarkers(${2:int idx},${3:bool &isrgn},${4:&pos},${5:&rgnend},${6:#name},${7:int &markrgnindexnumber})$0"
    },
    "REAPER.ENUMPROJECTMARKERS_WR lua": {
        "prefix": "reaperwr.EnumProjectMarkers",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer retval},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:string name},${7:number markrgnindexnumber} = reaper.EnumProjectMarkers(${8:integer idx})$0"
    },
    "RPR_ENUMPROJECTMARKERS_WR python": {
        "prefix": "WR_RPR_EnumProjectMarkers",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int retval},${2:Int idx},${3:Boolean isrgnOut},${4:Float posOut},${5:Float rgnendOut},${6:String nameOut},${7:Int markrgnindexnumberOut} = RPR_EnumProjectMarkers(${8:idx},${9:isrgnOut},${10:posOut},${11:rgnendOut},${12:nameOut},${13:markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS2_WR c": {
        "prefix": "WR_EnumProjectMarkers2",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = EnumProjectMarkers2(${2:ReaProject* proj},${3:int idx},${4:bool* isrgnOut},${5:double* posOut},${6:double* rgnendOut},${7:const char** nameOut},${8:int* markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS2_WR eel2": {
        "prefix": "WR_EnumProjectMarkers2",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = EnumProjectMarkers2(${2:ReaProject proj},${3:int idx},${4:bool &isrgn},${5:&pos},${6:&rgnend},${7:#name},${8:int &markrgnindexnumber})$0"
    },
    "REAPER.ENUMPROJECTMARKERS2_WR lua": {
        "prefix": "reaperwr.EnumProjectMarkers2",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer retval},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:string name},${7:number markrgnindexnumber} = reaper.EnumProjectMarkers2(${8:ReaProject proj},${9:integer idx})$0"
    },
    "RPR_ENUMPROJECTMARKERS2_WR python": {
        "prefix": "WR_RPR_EnumProjectMarkers2",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int retval},${2:ReaProject proj},${3:Int idx},${4:Boolean isrgnOut},${5:Float posOut},${6:Float rgnendOut},${7:String nameOut},${8:Int markrgnindexnumberOut} = RPR_EnumProjectMarkers2(${9:proj},${10:idx},${11:isrgnOut},${12:posOut},${13:rgnendOut},${14:nameOut},${15:markrgnindexnumberOut})$0"
    },
    "ENUMPROJECTMARKERS3_WR c": {
        "prefix": "WR_EnumProjectMarkers3",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = EnumProjectMarkers3(${2:ReaProject* proj},${3:int idx},${4:bool* isrgnOut},${5:double* posOut},${6:double* rgnendOut},${7:const char** nameOut},${8:int* markrgnindexnumberOut},${9:int* colorOut})$0"
    },
    "ENUMPROJECTMARKERS3_WR eel2": {
        "prefix": "WR_EnumProjectMarkers3",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = EnumProjectMarkers3(${2:ReaProject proj},${3:int idx},${4:bool &isrgn},${5:&pos},${6:&rgnend},${7:#name},${8:int &markrgnindexnumber},${9:int &color})$0"
    },
    "REAPER.ENUMPROJECTMARKERS3_WR lua": {
        "prefix": "reaperwr.EnumProjectMarkers3",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer retval},${3:boolean isrgn},${4:number pos},${5:number rgnend},${6:string name},${7:number markrgnindexnumber},${8:number color} = reaper.EnumProjectMarkers3(${9:ReaProject proj},${10:integer idx})$0"
    },
    "RPR_ENUMPROJECTMARKERS3_WR python": {
        "prefix": "WR_RPR_EnumProjectMarkers3",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int retval},${2:ReaProject proj},${3:Int idx},${4:Boolean isrgnOut},${5:Float posOut},${6:Float rgnendOut},${7:String nameOut},${8:Int markrgnindexnumberOut},${9:Int colorOut} = RPR_EnumProjectMarkers3(${10:proj},${11:idx},${12:isrgnOut},${13:posOut},${14:rgnendOut},${15:nameOut},${16:markrgnindexnumberOut},${17:colorOut})$0"
    },
    "ENUMPROJECTS_WR c": {
        "prefix": "WR_EnumProjects",
        "scope": "c",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "${1:ReaProject*} = EnumProjects(${2:int idx},${3:char* projfnOutOptional},${4:int projfnOutOptional_sz})$0"
    },
    "ENUMPROJECTS_WR eel2": {
        "prefix": "WR_EnumProjects",
        "scope": "eel2",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "${1:ReaProject} = EnumProjects(${2:int idx},${3:optional #projfn})$0"
    },
    "REAPER.ENUMPROJECTS_WR lua": {
        "prefix": "reaperwr.EnumProjects",
        "scope": "lua",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "${1:local }${2:ReaProject retval},${3:optional string projfn} = reaper.EnumProjects(${4:integer idx})$0"
    },
    "RPR_ENUMPROJECTS_WR python": {
        "prefix": "WR_RPR_EnumProjects",
        "scope": "python",
        "description": "idx=-1 for current project,projfn can be NULL if not interested in\nfilename. use idx 0x40000000 for currently rendering project, if any.\n",
        "body": "${1:ReaProject retval},${2:Int idx},${3:String projfnOutOptional},${4:Int projfnOutOptional_sz} = RPR_EnumProjects(${5:idx},${6:projfnOutOptional},${7:projfnOutOptional_sz})$0"
    },
    "ENUMPROJEXTSTATE_WR c": {
        "prefix": "WR_EnumProjExtState",
        "scope": "c",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "${1:bool} = EnumProjExtState(${2:ReaProject* proj},${3:const char* extname},${4:int idx},${5:char* keyOutOptional},${6:int keyOutOptional_sz},${7:char* valOutOptional},${8:int valOutOptional_sz})$0"
    },
    "ENUMPROJEXTSTATE_WR eel2": {
        "prefix": "WR_EnumProjExtState",
        "scope": "eel2",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "${1:bool} = EnumProjExtState(${2:ReaProject proj},${3:\"extname\"},${4:int idx},${5:optional #key},${6:optional #val})$0"
    },
    "REAPER.ENUMPROJEXTSTATE_WR lua": {
        "prefix": "reaperwr.EnumProjExtState",
        "scope": "lua",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "${1:local }${2:boolean retval},${3:optional string key},${4:optional string val} = reaper.EnumProjExtState(${5:ReaProject proj},${6:string extname},${7:integer idx})$0"
    },
    "RPR_ENUMPROJEXTSTATE_WR python": {
        "prefix": "WR_RPR_EnumProjExtState",
        "scope": "python",
        "description": "Enumerate the data stored with the project for a specific extname. Returns false when there is no more data. See SetProjExtState, GetProjExtState.\n",
        "body": "${1:Boolean retval},${2:ReaProject proj},${3:String extname},${4:Int idx},${5:String keyOutOptional},${6:Int keyOutOptional_sz},${7:String valOutOptional},${8:Int valOutOptional_sz} = RPR_EnumProjExtState(${9:proj},${10:extname},${11:idx},${12:keyOutOptional},${13:keyOutOptional_sz},${14:valOutOptional},${15:valOutOptional_sz})$0"
    },
    "ENUMREGIONRENDERMATRIX_WR c": {
        "prefix": "WR_EnumRegionRenderMatrix",
        "scope": "c",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "${1:MediaTrack*} = EnumRegionRenderMatrix(${2:ReaProject* proj},${3:int regionindex},${4:int rendertrack})$0"
    },
    "ENUMREGIONRENDERMATRIX_WR eel2": {
        "prefix": "WR_EnumRegionRenderMatrix",
        "scope": "eel2",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "${1:MediaTrack} = EnumRegionRenderMatrix(${2:ReaProject proj},${3:int regionindex},${4:int rendertrack})$0"
    },
    "REAPER.ENUMREGIONRENDERMATRIX_WR lua": {
        "prefix": "reaperwr.EnumRegionRenderMatrix",
        "scope": "lua",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "${1:local }${2:MediaTrack} = reaper.EnumRegionRenderMatrix(${3:ReaProject proj},${4:integer regionindex},${5:integer rendertrack})$0"
    },
    "RPR_ENUMREGIONRENDERMATRIX_WR python": {
        "prefix": "WR_RPR_EnumRegionRenderMatrix",
        "scope": "python",
        "description": "Enumerate which tracks will be rendered within this region when using\nthe region render matrix. When called with rendertrack==0, the function\nreturns the first track that will be rendered (which may be the master\ntrack); rendertrack==1 will return the next track rendered, and so on.\nThe function returns NULL when there are no more tracks that will be\nrendered within this region.\n",
        "body": "${1:MediaTrack} = RPR_EnumRegionRenderMatrix(${2:ReaProject proj},${3:Int regionindex},${4:Int rendertrack})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMES_WR c": {
        "prefix": "WR_EnumTrackMIDIProgramNames",
        "scope": "c",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:bool} = EnumTrackMIDIProgramNames(${2:int track},${3:int programNumber},${4:char* programName},${5:int programName_sz})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMES_WR eel2": {
        "prefix": "WR_EnumTrackMIDIProgramNames",
        "scope": "eel2",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:bool} = EnumTrackMIDIProgramNames(${2:int track},${3:int programNumber},${4:#programName})$0"
    },
    "REAPER.ENUMTRACKMIDIPROGRAMNAMES_WR lua": {
        "prefix": "reaperwr.EnumTrackMIDIProgramNames",
        "scope": "lua",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:local }${2:boolean retval},${3:string programName} = reaper.EnumTrackMIDIProgramNames(${4:integer track},${5:integer programNumber},${6:string programName})$0"
    },
    "RPR_ENUMTRACKMIDIPROGRAMNAMES_WR python": {
        "prefix": "WR_RPR_EnumTrackMIDIProgramNames",
        "scope": "python",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:Boolean retval},${2:Int track},${3:Int programNumber},${4:String programName},${5:Int programName_sz} = RPR_EnumTrackMIDIProgramNames(${6:track},${7:programNumber},${8:programName},${9:programName_sz})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMESEX_WR c": {
        "prefix": "WR_EnumTrackMIDIProgramNamesEx",
        "scope": "c",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:bool} = EnumTrackMIDIProgramNamesEx(${2:ReaProject* proj},${3:MediaTrack* track},${4:int programNumber},${5:char* programName},${6:int programName_sz})$0"
    },
    "ENUMTRACKMIDIPROGRAMNAMESEX_WR eel2": {
        "prefix": "WR_EnumTrackMIDIProgramNamesEx",
        "scope": "eel2",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:bool} = EnumTrackMIDIProgramNamesEx(${2:ReaProject proj},${3:MediaTrack track},${4:int programNumber},${5:#programName})$0"
    },
    "REAPER.ENUMTRACKMIDIPROGRAMNAMESEX_WR lua": {
        "prefix": "reaperwr.EnumTrackMIDIProgramNamesEx",
        "scope": "lua",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:local }${2:boolean retval},${3:string programName} = reaper.EnumTrackMIDIProgramNamesEx(${4:ReaProject proj},${5:MediaTrack track},${6:integer programNumber},${7:string programName})$0"
    },
    "RPR_ENUMTRACKMIDIPROGRAMNAMESEX_WR python": {
        "prefix": "WR_RPR_EnumTrackMIDIProgramNamesEx",
        "scope": "python",
        "description": "returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated\n",
        "body": "${1:Boolean retval},${2:ReaProject proj},${3:MediaTrack track},${4:Int programNumber},${5:String programName},${6:Int programName_sz} = RPR_EnumTrackMIDIProgramNamesEx(${7:proj},${8:track},${9:programNumber},${10:programName},${11:programName_sz})$0"
    },
    "ENVELOPE_EVALUATE_WR c": {
        "prefix": "WR_Envelope_Evaluate",
        "scope": "c",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "${1:int} = Envelope_Evaluate(${2:TrackEnvelope* envelope},${3:double time},${4:double samplerate},${5:int samplesRequested},${6:double* valueOutOptional},${7:double* dVdSOutOptional},${8:double* ddVdSOutOptional},${9:double* dddVdSOutOptional})$0"
    },
    "ENVELOPE_EVALUATE_WR eel2": {
        "prefix": "WR_Envelope_Evaluate",
        "scope": "eel2",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "${1:int} = Envelope_Evaluate(${2:TrackEnvelope envelope},${3:time},${4:samplerate},${5:int samplesRequested},${6:optional &value},${7:optional &dVdS},${8:optional &ddVdS},${9:optional &dddVdS})$0"
    },
    "REAPER.ENVELOPE_EVALUATE_WR lua": {
        "prefix": "reaperwr.Envelope_Evaluate",
        "scope": "lua",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "${1:local }${2:integer retval},${3:optional number value},${4:optional number dVdS},${5:optional number ddVdS},${6:optional number dddVdS} = reaper.Envelope_Evaluate(${7:TrackEnvelope envelope},${8:number time},${9:number samplerate},${10:integer samplesRequested})$0"
    },
    "RPR_ENVELOPE_EVALUATE_WR python": {
        "prefix": "WR_RPR_Envelope_Evaluate",
        "scope": "python",
        "description": "Get the effective envelope value at a given time position.\nsamplesRequested is how long the caller expects until the next call to\nEnvelope_Evaluate (often, the buffer block size). The return value is\nhow many samples beyond that time position that the returned values are\nvalid. dVdS is the change in value per sample (first derivative), ddVdS\nis the second derivative, dddVdS is the third derivative. See GetEnvelopeScalingMode.\n",
        "body": "${1:Int retval},${2:TrackEnvelope envelope},${3:Float time},${4:Float samplerate},${5:Int samplesRequested},${6:Float valueOutOptional},${7:Float dVdSOutOptional},${8:Float ddVdSOutOptional},${9:Float dddVdSOutOptional} = RPR_Envelope_Evaluate(${10:envelope},${11:time},${12:samplerate},${13:samplesRequested},${14:valueOutOptional},${15:dVdSOutOptional},${16:ddVdSOutOptional},${17:dddVdSOutOptional})$0"
    },
    "ENVELOPE_FORMATVALUE_WR c": {
        "prefix": "WR_Envelope_FormatValue",
        "scope": "c",
        "description": "Formats the value of an envelope to a user-readable form\n",
        "body": "${1:void} = Envelope_FormatValue(${2:TrackEnvelope* env},${3:double value},${4:char* bufOut},${5:int bufOut_sz})$0"
    },
    "REAPER.ENVELOPE_FORMATVALUE_WR lua": {
        "prefix": "reaperwr.Envelope_FormatValue",
        "scope": "lua",
        "description": "Formats the value of an envelope to a user-readable form\n",
        "body": "${1:local }${2:string buf} = reaper.Envelope_FormatValue(${3:TrackEnvelope env},${4:number value})$0"
    },
    "RPR_ENVELOPE_FORMATVALUE_WR python": {
        "prefix": "WR_RPR_Envelope_FormatValue",
        "scope": "python",
        "description": "Formats the value of an envelope to a user-readable form\n",
        "body": "${1:TrackEnvelope env},${2:Float value},${3:String bufOut},${4:Int bufOut_sz} = RPR_Envelope_FormatValue(${5:env},${6:value},${7:bufOut},${8:bufOut_sz})$0"
    },
    "ENVELOPE_GETPARENTTAKE_WR c": {
        "prefix": "WR_Envelope_GetParentTake",
        "scope": "c",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:MediaItem_Take*} = Envelope_GetParentTake(${2:TrackEnvelope* env},${3:int* indexOutOptional},${4:int* index2OutOptional})$0"
    },
    "ENVELOPE_GETPARENTTAKE_WR eel2": {
        "prefix": "WR_Envelope_GetParentTake",
        "scope": "eel2",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:MediaItem_Take} = Envelope_GetParentTake(${2:TrackEnvelope env},${3:optional int &index},${4:optional int &index2})$0"
    },
    "REAPER.ENVELOPE_GETPARENTTAKE_WR lua": {
        "prefix": "reaperwr.Envelope_GetParentTake",
        "scope": "lua",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:local }${2:MediaItem_Take retval},${3:optional number index},${4:optional number index2} = reaper.Envelope_GetParentTake(${5:TrackEnvelope env})$0"
    },
    "RPR_ENVELOPE_GETPARENTTAKE_WR python": {
        "prefix": "WR_RPR_Envelope_GetParentTake",
        "scope": "python",
        "description": "If take envelope, gets the take from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:MediaItem_Take retval},${2:TrackEnvelope env},${3:Int indexOutOptional},${4:Int index2OutOptional} = RPR_Envelope_GetParentTake(${5:env},${6:indexOutOptional},${7:index2OutOptional})$0"
    },
    "ENVELOPE_GETPARENTTRACK_WR c": {
        "prefix": "WR_Envelope_GetParentTrack",
        "scope": "c",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:MediaTrack*} = Envelope_GetParentTrack(${2:TrackEnvelope* env},${3:int* indexOutOptional},${4:int* index2OutOptional})$0"
    },
    "ENVELOPE_GETPARENTTRACK_WR eel2": {
        "prefix": "WR_Envelope_GetParentTrack",
        "scope": "eel2",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:MediaTrack} = Envelope_GetParentTrack(${2:TrackEnvelope env},${3:optional int &index},${4:optional int &index2})$0"
    },
    "REAPER.ENVELOPE_GETPARENTTRACK_WR lua": {
        "prefix": "reaperwr.Envelope_GetParentTrack",
        "scope": "lua",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:local }${2:MediaTrack retval},${3:optional number index},${4:optional number index2} = reaper.Envelope_GetParentTrack(${5:TrackEnvelope env})$0"
    },
    "RPR_ENVELOPE_GETPARENTTRACK_WR python": {
        "prefix": "WR_RPR_Envelope_GetParentTrack",
        "scope": "python",
        "description": "If track envelope, gets the track from the envelope. If FX,\nindexOutOptional set to FX index, index2OutOptional set to parameter\nindex, otherwise -1.\n",
        "body": "${1:MediaTrack retval},${2:TrackEnvelope env},${3:Int indexOutOptional},${4:Int index2OutOptional} = RPR_Envelope_GetParentTrack(${5:env},${6:indexOutOptional},${7:index2OutOptional})$0"
    },
    "ENVELOPE_SORTPOINTS_WR c": {
        "prefix": "WR_Envelope_SortPoints",
        "scope": "c",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:bool} = Envelope_SortPoints(${2:TrackEnvelope* envelope})$0"
    },
    "ENVELOPE_SORTPOINTS_WR eel2": {
        "prefix": "WR_Envelope_SortPoints",
        "scope": "eel2",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:bool} = Envelope_SortPoints(${2:TrackEnvelope envelope})$0"
    },
    "REAPER.ENVELOPE_SORTPOINTS_WR lua": {
        "prefix": "reaperwr.Envelope_SortPoints",
        "scope": "lua",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:local }${2:boolean} = reaper.Envelope_SortPoints(${3:TrackEnvelope envelope})$0"
    },
    "RPR_ENVELOPE_SORTPOINTS_WR python": {
        "prefix": "WR_RPR_Envelope_SortPoints",
        "scope": "python",
        "description": "Sort envelope points by time. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:Boolean} = RPR_Envelope_SortPoints(${2:TrackEnvelope envelope})$0"
    },
    "ENVELOPE_SORTPOINTSEX_WR c": {
        "prefix": "WR_Envelope_SortPointsEx",
        "scope": "c",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:bool} = Envelope_SortPointsEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx})$0"
    },
    "ENVELOPE_SORTPOINTSEX_WR eel2": {
        "prefix": "WR_Envelope_SortPointsEx",
        "scope": "eel2",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:bool} = Envelope_SortPointsEx(${2:TrackEnvelope envelope},${3:int autoitem_idx})$0"
    },
    "REAPER.ENVELOPE_SORTPOINTSEX_WR lua": {
        "prefix": "reaperwr.Envelope_SortPointsEx",
        "scope": "lua",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:local }${2:boolean} = reaper.Envelope_SortPointsEx(${3:TrackEnvelope envelope},${4:integer autoitem_idx})$0"
    },
    "RPR_ENVELOPE_SORTPOINTSEX_WR python": {
        "prefix": "WR_RPR_Envelope_SortPointsEx",
        "scope": "python",
        "description": "Sort envelope points by time. autoitem_idx=-1 for the underlying\nenvelope, 0 for the first automation item on the envelope, etc. See SetEnvelopePoint, InsertEnvelopePoint.\n",
        "body": "${1:Boolean} = RPR_Envelope_SortPointsEx(${2:TrackEnvelope envelope},${3:Int autoitem_idx})$0"
    },
    "EXECPROCESS_WR c": {
        "prefix": "WR_ExecProcess",
        "scope": "c",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "${1:const char*} = ExecProcess(${2:const char* cmdline},${3:int timeoutmsec})$0"
    },
    "EXECPROCESS_WR eel2": {
        "prefix": "WR_ExecProcess",
        "scope": "eel2",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "${1:bool} = ExecProcess(${2:#retval},${3:\"cmdline\"},${4:int timeoutmsec})$0"
    },
    "REAPER.EXECPROCESS_WR lua": {
        "prefix": "reaperwr.ExecProcess",
        "scope": "lua",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "${1:local }${2:string} = reaper.ExecProcess(${3:string cmdline},${4:integer timeoutmsec})$0"
    },
    "RPR_EXECPROCESS_WR python": {
        "prefix": "WR_RPR_ExecProcess",
        "scope": "python",
        "description": "Executes command line, returns NULL on total failure, otherwise the\nreturn value, a newline, and then the output of the command. If\ntimeoutmsec is 0, command will be allowed to run indefinitely\n(recommended for large amounts of returned output). timeoutmsec is -1\nfor no wait/terminate, -2 for no wait and minimize\n",
        "body": "${1:String} = RPR_ExecProcess(${2:String cmdline},${3:Int timeoutmsec})$0"
    },
    "FILE_EXISTS_WR c": {
        "prefix": "WR_file_exists",
        "scope": "c",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "${1:bool} = file_exists(${2:const char* path})$0"
    },
    "FILE_EXISTS_WR eel2": {
        "prefix": "WR_file_exists",
        "scope": "eel2",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "${1:bool} = file_exists(${2:\"path\"})$0"
    },
    "REAPER.FILE_EXISTS_WR lua": {
        "prefix": "reaperwr.file_exists",
        "scope": "lua",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "${1:local }${2:boolean} = reaper.file_exists(${3:string path})$0"
    },
    "RPR_FILE_EXISTS_WR python": {
        "prefix": "WR_RPR_file_exists",
        "scope": "python",
        "description": "returns true if path points to a valid, readable file\n",
        "body": "${1:Boolean} = RPR_file_exists(${2:String path})$0"
    },
    "FINDTEMPOTIMESIGMARKER_WR c": {
        "prefix": "WR_FindTempoTimeSigMarker",
        "scope": "c",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "${1:int} = FindTempoTimeSigMarker(${2:ReaProject* project},${3:double time})$0"
    },
    "FINDTEMPOTIMESIGMARKER_WR eel2": {
        "prefix": "WR_FindTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "${1:int} = FindTempoTimeSigMarker(${2:ReaProject project},${3:time})$0"
    },
    "REAPER.FINDTEMPOTIMESIGMARKER_WR lua": {
        "prefix": "reaperwr.FindTempoTimeSigMarker",
        "scope": "lua",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "${1:local }${2:integer} = reaper.FindTempoTimeSigMarker(${3:ReaProject project},${4:number time})$0"
    },
    "RPR_FINDTEMPOTIMESIGMARKER_WR python": {
        "prefix": "WR_RPR_FindTempoTimeSigMarker",
        "scope": "python",
        "description": "Find the tempo/time signature marker that falls at or before this time\nposition (the marker that is in effect as of this time position).\n",
        "body": "${1:Int} = RPR_FindTempoTimeSigMarker(${2:ReaProject project},${3:Float time})$0"
    },
    "FORMAT_TIMESTR_WR c": {
        "prefix": "WR_format_timestr",
        "scope": "c",
        "description": "Format tpos (which is time in seconds) as hh:mm:ss.sss. See format_timestr_pos, format_timestr_len.\n",
        "body": "${1:void} = format_timestr(${2:double tpos},${3:char* buf},${4:int buf_sz})$0"
    },
    "REAPER.FORMAT_TIMESTR_WR lua": {
        "prefix": "reaperwr.format_timestr",
        "scope": "lua",
        "description": "Format tpos (which is time in seconds) as hh:mm:ss.sss. See format_timestr_pos, format_timestr_len.\n",
        "body": "${1:local }${2:string buf} = reaper.format_timestr(${3:number tpos},${4:string buf})$0"
    },
    "RPR_FORMAT_TIMESTR_WR python": {
        "prefix": "WR_RPR_format_timestr",
        "scope": "python",
        "description": "Format tpos (which is time in seconds) as hh:mm:ss.sss. See format_timestr_pos, format_timestr_len.\n",
        "body": "${1:Float tpos},${2:String buf},${3:Int buf_sz} = RPR_format_timestr(${4:tpos},${5:buf},${6:buf_sz})$0"
    },
    "FORMAT_TIMESTR_LEN_WR c": {
        "prefix": "WR_format_timestr_len",
        "scope": "c",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\noffset is start of where the length will be calculated from\n",
        "body": "${1:void} = format_timestr_len(${2:double tpos},${3:char* buf},${4:int buf_sz},${5:double offset},${6:int modeoverride})$0"
    },
    "REAPER.FORMAT_TIMESTR_LEN_WR lua": {
        "prefix": "reaperwr.format_timestr_len",
        "scope": "lua",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\noffset is start of where the length will be calculated from\n",
        "body": "${1:local }${2:string buf} = reaper.format_timestr_len(${3:number tpos},${4:string buf},${5:number offset},${6:integer modeoverride})$0"
    },
    "RPR_FORMAT_TIMESTR_LEN_WR python": {
        "prefix": "WR_RPR_format_timestr_len",
        "scope": "python",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\noffset is start of where the length will be calculated from\n",
        "body": "${1:Float tpos},${2:String buf},${3:Int buf_sz},${4:Float offset},${5:Int modeoverride} = RPR_format_timestr_len(${6:tpos},${7:buf},${8:buf_sz},${9:offset},${10:modeoverride})$0"
    },
    "FORMAT_TIMESTR_POS_WR c": {
        "prefix": "WR_format_timestr_pos",
        "scope": "c",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:void} = format_timestr_pos(${2:double tpos},${3:char* buf},${4:int buf_sz},${5:int modeoverride})$0"
    },
    "REAPER.FORMAT_TIMESTR_POS_WR lua": {
        "prefix": "reaperwr.format_timestr_pos",
        "scope": "lua",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:local }${2:string buf} = reaper.format_timestr_pos(${3:number tpos},${4:string buf},${5:integer modeoverride})$0"
    },
    "RPR_FORMAT_TIMESTR_POS_WR python": {
        "prefix": "WR_RPR_format_timestr_pos",
        "scope": "python",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:Float tpos},${2:String buf},${3:Int buf_sz},${4:Int modeoverride} = RPR_format_timestr_pos(${5:tpos},${6:buf},${7:buf_sz},${8:modeoverride})$0"
    },
    "GENGUID_WR c": {
        "prefix": "WR_genGuid",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = genGuid(${2:GUID* g})$0"
    },
    "REAPER.GENGUID_WR lua": {
        "prefix": "reaperwr.genGuid",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string gGUID} = reaper.genGuid(${3:string gGUID})$0"
    },
    "GET_CONFIG_VAR_STRING_WR c": {
        "prefix": "WR_get_config_var_string",
        "scope": "c",
        "description": "gets ini configuration variable value as string\n",
        "body": "${1:bool} = get_config_var_string(${2:const char* name},${3:char* bufOut},${4:int bufOut_sz})$0"
    },
    "GET_CONFIG_VAR_STRING_WR eel2": {
        "prefix": "WR_get_config_var_string",
        "scope": "eel2",
        "description": "gets ini configuration variable value as string\n",
        "body": "${1:bool} = get_config_var_string(${2:\"name\"},${3:#buf})$0"
    },
    "REAPER.GET_CONFIG_VAR_STRING_WR lua": {
        "prefix": "reaperwr.get_config_var_string",
        "scope": "lua",
        "description": "gets ini configuration variable value as string\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.get_config_var_string(${4:string name})$0"
    },
    "RPR_GET_CONFIG_VAR_STRING_WR python": {
        "prefix": "WR_RPR_get_config_var_string",
        "scope": "python",
        "description": "gets ini configuration variable value as string\n",
        "body": "${1:Boolean retval},${2:String name},${3:String bufOut},${4:Int bufOut_sz} = RPR_get_config_var_string(${5:name},${6:bufOut},${7:bufOut_sz})$0"
    },
    "GET_INI_FILE_WR c": {
        "prefix": "WR_get_ini_file",
        "scope": "c",
        "description": "Get reaper.ini full filename.\n",
        "body": "${1:const char*} = get_ini_file()$0"
    },
    "GET_INI_FILE_WR eel2": {
        "prefix": "WR_get_ini_file",
        "scope": "eel2",
        "description": "Get reaper.ini full filename.\n",
        "body": "${1:bool} = get_ini_file(${2:#retval})$0"
    },
    "REAPER.GET_INI_FILE_WR lua": {
        "prefix": "reaperwr.get_ini_file",
        "scope": "lua",
        "description": "Get reaper.ini full filename.\n",
        "body": "${1:local }${2:string} = reaper.get_ini_file()$0"
    },
    "RPR_GET_INI_FILE_WR python": {
        "prefix": "WR_RPR_get_ini_file",
        "scope": "python",
        "description": "Get reaper.ini full filename.\n",
        "body": "${1:String} = RPR_get_ini_file()$0"
    },
    "GETACTIVETAKE_WR c": {
        "prefix": "WR_GetActiveTake",
        "scope": "c",
        "description": "get the active take in this item\n",
        "body": "${1:MediaItem_Take*} = GetActiveTake(${2:MediaItem* item})$0"
    },
    "GETACTIVETAKE_WR eel2": {
        "prefix": "WR_GetActiveTake",
        "scope": "eel2",
        "description": "get the active take in this item\n",
        "body": "${1:MediaItem_Take} = GetActiveTake(${2:MediaItem item})$0"
    },
    "REAPER.GETACTIVETAKE_WR lua": {
        "prefix": "reaperwr.GetActiveTake",
        "scope": "lua",
        "description": "get the active take in this item\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.GetActiveTake(${3:MediaItem item})$0"
    },
    "RPR_GETACTIVETAKE_WR python": {
        "prefix": "WR_RPR_GetActiveTake",
        "scope": "python",
        "description": "get the active take in this item\n",
        "body": "${1:MediaItem_Take} = RPR_GetActiveTake(${2:MediaItem item})$0"
    },
    "GETALLPROJECTPLAYSTATES_WR c": {
        "prefix": "WR_GetAllProjectPlayStates",
        "scope": "c",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "${1:int} = GetAllProjectPlayStates(${2:ReaProject* ignoreProject})$0"
    },
    "GETALLPROJECTPLAYSTATES_WR eel2": {
        "prefix": "WR_GetAllProjectPlayStates",
        "scope": "eel2",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "${1:int} = GetAllProjectPlayStates(${2:ReaProject ignoreProject})$0"
    },
    "REAPER.GETALLPROJECTPLAYSTATES_WR lua": {
        "prefix": "reaperwr.GetAllProjectPlayStates",
        "scope": "lua",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "${1:local }${2:integer} = reaper.GetAllProjectPlayStates(${3:ReaProject ignoreProject})$0"
    },
    "RPR_GETALLPROJECTPLAYSTATES_WR python": {
        "prefix": "WR_RPR_GetAllProjectPlayStates",
        "scope": "python",
        "description": "returns the bitwise OR of all project play states (1=playing, 2=pause, 4=recording)\n",
        "body": "${1:Int} = RPR_GetAllProjectPlayStates(${2:ReaProject ignoreProject})$0"
    },
    "GETAPPVERSION_WR c": {
        "prefix": "WR_GetAppVersion",
        "scope": "c",
        "description": "\n",
        "body": "${1:const char*} = GetAppVersion()$0"
    },
    "GETAPPVERSION_WR eel2": {
        "prefix": "WR_GetAppVersion",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetAppVersion(${2:#retval})$0"
    },
    "REAPER.GETAPPVERSION_WR lua": {
        "prefix": "reaperwr.GetAppVersion",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string} = reaper.GetAppVersion()$0"
    },
    "RPR_GETAPPVERSION_WR python": {
        "prefix": "WR_RPR_GetAppVersion",
        "scope": "python",
        "description": "\n",
        "body": "${1:String} = RPR_GetAppVersion()$0"
    },
    "GETARMEDCOMMAND_WR c": {
        "prefix": "WR_GetArmedCommand",
        "scope": "c",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "${1:int} = GetArmedCommand(${2:char* secOut},${3:int secOut_sz})$0"
    },
    "GETARMEDCOMMAND_WR eel2": {
        "prefix": "WR_GetArmedCommand",
        "scope": "eel2",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "${1:int} = GetArmedCommand(${2:#sec})$0"
    },
    "REAPER.GETARMEDCOMMAND_WR lua": {
        "prefix": "reaperwr.GetArmedCommand",
        "scope": "lua",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "${1:local }${2:integer retval},${3:string sec} = reaper.GetArmedCommand()$0"
    },
    "RPR_GETARMEDCOMMAND_WR python": {
        "prefix": "WR_RPR_GetArmedCommand",
        "scope": "python",
        "description": "gets the currently armed command and section name (returns 0 if nothing armed). section name is empty-string for main section.\n",
        "body": "${1:Int retval},${2:String secOut},${3:Int secOut_sz} = RPR_GetArmedCommand(${4:secOut},${5:secOut_sz})$0"
    },
    "GETAUDIOACCESSORENDTIME_WR c": {
        "prefix": "WR_GetAudioAccessorEndTime",
        "scope": "c",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "${1:double} = GetAudioAccessorEndTime(${2:AudioAccessor* accessor})$0"
    },
    "GETAUDIOACCESSORENDTIME_WR eel2": {
        "prefix": "WR_GetAudioAccessorEndTime",
        "scope": "eel2",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "${1:double} = GetAudioAccessorEndTime(${2:AudioAccessor accessor})$0"
    },
    "REAPER.GETAUDIOACCESSORENDTIME_WR lua": {
        "prefix": "reaperwr.GetAudioAccessorEndTime",
        "scope": "lua",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "${1:local }${2:number} = reaper.GetAudioAccessorEndTime(${3:AudioAccessor accessor})$0"
    },
    "RPR_GETAUDIOACCESSORENDTIME_WR python": {
        "prefix": "WR_RPR_GetAudioAccessorEndTime",
        "scope": "python",
        "description": "Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorSamples.\n",
        "body": "${1:Float} = RPR_GetAudioAccessorEndTime(${2:AudioAccessor accessor})$0"
    },
    "GETAUDIOACCESSORHASH_WR c": {
        "prefix": "WR_GetAudioAccessorHash",
        "scope": "c",
        "description": "Deprecated. See AudioAccessorStateChanged instead.\n",
        "body": "${1:void} = GetAudioAccessorHash(${2:AudioAccessor* accessor},${3:char* hashNeed128})$0"
    },
    "REAPER.GETAUDIOACCESSORHASH_WR lua": {
        "prefix": "reaperwr.GetAudioAccessorHash",
        "scope": "lua",
        "description": "Deprecated. See AudioAccessorStateChanged instead.\n",
        "body": "${1:local }${2:string hashNeed128} = reaper.GetAudioAccessorHash(${3:AudioAccessor accessor},${4:string hashNeed128})$0"
    },
    "RPR_GETAUDIOACCESSORHASH_WR python": {
        "prefix": "WR_RPR_GetAudioAccessorHash",
        "scope": "python",
        "description": "Deprecated. See AudioAccessorStateChanged instead.\n",
        "body": "${1:AudioAccessor accessor},${2:String hashNeed128} = RPR_GetAudioAccessorHash(${3:accessor},${4:hashNeed128})$0"
    },
    "GETAUDIOACCESSORSAMPLES_WR c": {
        "prefix": "WR_GetAudioAccessorSamples",
        "scope": "c",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "${1:int} = GetAudioAccessorSamples(${2:AudioAccessor* accessor},${3:int samplerate},${4:int numchannels},${5:double starttime_sec},${6:int numsamplesperchannel},${7:double* samplebuffer})$0"
    },
    "GETAUDIOACCESSORSAMPLES_WR eel2": {
        "prefix": "WR_GetAudioAccessorSamples",
        "scope": "eel2",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "${1:int} = GetAudioAccessorSamples(${2:AudioAccessor accessor},${3:int samplerate},${4:int numchannels},${5:starttime_sec},${6:int numsamplesperchannel},${7:buffer_ptr samplebuffer})$0"
    },
    "REAPER.GETAUDIOACCESSORSAMPLES_WR lua": {
        "prefix": "reaperwr.GetAudioAccessorSamples",
        "scope": "lua",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "${1:local }${2:integer} = reaper.GetAudioAccessorSamples(${3:AudioAccessor accessor},${4:integer samplerate},${5:integer numchannels},${6:number starttime_sec},${7:integer numsamplesperchannel},${8:reaper_array samplebuffer})$0"
    },
    "RPR_GETAUDIOACCESSORSAMPLES_WR python": {
        "prefix": "WR_RPR_GetAudioAccessorSamples",
        "scope": "python",
        "description": "Get a block of samples from the audio accessor. Samples are extracted\nimmediately pre-FX, and returned interleaved (first sample of first\nchannel, first sample of second channel...). Returns 0 if no audio, 1 if\naudio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorStartTime, GetAudioAccessorEndTime.\nThis function has special handling in Python, and only returns two\nobjects, the API function return value, and the sample buffer. Example\nusage:\ntr = RPR_GetTrack(0, 0)\naa = RPR_CreateTrackAudioAccessor(tr)\nbuf = list([0]*2*1024) # 2 channels, 1024 samples each, initialized to zero\npos = 0.0\n(ret, buf) = GetAudioAccessorSamples(aa, 44100, 2, pos, 1024, buf)\n# buf now holds the first 2*1024 audio samples from the track.\n# typically GetAudioAccessorSamples() would be called within a loop, increasing pos each time.\n",
        "body": "${1:Int retval},${2:AudioAccessor accessor},${3:Int samplerate},${4:Int numchannels},${5:Float starttime_sec},${6:Int numsamplesperchannel},${7:Float samplebuffer} = RPR_GetAudioAccessorSamples(${8:accessor},${9:samplerate},${10:numchannels},${11:starttime_sec},${12:numsamplesperchannel},${13:samplebuffer})$0"
    },
    "GETAUDIOACCESSORSTARTTIME_WR c": {
        "prefix": "WR_GetAudioAccessorStartTime",
        "scope": "c",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:double} = GetAudioAccessorStartTime(${2:AudioAccessor* accessor})$0"
    },
    "GETAUDIOACCESSORSTARTTIME_WR eel2": {
        "prefix": "WR_GetAudioAccessorStartTime",
        "scope": "eel2",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:double} = GetAudioAccessorStartTime(${2:AudioAccessor accessor})$0"
    },
    "REAPER.GETAUDIOACCESSORSTARTTIME_WR lua": {
        "prefix": "reaperwr.GetAudioAccessorStartTime",
        "scope": "lua",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:local }${2:number} = reaper.GetAudioAccessorStartTime(${3:AudioAccessor accessor})$0"
    },
    "RPR_GETAUDIOACCESSORSTARTTIME_WR python": {
        "prefix": "WR_RPR_GetAudioAccessorStartTime",
        "scope": "python",
        "description": "Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, AudioAccessorStateChanged, GetAudioAccessorEndTime, GetAudioAccessorSamples.\n",
        "body": "${1:Float} = RPR_GetAudioAccessorStartTime(${2:AudioAccessor accessor})$0"
    },
    "GETAUDIODEVICEINFO_WR c": {
        "prefix": "WR_GetAudioDeviceInfo",
        "scope": "c",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "${1:bool} = GetAudioDeviceInfo(${2:const char* attribute},${3:char* desc},${4:int desc_sz})$0"
    },
    "GETAUDIODEVICEINFO_WR eel2": {
        "prefix": "WR_GetAudioDeviceInfo",
        "scope": "eel2",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "${1:bool} = GetAudioDeviceInfo(${2:\"attribute\"},${3:#desc})$0"
    },
    "REAPER.GETAUDIODEVICEINFO_WR lua": {
        "prefix": "reaperwr.GetAudioDeviceInfo",
        "scope": "lua",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "${1:local }${2:boolean retval},${3:string desc} = reaper.GetAudioDeviceInfo(${4:string attribute},${5:string desc})$0"
    },
    "RPR_GETAUDIODEVICEINFO_WR python": {
        "prefix": "WR_RPR_GetAudioDeviceInfo",
        "scope": "python",
        "description": "get information about the currently open audio device. attribute can be\nMODE, IDENT_IN, IDENT_OUT, BSIZE, SRATE, BPS. returns false if unknown\nattribute or device not open.\n",
        "body": "${1:Boolean retval},${2:String attribute},${3:String desc},${4:Int desc_sz} = RPR_GetAudioDeviceInfo(${5:attribute},${6:desc},${7:desc_sz})$0"
    },
    "GETCONFIGWANTSDOCK_WR c": {
        "prefix": "WR_GetConfigWantsDock",
        "scope": "c",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "${1:int} = GetConfigWantsDock(${2:const char* ident_str})$0"
    },
    "GETCONFIGWANTSDOCK_WR eel2": {
        "prefix": "WR_GetConfigWantsDock",
        "scope": "eel2",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "${1:int} = GetConfigWantsDock(${2:\"ident_str\"})$0"
    },
    "REAPER.GETCONFIGWANTSDOCK_WR lua": {
        "prefix": "reaperwr.GetConfigWantsDock",
        "scope": "lua",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "${1:local }${2:integer} = reaper.GetConfigWantsDock(${3:string ident_str})$0"
    },
    "RPR_GETCONFIGWANTSDOCK_WR python": {
        "prefix": "WR_RPR_GetConfigWantsDock",
        "scope": "python",
        "description": "gets the dock ID desired by ident_str, if any\n",
        "body": "${1:Int} = RPR_GetConfigWantsDock(${2:String ident_str})$0"
    },
    "GETCURRENTPROJECTINLOADSAVE_WR c": {
        "prefix": "WR_GetCurrentProjectInLoadSave",
        "scope": "c",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "${1:ReaProject*} = GetCurrentProjectInLoadSave()$0"
    },
    "GETCURRENTPROJECTINLOADSAVE_WR eel2": {
        "prefix": "WR_GetCurrentProjectInLoadSave",
        "scope": "eel2",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "${1:ReaProject} = GetCurrentProjectInLoadSave()$0"
    },
    "REAPER.GETCURRENTPROJECTINLOADSAVE_WR lua": {
        "prefix": "reaperwr.GetCurrentProjectInLoadSave",
        "scope": "lua",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "${1:local }${2:ReaProject} = reaper.GetCurrentProjectInLoadSave()$0"
    },
    "RPR_GETCURRENTPROJECTINLOADSAVE_WR python": {
        "prefix": "WR_RPR_GetCurrentProjectInLoadSave",
        "scope": "python",
        "description": "returns current project if in load/save (usually only used from project_config_extension_t)\n",
        "body": "${1:ReaProject} = RPR_GetCurrentProjectInLoadSave()$0"
    },
    "GETCURSORCONTEXT_WR c": {
        "prefix": "WR_GetCursorContext",
        "scope": "c",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "${1:int} = GetCursorContext()$0"
    },
    "GETCURSORCONTEXT_WR eel2": {
        "prefix": "WR_GetCursorContext",
        "scope": "eel2",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "${1:int} = GetCursorContext()$0"
    },
    "REAPER.GETCURSORCONTEXT_WR lua": {
        "prefix": "reaperwr.GetCursorContext",
        "scope": "lua",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "${1:local }${2:integer} = reaper.GetCursorContext()$0"
    },
    "RPR_GETCURSORCONTEXT_WR python": {
        "prefix": "WR_RPR_GetCursorContext",
        "scope": "python",
        "description": "return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown\n",
        "body": "${1:Int} = RPR_GetCursorContext()$0"
    },
    "GETCURSORCONTEXT2_WR c": {
        "prefix": "WR_GetCursorContext2",
        "scope": "c",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "${1:int} = GetCursorContext2(${2:bool want_last_valid})$0"
    },
    "GETCURSORCONTEXT2_WR eel2": {
        "prefix": "WR_GetCursorContext2",
        "scope": "eel2",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "${1:int} = GetCursorContext2(${2:bool want_last_valid})$0"
    },
    "REAPER.GETCURSORCONTEXT2_WR lua": {
        "prefix": "reaperwr.GetCursorContext2",
        "scope": "lua",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "${1:local }${2:integer} = reaper.GetCursorContext2(${3:boolean want_last_valid})$0"
    },
    "RPR_GETCURSORCONTEXT2_WR python": {
        "prefix": "WR_RPR_GetCursorContext2",
        "scope": "python",
        "description": "0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)\n",
        "body": "${1:Int} = RPR_GetCursorContext2(${2:Boolean want_last_valid})$0"
    },
    "GETCURSORPOSITION_WR c": {
        "prefix": "WR_GetCursorPosition",
        "scope": "c",
        "description": "edit cursor position\n",
        "body": "${1:double} = GetCursorPosition()$0"
    },
    "GETCURSORPOSITION_WR eel2": {
        "prefix": "WR_GetCursorPosition",
        "scope": "eel2",
        "description": "edit cursor position\n",
        "body": "${1:double} = GetCursorPosition()$0"
    },
    "REAPER.GETCURSORPOSITION_WR lua": {
        "prefix": "reaperwr.GetCursorPosition",
        "scope": "lua",
        "description": "edit cursor position\n",
        "body": "${1:local }${2:number} = reaper.GetCursorPosition()$0"
    },
    "RPR_GETCURSORPOSITION_WR python": {
        "prefix": "WR_RPR_GetCursorPosition",
        "scope": "python",
        "description": "edit cursor position\n",
        "body": "${1:Float} = RPR_GetCursorPosition()$0"
    },
    "GETCURSORPOSITIONEX_WR c": {
        "prefix": "WR_GetCursorPositionEx",
        "scope": "c",
        "description": "edit cursor position\n",
        "body": "${1:double} = GetCursorPositionEx(${2:ReaProject* proj})$0"
    },
    "GETCURSORPOSITIONEX_WR eel2": {
        "prefix": "WR_GetCursorPositionEx",
        "scope": "eel2",
        "description": "edit cursor position\n",
        "body": "${1:double} = GetCursorPositionEx(${2:ReaProject proj})$0"
    },
    "REAPER.GETCURSORPOSITIONEX_WR lua": {
        "prefix": "reaperwr.GetCursorPositionEx",
        "scope": "lua",
        "description": "edit cursor position\n",
        "body": "${1:local }${2:number} = reaper.GetCursorPositionEx(${3:ReaProject proj})$0"
    },
    "RPR_GETCURSORPOSITIONEX_WR python": {
        "prefix": "WR_RPR_GetCursorPositionEx",
        "scope": "python",
        "description": "edit cursor position\n",
        "body": "${1:Float} = RPR_GetCursorPositionEx(${2:ReaProject proj})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR_WR c": {
        "prefix": "WR_GetDisplayedMediaItemColor",
        "scope": "c",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "${1:int} = GetDisplayedMediaItemColor(${2:MediaItem* item})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR_WR eel2": {
        "prefix": "WR_GetDisplayedMediaItemColor",
        "scope": "eel2",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "${1:int} = GetDisplayedMediaItemColor(${2:MediaItem item})$0"
    },
    "REAPER.GETDISPLAYEDMEDIAITEMCOLOR_WR lua": {
        "prefix": "reaperwr.GetDisplayedMediaItemColor",
        "scope": "lua",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "${1:local }${2:integer} = reaper.GetDisplayedMediaItemColor(${3:MediaItem item})$0"
    },
    "RPR_GETDISPLAYEDMEDIAITEMCOLOR_WR python": {
        "prefix": "WR_RPR_GetDisplayedMediaItemColor",
        "scope": "python",
        "description": "see GetDisplayedMediaItemColor2.\n",
        "body": "${1:Int} = RPR_GetDisplayedMediaItemColor(${2:MediaItem item})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR2_WR c": {
        "prefix": "WR_GetDisplayedMediaItemColor2",
        "scope": "c",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "${1:int} = GetDisplayedMediaItemColor2(${2:MediaItem* item},${3:MediaItem_Take* take})$0"
    },
    "GETDISPLAYEDMEDIAITEMCOLOR2_WR eel2": {
        "prefix": "WR_GetDisplayedMediaItemColor2",
        "scope": "eel2",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "${1:int} = GetDisplayedMediaItemColor2(${2:MediaItem item},${3:MediaItem_Take take})$0"
    },
    "REAPER.GETDISPLAYEDMEDIAITEMCOLOR2_WR lua": {
        "prefix": "reaperwr.GetDisplayedMediaItemColor2",
        "scope": "lua",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "${1:local }${2:integer} = reaper.GetDisplayedMediaItemColor2(${3:MediaItem item},${4:MediaItem_Take take})$0"
    },
    "RPR_GETDISPLAYEDMEDIAITEMCOLOR2_WR python": {
        "prefix": "WR_RPR_GetDisplayedMediaItemColor2",
        "scope": "python",
        "description": "Returns the custom take, item, or track color that is used (according to\nthe user preference) to color the media item. The returned color is OS\ndependent|0x01000000 (i.e. ColorToNative(r,g,b)|0x01000000), so a return\nof zero means \"no color\", not black.\n",
        "body": "${1:Int} = RPR_GetDisplayedMediaItemColor2(${2:MediaItem item},${3:MediaItem_Take take})$0"
    },
    "GETENVELOPEINFO_VALUE_WR c": {
        "prefix": "WR_GetEnvelopeInfo_Value",
        "scope": "c",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "${1:double} = GetEnvelopeInfo_Value(${2:TrackEnvelope* tr},${3|const char* parmname,\"I_TCPY\",\"I_TCPH\",\"I_TCPY_USED\",\"I_TCPH_USED\",\"P_TRACK\",\"P_ITEM\",\"P_TAKE\"|})$0"
    },
    "GETENVELOPEINFO_VALUE_WR eel2": {
        "prefix": "WR_GetEnvelopeInfo_Value",
        "scope": "eel2",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "${1:double} = GetEnvelopeInfo_Value(${2:TrackEnvelope tr},${3:\"parmname\"})$0"
    },
    "REAPER.GETENVELOPEINFO_VALUE_WR lua": {
        "prefix": "reaperwr.GetEnvelopeInfo_Value",
        "scope": "lua",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "${1:local }${2:number} = reaper.GetEnvelopeInfo_Value(${3:TrackEnvelope tr},${4|string parmname,\"I_TCPY\",\"I_TCPH\",\"I_TCPY_USED\",\"I_TCPH_USED\",\"P_TRACK\",\"P_ITEM\",\"P_TAKE\"|})$0"
    },
    "RPR_GETENVELOPEINFO_VALUE_WR python": {
        "prefix": "WR_RPR_GetEnvelopeInfo_Value",
        "scope": "python",
        "description": "Gets an envelope numerical-value attribute:\nI_TCPY : int *, Y offset of envelope relative to parent track (may be\nseparate lane or overlap with track contents)I_TCPH : int *, visible\nheight of envelopeI_TCPY_USED : int *, Y offset of envelope relative to\nparent track, exclusive of paddingI_TCPH_USED : int *, visible height of\nenvelope, exclusive of paddingP_TRACK : MediaTrack *, parent track\npointer (if any)P_ITEM : MediaItem *, parent item pointer (if any)P_TAKE\n: MediaItem_Take *, parent take pointer (if any)\n",
        "body": "${1:Float} = RPR_GetEnvelopeInfo_Value(${2:TrackEnvelope tr},${3|String parmname,\"I_TCPY\",\"I_TCPH\",\"I_TCPY_USED\",\"I_TCPH_USED\",\"P_TRACK\",\"P_ITEM\",\"P_TAKE\"|})$0"
    },
    "GETENVELOPENAME_WR c": {
        "prefix": "WR_GetEnvelopeName",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = GetEnvelopeName(${2:TrackEnvelope* env},${3:char* bufOut},${4:int bufOut_sz})$0"
    },
    "GETENVELOPENAME_WR eel2": {
        "prefix": "WR_GetEnvelopeName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetEnvelopeName(${2:TrackEnvelope env},${3:#buf})$0"
    },
    "REAPER.GETENVELOPENAME_WR lua": {
        "prefix": "reaperwr.GetEnvelopeName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.GetEnvelopeName(${4:TrackEnvelope env})$0"
    },
    "RPR_GETENVELOPENAME_WR python": {
        "prefix": "WR_RPR_GetEnvelopeName",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope env},${3:String bufOut},${4:Int bufOut_sz} = RPR_GetEnvelopeName(${5:env},${6:bufOut},${7:bufOut_sz})$0"
    },
    "GETENVELOPEPOINT_WR c": {
        "prefix": "WR_GetEnvelopePoint",
        "scope": "c",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "${1:bool} = GetEnvelopePoint(${2:TrackEnvelope* envelope},${3:int ptidx},${4:double* timeOutOptional},${5:double* valueOutOptional},${6:int* shapeOutOptional},${7:double* tensionOutOptional},${8:bool* selectedOutOptional})$0"
    },
    "GETENVELOPEPOINT_WR eel2": {
        "prefix": "WR_GetEnvelopePoint",
        "scope": "eel2",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "${1:bool} = GetEnvelopePoint(${2:TrackEnvelope envelope},${3:int ptidx},${4:optional &time},${5:optional &value},${6:optional int &shape},${7:optional &tension},${8:optional bool &selected})$0"
    },
    "REAPER.GETENVELOPEPOINT_WR lua": {
        "prefix": "reaperwr.GetEnvelopePoint",
        "scope": "lua",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean retval},${3:optional number time},${4:optional number value},${5:optional number shape},${6:optional number tension},${7:optional boolean selected} = reaper.GetEnvelopePoint(${8:TrackEnvelope envelope},${9:integer ptidx})$0"
    },
    "RPR_GETENVELOPEPOINT_WR python": {
        "prefix": "WR_RPR_GetEnvelopePoint",
        "scope": "python",
        "description": "Get the attributes of an envelope point. See GetEnvelopePointEx.\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope envelope},${3:Int ptidx},${4:Float timeOutOptional},${5:Float valueOutOptional},${6:Int shapeOutOptional},${7:Float tensionOutOptional},${8:Boolean selectedOutOptional} = RPR_GetEnvelopePoint(${9:envelope},${10:ptidx},${11:timeOutOptional},${12:valueOutOptional},${13:shapeOutOptional},${14:tensionOutOptional},${15:selectedOutOptional})$0"
    },
    "GETENVELOPEPOINTBYTIME_WR c": {
        "prefix": "WR_GetEnvelopePointByTime",
        "scope": "c",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "${1:int} = GetEnvelopePointByTime(${2:TrackEnvelope* envelope},${3:double time})$0"
    },
    "GETENVELOPEPOINTBYTIME_WR eel2": {
        "prefix": "WR_GetEnvelopePointByTime",
        "scope": "eel2",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "${1:int} = GetEnvelopePointByTime(${2:TrackEnvelope envelope},${3:time})$0"
    },
    "REAPER.GETENVELOPEPOINTBYTIME_WR lua": {
        "prefix": "reaperwr.GetEnvelopePointByTime",
        "scope": "lua",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "${1:local }${2:integer} = reaper.GetEnvelopePointByTime(${3:TrackEnvelope envelope},${4:number time})$0"
    },
    "RPR_GETENVELOPEPOINTBYTIME_WR python": {
        "prefix": "WR_RPR_GetEnvelopePointByTime",
        "scope": "python",
        "description": "Returns the envelope point at or immediately prior to the given time position. See GetEnvelopePointByTimeEx.\n",
        "body": "${1:Int} = RPR_GetEnvelopePointByTime(${2:TrackEnvelope envelope},${3:Float time})$0"
    },
    "GETENVELOPEPOINTBYTIMEEX_WR c": {
        "prefix": "WR_GetEnvelopePointByTimeEx",
        "scope": "c",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:int} = GetEnvelopePointByTimeEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx},${4:double time})$0"
    },
    "GETENVELOPEPOINTBYTIMEEX_WR eel2": {
        "prefix": "WR_GetEnvelopePointByTimeEx",
        "scope": "eel2",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:int} = GetEnvelopePointByTimeEx(${2:TrackEnvelope envelope},${3:int autoitem_idx},${4:time})$0"
    },
    "REAPER.GETENVELOPEPOINTBYTIMEEX_WR lua": {
        "prefix": "reaperwr.GetEnvelopePointByTimeEx",
        "scope": "lua",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:local }${2:integer} = reaper.GetEnvelopePointByTimeEx(${3:TrackEnvelope envelope},${4:integer autoitem_idx},${5:number time})$0"
    },
    "RPR_GETENVELOPEPOINTBYTIMEEX_WR python": {
        "prefix": "WR_RPR_GetEnvelopePointByTimeEx",
        "scope": "python",
        "description": "Returns the envelope point at or immediately prior to the given time position.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee GetEnvelopePointEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:Int} = RPR_GetEnvelopePointByTimeEx(${2:TrackEnvelope envelope},${3:Int autoitem_idx},${4:Float time})$0"
    },
    "GETENVELOPEPOINTEX_WR c": {
        "prefix": "WR_GetEnvelopePointEx",
        "scope": "c",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = GetEnvelopePointEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx},${4:int ptidx},${5:double* timeOutOptional},${6:double* valueOutOptional},${7:int* shapeOutOptional},${8:double* tensionOutOptional},${9:bool* selectedOutOptional})$0"
    },
    "GETENVELOPEPOINTEX_WR eel2": {
        "prefix": "WR_GetEnvelopePointEx",
        "scope": "eel2",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = GetEnvelopePointEx(${2:TrackEnvelope envelope},${3:int autoitem_idx},${4:int ptidx},${5:optional &time},${6:optional &value},${7:optional int &shape},${8:optional &tension},${9:optional bool &selected})$0"
    },
    "REAPER.GETENVELOPEPOINTEX_WR lua": {
        "prefix": "reaperwr.GetEnvelopePointEx",
        "scope": "lua",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean retval},${3:optional number time},${4:optional number value},${5:optional number shape},${6:optional number tension},${7:optional boolean selected} = reaper.GetEnvelopePointEx(${8:TrackEnvelope envelope},${9:integer autoitem_idx},${10:integer ptidx})$0"
    },
    "RPR_GETENVELOPEPOINTEX_WR python": {
        "prefix": "WR_RPR_GetEnvelopePointEx",
        "scope": "python",
        "description": "Get the attributes of an envelope point.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, SetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope envelope},${3:Int autoitem_idx},${4:Int ptidx},${5:Float timeOutOptional},${6:Float valueOutOptional},${7:Int shapeOutOptional},${8:Float tensionOutOptional},${9:Boolean selectedOutOptional} = RPR_GetEnvelopePointEx(${10:envelope},${11:autoitem_idx},${12:ptidx},${13:timeOutOptional},${14:valueOutOptional},${15:shapeOutOptional},${16:tensionOutOptional},${17:selectedOutOptional})$0"
    },
    "GETENVELOPESCALINGMODE_WR c": {
        "prefix": "WR_GetEnvelopeScalingMode",
        "scope": "c",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "${1:int} = GetEnvelopeScalingMode(${2:TrackEnvelope* env})$0"
    },
    "GETENVELOPESCALINGMODE_WR eel2": {
        "prefix": "WR_GetEnvelopeScalingMode",
        "scope": "eel2",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "${1:int} = GetEnvelopeScalingMode(${2:TrackEnvelope env})$0"
    },
    "REAPER.GETENVELOPESCALINGMODE_WR lua": {
        "prefix": "reaperwr.GetEnvelopeScalingMode",
        "scope": "lua",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "${1:local }${2:integer} = reaper.GetEnvelopeScalingMode(${3:TrackEnvelope env})$0"
    },
    "RPR_GETENVELOPESCALINGMODE_WR python": {
        "prefix": "WR_RPR_GetEnvelopeScalingMode",
        "scope": "python",
        "description": "Returns the envelope scaling mode: 0=no scaling, 1=fader scaling. All\nAPI functions deal with raw envelope point values, to convert raw\nfrom/to scaled values see ScaleFromEnvelopeMode, ScaleToEnvelopeMode.\n",
        "body": "${1:Int} = RPR_GetEnvelopeScalingMode(${2:TrackEnvelope env})$0"
    },
    "GETENVELOPESTATECHUNK_WR c": {
        "prefix": "WR_GetEnvelopeStateChunk",
        "scope": "c",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = GetEnvelopeStateChunk(${2:TrackEnvelope* env},${3:char* strNeedBig},${4:int strNeedBig_sz},${5:bool isundoOptional})$0"
    },
    "GETENVELOPESTATECHUNK_WR eel2": {
        "prefix": "WR_GetEnvelopeStateChunk",
        "scope": "eel2",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = GetEnvelopeStateChunk(${2:TrackEnvelope env},${3:#str},${4:bool isundo})$0"
    },
    "REAPER.GETENVELOPESTATECHUNK_WR lua": {
        "prefix": "reaperwr.GetEnvelopeStateChunk",
        "scope": "lua",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetEnvelopeStateChunk(${4:TrackEnvelope env},${5:string str},${6:boolean isundo})$0"
    },
    "RPR_GETENVELOPESTATECHUNK_WR python": {
        "prefix": "WR_RPR_GetEnvelopeStateChunk",
        "scope": "python",
        "description": "Gets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope env},${3:String strNeedBig},${4:Int strNeedBig_sz},${5:Boolean isundoOptional} = RPR_GetEnvelopeStateChunk(${6:env},${7:strNeedBig},${8:strNeedBig_sz},${9:isundoOptional})$0"
    },
    "GETEXEPATH_WR c": {
        "prefix": "WR_GetExePath",
        "scope": "c",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "${1:const char*} = GetExePath()$0"
    },
    "GETEXEPATH_WR eel2": {
        "prefix": "WR_GetExePath",
        "scope": "eel2",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "${1:bool} = GetExePath(${2:#retval})$0"
    },
    "REAPER.GETEXEPATH_WR lua": {
        "prefix": "reaperwr.GetExePath",
        "scope": "lua",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "${1:local }${2:string} = reaper.GetExePath()$0"
    },
    "RPR_GETEXEPATH_WR python": {
        "prefix": "WR_RPR_GetExePath",
        "scope": "python",
        "description": "returns path of REAPER.exe (not including EXE), i.e. C:\\Program Files\\REAPER\n",
        "body": "${1:String} = RPR_GetExePath()$0"
    },
    "GETEXTSTATE_WR c": {
        "prefix": "WR_GetExtState",
        "scope": "c",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "${1:const char*} = GetExtState(${2:const char* section},${3:const char* key})$0"
    },
    "GETEXTSTATE_WR eel2": {
        "prefix": "WR_GetExtState",
        "scope": "eel2",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "${1:bool} = GetExtState(${2:#retval},${3:\"section\"},${4:\"key\"})$0"
    },
    "REAPER.GETEXTSTATE_WR lua": {
        "prefix": "reaperwr.GetExtState",
        "scope": "lua",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "${1:local }${2:string} = reaper.GetExtState(${3:string section},${4:string key})$0"
    },
    "RPR_GETEXTSTATE_WR python": {
        "prefix": "WR_RPR_GetExtState",
        "scope": "python",
        "description": "Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.\n",
        "body": "${1:String} = RPR_GetExtState(${2:String section},${3:String key})$0"
    },
    "GETFOCUSEDFX_WR c": {
        "prefix": "WR_GetFocusedFX",
        "scope": "c",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "${1:int} = GetFocusedFX(${2:int* tracknumberOut},${3:int* itemnumberOut},${4:int* fxnumberOut})$0"
    },
    "GETFOCUSEDFX_WR eel2": {
        "prefix": "WR_GetFocusedFX",
        "scope": "eel2",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "${1:int} = GetFocusedFX(${2:int &tracknumber},${3:int &itemnumber},${4:int &fxnumber})$0"
    },
    "REAPER.GETFOCUSEDFX_WR lua": {
        "prefix": "reaperwr.GetFocusedFX",
        "scope": "lua",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "${1:local }${2:integer retval},${3:number tracknumber},${4:number itemnumber},${5:number fxnumber} = reaper.GetFocusedFX()$0"
    },
    "RPR_GETFOCUSEDFX_WR python": {
        "prefix": "WR_RPR_GetFocusedFX",
        "scope": "python",
        "description": "Returns 1 if a track FX window has focus or was the last focused and\nstill open, 2 if an item FX window has focus or was the last focused and\nstill open, 0 if no FX window has focus. tracknumber==0 means the\nmaster track, 1 means track 1, etc. itemnumber and fxnumber are\nzero-based. If item FX, fxnumber will have the high word be the take\nindex, the low word the FX index. See GetLastTouchedFX.\n",
        "body": "${1:Int retval},${2:Int tracknumberOut},${3:Int itemnumberOut},${4:Int fxnumberOut} = RPR_GetFocusedFX(${5:tracknumberOut},${6:itemnumberOut},${7:fxnumberOut})$0"
    },
    "GETFREEDISKSPACEFORRECORDPATH_WR c": {
        "prefix": "WR_GetFreeDiskSpaceForRecordPath",
        "scope": "c",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "${1:int} = GetFreeDiskSpaceForRecordPath(${2:ReaProject* proj},${3:int pathidx})$0"
    },
    "GETFREEDISKSPACEFORRECORDPATH_WR eel2": {
        "prefix": "WR_GetFreeDiskSpaceForRecordPath",
        "scope": "eel2",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "${1:int} = GetFreeDiskSpaceForRecordPath(${2:ReaProject proj},${3:int pathidx})$0"
    },
    "REAPER.GETFREEDISKSPACEFORRECORDPATH_WR lua": {
        "prefix": "reaperwr.GetFreeDiskSpaceForRecordPath",
        "scope": "lua",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "${1:local }${2:integer} = reaper.GetFreeDiskSpaceForRecordPath(${3:ReaProject proj},${4:integer pathidx})$0"
    },
    "RPR_GETFREEDISKSPACEFORRECORDPATH_WR python": {
        "prefix": "WR_RPR_GetFreeDiskSpaceForRecordPath",
        "scope": "python",
        "description": "returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.\n",
        "body": "${1:Int} = RPR_GetFreeDiskSpaceForRecordPath(${2:ReaProject proj},${3:Int pathidx})$0"
    },
    "GETFXENVELOPE_WR c": {
        "prefix": "WR_GetFXEnvelope",
        "scope": "c",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:TrackEnvelope*} = GetFXEnvelope(${2:MediaTrack* track},${3:int fxindex},${4:int parameterindex},${5:bool create})$0"
    },
    "GETFXENVELOPE_WR eel2": {
        "prefix": "WR_GetFXEnvelope",
        "scope": "eel2",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:TrackEnvelope} = GetFXEnvelope(${2:MediaTrack track},${3:int fxindex},${4:int parameterindex},${5:bool create})$0"
    },
    "REAPER.GETFXENVELOPE_WR lua": {
        "prefix": "reaperwr.GetFXEnvelope",
        "scope": "lua",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetFXEnvelope(${3:MediaTrack track},${4:integer fxindex},${5:integer parameterindex},${6:boolean create})$0"
    },
    "RPR_GETFXENVELOPE_WR python": {
        "prefix": "WR_RPR_GetFXEnvelope",
        "scope": "python",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:TrackEnvelope} = RPR_GetFXEnvelope(${2:MediaTrack track},${3:Int fxindex},${4:Int parameterindex},${5:Boolean create})$0"
    },
    "GETGLOBALAUTOMATIONOVERRIDE_WR c": {
        "prefix": "WR_GetGlobalAutomationOverride",
        "scope": "c",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "${1:int} = GetGlobalAutomationOverride()$0"
    },
    "GETGLOBALAUTOMATIONOVERRIDE_WR eel2": {
        "prefix": "WR_GetGlobalAutomationOverride",
        "scope": "eel2",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "${1:int} = GetGlobalAutomationOverride()$0"
    },
    "REAPER.GETGLOBALAUTOMATIONOVERRIDE_WR lua": {
        "prefix": "reaperwr.GetGlobalAutomationOverride",
        "scope": "lua",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "${1:local }${2:integer} = reaper.GetGlobalAutomationOverride()$0"
    },
    "RPR_GETGLOBALAUTOMATIONOVERRIDE_WR python": {
        "prefix": "WR_RPR_GetGlobalAutomationOverride",
        "scope": "python",
        "description": "return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass\n",
        "body": "${1:Int} = RPR_GetGlobalAutomationOverride()$0"
    },
    "GETHZOOMLEVEL_WR c": {
        "prefix": "WR_GetHZoomLevel",
        "scope": "c",
        "description": "returns pixels/second\n",
        "body": "${1:double} = GetHZoomLevel()$0"
    },
    "GETHZOOMLEVEL_WR eel2": {
        "prefix": "WR_GetHZoomLevel",
        "scope": "eel2",
        "description": "returns pixels/second\n",
        "body": "${1:double} = GetHZoomLevel()$0"
    },
    "REAPER.GETHZOOMLEVEL_WR lua": {
        "prefix": "reaperwr.GetHZoomLevel",
        "scope": "lua",
        "description": "returns pixels/second\n",
        "body": "${1:local }${2:number} = reaper.GetHZoomLevel()$0"
    },
    "RPR_GETHZOOMLEVEL_WR python": {
        "prefix": "WR_RPR_GetHZoomLevel",
        "scope": "python",
        "description": "returns pixels/second\n",
        "body": "${1:Float} = RPR_GetHZoomLevel()$0"
    },
    "GETINPUTCHANNELNAME_WR c": {
        "prefix": "WR_GetInputChannelName",
        "scope": "c",
        "description": "\n",
        "body": "${1:const char*} = GetInputChannelName(${2:int channelIndex})$0"
    },
    "GETINPUTCHANNELNAME_WR eel2": {
        "prefix": "WR_GetInputChannelName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetInputChannelName(${2:#retval},${3:int channelIndex})$0"
    },
    "REAPER.GETINPUTCHANNELNAME_WR lua": {
        "prefix": "reaperwr.GetInputChannelName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string} = reaper.GetInputChannelName(${3:integer channelIndex})$0"
    },
    "RPR_GETINPUTCHANNELNAME_WR python": {
        "prefix": "WR_RPR_GetInputChannelName",
        "scope": "python",
        "description": "\n",
        "body": "${1:String} = RPR_GetInputChannelName(${2:Int channelIndex})$0"
    },
    "GETINPUTOUTPUTLATENCY_WR c": {
        "prefix": "WR_GetInputOutputLatency",
        "scope": "c",
        "description": "Gets the audio device input/output latency in samples\n",
        "body": "${1:void} = GetInputOutputLatency(${2:int* inputlatencyOut},${3:int* outputLatencyOut})$0"
    },
    "REAPER.GETINPUTOUTPUTLATENCY_WR lua": {
        "prefix": "reaperwr.GetInputOutputLatency",
        "scope": "lua",
        "description": "Gets the audio device input/output latency in samples\n",
        "body": "${1:local }${2:number inputlatency},${3:number outputLatency} = reaper.GetInputOutputLatency()$0"
    },
    "RPR_GETINPUTOUTPUTLATENCY_WR python": {
        "prefix": "WR_RPR_GetInputOutputLatency",
        "scope": "python",
        "description": "Gets the audio device input/output latency in samples\n",
        "body": "${1:Int inputlatencyOut},${2:Int outputLatencyOut} = RPR_GetInputOutputLatency(${3:inputlatencyOut},${4:outputLatencyOut})$0"
    },
    "GETITEMEDITINGTIME2_WR c": {
        "prefix": "WR_GetItemEditingTime2",
        "scope": "c",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "${1:double} = GetItemEditingTime2(${2:PCM_source** which_itemOut},${3:int* flagsOut})$0"
    },
    "GETITEMEDITINGTIME2_WR eel2": {
        "prefix": "WR_GetItemEditingTime2",
        "scope": "eel2",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "${1:double} = GetItemEditingTime2(${2:PCM_source &which_item},${3:int &flags})$0"
    },
    "REAPER.GETITEMEDITINGTIME2_WR lua": {
        "prefix": "reaperwr.GetItemEditingTime2",
        "scope": "lua",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "${1:local }${2:number},${3:PCM_source which_item},${4:number flags} = reaper.GetItemEditingTime2()$0"
    },
    "RPR_GETITEMEDITINGTIME2_WR python": {
        "prefix": "WR_RPR_GetItemEditingTime2",
        "scope": "python",
        "description": "returns time of relevant edit, set which_item to the pcm_source (if\napplicable), flags (if specified) will be set to 1 for edge resizing, 2\nfor fade change, 4 for item move, 8 for item slip edit (edit cursor time\nor start of item)\n",
        "body": "${1:Float retval},${2:PCM_source* which_itemOut},${3:Int flagsOut} = RPR_GetItemEditingTime2(${4:which_itemOut},${5:flagsOut})$0"
    },
    "GETITEMFROMPOINT_WR c": {
        "prefix": "WR_GetItemFromPoint",
        "scope": "c",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "${1:MediaItem*} = GetItemFromPoint(${2:int screen_x},${3:int screen_y},${4:bool allow_locked},${5:MediaItem_Take** takeOutOptional})$0"
    },
    "GETITEMFROMPOINT_WR eel2": {
        "prefix": "WR_GetItemFromPoint",
        "scope": "eel2",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "${1:MediaItem} = GetItemFromPoint(${2:int screen_x},${3:int screen_y},${4:bool allow_locked},${5:MediaItem_Take &take})$0"
    },
    "REAPER.GETITEMFROMPOINT_WR lua": {
        "prefix": "reaperwr.GetItemFromPoint",
        "scope": "lua",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "${1:local }${2:MediaItem},${3:MediaItem_Take take} = reaper.GetItemFromPoint(${4:integer screen_x},${5:integer screen_y},${6:boolean allow_locked})$0"
    },
    "RPR_GETITEMFROMPOINT_WR python": {
        "prefix": "WR_RPR_GetItemFromPoint",
        "scope": "python",
        "description": "Returns the first item at the screen coordinates specified. If\nallow_locked is false, locked items are ignored. If takeOutOptional\nspecified, returns the take hit.\n",
        "body": "${1:MediaItem} = RPR_GetItemFromPoint(${2:Int screen_x},${3:Int screen_y},${4:Boolean allow_locked},${5:MediaItem_Take* takeOutOptional})$0"
    },
    "GETITEMPROJECTCONTEXT_WR c": {
        "prefix": "WR_GetItemProjectContext",
        "scope": "c",
        "description": "\n",
        "body": "${1:ReaProject*} = GetItemProjectContext(${2:MediaItem* item})$0"
    },
    "GETITEMPROJECTCONTEXT_WR eel2": {
        "prefix": "WR_GetItemProjectContext",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:ReaProject} = GetItemProjectContext(${2:MediaItem item})$0"
    },
    "REAPER.GETITEMPROJECTCONTEXT_WR lua": {
        "prefix": "reaperwr.GetItemProjectContext",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:ReaProject} = reaper.GetItemProjectContext(${3:MediaItem item})$0"
    },
    "RPR_GETITEMPROJECTCONTEXT_WR python": {
        "prefix": "WR_RPR_GetItemProjectContext",
        "scope": "python",
        "description": "\n",
        "body": "${1:ReaProject} = RPR_GetItemProjectContext(${2:MediaItem item})$0"
    },
    "GETITEMSTATECHUNK_WR c": {
        "prefix": "WR_GetItemStateChunk",
        "scope": "c",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = GetItemStateChunk(${2:MediaItem* item},${3:char* strNeedBig},${4:int strNeedBig_sz},${5:bool isundoOptional})$0"
    },
    "GETITEMSTATECHUNK_WR eel2": {
        "prefix": "WR_GetItemStateChunk",
        "scope": "eel2",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = GetItemStateChunk(${2:MediaItem item},${3:#str},${4:bool isundo})$0"
    },
    "REAPER.GETITEMSTATECHUNK_WR lua": {
        "prefix": "reaperwr.GetItemStateChunk",
        "scope": "lua",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetItemStateChunk(${4:MediaItem item},${5:string str},${6:boolean isundo})$0"
    },
    "RPR_GETITEMSTATECHUNK_WR python": {
        "prefix": "WR_RPR_GetItemStateChunk",
        "scope": "python",
        "description": "Gets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:Boolean retval},${2:MediaItem item},${3:String strNeedBig},${4:Int strNeedBig_sz},${5:Boolean isundoOptional} = RPR_GetItemStateChunk(${6:item},${7:strNeedBig},${8:strNeedBig_sz},${9:isundoOptional})$0"
    },
    "GETLASTCOLORTHEMEFILE_WR c": {
        "prefix": "WR_GetLastColorThemeFile",
        "scope": "c",
        "description": "\n",
        "body": "${1:const char*} = GetLastColorThemeFile()$0"
    },
    "GETLASTCOLORTHEMEFILE_WR eel2": {
        "prefix": "WR_GetLastColorThemeFile",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetLastColorThemeFile(${2:#retval})$0"
    },
    "REAPER.GETLASTCOLORTHEMEFILE_WR lua": {
        "prefix": "reaperwr.GetLastColorThemeFile",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string} = reaper.GetLastColorThemeFile()$0"
    },
    "RPR_GETLASTCOLORTHEMEFILE_WR python": {
        "prefix": "WR_RPR_GetLastColorThemeFile",
        "scope": "python",
        "description": "\n",
        "body": "${1:String} = RPR_GetLastColorThemeFile()$0"
    },
    "GETLASTMARKERANDCURREGION_WR c": {
        "prefix": "WR_GetLastMarkerAndCurRegion",
        "scope": "c",
        "description": "Get the last project marker before time, and/or the project region that\nincludes time. markeridx and regionidx are returned not necessarily as\nthe displayed marker/region index, but as the index that can be passed\nto EnumProjectMarkers. Either or both of markeridx and regionidx may be\nNULL. See EnumProjectMarkers.\n",
        "body": "${1:void} = GetLastMarkerAndCurRegion(${2:ReaProject* proj},${3:double time},${4:int* markeridxOut},${5:int* regionidxOut})$0"
    },
    "REAPER.GETLASTMARKERANDCURREGION_WR lua": {
        "prefix": "reaperwr.GetLastMarkerAndCurRegion",
        "scope": "lua",
        "description": "Get the last project marker before time, and/or the project region that\nincludes time. markeridx and regionidx are returned not necessarily as\nthe displayed marker/region index, but as the index that can be passed\nto EnumProjectMarkers. Either or both of markeridx and regionidx may be\nNULL. See EnumProjectMarkers.\n",
        "body": "${1:local }${2:number markeridx},${3:number regionidx} = reaper.GetLastMarkerAndCurRegion(${4:ReaProject proj},${5:number time})$0"
    },
    "RPR_GETLASTMARKERANDCURREGION_WR python": {
        "prefix": "WR_RPR_GetLastMarkerAndCurRegion",
        "scope": "python",
        "description": "Get the last project marker before time, and/or the project region that\nincludes time. markeridx and regionidx are returned not necessarily as\nthe displayed marker/region index, but as the index that can be passed\nto EnumProjectMarkers. Either or both of markeridx and regionidx may be\nNULL. See EnumProjectMarkers.\n",
        "body": "${1:ReaProject proj},${2:Float time},${3:Int markeridxOut},${4:Int regionidxOut} = RPR_GetLastMarkerAndCurRegion(${5:proj},${6:time},${7:markeridxOut},${8:regionidxOut})$0"
    },
    "GETLASTTOUCHEDFX_WR c": {
        "prefix": "WR_GetLastTouchedFX",
        "scope": "c",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "${1:bool} = GetLastTouchedFX(${2:int* tracknumberOut},${3:int* fxnumberOut},${4:int* paramnumberOut})$0"
    },
    "GETLASTTOUCHEDFX_WR eel2": {
        "prefix": "WR_GetLastTouchedFX",
        "scope": "eel2",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "${1:bool} = GetLastTouchedFX(${2:int &tracknumber},${3:int &fxnumber},${4:int &paramnumber})$0"
    },
    "REAPER.GETLASTTOUCHEDFX_WR lua": {
        "prefix": "reaperwr.GetLastTouchedFX",
        "scope": "lua",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "${1:local }${2:boolean retval},${3:number tracknumber},${4:number fxnumber},${5:number paramnumber} = reaper.GetLastTouchedFX()$0"
    },
    "RPR_GETLASTTOUCHEDFX_WR python": {
        "prefix": "WR_RPR_GetLastTouchedFX",
        "scope": "python",
        "description": "Returns true if the last touched FX parameter is valid, false otherwise.\nThe low word of tracknumber is the 1-based track index -- 0 means the\nmaster track, 1 means track 1, etc. If the high word of tracknumber is\nnonzero, it refers to the 1-based item index (1 is the first item on the\ntrack, etc). For track FX, the low 24 bits of fxnumber refer to the FX\nindex in the chain, and if the next 8 bits are 01, then the FX is record\nFX. For item FX, the low word defines the FX index in the chain, and\nthe high word defines the take number. See GetFocusedFX.\n",
        "body": "${1:Boolean retval},${2:Int tracknumberOut},${3:Int fxnumberOut},${4:Int paramnumberOut} = RPR_GetLastTouchedFX(${5:tracknumberOut},${6:fxnumberOut},${7:paramnumberOut})$0"
    },
    "GETLASTTOUCHEDTRACK_WR c": {
        "prefix": "WR_GetLastTouchedTrack",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaTrack*} = GetLastTouchedTrack()$0"
    },
    "GETLASTTOUCHEDTRACK_WR eel2": {
        "prefix": "WR_GetLastTouchedTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaTrack} = GetLastTouchedTrack()$0"
    },
    "REAPER.GETLASTTOUCHEDTRACK_WR lua": {
        "prefix": "reaperwr.GetLastTouchedTrack",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetLastTouchedTrack()$0"
    },
    "RPR_GETLASTTOUCHEDTRACK_WR python": {
        "prefix": "WR_RPR_GetLastTouchedTrack",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaTrack} = RPR_GetLastTouchedTrack()$0"
    },
    "GETMAINHWND_WR c": {
        "prefix": "WR_GetMainHwnd",
        "scope": "c",
        "description": "\n",
        "body": "${1:HWND} = GetMainHwnd()$0"
    },
    "GETMAINHWND_WR eel2": {
        "prefix": "WR_GetMainHwnd",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:HWND} = GetMainHwnd()$0"
    },
    "REAPER.GETMAINHWND_WR lua": {
        "prefix": "reaperwr.GetMainHwnd",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:HWND} = reaper.GetMainHwnd()$0"
    },
    "RPR_GETMAINHWND_WR python": {
        "prefix": "WR_RPR_GetMainHwnd",
        "scope": "python",
        "description": "\n",
        "body": "${1:HWND} = RPR_GetMainHwnd()$0"
    },
    "GETMASTERMUTESOLOFLAGS_WR c": {
        "prefix": "WR_GetMasterMuteSoloFlags",
        "scope": "c",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "${1:int} = GetMasterMuteSoloFlags()$0"
    },
    "GETMASTERMUTESOLOFLAGS_WR eel2": {
        "prefix": "WR_GetMasterMuteSoloFlags",
        "scope": "eel2",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "${1:int} = GetMasterMuteSoloFlags()$0"
    },
    "REAPER.GETMASTERMUTESOLOFLAGS_WR lua": {
        "prefix": "reaperwr.GetMasterMuteSoloFlags",
        "scope": "lua",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "${1:local }${2:integer} = reaper.GetMasterMuteSoloFlags()$0"
    },
    "RPR_GETMASTERMUTESOLOFLAGS_WR python": {
        "prefix": "WR_RPR_GetMasterMuteSoloFlags",
        "scope": "python",
        "description": "&1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.\n",
        "body": "${1:Int} = RPR_GetMasterMuteSoloFlags()$0"
    },
    "GETMASTERTRACK_WR c": {
        "prefix": "WR_GetMasterTrack",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaTrack*} = GetMasterTrack(${2:ReaProject* proj})$0"
    },
    "GETMASTERTRACK_WR eel2": {
        "prefix": "WR_GetMasterTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaTrack} = GetMasterTrack(${2:ReaProject proj})$0"
    },
    "REAPER.GETMASTERTRACK_WR lua": {
        "prefix": "reaperwr.GetMasterTrack",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetMasterTrack(${3:ReaProject proj})$0"
    },
    "RPR_GETMASTERTRACK_WR python": {
        "prefix": "WR_RPR_GetMasterTrack",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaTrack} = RPR_GetMasterTrack(${2:ReaProject proj})$0"
    },
    "GETMASTERTRACKVISIBILITY_WR c": {
        "prefix": "WR_GetMasterTrackVisibility",
        "scope": "c",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "${1:int} = GetMasterTrackVisibility()$0"
    },
    "GETMASTERTRACKVISIBILITY_WR eel2": {
        "prefix": "WR_GetMasterTrackVisibility",
        "scope": "eel2",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "${1:int} = GetMasterTrackVisibility()$0"
    },
    "REAPER.GETMASTERTRACKVISIBILITY_WR lua": {
        "prefix": "reaperwr.GetMasterTrackVisibility",
        "scope": "lua",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "${1:local }${2:integer} = reaper.GetMasterTrackVisibility()$0"
    },
    "RPR_GETMASTERTRACKVISIBILITY_WR python": {
        "prefix": "WR_RPR_GetMasterTrackVisibility",
        "scope": "python",
        "description": "returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.\n",
        "body": "${1:Int} = RPR_GetMasterTrackVisibility()$0"
    },
    "GETMAXMIDIINPUTS_WR c": {
        "prefix": "WR_GetMaxMidiInputs",
        "scope": "c",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "${1:int} = GetMaxMidiInputs()$0"
    },
    "GETMAXMIDIINPUTS_WR eel2": {
        "prefix": "WR_GetMaxMidiInputs",
        "scope": "eel2",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "${1:int} = GetMaxMidiInputs()$0"
    },
    "REAPER.GETMAXMIDIINPUTS_WR lua": {
        "prefix": "reaperwr.GetMaxMidiInputs",
        "scope": "lua",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "${1:local }${2:integer} = reaper.GetMaxMidiInputs()$0"
    },
    "RPR_GETMAXMIDIINPUTS_WR python": {
        "prefix": "WR_RPR_GetMaxMidiInputs",
        "scope": "python",
        "description": "returns max dev for midi inputs/outputs\n",
        "body": "${1:Int} = RPR_GetMaxMidiInputs()$0"
    },
    "GETMAXMIDIOUTPUTS_WR c": {
        "prefix": "WR_GetMaxMidiOutputs",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = GetMaxMidiOutputs()$0"
    },
    "GETMAXMIDIOUTPUTS_WR eel2": {
        "prefix": "WR_GetMaxMidiOutputs",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = GetMaxMidiOutputs()$0"
    },
    "REAPER.GETMAXMIDIOUTPUTS_WR lua": {
        "prefix": "reaperwr.GetMaxMidiOutputs",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.GetMaxMidiOutputs()$0"
    },
    "RPR_GETMAXMIDIOUTPUTS_WR python": {
        "prefix": "WR_RPR_GetMaxMidiOutputs",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_GetMaxMidiOutputs()$0"
    },
    "GETMEDIAITEM_WR c": {
        "prefix": "WR_GetMediaItem",
        "scope": "c",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaItem*} = GetMediaItem(${2:ReaProject* proj},${3:int itemidx})$0"
    },
    "GETMEDIAITEM_WR eel2": {
        "prefix": "WR_GetMediaItem",
        "scope": "eel2",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaItem} = GetMediaItem(${2:ReaProject proj},${3:int itemidx})$0"
    },
    "REAPER.GETMEDIAITEM_WR lua": {
        "prefix": "reaperwr.GetMediaItem",
        "scope": "lua",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:local }${2:MediaItem} = reaper.GetMediaItem(${3:ReaProject proj},${4:integer itemidx})$0"
    },
    "RPR_GETMEDIAITEM_WR python": {
        "prefix": "WR_RPR_GetMediaItem",
        "scope": "python",
        "description": "get an item from a project by item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaItem} = RPR_GetMediaItem(${2:ReaProject proj},${3:Int itemidx})$0"
    },
    "GETMEDIAITEM_TRACK_WR c": {
        "prefix": "WR_GetMediaItem_Track",
        "scope": "c",
        "description": "Get parent track of media item\n",
        "body": "${1:MediaTrack*} = GetMediaItem_Track(${2:MediaItem* item})$0"
    },
    "GETMEDIAITEM_TRACK_WR eel2": {
        "prefix": "WR_GetMediaItem_Track",
        "scope": "eel2",
        "description": "Get parent track of media item\n",
        "body": "${1:MediaTrack} = GetMediaItem_Track(${2:MediaItem item})$0"
    },
    "REAPER.GETMEDIAITEM_TRACK_WR lua": {
        "prefix": "reaperwr.GetMediaItem_Track",
        "scope": "lua",
        "description": "Get parent track of media item\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetMediaItem_Track(${3:MediaItem item})$0"
    },
    "RPR_GETMEDIAITEM_TRACK_WR python": {
        "prefix": "WR_RPR_GetMediaItem_Track",
        "scope": "python",
        "description": "Get parent track of media item\n",
        "body": "${1:MediaTrack} = RPR_GetMediaItem_Track(${2:MediaItem item})$0"
    },
    "GETMEDIAITEMINFO_VALUE_WR c": {
        "prefix": "WR_GetMediaItemInfo_Value",
        "scope": "c",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "${1:double} = GetMediaItemInfo_Value(${2:MediaItem* item},${3|const char* parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\",\"P_TRACK\"|})$0"
    },
    "GETMEDIAITEMINFO_VALUE_WR eel2": {
        "prefix": "WR_GetMediaItemInfo_Value",
        "scope": "eel2",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "${1:double} = GetMediaItemInfo_Value(${2:MediaItem item},${3:\"parmname\"})$0"
    },
    "REAPER.GETMEDIAITEMINFO_VALUE_WR lua": {
        "prefix": "reaperwr.GetMediaItemInfo_Value",
        "scope": "lua",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "${1:local }${2:number} = reaper.GetMediaItemInfo_Value(${3:MediaItem item},${4|string parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\",\"P_TRACK\"|})$0"
    },
    "RPR_GETMEDIAITEMINFO_VALUE_WR python": {
        "prefix": "WR_RPR_GetMediaItemInfo_Value",
        "scope": "python",
        "description": "Get media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\nP_TRACK : MediaTrack * (read-only)\n",
        "body": "${1:Float} = RPR_GetMediaItemInfo_Value(${2:MediaItem item},${3|String parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\",\"P_TRACK\"|})$0"
    },
    "GETMEDIAITEMNUMTAKES_WR c": {
        "prefix": "WR_GetMediaItemNumTakes",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = GetMediaItemNumTakes(${2:MediaItem* item})$0"
    },
    "GETMEDIAITEMNUMTAKES_WR eel2": {
        "prefix": "WR_GetMediaItemNumTakes",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = GetMediaItemNumTakes(${2:MediaItem item})$0"
    },
    "REAPER.GETMEDIAITEMNUMTAKES_WR lua": {
        "prefix": "reaperwr.GetMediaItemNumTakes",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.GetMediaItemNumTakes(${3:MediaItem item})$0"
    },
    "RPR_GETMEDIAITEMNUMTAKES_WR python": {
        "prefix": "WR_RPR_GetMediaItemNumTakes",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_GetMediaItemNumTakes(${2:MediaItem item})$0"
    },
    "GETMEDIAITEMTAKE_WR c": {
        "prefix": "WR_GetMediaItemTake",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaItem_Take*} = GetMediaItemTake(${2:MediaItem* item},${3:int tk})$0"
    },
    "GETMEDIAITEMTAKE_WR eel2": {
        "prefix": "WR_GetMediaItemTake",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaItem_Take} = GetMediaItemTake(${2:MediaItem item},${3:int tk})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_WR lua": {
        "prefix": "reaperwr.GetMediaItemTake",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.GetMediaItemTake(${3:MediaItem item},${4:integer tk})$0"
    },
    "RPR_GETMEDIAITEMTAKE_WR python": {
        "prefix": "WR_RPR_GetMediaItemTake",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaItem_Take} = RPR_GetMediaItemTake(${2:MediaItem item},${3:Int tk})$0"
    },
    "GETMEDIAITEMTAKE_ITEM_WR c": {
        "prefix": "WR_GetMediaItemTake_Item",
        "scope": "c",
        "description": "Get parent item of media item take\n",
        "body": "${1:MediaItem*} = GetMediaItemTake_Item(${2:MediaItem_Take* take})$0"
    },
    "GETMEDIAITEMTAKE_ITEM_WR eel2": {
        "prefix": "WR_GetMediaItemTake_Item",
        "scope": "eel2",
        "description": "Get parent item of media item take\n",
        "body": "${1:MediaItem} = GetMediaItemTake_Item(${2:MediaItem_Take take})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_ITEM_WR lua": {
        "prefix": "reaperwr.GetMediaItemTake_Item",
        "scope": "lua",
        "description": "Get parent item of media item take\n",
        "body": "${1:local }${2:MediaItem} = reaper.GetMediaItemTake_Item(${3:MediaItem_Take take})$0"
    },
    "RPR_GETMEDIAITEMTAKE_ITEM_WR python": {
        "prefix": "WR_RPR_GetMediaItemTake_Item",
        "scope": "python",
        "description": "Get parent item of media item take\n",
        "body": "${1:MediaItem} = RPR_GetMediaItemTake_Item(${2:MediaItem_Take take})$0"
    },
    "GETMEDIAITEMTAKE_PEAKS_WR c": {
        "prefix": "WR_GetMediaItemTake_Peaks",
        "scope": "c",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:int} = GetMediaItemTake_Peaks(${2:MediaItem_Take* take},${3:double peakrate},${4:double starttime},${5:int numchannels},${6:int numsamplesperchannel},${7:int want_extra_type},${8:double* buf})$0"
    },
    "GETMEDIAITEMTAKE_PEAKS_WR eel2": {
        "prefix": "WR_GetMediaItemTake_Peaks",
        "scope": "eel2",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:int} = GetMediaItemTake_Peaks(${2:MediaItem_Take take},${3:peakrate},${4:starttime},${5:int numchannels},${6:int numsamplesperchannel},${7:int want_extra_type},${8:buffer_ptr buf})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_PEAKS_WR lua": {
        "prefix": "reaperwr.GetMediaItemTake_Peaks",
        "scope": "lua",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:local }${2:integer} = reaper.GetMediaItemTake_Peaks(${3:MediaItem_Take take},${4:number peakrate},${5:number starttime},${6:integer numchannels},${7:integer numsamplesperchannel},${8:integer want_extra_type},${9:reaper_array buf})$0"
    },
    "RPR_GETMEDIAITEMTAKE_PEAKS_WR python": {
        "prefix": "WR_RPR_GetMediaItemTake_Peaks",
        "scope": "python",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:Int retval},${2:MediaItem_Take take},${3:Float peakrate},${4:Float starttime},${5:Int numchannels},${6:Int numsamplesperchannel},${7:Int want_extra_type},${8:Float buf} = RPR_GetMediaItemTake_Peaks(${9:take},${10:peakrate},${11:starttime},${12:numchannels},${13:numsamplesperchannel},${14:want_extra_type},${15:buf})$0"
    },
    "GETMEDIAITEMTAKE_SOURCE_WR c": {
        "prefix": "WR_GetMediaItemTake_Source",
        "scope": "c",
        "description": "Get media source of media item take\n",
        "body": "${1:PCM_source*} = GetMediaItemTake_Source(${2:MediaItem_Take* take})$0"
    },
    "GETMEDIAITEMTAKE_SOURCE_WR eel2": {
        "prefix": "WR_GetMediaItemTake_Source",
        "scope": "eel2",
        "description": "Get media source of media item take\n",
        "body": "${1:PCM_source} = GetMediaItemTake_Source(${2:MediaItem_Take take})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_SOURCE_WR lua": {
        "prefix": "reaperwr.GetMediaItemTake_Source",
        "scope": "lua",
        "description": "Get media source of media item take\n",
        "body": "${1:local }${2:PCM_source} = reaper.GetMediaItemTake_Source(${3:MediaItem_Take take})$0"
    },
    "RPR_GETMEDIAITEMTAKE_SOURCE_WR python": {
        "prefix": "WR_RPR_GetMediaItemTake_Source",
        "scope": "python",
        "description": "Get media source of media item take\n",
        "body": "${1:PCM_source} = RPR_GetMediaItemTake_Source(${2:MediaItem_Take take})$0"
    },
    "GETMEDIAITEMTAKE_TRACK_WR c": {
        "prefix": "WR_GetMediaItemTake_Track",
        "scope": "c",
        "description": "Get parent track of media item take\n",
        "body": "${1:MediaTrack*} = GetMediaItemTake_Track(${2:MediaItem_Take* take})$0"
    },
    "GETMEDIAITEMTAKE_TRACK_WR eel2": {
        "prefix": "WR_GetMediaItemTake_Track",
        "scope": "eel2",
        "description": "Get parent track of media item take\n",
        "body": "${1:MediaTrack} = GetMediaItemTake_Track(${2:MediaItem_Take take})$0"
    },
    "REAPER.GETMEDIAITEMTAKE_TRACK_WR lua": {
        "prefix": "reaperwr.GetMediaItemTake_Track",
        "scope": "lua",
        "description": "Get parent track of media item take\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetMediaItemTake_Track(${3:MediaItem_Take take})$0"
    },
    "RPR_GETMEDIAITEMTAKE_TRACK_WR python": {
        "prefix": "WR_RPR_GetMediaItemTake_Track",
        "scope": "python",
        "description": "Get parent track of media item take\n",
        "body": "${1:MediaTrack} = RPR_GetMediaItemTake_Track(${2:MediaItem_Take take})$0"
    },
    "GETMEDIAITEMTAKEBYGUID_WR c": {
        "prefix": "WR_GetMediaItemTakeByGUID",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaItem_Take*} = GetMediaItemTakeByGUID(${2:ReaProject* project},${3:const GUID* guid})$0"
    },
    "GETMEDIAITEMTAKEBYGUID_WR eel2": {
        "prefix": "WR_GetMediaItemTakeByGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaItem_Take} = GetMediaItemTakeByGUID(${2:ReaProject project},${3:\"guidGUID\"})$0"
    },
    "REAPER.GETMEDIAITEMTAKEBYGUID_WR lua": {
        "prefix": "reaperwr.GetMediaItemTakeByGUID",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.GetMediaItemTakeByGUID(${3:ReaProject project},${4:string guidGUID})$0"
    },
    "RPR_GETMEDIAITEMTAKEBYGUID_WR python": {
        "prefix": "WR_RPR_GetMediaItemTakeByGUID",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaItem_Take} = RPR_GetMediaItemTakeByGUID(${2:ReaProject project},${3:const GUID guid})$0"
    },
    "GETMEDIAITEMTAKEINFO_VALUE_WR c": {
        "prefix": "WR_GetMediaItemTakeInfo_Value",
        "scope": "c",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "${1:double} = GetMediaItemTakeInfo_Value(${2:MediaItem_Take* take},${3|const char* parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\",\"P_TRACK\",\"P_ITEM\",\"P_SOURCE\"|})$0"
    },
    "GETMEDIAITEMTAKEINFO_VALUE_WR eel2": {
        "prefix": "WR_GetMediaItemTakeInfo_Value",
        "scope": "eel2",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "${1:double} = GetMediaItemTakeInfo_Value(${2:MediaItem_Take take},${3:\"parmname\"})$0"
    },
    "REAPER.GETMEDIAITEMTAKEINFO_VALUE_WR lua": {
        "prefix": "reaperwr.GetMediaItemTakeInfo_Value",
        "scope": "lua",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "${1:local }${2:number} = reaper.GetMediaItemTakeInfo_Value(${3:MediaItem_Take take},${4|string parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\",\"P_TRACK\",\"P_ITEM\",\"P_SOURCE\"|})$0"
    },
    "RPR_GETMEDIAITEMTAKEINFO_VALUE_WR python": {
        "prefix": "WR_RPR_GetMediaItemTakeInfo_Value",
        "scope": "python",
        "description": "Get media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\nP_TRACK : pointer to MediaTrack (read-only)\nP_ITEM : pointer to MediaItem (read-only)\nP_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n",
        "body": "${1:Float} = RPR_GetMediaItemTakeInfo_Value(${2:MediaItem_Take take},${3|String parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\",\"P_TRACK\",\"P_ITEM\",\"P_SOURCE\"|})$0"
    },
    "GETMEDIAITEMTRACK_WR c": {
        "prefix": "WR_GetMediaItemTrack",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaTrack*} = GetMediaItemTrack(${2:MediaItem* item})$0"
    },
    "GETMEDIAITEMTRACK_WR eel2": {
        "prefix": "WR_GetMediaItemTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaTrack} = GetMediaItemTrack(${2:MediaItem item})$0"
    },
    "REAPER.GETMEDIAITEMTRACK_WR lua": {
        "prefix": "reaperwr.GetMediaItemTrack",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetMediaItemTrack(${3:MediaItem item})$0"
    },
    "RPR_GETMEDIAITEMTRACK_WR python": {
        "prefix": "WR_RPR_GetMediaItemTrack",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaTrack} = RPR_GetMediaItemTrack(${2:MediaItem item})$0"
    },
    "GETMEDIASOURCEFILENAME_WR c": {
        "prefix": "WR_GetMediaSourceFileName",
        "scope": "c",
        "description": "Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename. See GetMediaSourceParent.\n",
        "body": "${1:void} = GetMediaSourceFileName(${2:PCM_source* source},${3:char* filenamebuf},${4:int filenamebuf_sz})$0"
    },
    "REAPER.GETMEDIASOURCEFILENAME_WR lua": {
        "prefix": "reaperwr.GetMediaSourceFileName",
        "scope": "lua",
        "description": "Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename. See GetMediaSourceParent.\n",
        "body": "${1:local }${2:string filenamebuf} = reaper.GetMediaSourceFileName(${3:PCM_source source},${4:string filenamebuf})$0"
    },
    "RPR_GETMEDIASOURCEFILENAME_WR python": {
        "prefix": "WR_RPR_GetMediaSourceFileName",
        "scope": "python",
        "description": "Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename. See GetMediaSourceParent.\n",
        "body": "${1:PCM_source source},${2:String filenamebuf},${3:Int filenamebuf_sz} = RPR_GetMediaSourceFileName(${4:source},${5:filenamebuf},${6:filenamebuf_sz})$0"
    },
    "GETMEDIASOURCELENGTH_WR c": {
        "prefix": "WR_GetMediaSourceLength",
        "scope": "c",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "${1:double} = GetMediaSourceLength(${2:PCM_source* source},${3:bool* lengthIsQNOut})$0"
    },
    "GETMEDIASOURCELENGTH_WR eel2": {
        "prefix": "WR_GetMediaSourceLength",
        "scope": "eel2",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "${1:double} = GetMediaSourceLength(${2:PCM_source source},${3:bool &lengthIsQN})$0"
    },
    "REAPER.GETMEDIASOURCELENGTH_WR lua": {
        "prefix": "reaperwr.GetMediaSourceLength",
        "scope": "lua",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "${1:local }${2:number retval},${3:boolean lengthIsQN} = reaper.GetMediaSourceLength(${4:PCM_source source})$0"
    },
    "RPR_GETMEDIASOURCELENGTH_WR python": {
        "prefix": "WR_RPR_GetMediaSourceLength",
        "scope": "python",
        "description": "Returns the length of the source media. If the media source is\nbeat-based, the length will be in quarter notes, otherwise it will be in\nseconds.\n",
        "body": "${1:Float retval},${2:PCM_source source},${3:Boolean lengthIsQNOut} = RPR_GetMediaSourceLength(${4:source},${5:lengthIsQNOut})$0"
    },
    "GETMEDIASOURCENUMCHANNELS_WR c": {
        "prefix": "WR_GetMediaSourceNumChannels",
        "scope": "c",
        "description": "Returns the number of channels in the source media.\n",
        "body": "${1:int} = GetMediaSourceNumChannels(${2:PCM_source* source})$0"
    },
    "GETMEDIASOURCENUMCHANNELS_WR eel2": {
        "prefix": "WR_GetMediaSourceNumChannels",
        "scope": "eel2",
        "description": "Returns the number of channels in the source media.\n",
        "body": "${1:int} = GetMediaSourceNumChannels(${2:PCM_source source})$0"
    },
    "REAPER.GETMEDIASOURCENUMCHANNELS_WR lua": {
        "prefix": "reaperwr.GetMediaSourceNumChannels",
        "scope": "lua",
        "description": "Returns the number of channels in the source media.\n",
        "body": "${1:local }${2:integer} = reaper.GetMediaSourceNumChannels(${3:PCM_source source})$0"
    },
    "RPR_GETMEDIASOURCENUMCHANNELS_WR python": {
        "prefix": "WR_RPR_GetMediaSourceNumChannels",
        "scope": "python",
        "description": "Returns the number of channels in the source media.\n",
        "body": "${1:Int} = RPR_GetMediaSourceNumChannels(${2:PCM_source source})$0"
    },
    "GETMEDIASOURCEPARENT_WR c": {
        "prefix": "WR_GetMediaSourceParent",
        "scope": "c",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "${1:PCM_source*} = GetMediaSourceParent(${2:PCM_source* src})$0"
    },
    "GETMEDIASOURCEPARENT_WR eel2": {
        "prefix": "WR_GetMediaSourceParent",
        "scope": "eel2",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "${1:PCM_source} = GetMediaSourceParent(${2:PCM_source src})$0"
    },
    "REAPER.GETMEDIASOURCEPARENT_WR lua": {
        "prefix": "reaperwr.GetMediaSourceParent",
        "scope": "lua",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "${1:local }${2:PCM_source} = reaper.GetMediaSourceParent(${3:PCM_source src})$0"
    },
    "RPR_GETMEDIASOURCEPARENT_WR python": {
        "prefix": "WR_RPR_GetMediaSourceParent",
        "scope": "python",
        "description": "Returns the parent source, or NULL if src is the root source. This can\nbe used to retrieve the parent properties of sections or reversed\nsources for example.\n",
        "body": "${1:PCM_source} = RPR_GetMediaSourceParent(${2:PCM_source src})$0"
    },
    "GETMEDIASOURCESAMPLERATE_WR c": {
        "prefix": "WR_GetMediaSourceSampleRate",
        "scope": "c",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "${1:int} = GetMediaSourceSampleRate(${2:PCM_source* source})$0"
    },
    "GETMEDIASOURCESAMPLERATE_WR eel2": {
        "prefix": "WR_GetMediaSourceSampleRate",
        "scope": "eel2",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "${1:int} = GetMediaSourceSampleRate(${2:PCM_source source})$0"
    },
    "REAPER.GETMEDIASOURCESAMPLERATE_WR lua": {
        "prefix": "reaperwr.GetMediaSourceSampleRate",
        "scope": "lua",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "${1:local }${2:integer} = reaper.GetMediaSourceSampleRate(${3:PCM_source source})$0"
    },
    "RPR_GETMEDIASOURCESAMPLERATE_WR python": {
        "prefix": "WR_RPR_GetMediaSourceSampleRate",
        "scope": "python",
        "description": "Returns the sample rate. MIDI source media will return zero.\n",
        "body": "${1:Int} = RPR_GetMediaSourceSampleRate(${2:PCM_source source})$0"
    },
    "GETMEDIASOURCETYPE_WR c": {
        "prefix": "WR_GetMediaSourceType",
        "scope": "c",
        "description": "copies the media source type (\"WAV\", \"MIDI\", etc) to typebuf\n",
        "body": "${1:void} = GetMediaSourceType(${2:PCM_source* source},${3:char* typebuf},${4:int typebuf_sz})$0"
    },
    "REAPER.GETMEDIASOURCETYPE_WR lua": {
        "prefix": "reaperwr.GetMediaSourceType",
        "scope": "lua",
        "description": "copies the media source type (\"WAV\", \"MIDI\", etc) to typebuf\n",
        "body": "${1:local }${2:string typebuf} = reaper.GetMediaSourceType(${3:PCM_source source},${4:string typebuf})$0"
    },
    "RPR_GETMEDIASOURCETYPE_WR python": {
        "prefix": "WR_RPR_GetMediaSourceType",
        "scope": "python",
        "description": "copies the media source type (\"WAV\", \"MIDI\", etc) to typebuf\n",
        "body": "${1:PCM_source source},${2:String typebuf},${3:Int typebuf_sz} = RPR_GetMediaSourceType(${4:source},${5:typebuf},${6:typebuf_sz})$0"
    },
    "GETMEDIATRACKINFO_VALUE_WR c": {
        "prefix": "WR_GetMediaTrackInfo_Value",
        "scope": "c",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "${1:double} = GetMediaTrackInfo_Value(${2:MediaTrack* tr},${3|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\",\"P_PARTRACK\",\"P_PROJECT\"|})$0"
    },
    "GETMEDIATRACKINFO_VALUE_WR eel2": {
        "prefix": "WR_GetMediaTrackInfo_Value",
        "scope": "eel2",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "${1:double} = GetMediaTrackInfo_Value(${2:MediaTrack tr},${3:\"parmname\"})$0"
    },
    "REAPER.GETMEDIATRACKINFO_VALUE_WR lua": {
        "prefix": "reaperwr.GetMediaTrackInfo_Value",
        "scope": "lua",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "${1:local }${2:number} = reaper.GetMediaTrackInfo_Value(${3:MediaTrack tr},${4|string parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\",\"P_PARTRACK\",\"P_PROJECT\"|})$0"
    },
    "RPR_GETMEDIATRACKINFO_VALUE_WR python": {
        "prefix": "WR_RPR_GetMediaTrackInfo_Value",
        "scope": "python",
        "description": "Get track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\nP_PARTRACK : MediaTrack * : parent track (read-only)\nP_PROJECT : ReaProject * : parent project (read-only)\n",
        "body": "${1:Float} = RPR_GetMediaTrackInfo_Value(${2:MediaTrack tr},${3|String parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\",\"P_PARTRACK\",\"P_PROJECT\"|})$0"
    },
    "GETMIDIINPUTNAME_WR c": {
        "prefix": "WR_GetMIDIInputName",
        "scope": "c",
        "description": "returns true if device present\n",
        "body": "${1:bool} = GetMIDIInputName(${2:int dev},${3:char* nameout},${4:int nameout_sz})$0"
    },
    "GETMIDIINPUTNAME_WR eel2": {
        "prefix": "WR_GetMIDIInputName",
        "scope": "eel2",
        "description": "returns true if device present\n",
        "body": "${1:bool} = GetMIDIInputName(${2:int dev},${3:#nameout})$0"
    },
    "REAPER.GETMIDIINPUTNAME_WR lua": {
        "prefix": "reaperwr.GetMIDIInputName",
        "scope": "lua",
        "description": "returns true if device present\n",
        "body": "${1:local }${2:boolean retval},${3:string nameout} = reaper.GetMIDIInputName(${4:integer dev},${5:string nameout})$0"
    },
    "RPR_GETMIDIINPUTNAME_WR python": {
        "prefix": "WR_RPR_GetMIDIInputName",
        "scope": "python",
        "description": "returns true if device present\n",
        "body": "${1:Boolean retval},${2:Int dev},${3:String nameout},${4:Int nameout_sz} = RPR_GetMIDIInputName(${5:dev},${6:nameout},${7:nameout_sz})$0"
    },
    "GETMIDIOUTPUTNAME_WR c": {
        "prefix": "WR_GetMIDIOutputName",
        "scope": "c",
        "description": "returns true if device present\n",
        "body": "${1:bool} = GetMIDIOutputName(${2:int dev},${3:char* nameout},${4:int nameout_sz})$0"
    },
    "GETMIDIOUTPUTNAME_WR eel2": {
        "prefix": "WR_GetMIDIOutputName",
        "scope": "eel2",
        "description": "returns true if device present\n",
        "body": "${1:bool} = GetMIDIOutputName(${2:int dev},${3:#nameout})$0"
    },
    "REAPER.GETMIDIOUTPUTNAME_WR lua": {
        "prefix": "reaperwr.GetMIDIOutputName",
        "scope": "lua",
        "description": "returns true if device present\n",
        "body": "${1:local }${2:boolean retval},${3:string nameout} = reaper.GetMIDIOutputName(${4:integer dev},${5:string nameout})$0"
    },
    "RPR_GETMIDIOUTPUTNAME_WR python": {
        "prefix": "WR_RPR_GetMIDIOutputName",
        "scope": "python",
        "description": "returns true if device present\n",
        "body": "${1:Boolean retval},${2:Int dev},${3:String nameout},${4:Int nameout_sz} = RPR_GetMIDIOutputName(${5:dev},${6:nameout},${7:nameout_sz})$0"
    },
    "GETMIXERSCROLL_WR c": {
        "prefix": "WR_GetMixerScroll",
        "scope": "c",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "${1:MediaTrack*} = GetMixerScroll()$0"
    },
    "GETMIXERSCROLL_WR eel2": {
        "prefix": "WR_GetMixerScroll",
        "scope": "eel2",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "${1:MediaTrack} = GetMixerScroll()$0"
    },
    "REAPER.GETMIXERSCROLL_WR lua": {
        "prefix": "reaperwr.GetMixerScroll",
        "scope": "lua",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetMixerScroll()$0"
    },
    "RPR_GETMIXERSCROLL_WR python": {
        "prefix": "WR_RPR_GetMixerScroll",
        "scope": "python",
        "description": "Get the leftmost track visible in the mixer\n",
        "body": "${1:MediaTrack} = RPR_GetMixerScroll()$0"
    },
    "GETMOUSEMODIFIER_WR c": {
        "prefix": "WR_GetMouseModifier",
        "scope": "c",
        "description": "Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.\naction will be filled in with the command ID number for a built-in mouse modifier\nor built-in REAPER command ID, or the custom action ID string.\nSee SetMouseModifier for more information.\n",
        "body": "${1:void} = GetMouseModifier(${2:const char* context},${3:int modifier_flag},${4:char* action},${5:int action_sz})$0"
    },
    "REAPER.GETMOUSEMODIFIER_WR lua": {
        "prefix": "reaperwr.GetMouseModifier",
        "scope": "lua",
        "description": "Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.\naction will be filled in with the command ID number for a built-in mouse modifier\nor built-in REAPER command ID, or the custom action ID string.\nSee SetMouseModifier for more information.\n",
        "body": "${1:local }${2:string action} = reaper.GetMouseModifier(${3:string context},${4:integer modifier_flag},${5:string action})$0"
    },
    "RPR_GETMOUSEMODIFIER_WR python": {
        "prefix": "WR_RPR_GetMouseModifier",
        "scope": "python",
        "description": "Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.\naction will be filled in with the command ID number for a built-in mouse modifier\nor built-in REAPER command ID, or the custom action ID string.\nSee SetMouseModifier for more information.\n",
        "body": "${1:String context},${2:Int modifier_flag},${3:String action},${4:Int action_sz} = RPR_GetMouseModifier(${5:context},${6:modifier_flag},${7:action},${8:action_sz})$0"
    },
    "GETMOUSEPOSITION_WR c": {
        "prefix": "WR_GetMousePosition",
        "scope": "c",
        "description": "get mouse position in screen coordinates\n",
        "body": "${1:void} = GetMousePosition(${2:int* xOut},${3:int* yOut})$0"
    },
    "REAPER.GETMOUSEPOSITION_WR lua": {
        "prefix": "reaperwr.GetMousePosition",
        "scope": "lua",
        "description": "get mouse position in screen coordinates\n",
        "body": "${1:local }${2:number x},${3:number y} = reaper.GetMousePosition()$0"
    },
    "RPR_GETMOUSEPOSITION_WR python": {
        "prefix": "WR_RPR_GetMousePosition",
        "scope": "python",
        "description": "get mouse position in screen coordinates\n",
        "body": "${1:Int xOut},${2:Int yOut} = RPR_GetMousePosition(${3:xOut},${4:yOut})$0"
    },
    "GETNUMAUDIOINPUTS_WR c": {
        "prefix": "WR_GetNumAudioInputs",
        "scope": "c",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "${1:int} = GetNumAudioInputs()$0"
    },
    "GETNUMAUDIOINPUTS_WR eel2": {
        "prefix": "WR_GetNumAudioInputs",
        "scope": "eel2",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "${1:int} = GetNumAudioInputs()$0"
    },
    "REAPER.GETNUMAUDIOINPUTS_WR lua": {
        "prefix": "reaperwr.GetNumAudioInputs",
        "scope": "lua",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "${1:local }${2:integer} = reaper.GetNumAudioInputs()$0"
    },
    "RPR_GETNUMAUDIOINPUTS_WR python": {
        "prefix": "WR_RPR_GetNumAudioInputs",
        "scope": "python",
        "description": "Return number of normal audio hardware inputs available\n",
        "body": "${1:Int} = RPR_GetNumAudioInputs()$0"
    },
    "GETNUMAUDIOOUTPUTS_WR c": {
        "prefix": "WR_GetNumAudioOutputs",
        "scope": "c",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "${1:int} = GetNumAudioOutputs()$0"
    },
    "GETNUMAUDIOOUTPUTS_WR eel2": {
        "prefix": "WR_GetNumAudioOutputs",
        "scope": "eel2",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "${1:int} = GetNumAudioOutputs()$0"
    },
    "REAPER.GETNUMAUDIOOUTPUTS_WR lua": {
        "prefix": "reaperwr.GetNumAudioOutputs",
        "scope": "lua",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "${1:local }${2:integer} = reaper.GetNumAudioOutputs()$0"
    },
    "RPR_GETNUMAUDIOOUTPUTS_WR python": {
        "prefix": "WR_RPR_GetNumAudioOutputs",
        "scope": "python",
        "description": "Return number of normal audio hardware outputs available\n",
        "body": "${1:Int} = RPR_GetNumAudioOutputs()$0"
    },
    "GETNUMMIDIINPUTS_WR c": {
        "prefix": "WR_GetNumMIDIInputs",
        "scope": "c",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "${1:int} = GetNumMIDIInputs()$0"
    },
    "GETNUMMIDIINPUTS_WR eel2": {
        "prefix": "WR_GetNumMIDIInputs",
        "scope": "eel2",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "${1:int} = GetNumMIDIInputs()$0"
    },
    "REAPER.GETNUMMIDIINPUTS_WR lua": {
        "prefix": "reaperwr.GetNumMIDIInputs",
        "scope": "lua",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "${1:local }${2:integer} = reaper.GetNumMIDIInputs()$0"
    },
    "RPR_GETNUMMIDIINPUTS_WR python": {
        "prefix": "WR_RPR_GetNumMIDIInputs",
        "scope": "python",
        "description": "returns max number of real midi hardware inputs\n",
        "body": "${1:Int} = RPR_GetNumMIDIInputs()$0"
    },
    "GETNUMMIDIOUTPUTS_WR c": {
        "prefix": "WR_GetNumMIDIOutputs",
        "scope": "c",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "${1:int} = GetNumMIDIOutputs()$0"
    },
    "GETNUMMIDIOUTPUTS_WR eel2": {
        "prefix": "WR_GetNumMIDIOutputs",
        "scope": "eel2",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "${1:int} = GetNumMIDIOutputs()$0"
    },
    "REAPER.GETNUMMIDIOUTPUTS_WR lua": {
        "prefix": "reaperwr.GetNumMIDIOutputs",
        "scope": "lua",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "${1:local }${2:integer} = reaper.GetNumMIDIOutputs()$0"
    },
    "RPR_GETNUMMIDIOUTPUTS_WR python": {
        "prefix": "WR_RPR_GetNumMIDIOutputs",
        "scope": "python",
        "description": "returns max number of real midi hardware outputs\n",
        "body": "${1:Int} = RPR_GetNumMIDIOutputs()$0"
    },
    "GETNUMTRACKS_WR c": {
        "prefix": "WR_GetNumTracks",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = GetNumTracks()$0"
    },
    "GETNUMTRACKS_WR eel2": {
        "prefix": "WR_GetNumTracks",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = GetNumTracks()$0"
    },
    "REAPER.GETNUMTRACKS_WR lua": {
        "prefix": "reaperwr.GetNumTracks",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.GetNumTracks()$0"
    },
    "RPR_GETNUMTRACKS_WR python": {
        "prefix": "WR_RPR_GetNumTracks",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_GetNumTracks()$0"
    },
    "GETOS_WR c": {
        "prefix": "WR_GetOS",
        "scope": "c",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "${1:const char*} = GetOS()$0"
    },
    "GETOS_WR eel2": {
        "prefix": "WR_GetOS",
        "scope": "eel2",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "${1:bool} = GetOS(${2:#retval})$0"
    },
    "REAPER.GETOS_WR lua": {
        "prefix": "reaperwr.GetOS",
        "scope": "lua",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "${1:local }${2:string} = reaper.GetOS()$0"
    },
    "RPR_GETOS_WR python": {
        "prefix": "WR_RPR_GetOS",
        "scope": "python",
        "description": "Returns \"Win32\", \"Win64\", \"OSX32\", \"OSX64\", or \"Other\".\n",
        "body": "${1:String} = RPR_GetOS()$0"
    },
    "GETOUTPUTCHANNELNAME_WR c": {
        "prefix": "WR_GetOutputChannelName",
        "scope": "c",
        "description": "\n",
        "body": "${1:const char*} = GetOutputChannelName(${2:int channelIndex})$0"
    },
    "GETOUTPUTCHANNELNAME_WR eel2": {
        "prefix": "WR_GetOutputChannelName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetOutputChannelName(${2:#retval},${3:int channelIndex})$0"
    },
    "REAPER.GETOUTPUTCHANNELNAME_WR lua": {
        "prefix": "reaperwr.GetOutputChannelName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string} = reaper.GetOutputChannelName(${3:integer channelIndex})$0"
    },
    "RPR_GETOUTPUTCHANNELNAME_WR python": {
        "prefix": "WR_RPR_GetOutputChannelName",
        "scope": "python",
        "description": "\n",
        "body": "${1:String} = RPR_GetOutputChannelName(${2:Int channelIndex})$0"
    },
    "GETOUTPUTLATENCY_WR c": {
        "prefix": "WR_GetOutputLatency",
        "scope": "c",
        "description": "returns output latency in seconds\n",
        "body": "${1:double} = GetOutputLatency()$0"
    },
    "GETOUTPUTLATENCY_WR eel2": {
        "prefix": "WR_GetOutputLatency",
        "scope": "eel2",
        "description": "returns output latency in seconds\n",
        "body": "${1:double} = GetOutputLatency()$0"
    },
    "REAPER.GETOUTPUTLATENCY_WR lua": {
        "prefix": "reaperwr.GetOutputLatency",
        "scope": "lua",
        "description": "returns output latency in seconds\n",
        "body": "${1:local }${2:number} = reaper.GetOutputLatency()$0"
    },
    "RPR_GETOUTPUTLATENCY_WR python": {
        "prefix": "WR_RPR_GetOutputLatency",
        "scope": "python",
        "description": "returns output latency in seconds\n",
        "body": "${1:Float} = RPR_GetOutputLatency()$0"
    },
    "GETPARENTTRACK_WR c": {
        "prefix": "WR_GetParentTrack",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaTrack*} = GetParentTrack(${2:MediaTrack* track})$0"
    },
    "GETPARENTTRACK_WR eel2": {
        "prefix": "WR_GetParentTrack",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaTrack} = GetParentTrack(${2:MediaTrack track})$0"
    },
    "REAPER.GETPARENTTRACK_WR lua": {
        "prefix": "reaperwr.GetParentTrack",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetParentTrack(${3:MediaTrack track})$0"
    },
    "RPR_GETPARENTTRACK_WR python": {
        "prefix": "WR_RPR_GetParentTrack",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaTrack} = RPR_GetParentTrack(${2:MediaTrack track})$0"
    },
    "GETPEAKFILENAME_WR c": {
        "prefix": "WR_GetPeakFileName",
        "scope": "c",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "${1:void} = GetPeakFileName(${2:const char* fn},${3:char* buf},${4:int buf_sz})$0"
    },
    "REAPER.GETPEAKFILENAME_WR lua": {
        "prefix": "reaperwr.GetPeakFileName",
        "scope": "lua",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "${1:local }${2:string buf} = reaper.GetPeakFileName(${3:string fn},${4:string buf})$0"
    },
    "RPR_GETPEAKFILENAME_WR python": {
        "prefix": "WR_RPR_GetPeakFileName",
        "scope": "python",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "${1:String fn},${2:String buf},${3:Int buf_sz} = RPR_GetPeakFileName(${4:fn},${5:buf},${6:buf_sz})$0"
    },
    "GETPEAKFILENAMEEX_WR c": {
        "prefix": "WR_GetPeakFileNameEx",
        "scope": "c",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "${1:void} = GetPeakFileNameEx(${2:const char* fn},${3:char* buf},${4:int buf_sz},${5:bool forWrite})$0"
    },
    "REAPER.GETPEAKFILENAMEEX_WR lua": {
        "prefix": "reaperwr.GetPeakFileNameEx",
        "scope": "lua",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "${1:local }${2:string buf} = reaper.GetPeakFileNameEx(${3:string fn},${4:string buf},${5:boolean forWrite})$0"
    },
    "RPR_GETPEAKFILENAMEEX_WR python": {
        "prefix": "WR_RPR_GetPeakFileNameEx",
        "scope": "python",
        "description": "get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)\n",
        "body": "${1:String fn},${2:String buf},${3:Int buf_sz},${4:Boolean forWrite} = RPR_GetPeakFileNameEx(${5:fn},${6:buf},${7:buf_sz},${8:forWrite})$0"
    },
    "GETPEAKFILENAMEEX2_WR c": {
        "prefix": "WR_GetPeakFileNameEx2",
        "scope": "c",
        "description": "Like GetPeakFileNameEx, but you can specify peaksfileextension such as \".reapeaks\"\n",
        "body": "${1:void} = GetPeakFileNameEx2(${2:const char* fn},${3:char* buf},${4:int buf_sz},${5:bool forWrite},${6:const char* peaksfileextension})$0"
    },
    "REAPER.GETPEAKFILENAMEEX2_WR lua": {
        "prefix": "reaperwr.GetPeakFileNameEx2",
        "scope": "lua",
        "description": "Like GetPeakFileNameEx, but you can specify peaksfileextension such as \".reapeaks\"\n",
        "body": "${1:local }${2:string buf} = reaper.GetPeakFileNameEx2(${3:string fn},${4:string buf},${5:boolean forWrite},${6:string peaksfileextension})$0"
    },
    "RPR_GETPEAKFILENAMEEX2_WR python": {
        "prefix": "WR_RPR_GetPeakFileNameEx2",
        "scope": "python",
        "description": "Like GetPeakFileNameEx, but you can specify peaksfileextension such as \".reapeaks\"\n",
        "body": "${1:String fn},${2:String buf},${3:Int buf_sz},${4:Boolean forWrite},${5:String peaksfileextension} = RPR_GetPeakFileNameEx2(${6:fn},${7:buf},${8:buf_sz},${9:forWrite},${10:peaksfileextension})$0"
    },
    "GETPLAYPOSITION_WR c": {
        "prefix": "WR_GetPlayPosition",
        "scope": "c",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:double} = GetPlayPosition()$0"
    },
    "GETPLAYPOSITION_WR eel2": {
        "prefix": "WR_GetPlayPosition",
        "scope": "eel2",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:double} = GetPlayPosition()$0"
    },
    "REAPER.GETPLAYPOSITION_WR lua": {
        "prefix": "reaperwr.GetPlayPosition",
        "scope": "lua",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:local }${2:number} = reaper.GetPlayPosition()$0"
    },
    "RPR_GETPLAYPOSITION_WR python": {
        "prefix": "WR_RPR_GetPlayPosition",
        "scope": "python",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:Float} = RPR_GetPlayPosition()$0"
    },
    "GETPLAYPOSITION2_WR c": {
        "prefix": "WR_GetPlayPosition2",
        "scope": "c",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:double} = GetPlayPosition2()$0"
    },
    "GETPLAYPOSITION2_WR eel2": {
        "prefix": "WR_GetPlayPosition2",
        "scope": "eel2",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:double} = GetPlayPosition2()$0"
    },
    "REAPER.GETPLAYPOSITION2_WR lua": {
        "prefix": "reaperwr.GetPlayPosition2",
        "scope": "lua",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:local }${2:number} = reaper.GetPlayPosition2()$0"
    },
    "RPR_GETPLAYPOSITION2_WR python": {
        "prefix": "WR_RPR_GetPlayPosition2",
        "scope": "python",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:Float} = RPR_GetPlayPosition2()$0"
    },
    "GETPLAYPOSITION2EX_WR c": {
        "prefix": "WR_GetPlayPosition2Ex",
        "scope": "c",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:double} = GetPlayPosition2Ex(${2:ReaProject* proj})$0"
    },
    "GETPLAYPOSITION2EX_WR eel2": {
        "prefix": "WR_GetPlayPosition2Ex",
        "scope": "eel2",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:double} = GetPlayPosition2Ex(${2:ReaProject proj})$0"
    },
    "REAPER.GETPLAYPOSITION2EX_WR lua": {
        "prefix": "reaperwr.GetPlayPosition2Ex",
        "scope": "lua",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:local }${2:number} = reaper.GetPlayPosition2Ex(${3:ReaProject proj})$0"
    },
    "RPR_GETPLAYPOSITION2EX_WR python": {
        "prefix": "WR_RPR_GetPlayPosition2Ex",
        "scope": "python",
        "description": "returns position of next audio block being processed\n",
        "body": "${1:Float} = RPR_GetPlayPosition2Ex(${2:ReaProject proj})$0"
    },
    "GETPLAYPOSITIONEX_WR c": {
        "prefix": "WR_GetPlayPositionEx",
        "scope": "c",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:double} = GetPlayPositionEx(${2:ReaProject* proj})$0"
    },
    "GETPLAYPOSITIONEX_WR eel2": {
        "prefix": "WR_GetPlayPositionEx",
        "scope": "eel2",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:double} = GetPlayPositionEx(${2:ReaProject proj})$0"
    },
    "REAPER.GETPLAYPOSITIONEX_WR lua": {
        "prefix": "reaperwr.GetPlayPositionEx",
        "scope": "lua",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:local }${2:number} = reaper.GetPlayPositionEx(${3:ReaProject proj})$0"
    },
    "RPR_GETPLAYPOSITIONEX_WR python": {
        "prefix": "WR_RPR_GetPlayPositionEx",
        "scope": "python",
        "description": "returns latency-compensated actual-what-you-hear position\n",
        "body": "${1:Float} = RPR_GetPlayPositionEx(${2:ReaProject proj})$0"
    },
    "GETPLAYSTATE_WR c": {
        "prefix": "WR_GetPlayState",
        "scope": "c",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:int} = GetPlayState()$0"
    },
    "GETPLAYSTATE_WR eel2": {
        "prefix": "WR_GetPlayState",
        "scope": "eel2",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:int} = GetPlayState()$0"
    },
    "REAPER.GETPLAYSTATE_WR lua": {
        "prefix": "reaperwr.GetPlayState",
        "scope": "lua",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:local }${2:integer} = reaper.GetPlayState()$0"
    },
    "RPR_GETPLAYSTATE_WR python": {
        "prefix": "WR_RPR_GetPlayState",
        "scope": "python",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:Int} = RPR_GetPlayState()$0"
    },
    "GETPLAYSTATEEX_WR c": {
        "prefix": "WR_GetPlayStateEx",
        "scope": "c",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:int} = GetPlayStateEx(${2:ReaProject* proj})$0"
    },
    "GETPLAYSTATEEX_WR eel2": {
        "prefix": "WR_GetPlayStateEx",
        "scope": "eel2",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:int} = GetPlayStateEx(${2:ReaProject proj})$0"
    },
    "REAPER.GETPLAYSTATEEX_WR lua": {
        "prefix": "reaperwr.GetPlayStateEx",
        "scope": "lua",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:local }${2:integer} = reaper.GetPlayStateEx(${3:ReaProject proj})$0"
    },
    "RPR_GETPLAYSTATEEX_WR python": {
        "prefix": "WR_RPR_GetPlayStateEx",
        "scope": "python",
        "description": "&1=playing,&2=pause,&=4 is recording\n",
        "body": "${1:Int} = RPR_GetPlayStateEx(${2:ReaProject proj})$0"
    },
    "GETPROJECTLENGTH_WR c": {
        "prefix": "WR_GetProjectLength",
        "scope": "c",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "${1:double} = GetProjectLength(${2:ReaProject* proj})$0"
    },
    "GETPROJECTLENGTH_WR eel2": {
        "prefix": "WR_GetProjectLength",
        "scope": "eel2",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "${1:double} = GetProjectLength(${2:ReaProject proj})$0"
    },
    "REAPER.GETPROJECTLENGTH_WR lua": {
        "prefix": "reaperwr.GetProjectLength",
        "scope": "lua",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "${1:local }${2:number} = reaper.GetProjectLength(${3:ReaProject proj})$0"
    },
    "RPR_GETPROJECTLENGTH_WR python": {
        "prefix": "WR_RPR_GetProjectLength",
        "scope": "python",
        "description": "returns length of project (maximum of end of media item, markers, end of regions, tempo map\n",
        "body": "${1:Float} = RPR_GetProjectLength(${2:ReaProject proj})$0"
    },
    "GETPROJECTNAME_WR c": {
        "prefix": "WR_GetProjectName",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = GetProjectName(${2:ReaProject* proj},${3:char* buf},${4:int buf_sz})$0"
    },
    "REAPER.GETPROJECTNAME_WR lua": {
        "prefix": "reaperwr.GetProjectName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string buf} = reaper.GetProjectName(${3:ReaProject proj},${4:string buf})$0"
    },
    "RPR_GETPROJECTNAME_WR python": {
        "prefix": "WR_RPR_GetProjectName",
        "scope": "python",
        "description": "\n",
        "body": "${1:ReaProject proj},${2:String buf},${3:Int buf_sz} = RPR_GetProjectName(${4:proj},${5:buf},${6:buf_sz})$0"
    },
    "GETPROJECTPATH_WR c": {
        "prefix": "WR_GetProjectPath",
        "scope": "c",
        "description": "Get the project recording path.\n",
        "body": "${1:void} = GetProjectPath(${2:char* buf},${3:int buf_sz})$0"
    },
    "REAPER.GETPROJECTPATH_WR lua": {
        "prefix": "reaperwr.GetProjectPath",
        "scope": "lua",
        "description": "Get the project recording path.\n",
        "body": "${1:local }${2:string buf} = reaper.GetProjectPath(${3:string buf})$0"
    },
    "RPR_GETPROJECTPATH_WR python": {
        "prefix": "WR_RPR_GetProjectPath",
        "scope": "python",
        "description": "Get the project recording path.\n",
        "body": "${1:String buf},${2:Int buf_sz} = RPR_GetProjectPath(${3:buf},${4:buf_sz})$0"
    },
    "GETPROJECTPATHEX_WR c": {
        "prefix": "WR_GetProjectPathEx",
        "scope": "c",
        "description": "Get the project recording path.\n",
        "body": "${1:void} = GetProjectPathEx(${2:ReaProject* proj},${3:char* buf},${4:int buf_sz})$0"
    },
    "REAPER.GETPROJECTPATHEX_WR lua": {
        "prefix": "reaperwr.GetProjectPathEx",
        "scope": "lua",
        "description": "Get the project recording path.\n",
        "body": "${1:local }${2:string buf} = reaper.GetProjectPathEx(${3:ReaProject proj},${4:string buf})$0"
    },
    "RPR_GETPROJECTPATHEX_WR python": {
        "prefix": "WR_RPR_GetProjectPathEx",
        "scope": "python",
        "description": "Get the project recording path.\n",
        "body": "${1:ReaProject proj},${2:String buf},${3:Int buf_sz} = RPR_GetProjectPathEx(${4:proj},${5:buf},${6:buf_sz})$0"
    },
    "GETPROJECTSTATECHANGECOUNT_WR c": {
        "prefix": "WR_GetProjectStateChangeCount",
        "scope": "c",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "${1:int} = GetProjectStateChangeCount(${2:ReaProject* proj})$0"
    },
    "GETPROJECTSTATECHANGECOUNT_WR eel2": {
        "prefix": "WR_GetProjectStateChangeCount",
        "scope": "eel2",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "${1:int} = GetProjectStateChangeCount(${2:ReaProject proj})$0"
    },
    "REAPER.GETPROJECTSTATECHANGECOUNT_WR lua": {
        "prefix": "reaperwr.GetProjectStateChangeCount",
        "scope": "lua",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "${1:local }${2:integer} = reaper.GetProjectStateChangeCount(${3:ReaProject proj})$0"
    },
    "RPR_GETPROJECTSTATECHANGECOUNT_WR python": {
        "prefix": "WR_RPR_GetProjectStateChangeCount",
        "scope": "python",
        "description": "returns an integer that changes when the project state changes\n",
        "body": "${1:Int} = RPR_GetProjectStateChangeCount(${2:ReaProject proj})$0"
    },
    "GETPROJECTTIMEOFFSET_WR c": {
        "prefix": "WR_GetProjectTimeOffset",
        "scope": "c",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "${1:double} = GetProjectTimeOffset(${2:ReaProject* proj},${3:bool rndframe})$0"
    },
    "GETPROJECTTIMEOFFSET_WR eel2": {
        "prefix": "WR_GetProjectTimeOffset",
        "scope": "eel2",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "${1:double} = GetProjectTimeOffset(${2:ReaProject proj},${3:bool rndframe})$0"
    },
    "REAPER.GETPROJECTTIMEOFFSET_WR lua": {
        "prefix": "reaperwr.GetProjectTimeOffset",
        "scope": "lua",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "${1:local }${2:number} = reaper.GetProjectTimeOffset(${3:ReaProject proj},${4:boolean rndframe})$0"
    },
    "RPR_GETPROJECTTIMEOFFSET_WR python": {
        "prefix": "WR_RPR_GetProjectTimeOffset",
        "scope": "python",
        "description": "Gets project time offset in seconds (project settings - project start\ntime). If rndframe is true, the offset is rounded to a multiple of the\nproject frame size.\n",
        "body": "${1:Float} = RPR_GetProjectTimeOffset(${2:ReaProject proj},${3:Boolean rndframe})$0"
    },
    "GETPROJECTTIMESIGNATURE_WR c": {
        "prefix": "WR_GetProjectTimeSignature",
        "scope": "c",
        "description": "deprecated\n",
        "body": "${1:void} = GetProjectTimeSignature(${2:double* bpmOut},${3:double* bpiOut})$0"
    },
    "REAPER.GETPROJECTTIMESIGNATURE_WR lua": {
        "prefix": "reaperwr.GetProjectTimeSignature",
        "scope": "lua",
        "description": "deprecated\n",
        "body": "${1:local }${2:number bpm},${3:number bpi} = reaper.GetProjectTimeSignature()$0"
    },
    "RPR_GETPROJECTTIMESIGNATURE_WR python": {
        "prefix": "WR_RPR_GetProjectTimeSignature",
        "scope": "python",
        "description": "deprecated\n",
        "body": "${1:Float bpmOut},${2:Float bpiOut} = RPR_GetProjectTimeSignature(${3:bpmOut},${4:bpiOut})$0"
    },
    "GETPROJECTTIMESIGNATURE2_WR c": {
        "prefix": "WR_GetProjectTimeSignature2",
        "scope": "c",
        "description": "Gets basic time signature (beats per minute, numerator of time signature in bpi)\nthis does not reflect tempo envelopes but is purely what is set in the project settings.\n",
        "body": "${1:void} = GetProjectTimeSignature2(${2:ReaProject* proj},${3:double* bpmOut},${4:double* bpiOut})$0"
    },
    "REAPER.GETPROJECTTIMESIGNATURE2_WR lua": {
        "prefix": "reaperwr.GetProjectTimeSignature2",
        "scope": "lua",
        "description": "Gets basic time signature (beats per minute, numerator of time signature in bpi)\nthis does not reflect tempo envelopes but is purely what is set in the project settings.\n",
        "body": "${1:local }${2:number bpm},${3:number bpi} = reaper.GetProjectTimeSignature2(${4:ReaProject proj})$0"
    },
    "RPR_GETPROJECTTIMESIGNATURE2_WR python": {
        "prefix": "WR_RPR_GetProjectTimeSignature2",
        "scope": "python",
        "description": "Gets basic time signature (beats per minute, numerator of time signature in bpi)\nthis does not reflect tempo envelopes but is purely what is set in the project settings.\n",
        "body": "${1:ReaProject proj},${2:Float bpmOut},${3:Float bpiOut} = RPR_GetProjectTimeSignature2(${4:proj},${5:bpmOut},${6:bpiOut})$0"
    },
    "GETPROJEXTSTATE_WR c": {
        "prefix": "WR_GetProjExtState",
        "scope": "c",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "${1:int} = GetProjExtState(${2:ReaProject* proj},${3:const char* extname},${4:const char* key},${5:char* valOutNeedBig},${6:int valOutNeedBig_sz})$0"
    },
    "GETPROJEXTSTATE_WR eel2": {
        "prefix": "WR_GetProjExtState",
        "scope": "eel2",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "${1:int} = GetProjExtState(${2:ReaProject proj},${3:\"extname\"},${4:\"key\"},${5:#val})$0"
    },
    "REAPER.GETPROJEXTSTATE_WR lua": {
        "prefix": "reaperwr.GetProjExtState",
        "scope": "lua",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "${1:local }${2:integer retval},${3:string val} = reaper.GetProjExtState(${4:ReaProject proj},${5:string extname},${6:string key})$0"
    },
    "RPR_GETPROJEXTSTATE_WR python": {
        "prefix": "WR_RPR_GetProjExtState",
        "scope": "python",
        "description": "Get the value previously associated with this extname and key, the last time the project was saved. See SetProjExtState, EnumProjExtState.\n",
        "body": "${1:Int retval},${2:ReaProject proj},${3:String extname},${4:String key},${5:String valOutNeedBig},${6:Int valOutNeedBig_sz} = RPR_GetProjExtState(${7:proj},${8:extname},${9:key},${10:valOutNeedBig},${11:valOutNeedBig_sz})$0"
    },
    "GETRESOURCEPATH_WR c": {
        "prefix": "WR_GetResourcePath",
        "scope": "c",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "${1:const char*} = GetResourcePath()$0"
    },
    "GETRESOURCEPATH_WR eel2": {
        "prefix": "WR_GetResourcePath",
        "scope": "eel2",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "${1:bool} = GetResourcePath(${2:#retval})$0"
    },
    "REAPER.GETRESOURCEPATH_WR lua": {
        "prefix": "reaperwr.GetResourcePath",
        "scope": "lua",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "${1:local }${2:string} = reaper.GetResourcePath()$0"
    },
    "RPR_GETRESOURCEPATH_WR python": {
        "prefix": "WR_RPR_GetResourcePath",
        "scope": "python",
        "description": "returns path where ini files are stored, other things are in subdirectories.\n",
        "body": "${1:String} = RPR_GetResourcePath()$0"
    },
    "GETSELECTEDENVELOPE_WR c": {
        "prefix": "WR_GetSelectedEnvelope",
        "scope": "c",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "${1:TrackEnvelope*} = GetSelectedEnvelope(${2:ReaProject* proj})$0"
    },
    "GETSELECTEDENVELOPE_WR eel2": {
        "prefix": "WR_GetSelectedEnvelope",
        "scope": "eel2",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "${1:TrackEnvelope} = GetSelectedEnvelope(${2:ReaProject proj})$0"
    },
    "REAPER.GETSELECTEDENVELOPE_WR lua": {
        "prefix": "reaperwr.GetSelectedEnvelope",
        "scope": "lua",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetSelectedEnvelope(${3:ReaProject proj})$0"
    },
    "RPR_GETSELECTEDENVELOPE_WR python": {
        "prefix": "WR_RPR_GetSelectedEnvelope",
        "scope": "python",
        "description": "get the currently selected envelope, returns 0 if no envelope is selected\n",
        "body": "${1:TrackEnvelope} = RPR_GetSelectedEnvelope(${2:ReaProject proj})$0"
    },
    "GETSELECTEDMEDIAITEM_WR c": {
        "prefix": "WR_GetSelectedMediaItem",
        "scope": "c",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaItem*} = GetSelectedMediaItem(${2:ReaProject* proj},${3:int selitem})$0"
    },
    "GETSELECTEDMEDIAITEM_WR eel2": {
        "prefix": "WR_GetSelectedMediaItem",
        "scope": "eel2",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaItem} = GetSelectedMediaItem(${2:ReaProject proj},${3:int selitem})$0"
    },
    "REAPER.GETSELECTEDMEDIAITEM_WR lua": {
        "prefix": "reaperwr.GetSelectedMediaItem",
        "scope": "lua",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:local }${2:MediaItem} = reaper.GetSelectedMediaItem(${3:ReaProject proj},${4:integer selitem})$0"
    },
    "RPR_GETSELECTEDMEDIAITEM_WR python": {
        "prefix": "WR_RPR_GetSelectedMediaItem",
        "scope": "python",
        "description": "get a selected item by selected item count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaItem} = RPR_GetSelectedMediaItem(${2:ReaProject proj},${3:Int selitem})$0"
    },
    "GETSELECTEDTRACK_WR c": {
        "prefix": "WR_GetSelectedTrack",
        "scope": "c",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "${1:MediaTrack*} = GetSelectedTrack(${2:ReaProject* proj},${3:int seltrackidx})$0"
    },
    "GETSELECTEDTRACK_WR eel2": {
        "prefix": "WR_GetSelectedTrack",
        "scope": "eel2",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "${1:MediaTrack} = GetSelectedTrack(${2:ReaProject proj},${3:int seltrackidx})$0"
    },
    "REAPER.GETSELECTEDTRACK_WR lua": {
        "prefix": "reaperwr.GetSelectedTrack",
        "scope": "lua",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetSelectedTrack(${3:ReaProject proj},${4:integer seltrackidx})$0"
    },
    "RPR_GETSELECTEDTRACK_WR python": {
        "prefix": "WR_RPR_GetSelectedTrack",
        "scope": "python",
        "description": "Get a selected track from a project (proj=0 for active project) by\nselected track count (zero-based). This function ignores the master\ntrack, see GetSelectedTrack2.\n",
        "body": "${1:MediaTrack} = RPR_GetSelectedTrack(${2:ReaProject proj},${3:Int seltrackidx})$0"
    },
    "GETSELECTEDTRACK2_WR c": {
        "prefix": "WR_GetSelectedTrack2",
        "scope": "c",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "${1:MediaTrack*} = GetSelectedTrack2(${2:ReaProject* proj},${3:int seltrackidx},${4:bool wantmaster})$0"
    },
    "GETSELECTEDTRACK2_WR eel2": {
        "prefix": "WR_GetSelectedTrack2",
        "scope": "eel2",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "${1:MediaTrack} = GetSelectedTrack2(${2:ReaProject proj},${3:int seltrackidx},${4:bool wantmaster})$0"
    },
    "REAPER.GETSELECTEDTRACK2_WR lua": {
        "prefix": "reaperwr.GetSelectedTrack2",
        "scope": "lua",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetSelectedTrack2(${3:ReaProject proj},${4:integer seltrackidx},${5:boolean wantmaster})$0"
    },
    "RPR_GETSELECTEDTRACK2_WR python": {
        "prefix": "WR_RPR_GetSelectedTrack2",
        "scope": "python",
        "description": "Get a selected track from a project (proj=0 for active project) by selected track count (zero-based).\n",
        "body": "${1:MediaTrack} = RPR_GetSelectedTrack2(${2:ReaProject proj},${3:Int seltrackidx},${4:Boolean wantmaster})$0"
    },
    "GETSELECTEDTRACKENVELOPE_WR c": {
        "prefix": "WR_GetSelectedTrackEnvelope",
        "scope": "c",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "${1:TrackEnvelope*} = GetSelectedTrackEnvelope(${2:ReaProject* proj})$0"
    },
    "GETSELECTEDTRACKENVELOPE_WR eel2": {
        "prefix": "WR_GetSelectedTrackEnvelope",
        "scope": "eel2",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "${1:TrackEnvelope} = GetSelectedTrackEnvelope(${2:ReaProject proj})$0"
    },
    "REAPER.GETSELECTEDTRACKENVELOPE_WR lua": {
        "prefix": "reaperwr.GetSelectedTrackEnvelope",
        "scope": "lua",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetSelectedTrackEnvelope(${3:ReaProject proj})$0"
    },
    "RPR_GETSELECTEDTRACKENVELOPE_WR python": {
        "prefix": "WR_RPR_GetSelectedTrackEnvelope",
        "scope": "python",
        "description": "get the currently selected track envelope, returns 0 if no envelope is selected\n",
        "body": "${1:TrackEnvelope} = RPR_GetSelectedTrackEnvelope(${2:ReaProject proj})$0"
    },
    "GETSET_ARRANGEVIEW2_WR c": {
        "prefix": "WR_GetSet_ArrangeView2",
        "scope": "c",
        "description": "Gets or sets the arrange view start/end time for screen coordinates. use\nscreen_x_start=screen_x_end=0 to use the full arrange view's start/end\ntime\n",
        "body": "${1:void} = GetSet_ArrangeView2(${2:ReaProject* proj},${3:bool isSet},${4:int screen_x_start},${5:int screen_x_end},${6:double* start_timeOut},${7:double* end_timeOut})$0"
    },
    "REAPER.GETSET_ARRANGEVIEW2_WR lua": {
        "prefix": "reaperwr.GetSet_ArrangeView2",
        "scope": "lua",
        "description": "Gets or sets the arrange view start/end time for screen coordinates. use\nscreen_x_start=screen_x_end=0 to use the full arrange view's start/end\ntime\n",
        "body": "${1:local }${2:number start_time},${3:number end_time} = reaper.GetSet_ArrangeView2(${4:ReaProject proj},${5:boolean isSet},${6:integer screen_x_start},${7:integer screen_x_end})$0"
    },
    "RPR_GETSET_ARRANGEVIEW2_WR python": {
        "prefix": "WR_RPR_GetSet_ArrangeView2",
        "scope": "python",
        "description": "Gets or sets the arrange view start/end time for screen coordinates. use\nscreen_x_start=screen_x_end=0 to use the full arrange view's start/end\ntime\n",
        "body": "${1:ReaProject proj},${2:Boolean isSet},${3:Int screen_x_start},${4:Int screen_x_end},${5:Float start_timeOut},${6:Float end_timeOut} = RPR_GetSet_ArrangeView2(${7:proj},${8:isSet},${9:screen_x_start},${10:screen_x_end},${11:start_timeOut},${12:end_timeOut})$0"
    },
    "GETSET_LOOPTIMERANGE_WR c": {
        "prefix": "WR_GetSet_LoopTimeRange",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = GetSet_LoopTimeRange(${2:bool isSet},${3:bool isLoop},${4:double* startOut},${5:double* endOut},${6:bool allowautoseek})$0"
    },
    "REAPER.GETSET_LOOPTIMERANGE_WR lua": {
        "prefix": "reaperwr.GetSet_LoopTimeRange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number start},${3:number end} = reaper.GetSet_LoopTimeRange(${4:boolean isSet},${5:boolean isLoop},${6:number start},${7:number end},${8:boolean allowautoseek})$0"
    },
    "RPR_GETSET_LOOPTIMERANGE_WR python": {
        "prefix": "WR_RPR_GetSet_LoopTimeRange",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean isSet},${2:Boolean isLoop},${3:Float startOut},${4:Float endOut},${5:Boolean allowautoseek} = RPR_GetSet_LoopTimeRange(${6:isSet},${7:isLoop},${8:startOut},${9:endOut},${10:allowautoseek})$0"
    },
    "GETSET_LOOPTIMERANGE2_WR c": {
        "prefix": "WR_GetSet_LoopTimeRange2",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = GetSet_LoopTimeRange2(${2:ReaProject* proj},${3:bool isSet},${4:bool isLoop},${5:double* startOut},${6:double* endOut},${7:bool allowautoseek})$0"
    },
    "REAPER.GETSET_LOOPTIMERANGE2_WR lua": {
        "prefix": "reaperwr.GetSet_LoopTimeRange2",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number start},${3:number end} = reaper.GetSet_LoopTimeRange2(${4:ReaProject proj},${5:boolean isSet},${6:boolean isLoop},${7:number start},${8:number end},${9:boolean allowautoseek})$0"
    },
    "RPR_GETSET_LOOPTIMERANGE2_WR python": {
        "prefix": "WR_RPR_GetSet_LoopTimeRange2",
        "scope": "python",
        "description": "\n",
        "body": "${1:ReaProject proj},${2:Boolean isSet},${3:Boolean isLoop},${4:Float startOut},${5:Float endOut},${6:Boolean allowautoseek} = RPR_GetSet_LoopTimeRange2(${7:proj},${8:isSet},${9:isLoop},${10:startOut},${11:endOut},${12:allowautoseek})$0"
    },
    "GETSETAUTOMATIONITEMINFO_WR c": {
        "prefix": "WR_GetSetAutomationItemInfo",
        "scope": "c",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "${1:double} = GetSetAutomationItemInfo(${2:TrackEnvelope* env},${3:int autoitem_idx},${4|const char* desc,\"D_POOL_ID\",\"D_POSITION\",\"D_LENGTH\",\"D_STARTOFFS\",\"D_PLAYRATE\",\"D_BASELINE\",\"D_AMPLITUDE\",\"D_LOOPSRC\",\"D_UISEL\",\"D_POOL_QNLEN\"|},${5:double value},${6:bool is_set})$0"
    },
    "GETSETAUTOMATIONITEMINFO_WR eel2": {
        "prefix": "WR_GetSetAutomationItemInfo",
        "scope": "eel2",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "${1:double} = GetSetAutomationItemInfo(${2:TrackEnvelope env},${3:int autoitem_idx},${4:\"desc\"},${5:value},${6:bool is_set})$0"
    },
    "REAPER.GETSETAUTOMATIONITEMINFO_WR lua": {
        "prefix": "reaperwr.GetSetAutomationItemInfo",
        "scope": "lua",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "${1:local }${2:number} = reaper.GetSetAutomationItemInfo(${3:TrackEnvelope env},${4:integer autoitem_idx},${5|string desc,\"D_POOL_ID\",\"D_POSITION\",\"D_LENGTH\",\"D_STARTOFFS\",\"D_PLAYRATE\",\"D_BASELINE\",\"D_AMPLITUDE\",\"D_LOOPSRC\",\"D_UISEL\",\"D_POOL_QNLEN\"|},${6:number value},${7:boolean is_set})$0"
    },
    "RPR_GETSETAUTOMATIONITEMINFO_WR python": {
        "prefix": "WR_RPR_GetSetAutomationItemInfo",
        "scope": "python",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. desc can be\nany of the following:\nD_POOL_ID : double * : automation item pool ID (as an integer); edits\nare propagated to all other automation items that share a pool ID\nD_POSITION : double * : automation item timeline position in seconds\nD_LENGTH : double * : automation item length in seconds\nD_STARTOFFS : double * : automation item start offset in seconds\nD_PLAYRATE : double * : automation item playback rate\nD_BASELINE : double * : automation item baseline value in the range [0,1]\nD_AMPLITUDE : double * : automation item amplitude in the range [-1,1]\nD_LOOPSRC : double * : nonzero if the automation item contents are looped\nD_UISEL : double * : nonzero if the automation item is selected in the arrange view\nD_POOL_QNLEN : double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n",
        "body": "${1:Float} = RPR_GetSetAutomationItemInfo(${2:TrackEnvelope env},${3:Int autoitem_idx},${4|String desc,\"D_POOL_ID\",\"D_POSITION\",\"D_LENGTH\",\"D_STARTOFFS\",\"D_PLAYRATE\",\"D_BASELINE\",\"D_AMPLITUDE\",\"D_LOOPSRC\",\"D_UISEL\",\"D_POOL_QNLEN\"|},${5:Float value},${6:Boolean is_set})$0"
    },
    "GETSETAUTOMATIONITEMINFO_STRING_WR c": {
        "prefix": "WR_GetSetAutomationItemInfo_String",
        "scope": "c",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "${1:bool} = GetSetAutomationItemInfo_String(${2:TrackEnvelope* env},${3:int autoitem_idx},${4|const char* desc,\"P_POOL_NAME\",\"P_POOL_EXT:xyz\"|},${5:char* valuestrNeedBig},${6:bool is_set})$0"
    },
    "GETSETAUTOMATIONITEMINFO_STRING_WR eel2": {
        "prefix": "WR_GetSetAutomationItemInfo_String",
        "scope": "eel2",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "${1:bool} = GetSetAutomationItemInfo_String(${2:TrackEnvelope env},${3:int autoitem_idx},${4:\"desc\"},${5:#valuestrNeedBig},${6:bool is_set})$0"
    },
    "REAPER.GETSETAUTOMATIONITEMINFO_STRING_WR lua": {
        "prefix": "reaperwr.GetSetAutomationItemInfo_String",
        "scope": "lua",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "${1:local }${2:boolean retval},${3:string valuestrNeedBig} = reaper.GetSetAutomationItemInfo_String(${4:TrackEnvelope env},${5:integer autoitem_idx},${6|string desc,\"P_POOL_NAME\",\"P_POOL_EXT:xyz\"|},${7:string valuestrNeedBig},${8:boolean is_set})$0"
    },
    "RPR_GETSETAUTOMATIONITEMINFO_STRING_WR python": {
        "prefix": "WR_RPR_GetSetAutomationItemInfo_String",
        "scope": "python",
        "description": "Get or set automation item information. autoitem_idx=0 for the first\nautomation item on an envelope, 1 for the second item, etc. returns true\non success. desc can be any of the following:\nP_POOL_NAME : char *, name of the underlying automation item pool\nP_POOL_EXT:xyz : char *, extension-specific persistent data\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope env},${3:Int autoitem_idx},${4:String desc},${5:String valuestrNeedBig},${6:Boolean is_set} = RPR_GetSetAutomationItemInfo_String(${7:env},${8:autoitem_idx},${9:desc},${10:valuestrNeedBig},${11:is_set})$0"
    },
    "GETSETENVELOPEINFO_STRING_WR c": {
        "prefix": "WR_GetSetEnvelopeInfo_String",
        "scope": "c",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:bool} = GetSetEnvelopeInfo_String(${2:TrackEnvelope* env},${3|const char* parmname,\"P_EXT:xyz\"|},${4:char* stringNeedBig},${5:bool setNewValue})$0"
    },
    "GETSETENVELOPEINFO_STRING_WR eel2": {
        "prefix": "WR_GetSetEnvelopeInfo_String",
        "scope": "eel2",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:bool} = GetSetEnvelopeInfo_String(${2:TrackEnvelope env},${3:\"parmname\"},${4:#stringNeedBig},${5:bool setNewValue})$0"
    },
    "REAPER.GETSETENVELOPEINFO_STRING_WR lua": {
        "prefix": "reaperwr.GetSetEnvelopeInfo_String",
        "scope": "lua",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:local }${2:boolean retval},${3:string stringNeedBig} = reaper.GetSetEnvelopeInfo_String(${4:TrackEnvelope env},${5|string parmname,\"P_EXT:xyz\"|},${6:string stringNeedBig},${7:boolean setNewValue})$0"
    },
    "RPR_GETSETENVELOPEINFO_STRING_WR python": {
        "prefix": "WR_RPR_GetSetEnvelopeInfo_String",
        "scope": "python",
        "description": "Gets/sets an attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope env},${3:String parmname},${4:String stringNeedBig},${5:Boolean setNewValue} = RPR_GetSetEnvelopeInfo_String(${6:env},${7:parmname},${8:stringNeedBig},${9:setNewValue})$0"
    },
    "GETSETENVELOPESTATE_WR c": {
        "prefix": "WR_GetSetEnvelopeState",
        "scope": "c",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:bool} = GetSetEnvelopeState(${2:TrackEnvelope* env},${3:char* str},${4:int str_sz})$0"
    },
    "GETSETENVELOPESTATE_WR eel2": {
        "prefix": "WR_GetSetEnvelopeState",
        "scope": "eel2",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:bool} = GetSetEnvelopeState(${2:TrackEnvelope env},${3:#str})$0"
    },
    "REAPER.GETSETENVELOPESTATE_WR lua": {
        "prefix": "reaperwr.GetSetEnvelopeState",
        "scope": "lua",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetSetEnvelopeState(${4:TrackEnvelope env},${5:string str})$0"
    },
    "RPR_GETSETENVELOPESTATE_WR python": {
        "prefix": "WR_RPR_GetSetEnvelopeState",
        "scope": "python",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope env},${3:String str},${4:Int str_sz} = RPR_GetSetEnvelopeState(${5:env},${6:str},${7:str_sz})$0"
    },
    "GETSETENVELOPESTATE2_WR c": {
        "prefix": "WR_GetSetEnvelopeState2",
        "scope": "c",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:bool} = GetSetEnvelopeState2(${2:TrackEnvelope* env},${3:char* str},${4:int str_sz},${5:bool isundo})$0"
    },
    "GETSETENVELOPESTATE2_WR eel2": {
        "prefix": "WR_GetSetEnvelopeState2",
        "scope": "eel2",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:bool} = GetSetEnvelopeState2(${2:TrackEnvelope env},${3:#str},${4:bool isundo})$0"
    },
    "REAPER.GETSETENVELOPESTATE2_WR lua": {
        "prefix": "reaperwr.GetSetEnvelopeState2",
        "scope": "lua",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetSetEnvelopeState2(${4:TrackEnvelope env},${5:string str},${6:boolean isundo})$0"
    },
    "RPR_GETSETENVELOPESTATE2_WR python": {
        "prefix": "WR_RPR_GetSetEnvelopeState2",
        "scope": "python",
        "description": "deprecated -- see SetEnvelopeStateChunk, GetEnvelopeStateChunk\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope env},${3:String str},${4:Int str_sz},${5:Boolean isundo} = RPR_GetSetEnvelopeState2(${6:env},${7:str},${8:str_sz},${9:isundo})$0"
    },
    "GETSETITEMSTATE_WR c": {
        "prefix": "WR_GetSetItemState",
        "scope": "c",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:bool} = GetSetItemState(${2:MediaItem* item},${3:char* str},${4:int str_sz})$0"
    },
    "GETSETITEMSTATE_WR eel2": {
        "prefix": "WR_GetSetItemState",
        "scope": "eel2",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:bool} = GetSetItemState(${2:MediaItem item},${3:#str})$0"
    },
    "REAPER.GETSETITEMSTATE_WR lua": {
        "prefix": "reaperwr.GetSetItemState",
        "scope": "lua",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetSetItemState(${4:MediaItem item},${5:string str})$0"
    },
    "RPR_GETSETITEMSTATE_WR python": {
        "prefix": "WR_RPR_GetSetItemState",
        "scope": "python",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:Boolean retval},${2:MediaItem item},${3:String str},${4:Int str_sz} = RPR_GetSetItemState(${5:item},${6:str},${7:str_sz})$0"
    },
    "GETSETITEMSTATE2_WR c": {
        "prefix": "WR_GetSetItemState2",
        "scope": "c",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:bool} = GetSetItemState2(${2:MediaItem* item},${3:char* str},${4:int str_sz},${5:bool isundo})$0"
    },
    "GETSETITEMSTATE2_WR eel2": {
        "prefix": "WR_GetSetItemState2",
        "scope": "eel2",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:bool} = GetSetItemState2(${2:MediaItem item},${3:#str},${4:bool isundo})$0"
    },
    "REAPER.GETSETITEMSTATE2_WR lua": {
        "prefix": "reaperwr.GetSetItemState2",
        "scope": "lua",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetSetItemState2(${4:MediaItem item},${5:string str},${6:boolean isundo})$0"
    },
    "RPR_GETSETITEMSTATE2_WR python": {
        "prefix": "WR_RPR_GetSetItemState2",
        "scope": "python",
        "description": "deprecated -- see SetItemStateChunk, GetItemStateChunk\n",
        "body": "${1:Boolean retval},${2:MediaItem item},${3:String str},${4:Int str_sz},${5:Boolean isundo} = RPR_GetSetItemState2(${6:item},${7:str},${8:str_sz},${9:isundo})$0"
    },
    "GETSETMEDIAITEMINFO_STRING_WR c": {
        "prefix": "WR_GetSetMediaItemInfo_String",
        "scope": "c",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:bool} = GetSetMediaItemInfo_String(${2:MediaItem* item},${3|const char* parmname,\"P_NOTES\",\"P_EXT:xyz\",\"GUID\"|},${4:char* stringNeedBig},${5:bool setNewValue})$0"
    },
    "GETSETMEDIAITEMINFO_STRING_WR eel2": {
        "prefix": "WR_GetSetMediaItemInfo_String",
        "scope": "eel2",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:bool} = GetSetMediaItemInfo_String(${2:MediaItem item},${3:\"parmname\"},${4:#stringNeedBig},${5:bool setNewValue})$0"
    },
    "REAPER.GETSETMEDIAITEMINFO_STRING_WR lua": {
        "prefix": "reaperwr.GetSetMediaItemInfo_String",
        "scope": "lua",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:local }${2:boolean retval},${3:string stringNeedBig} = reaper.GetSetMediaItemInfo_String(${4:MediaItem item},${5|string parmname,\"P_NOTES\",\"P_EXT:xyz\",\"GUID\"|},${6:string stringNeedBig},${7:boolean setNewValue})$0"
    },
    "RPR_GETSETMEDIAITEMINFO_STRING_WR python": {
        "prefix": "WR_RPR_GetSetMediaItemInfo_String",
        "scope": "python",
        "description": "Gets/sets an item attribute string:\nP_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:Boolean retval},${2:MediaItem item},${3:String parmname},${4:String stringNeedBig},${5:Boolean setNewValue} = RPR_GetSetMediaItemInfo_String(${6:item},${7:parmname},${8:stringNeedBig},${9:setNewValue})$0"
    },
    "GETSETMEDIAITEMTAKEINFO_STRING_WR c": {
        "prefix": "WR_GetSetMediaItemTakeInfo_String",
        "scope": "c",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:bool} = GetSetMediaItemTakeInfo_String(${2:MediaItem_Take* tk},${3|const char* parmname,\"P_NAME\",\"P_EXT:xyz\",\"GUID\"|},${4:char* stringNeedBig},${5:bool setNewValue})$0"
    },
    "GETSETMEDIAITEMTAKEINFO_STRING_WR eel2": {
        "prefix": "WR_GetSetMediaItemTakeInfo_String",
        "scope": "eel2",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:bool} = GetSetMediaItemTakeInfo_String(${2:MediaItem_Take tk},${3:\"parmname\"},${4:#stringNeedBig},${5:bool setNewValue})$0"
    },
    "REAPER.GETSETMEDIAITEMTAKEINFO_STRING_WR lua": {
        "prefix": "reaperwr.GetSetMediaItemTakeInfo_String",
        "scope": "lua",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:local }${2:boolean retval},${3:string stringNeedBig} = reaper.GetSetMediaItemTakeInfo_String(${4:MediaItem_Take tk},${5|string parmname,\"P_NAME\",\"P_EXT:xyz\",\"GUID\"|},${6:string stringNeedBig},${7:boolean setNewValue})$0"
    },
    "RPR_GETSETMEDIAITEMTAKEINFO_STRING_WR python": {
        "prefix": "WR_RPR_GetSetMediaItemTakeInfo_String",
        "scope": "python",
        "description": "Gets/sets a take attribute string:\nP_NAME : char * to take name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take tk},${3:String parmname},${4:String stringNeedBig},${5:Boolean setNewValue} = RPR_GetSetMediaItemTakeInfo_String(${6:tk},${7:parmname},${8:stringNeedBig},${9:setNewValue})$0"
    },
    "GETSETMEDIATRACKINFO_STRING_WR c": {
        "prefix": "WR_GetSetMediaTrackInfo_String",
        "scope": "c",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:bool} = GetSetMediaTrackInfo_String(${2:MediaTrack* tr},${3|const char* parmname,\"P_NAME\",\"P_ICON\",\"P_MCP_LAYOUT\",\"P_TCP_LAYOUT\",\"P_EXT:xyz\",\"GUID\"|},${4:char* stringNeedBig},${5:bool setNewValue})$0"
    },
    "GETSETMEDIATRACKINFO_STRING_WR eel2": {
        "prefix": "WR_GetSetMediaTrackInfo_String",
        "scope": "eel2",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:bool} = GetSetMediaTrackInfo_String(${2:MediaTrack tr},${3:\"parmname\"},${4:#stringNeedBig},${5:bool setNewValue})$0"
    },
    "REAPER.GETSETMEDIATRACKINFO_STRING_WR lua": {
        "prefix": "reaperwr.GetSetMediaTrackInfo_String",
        "scope": "lua",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:local }${2:boolean retval},${3:string stringNeedBig} = reaper.GetSetMediaTrackInfo_String(${4:MediaTrack tr},${5|string parmname,\"P_NAME\",\"P_ICON\",\"P_MCP_LAYOUT\",\"P_TCP_LAYOUT\",\"P_EXT:xyz\",\"GUID\"|},${6:string stringNeedBig},${7:boolean setNewValue})$0"
    },
    "RPR_GETSETMEDIATRACKINFO_STRING_WR python": {
        "prefix": "WR_RPR_GetSetMediaTrackInfo_String",
        "scope": "python",
        "description": "Get or set track string attributes.\nP_NAME : char * : track name (on master returns NULL)\nP_ICON : const char * : track icon (full filename, or relative to resource_path/data/track_icons)\nP_MCP_LAYOUT : const char * : layout name\nP_TCP_LAYOUT : const char * : layout name\nP_EXT:xyz : char * : extension-specific persistent data\nGUID : GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n",
        "body": "${1:Boolean retval},${2:MediaTrack tr},${3:String parmname},${4:String stringNeedBig},${5:Boolean setNewValue} = RPR_GetSetMediaTrackInfo_String(${6:tr},${7:parmname},${8:stringNeedBig},${9:setNewValue})$0"
    },
    "GETSETPROJECTAUTHOR_WR c": {
        "prefix": "WR_GetSetProjectAuthor",
        "scope": "c",
        "description": "gets or sets project author, author_sz is ignored when setting\n",
        "body": "${1:void} = GetSetProjectAuthor(${2:ReaProject* proj},${3:bool set},${4:char* author},${5:int author_sz})$0"
    },
    "REAPER.GETSETPROJECTAUTHOR_WR lua": {
        "prefix": "reaperwr.GetSetProjectAuthor",
        "scope": "lua",
        "description": "gets or sets project author, author_sz is ignored when setting\n",
        "body": "${1:local }${2:string author} = reaper.GetSetProjectAuthor(${3:ReaProject proj},${4:boolean set},${5:string author})$0"
    },
    "RPR_GETSETPROJECTAUTHOR_WR python": {
        "prefix": "WR_RPR_GetSetProjectAuthor",
        "scope": "python",
        "description": "gets or sets project author, author_sz is ignored when setting\n",
        "body": "${1:ReaProject proj},${2:Boolean set},${3:String author},${4:Int author_sz} = RPR_GetSetProjectAuthor(${5:proj},${6:set},${7:author},${8:author_sz})$0"
    },
    "GETSETPROJECTGRID_WR c": {
        "prefix": "WR_GetSetProjectGrid",
        "scope": "c",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "${1:int} = GetSetProjectGrid(${2:ReaProject* project},${3:bool set},${4:double* divisionInOutOptional},${5:int* swingmodeInOutOptional},${6:double* swingamtInOutOptional})$0"
    },
    "GETSETPROJECTGRID_WR eel2": {
        "prefix": "WR_GetSetProjectGrid",
        "scope": "eel2",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "${1:int} = GetSetProjectGrid(${2:ReaProject project},${3:bool set},${4:optional &division},${5:optional int &swingmode},${6:optional &swingamt})$0"
    },
    "REAPER.GETSETPROJECTGRID_WR lua": {
        "prefix": "reaperwr.GetSetProjectGrid",
        "scope": "lua",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "${1:local }${2:integer retval},${3:optional number division},${4:optional number swingmode},${5:optional number swingamt} = reaper.GetSetProjectGrid(${6:ReaProject project},${7:boolean set},${8:optional number division},${9:optional number swingmode},${10:optional number swingamt})$0"
    },
    "RPR_GETSETPROJECTGRID_WR python": {
        "prefix": "WR_RPR_GetSetProjectGrid",
        "scope": "python",
        "description": "Get or set the arrange view grid division. 0.25=quarter note,\n1.0/3.0=half note triplet, etc. swingmode can be 1 for swing enabled,\nswingamt is -1..1. swingmode can be 3 for measure-grid. Returns grid\nconfiguration flags\n",
        "body": "${1:Int retval},${2:ReaProject project},${3:Boolean set},${4:Float divisionInOutOptional},${5:Int swingmodeInOutOptional},${6:Float swingamtInOutOptional} = RPR_GetSetProjectGrid(${7:project},${8:set},${9:divisionInOutOptional},${10:swingmodeInOutOptional},${11:swingamtInOutOptional})$0"
    },
    "GETSETPROJECTINFO_WR c": {
        "prefix": "WR_GetSetProjectInfo",
        "scope": "c",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "${1:double} = GetSetProjectInfo(${2:ReaProject* project},${3|const char* desc,\"RENDER_SETTINGS\",\"RENDER_BOUNDSFLAG\",\"RENDER_CHANNELS\",\"RENDER_SRATE\",\"RENDER_STARTPOS\",\"RENDER_ENDPOS\",\"RENDER_TAILFLAG\",\"RENDER_TAILMS\",\"RENDER_ADDTOPROJ\",\"RENDER_DITHER\",\"PROJECT_SRATE\",\"PROJECT_SRATE_USE\"|},${4:double value},${5:bool is_set})$0"
    },
    "GETSETPROJECTINFO_WR eel2": {
        "prefix": "WR_GetSetProjectInfo",
        "scope": "eel2",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "${1:double} = GetSetProjectInfo(${2:ReaProject project},${3:\"desc\"},${4:value},${5:bool is_set})$0"
    },
    "REAPER.GETSETPROJECTINFO_WR lua": {
        "prefix": "reaperwr.GetSetProjectInfo",
        "scope": "lua",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "${1:local }${2:number} = reaper.GetSetProjectInfo(${3:ReaProject project},${4|string desc,\"RENDER_SETTINGS\",\"RENDER_BOUNDSFLAG\",\"RENDER_CHANNELS\",\"RENDER_SRATE\",\"RENDER_STARTPOS\",\"RENDER_ENDPOS\",\"RENDER_TAILFLAG\",\"RENDER_TAILMS\",\"RENDER_ADDTOPROJ\",\"RENDER_DITHER\",\"PROJECT_SRATE\",\"PROJECT_SRATE_USE\"|},${5:number value},${6:boolean is_set})$0"
    },
    "RPR_GETSETPROJECTINFO_WR python": {
        "prefix": "WR_RPR_GetSetProjectInfo",
        "scope": "python",
        "description": "Get or set project information.\nRENDER_SETTINGS : &(1|2)=0:master mix, &1=stems+master mix,\n&2=stems only, &4=multichannel tracks to multichannel files,\n&8=use render matrix, &16=tracks with only mono media to mono\nfiles, &32=selected media items, &64=selected media items via\nmaster\nRENDER_BOUNDSFLAG : 0=custom time bounds, 1=entire project, 2=time\nselection, 3=all project regions, 4=selected media items, 5=selected\nproject regions\nRENDER_CHANNELS : number of channels in rendered file\nRENDER_SRATE : sample rate of rendered file (or 0 for project sample rate)\nRENDER_STARTPOS : render start time when RENDER_BOUNDSFLAG=0\nRENDER_ENDPOS : render end time when RENDER_BOUNDSFLAG=0\nRENDER_TAILFLAG : apply render tail setting when rendering:\n&1=custom time bounds, &2=entire project, &4=time selection,\n&8=all project regions, &16=selected media items,\n&32=selected project regions\nRENDER_TAILMS : tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\nRENDER_ADDTOPROJ : 1=add rendered files to project\nRENDER_DITHER : &1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\nPROJECT_SRATE : samplerate (ignored unless PROJECT_SRATE_USE set)\nPROJECT_SRATE_USE : set to 1 if project samplerate is used\n",
        "body": "${1:Float} = RPR_GetSetProjectInfo(${2:ReaProject project},${3|String desc,\"RENDER_SETTINGS\",\"RENDER_BOUNDSFLAG\",\"RENDER_CHANNELS\",\"RENDER_SRATE\",\"RENDER_STARTPOS\",\"RENDER_ENDPOS\",\"RENDER_TAILFLAG\",\"RENDER_TAILMS\",\"RENDER_ADDTOPROJ\",\"RENDER_DITHER\",\"PROJECT_SRATE\",\"PROJECT_SRATE_USE\"|},${4:Float value},${5:Boolean is_set})$0"
    },
    "GETSETPROJECTINFO_STRING_WR c": {
        "prefix": "WR_GetSetProjectInfo_String",
        "scope": "c",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "${1:bool} = GetSetProjectInfo_String(${2:ReaProject* project},${3|const char* desc,\"MARKER_GUID:X\",\"RECORD_PATH\",\"RENDER_FILE\",\"RENDER_PATTERN\",\"RENDER_FORMAT\",\"RENDER_FORMAT2\"|},${4:char* valuestrNeedBig},${5:bool is_set})$0"
    },
    "GETSETPROJECTINFO_STRING_WR eel2": {
        "prefix": "WR_GetSetProjectInfo_String",
        "scope": "eel2",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "${1:bool} = GetSetProjectInfo_String(${2:ReaProject project},${3:\"desc\"},${4:#valuestrNeedBig},${5:bool is_set})$0"
    },
    "REAPER.GETSETPROJECTINFO_STRING_WR lua": {
        "prefix": "reaperwr.GetSetProjectInfo_String",
        "scope": "lua",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "${1:local }${2:boolean retval},${3:string valuestrNeedBig} = reaper.GetSetProjectInfo_String(${4:ReaProject project},${5|string desc,\"MARKER_GUID:X\",\"RECORD_PATH\",\"RENDER_FILE\",\"RENDER_PATTERN\",\"RENDER_FORMAT\",\"RENDER_FORMAT2\"|},${6:string valuestrNeedBig},${7:boolean is_set})$0"
    },
    "RPR_GETSETPROJECTINFO_STRING_WR python": {
        "prefix": "WR_RPR_GetSetProjectInfo_String",
        "scope": "python",
        "description": "Get or set project information.\nMARKER_GUID:X : get the GUID (unique ID) of the marker or region with\nindex X, where X is the index passed to EnumProjectMarkers, not\nnecessarily the displayed number\nRECORD_PATH : recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\nRENDER_FILE : render directory\nRENDER_PATTERN : render file name (may contain wildcards)\nRENDER_FORMAT : base64-encoded sink configuration (see project files,\netc). Callers can also pass a simple 4-byte string (non-base64-encoded),\ne.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\nRENDER_FORMAT2 : base64-encoded secondary sink configuration. Callers\ncan also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"\nor \"l3pm\", to use default settings for that sink type, or \"\" to disable\nsecondary render.\nFormats available on this machine:\n\"wave\" \"aiff\" \"iso \" \"ddp \" \"flac\" \"mp3l\" \"oggv\" \"OggS\" \"FFMP\" \"GIF \" \"LCF \" \"wvpk\"\n",
        "body": "${1:Boolean retval},${2:ReaProject project},${3:String desc},${4:String valuestrNeedBig},${5:Boolean is_set} = RPR_GetSetProjectInfo_String(${6:project},${7:desc},${8:valuestrNeedBig},${9:is_set})$0"
    },
    "GETSETPROJECTNOTES_WR c": {
        "prefix": "WR_GetSetProjectNotes",
        "scope": "c",
        "description": "gets or sets project notes, notesNeedBig_sz is ignored when setting\n",
        "body": "${1:void} = GetSetProjectNotes(${2:ReaProject* proj},${3:bool set},${4:char* notesNeedBig},${5:int notesNeedBig_sz})$0"
    },
    "REAPER.GETSETPROJECTNOTES_WR lua": {
        "prefix": "reaperwr.GetSetProjectNotes",
        "scope": "lua",
        "description": "gets or sets project notes, notesNeedBig_sz is ignored when setting\n",
        "body": "${1:local }${2:string notes} = reaper.GetSetProjectNotes(${3:ReaProject proj},${4:boolean set},${5:string notes})$0"
    },
    "RPR_GETSETPROJECTNOTES_WR python": {
        "prefix": "WR_RPR_GetSetProjectNotes",
        "scope": "python",
        "description": "gets or sets project notes, notesNeedBig_sz is ignored when setting\n",
        "body": "${1:ReaProject proj},${2:Boolean set},${3:String notesNeedBig},${4:Int notesNeedBig_sz} = RPR_GetSetProjectNotes(${5:proj},${6:set},${7:notesNeedBig},${8:notesNeedBig_sz})$0"
    },
    "GETSETREPEAT_WR c": {
        "prefix": "WR_GetSetRepeat",
        "scope": "c",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:int} = GetSetRepeat(${2:int val})$0"
    },
    "GETSETREPEAT_WR eel2": {
        "prefix": "WR_GetSetRepeat",
        "scope": "eel2",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:int} = GetSetRepeat(${2:int val})$0"
    },
    "REAPER.GETSETREPEAT_WR lua": {
        "prefix": "reaperwr.GetSetRepeat",
        "scope": "lua",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:local }${2:integer} = reaper.GetSetRepeat(${3:integer val})$0"
    },
    "RPR_GETSETREPEAT_WR python": {
        "prefix": "WR_RPR_GetSetRepeat",
        "scope": "python",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:Int} = RPR_GetSetRepeat(${2:Int val})$0"
    },
    "GETSETREPEATEX_WR c": {
        "prefix": "WR_GetSetRepeatEx",
        "scope": "c",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:int} = GetSetRepeatEx(${2:ReaProject* proj},${3:int val})$0"
    },
    "GETSETREPEATEX_WR eel2": {
        "prefix": "WR_GetSetRepeatEx",
        "scope": "eel2",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:int} = GetSetRepeatEx(${2:ReaProject proj},${3:int val})$0"
    },
    "REAPER.GETSETREPEATEX_WR lua": {
        "prefix": "reaperwr.GetSetRepeatEx",
        "scope": "lua",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:local }${2:integer} = reaper.GetSetRepeatEx(${3:ReaProject proj},${4:integer val})$0"
    },
    "RPR_GETSETREPEATEX_WR python": {
        "prefix": "WR_RPR_GetSetRepeatEx",
        "scope": "python",
        "description": "-1 == query,0=clear,1=set,>1=toggle . returns new value\n",
        "body": "${1:Int} = RPR_GetSetRepeatEx(${2:ReaProject proj},${3:Int val})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIP_WR c": {
        "prefix": "WR_GetSetTrackGroupMembership",
        "scope": "c",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:unsigned int} = GetSetTrackGroupMembership(${2:MediaTrack* tr},${3:const char* groupname},${4:unsigned int setmask},${5:unsigned int setvalue})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIP_WR eel2": {
        "prefix": "WR_GetSetTrackGroupMembership",
        "scope": "eel2",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:uint} = GetSetTrackGroupMembership(${2:MediaTrack tr},${3:\"groupname\"},${4:uint setmask},${5:uint setvalue})$0"
    },
    "REAPER.GETSETTRACKGROUPMEMBERSHIP_WR lua": {
        "prefix": "reaperwr.GetSetTrackGroupMembership",
        "scope": "lua",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:local }${2:integer} = reaper.GetSetTrackGroupMembership(${3:MediaTrack tr},${4:string groupname},${5:integer setmask},${6:integer setvalue})$0"
    },
    "RPR_GETSETTRACKGROUPMEMBERSHIP_WR python": {
        "prefix": "WR_RPR_GetSetTrackGroupMembership",
        "scope": "python",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:Unknown} = RPR_GetSetTrackGroupMembership(${2:MediaTrack tr},${3:String groupname},${4:Unknown setmask},${5:Unknown setvalue})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIPHIGH_WR c": {
        "prefix": "WR_GetSetTrackGroupMembershipHigh",
        "scope": "c",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:unsigned int} = GetSetTrackGroupMembershipHigh(${2:MediaTrack* tr},${3:const char* groupname},${4:unsigned int setmask},${5:unsigned int setvalue})$0"
    },
    "GETSETTRACKGROUPMEMBERSHIPHIGH_WR eel2": {
        "prefix": "WR_GetSetTrackGroupMembershipHigh",
        "scope": "eel2",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:uint} = GetSetTrackGroupMembershipHigh(${2:MediaTrack tr},${3:\"groupname\"},${4:uint setmask},${5:uint setvalue})$0"
    },
    "REAPER.GETSETTRACKGROUPMEMBERSHIPHIGH_WR lua": {
        "prefix": "reaperwr.GetSetTrackGroupMembershipHigh",
        "scope": "lua",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:local }${2:integer} = reaper.GetSetTrackGroupMembershipHigh(${3:MediaTrack tr},${4:string groupname},${5:integer setmask},${6:integer setvalue})$0"
    },
    "RPR_GETSETTRACKGROUPMEMBERSHIPHIGH_WR python": {
        "prefix": "WR_RPR_GetSetTrackGroupMembershipHigh",
        "scope": "python",
        "description": "Gets or modifies the group membership for a track. Returns group state\nprior to call (each bit represents one of the high 32 group numbers). if\nsetmask has bits set, those bits in setvalue will be applied to group.\nGroup can be one of:\nVOLUME_MASTER\nVOLUME_SLAVE\nVOLUME_VCA_MASTER\nVOLUME_VCA_SLAVE\nPAN_MASTER\nPAN_SLAVE\nWIDTH_MASTER\nWIDTH_SLAVE\nMUTE_MASTER\nMUTE_SLAVE\nSOLO_MASTER\nSOLO_SLAVE\nRECARM_MASTER\nRECARM_SLAVE\nPOLARITY_MASTER\nPOLARITY_SLAVE\nAUTOMODE_MASTER\nAUTOMODE_SLAVE\nVOLUME_REVERSE\nPAN_REVERSE\nWIDTH_REVERSE\nNO_MASTER_WHEN_SLAVE\nVOLUME_VCA_SLAVE_ISPREFX\n",
        "body": "${1:Unknown} = RPR_GetSetTrackGroupMembershipHigh(${2:MediaTrack tr},${3:String groupname},${4:Unknown setmask},${5:Unknown setvalue})$0"
    },
    "GETSETTRACKSENDINFO_STRING_WR c": {
        "prefix": "WR_GetSetTrackSendInfo_String",
        "scope": "c",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:bool} = GetSetTrackSendInfo_String(${2:MediaTrack* tr},${3:int category},${4:int sendidx},${5|const char* parmname,\"P_EXT:xyz\"|},${6:char* stringNeedBig},${7:bool setNewValue})$0"
    },
    "GETSETTRACKSENDINFO_STRING_WR eel2": {
        "prefix": "WR_GetSetTrackSendInfo_String",
        "scope": "eel2",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:bool} = GetSetTrackSendInfo_String(${2:MediaTrack tr},${3:int category},${4:int sendidx},${5:\"parmname\"},${6:#stringNeedBig},${7:bool setNewValue})$0"
    },
    "REAPER.GETSETTRACKSENDINFO_STRING_WR lua": {
        "prefix": "reaperwr.GetSetTrackSendInfo_String",
        "scope": "lua",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:local }${2:boolean retval},${3:string stringNeedBig} = reaper.GetSetTrackSendInfo_String(${4:MediaTrack tr},${5:integer category},${6:integer sendidx},${7|string parmname,\"P_EXT:xyz\"|},${8:string stringNeedBig},${9:boolean setNewValue})$0"
    },
    "RPR_GETSETTRACKSENDINFO_STRING_WR python": {
        "prefix": "WR_RPR_GetSetTrackSendInfo_String",
        "scope": "python",
        "description": "Gets/sets a send attribute string:\nP_EXT:xyz : char * : extension-specific persistent data\n",
        "body": "${1:Boolean retval},${2:MediaTrack tr},${3:Int category},${4:Int sendidx},${5:String parmname},${6:String stringNeedBig},${7:Boolean setNewValue} = RPR_GetSetTrackSendInfo_String(${8:tr},${9:category},${10:sendidx},${11:parmname},${12:stringNeedBig},${13:setNewValue})$0"
    },
    "GETSETTRACKSTATE_WR c": {
        "prefix": "WR_GetSetTrackState",
        "scope": "c",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:bool} = GetSetTrackState(${2:MediaTrack* track},${3:char* str},${4:int str_sz})$0"
    },
    "GETSETTRACKSTATE_WR eel2": {
        "prefix": "WR_GetSetTrackState",
        "scope": "eel2",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:bool} = GetSetTrackState(${2:MediaTrack track},${3:#str})$0"
    },
    "REAPER.GETSETTRACKSTATE_WR lua": {
        "prefix": "reaperwr.GetSetTrackState",
        "scope": "lua",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetSetTrackState(${4:MediaTrack track},${5:string str})$0"
    },
    "RPR_GETSETTRACKSTATE_WR python": {
        "prefix": "WR_RPR_GetSetTrackState",
        "scope": "python",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:String str},${4:Int str_sz} = RPR_GetSetTrackState(${5:track},${6:str},${7:str_sz})$0"
    },
    "GETSETTRACKSTATE2_WR c": {
        "prefix": "WR_GetSetTrackState2",
        "scope": "c",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:bool} = GetSetTrackState2(${2:MediaTrack* track},${3:char* str},${4:int str_sz},${5:bool isundo})$0"
    },
    "GETSETTRACKSTATE2_WR eel2": {
        "prefix": "WR_GetSetTrackState2",
        "scope": "eel2",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:bool} = GetSetTrackState2(${2:MediaTrack track},${3:#str},${4:bool isundo})$0"
    },
    "REAPER.GETSETTRACKSTATE2_WR lua": {
        "prefix": "reaperwr.GetSetTrackState2",
        "scope": "lua",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetSetTrackState2(${4:MediaTrack track},${5:string str},${6:boolean isundo})$0"
    },
    "RPR_GETSETTRACKSTATE2_WR python": {
        "prefix": "WR_RPR_GetSetTrackState2",
        "scope": "python",
        "description": "deprecated -- see SetTrackStateChunk, GetTrackStateChunk\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:String str},${4:Int str_sz},${5:Boolean isundo} = RPR_GetSetTrackState2(${6:track},${7:str},${8:str_sz},${9:isundo})$0"
    },
    "GETSUBPROJECTFROMSOURCE_WR c": {
        "prefix": "WR_GetSubProjectFromSource",
        "scope": "c",
        "description": "\n",
        "body": "${1:ReaProject*} = GetSubProjectFromSource(${2:PCM_source* src})$0"
    },
    "GETSUBPROJECTFROMSOURCE_WR eel2": {
        "prefix": "WR_GetSubProjectFromSource",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:ReaProject} = GetSubProjectFromSource(${2:PCM_source src})$0"
    },
    "REAPER.GETSUBPROJECTFROMSOURCE_WR lua": {
        "prefix": "reaperwr.GetSubProjectFromSource",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:ReaProject} = reaper.GetSubProjectFromSource(${3:PCM_source src})$0"
    },
    "RPR_GETSUBPROJECTFROMSOURCE_WR python": {
        "prefix": "WR_RPR_GetSubProjectFromSource",
        "scope": "python",
        "description": "\n",
        "body": "${1:ReaProject} = RPR_GetSubProjectFromSource(${2:PCM_source src})$0"
    },
    "GETTAKE_WR c": {
        "prefix": "WR_GetTake",
        "scope": "c",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "${1:MediaItem_Take*} = GetTake(${2:MediaItem* item},${3:int takeidx})$0"
    },
    "GETTAKE_WR eel2": {
        "prefix": "WR_GetTake",
        "scope": "eel2",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "${1:MediaItem_Take} = GetTake(${2:MediaItem item},${3:int takeidx})$0"
    },
    "REAPER.GETTAKE_WR lua": {
        "prefix": "reaperwr.GetTake",
        "scope": "lua",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.GetTake(${3:MediaItem item},${4:integer takeidx})$0"
    },
    "RPR_GETTAKE_WR python": {
        "prefix": "WR_RPR_GetTake",
        "scope": "python",
        "description": "get a take from an item by take count (zero-based)\n",
        "body": "${1:MediaItem_Take} = RPR_GetTake(${2:MediaItem item},${3:Int takeidx})$0"
    },
    "GETTAKEENVELOPE_WR c": {
        "prefix": "WR_GetTakeEnvelope",
        "scope": "c",
        "description": "\n",
        "body": "${1:TrackEnvelope*} = GetTakeEnvelope(${2:MediaItem_Take* take},${3:int envidx})$0"
    },
    "GETTAKEENVELOPE_WR eel2": {
        "prefix": "WR_GetTakeEnvelope",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:TrackEnvelope} = GetTakeEnvelope(${2:MediaItem_Take take},${3:int envidx})$0"
    },
    "REAPER.GETTAKEENVELOPE_WR lua": {
        "prefix": "reaperwr.GetTakeEnvelope",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetTakeEnvelope(${3:MediaItem_Take take},${4:integer envidx})$0"
    },
    "RPR_GETTAKEENVELOPE_WR python": {
        "prefix": "WR_RPR_GetTakeEnvelope",
        "scope": "python",
        "description": "\n",
        "body": "${1:TrackEnvelope} = RPR_GetTakeEnvelope(${2:MediaItem_Take take},${3:Int envidx})$0"
    },
    "GETTAKEENVELOPEBYNAME_WR c": {
        "prefix": "WR_GetTakeEnvelopeByName",
        "scope": "c",
        "description": "\n",
        "body": "${1:TrackEnvelope*} = GetTakeEnvelopeByName(${2:MediaItem_Take* take},${3:const char* envname})$0"
    },
    "GETTAKEENVELOPEBYNAME_WR eel2": {
        "prefix": "WR_GetTakeEnvelopeByName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:TrackEnvelope} = GetTakeEnvelopeByName(${2:MediaItem_Take take},${3:\"envname\"})$0"
    },
    "REAPER.GETTAKEENVELOPEBYNAME_WR lua": {
        "prefix": "reaperwr.GetTakeEnvelopeByName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetTakeEnvelopeByName(${3:MediaItem_Take take},${4:string envname})$0"
    },
    "RPR_GETTAKEENVELOPEBYNAME_WR python": {
        "prefix": "WR_RPR_GetTakeEnvelopeByName",
        "scope": "python",
        "description": "\n",
        "body": "${1:TrackEnvelope} = RPR_GetTakeEnvelopeByName(${2:MediaItem_Take take},${3:String envname})$0"
    },
    "GETTAKENAME_WR c": {
        "prefix": "WR_GetTakeName",
        "scope": "c",
        "description": "returns NULL if the take is not valid\n",
        "body": "${1:const char*} = GetTakeName(${2:MediaItem_Take* take})$0"
    },
    "GETTAKENAME_WR eel2": {
        "prefix": "WR_GetTakeName",
        "scope": "eel2",
        "description": "returns NULL if the take is not valid\n",
        "body": "${1:bool} = GetTakeName(${2:#retval},${3:MediaItem_Take take})$0"
    },
    "REAPER.GETTAKENAME_WR lua": {
        "prefix": "reaperwr.GetTakeName",
        "scope": "lua",
        "description": "returns NULL if the take is not valid\n",
        "body": "${1:local }${2:string} = reaper.GetTakeName(${3:MediaItem_Take take})$0"
    },
    "RPR_GETTAKENAME_WR python": {
        "prefix": "WR_RPR_GetTakeName",
        "scope": "python",
        "description": "returns NULL if the take is not valid\n",
        "body": "${1:String} = RPR_GetTakeName(${2:MediaItem_Take take})$0"
    },
    "GETTAKENUMSTRETCHMARKERS_WR c": {
        "prefix": "WR_GetTakeNumStretchMarkers",
        "scope": "c",
        "description": "Returns number of stretch markers in take\n",
        "body": "${1:int} = GetTakeNumStretchMarkers(${2:MediaItem_Take* take})$0"
    },
    "GETTAKENUMSTRETCHMARKERS_WR eel2": {
        "prefix": "WR_GetTakeNumStretchMarkers",
        "scope": "eel2",
        "description": "Returns number of stretch markers in take\n",
        "body": "${1:int} = GetTakeNumStretchMarkers(${2:MediaItem_Take take})$0"
    },
    "REAPER.GETTAKENUMSTRETCHMARKERS_WR lua": {
        "prefix": "reaperwr.GetTakeNumStretchMarkers",
        "scope": "lua",
        "description": "Returns number of stretch markers in take\n",
        "body": "${1:local }${2:integer} = reaper.GetTakeNumStretchMarkers(${3:MediaItem_Take take})$0"
    },
    "RPR_GETTAKENUMSTRETCHMARKERS_WR python": {
        "prefix": "WR_RPR_GetTakeNumStretchMarkers",
        "scope": "python",
        "description": "Returns number of stretch markers in take\n",
        "body": "${1:Int} = RPR_GetTakeNumStretchMarkers(${2:MediaItem_Take take})$0"
    },
    "GETTAKESTRETCHMARKER_WR c": {
        "prefix": "WR_GetTakeStretchMarker",
        "scope": "c",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "${1:int} = GetTakeStretchMarker(${2:MediaItem_Take* take},${3:int idx},${4:double* posOut},${5:double* srcposOutOptional})$0"
    },
    "GETTAKESTRETCHMARKER_WR eel2": {
        "prefix": "WR_GetTakeStretchMarker",
        "scope": "eel2",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "${1:int} = GetTakeStretchMarker(${2:MediaItem_Take take},${3:int idx},${4:&pos},${5:optional &srcpos})$0"
    },
    "REAPER.GETTAKESTRETCHMARKER_WR lua": {
        "prefix": "reaperwr.GetTakeStretchMarker",
        "scope": "lua",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "${1:local }${2:integer retval},${3:number pos},${4:optional number srcpos} = reaper.GetTakeStretchMarker(${5:MediaItem_Take take},${6:integer idx})$0"
    },
    "RPR_GETTAKESTRETCHMARKER_WR python": {
        "prefix": "WR_RPR_GetTakeStretchMarker",
        "scope": "python",
        "description": "Gets information on a stretch marker, idx is 0..n. Returns false if\nstretch marker not valid. posOut will be set to position in item,\nsrcposOutOptional will be set to source media position. Returns index.\nif input index is -1, next marker is found using position (or source\nposition if position is -1). If position/source position are used to\nfind marker position, their values are not updated.\n",
        "body": "${1:Int retval},${2:MediaItem_Take take},${3:Int idx},${4:Float posOut},${5:Float srcposOutOptional} = RPR_GetTakeStretchMarker(${6:take},${7:idx},${8:posOut},${9:srcposOutOptional})$0"
    },
    "GETTAKESTRETCHMARKERSLOPE_WR c": {
        "prefix": "WR_GetTakeStretchMarkerSlope",
        "scope": "c",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "${1:double} = GetTakeStretchMarkerSlope(${2:MediaItem_Take* take},${3:int idx})$0"
    },
    "GETTAKESTRETCHMARKERSLOPE_WR eel2": {
        "prefix": "WR_GetTakeStretchMarkerSlope",
        "scope": "eel2",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "${1:double} = GetTakeStretchMarkerSlope(${2:MediaItem_Take take},${3:int idx})$0"
    },
    "REAPER.GETTAKESTRETCHMARKERSLOPE_WR lua": {
        "prefix": "reaperwr.GetTakeStretchMarkerSlope",
        "scope": "lua",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "${1:local }${2:number} = reaper.GetTakeStretchMarkerSlope(${3:MediaItem_Take take},${4:integer idx})$0"
    },
    "RPR_GETTAKESTRETCHMARKERSLOPE_WR python": {
        "prefix": "WR_RPR_GetTakeStretchMarkerSlope",
        "scope": "python",
        "description": "See SetTakeStretchMarkerSlope\n",
        "body": "${1:Float} = RPR_GetTakeStretchMarkerSlope(${2:MediaItem_Take take},${3:Int idx})$0"
    },
    "GETTCPFXPARM_WR c": {
        "prefix": "WR_GetTCPFXParm",
        "scope": "c",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "${1:bool} = GetTCPFXParm(${2:ReaProject* project},${3:MediaTrack* track},${4:int index},${5:int* fxindexOut},${6:int* parmidxOut})$0"
    },
    "GETTCPFXPARM_WR eel2": {
        "prefix": "WR_GetTCPFXParm",
        "scope": "eel2",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "${1:bool} = GetTCPFXParm(${2:ReaProject project},${3:MediaTrack track},${4:int index},${5:int &fxindex},${6:int &parmidx})$0"
    },
    "REAPER.GETTCPFXPARM_WR lua": {
        "prefix": "reaperwr.GetTCPFXParm",
        "scope": "lua",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "${1:local }${2:boolean retval},${3:number fxindex},${4:number parmidx} = reaper.GetTCPFXParm(${5:ReaProject project},${6:MediaTrack track},${7:integer index})$0"
    },
    "RPR_GETTCPFXPARM_WR python": {
        "prefix": "WR_RPR_GetTCPFXParm",
        "scope": "python",
        "description": "Get information about a specific FX parameter knob (see CountTCPFXParms).\n",
        "body": "${1:Boolean retval},${2:ReaProject project},${3:MediaTrack track},${4:Int index},${5:Int fxindexOut},${6:Int parmidxOut} = RPR_GetTCPFXParm(${7:project},${8:track},${9:index},${10:fxindexOut},${11:parmidxOut})$0"
    },
    "GETTEMPOMATCHPLAYRATE_WR c": {
        "prefix": "WR_GetTempoMatchPlayRate",
        "scope": "c",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "${1:bool} = GetTempoMatchPlayRate(${2:PCM_source* source},${3:double srcscale},${4:double position},${5:double mult},${6:double* rateOut},${7:double* targetlenOut})$0"
    },
    "GETTEMPOMATCHPLAYRATE_WR eel2": {
        "prefix": "WR_GetTempoMatchPlayRate",
        "scope": "eel2",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "${1:bool} = GetTempoMatchPlayRate(${2:PCM_source source},${3:srcscale},${4:position},${5:mult},${6:&rate},${7:&targetlen})$0"
    },
    "REAPER.GETTEMPOMATCHPLAYRATE_WR lua": {
        "prefix": "reaperwr.GetTempoMatchPlayRate",
        "scope": "lua",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "${1:local }${2:boolean retval},${3:number rate},${4:number targetlen} = reaper.GetTempoMatchPlayRate(${5:PCM_source source},${6:number srcscale},${7:number position},${8:number mult})$0"
    },
    "RPR_GETTEMPOMATCHPLAYRATE_WR python": {
        "prefix": "WR_RPR_GetTempoMatchPlayRate",
        "scope": "python",
        "description": "finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256\n",
        "body": "${1:Boolean retval},${2:PCM_source source},${3:Float srcscale},${4:Float position},${5:Float mult},${6:Float rateOut},${7:Float targetlenOut} = RPR_GetTempoMatchPlayRate(${8:source},${9:srcscale},${10:position},${11:mult},${12:rateOut},${13:targetlenOut})$0"
    },
    "GETTEMPOTIMESIGMARKER_WR c": {
        "prefix": "WR_GetTempoTimeSigMarker",
        "scope": "c",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:bool} = GetTempoTimeSigMarker(${2:ReaProject* proj},${3:int ptidx},${4:double* timeposOut},${5:int* measureposOut},${6:double* beatposOut},${7:double* bpmOut},${8:int* timesig_numOut},${9:int* timesig_denomOut},${10:bool* lineartempoOut})$0"
    },
    "GETTEMPOTIMESIGMARKER_WR eel2": {
        "prefix": "WR_GetTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:bool} = GetTempoTimeSigMarker(${2:ReaProject proj},${3:int ptidx},${4:&timepos},${5:int &measurepos},${6:&beatpos},${7:&bpm},${8:int &timesig_num},${9:int &timesig_denom},${10:bool &lineartempo})$0"
    },
    "REAPER.GETTEMPOTIMESIGMARKER_WR lua": {
        "prefix": "reaperwr.GetTempoTimeSigMarker",
        "scope": "lua",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:local }${2:boolean retval},${3:number timepos},${4:number measurepos},${5:number beatpos},${6:number bpm},${7:number timesig_num},${8:number timesig_denom},${9:boolean lineartempo} = reaper.GetTempoTimeSigMarker(${10:ReaProject proj},${11:integer ptidx})$0"
    },
    "RPR_GETTEMPOTIMESIGMARKER_WR python": {
        "prefix": "WR_RPR_GetTempoTimeSigMarker",
        "scope": "python",
        "description": "Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:Boolean retval},${2:ReaProject proj},${3:Int ptidx},${4:Float timeposOut},${5:Int measureposOut},${6:Float beatposOut},${7:Float bpmOut},${8:Int timesig_numOut},${9:Int timesig_denomOut},${10:Boolean lineartempoOut} = RPR_GetTempoTimeSigMarker(${11:proj},${12:ptidx},${13:timeposOut},${14:measureposOut},${15:beatposOut},${16:bpmOut},${17:timesig_numOut},${18:timesig_denomOut},${19:lineartempoOut})$0"
    },
    "GETTOGGLECOMMANDSTATE_WR c": {
        "prefix": "WR_GetToggleCommandState",
        "scope": "c",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "${1:int} = GetToggleCommandState(${2:int command_id})$0"
    },
    "GETTOGGLECOMMANDSTATE_WR eel2": {
        "prefix": "WR_GetToggleCommandState",
        "scope": "eel2",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "${1:int} = GetToggleCommandState(${2:int command_id})$0"
    },
    "REAPER.GETTOGGLECOMMANDSTATE_WR lua": {
        "prefix": "reaperwr.GetToggleCommandState",
        "scope": "lua",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "${1:local }${2:integer} = reaper.GetToggleCommandState(${3:integer command_id})$0"
    },
    "RPR_GETTOGGLECOMMANDSTATE_WR python": {
        "prefix": "WR_RPR_GetToggleCommandState",
        "scope": "python",
        "description": "See GetToggleCommandStateEx.\n",
        "body": "${1:Int} = RPR_GetToggleCommandState(${2:Int command_id})$0"
    },
    "GETTOGGLECOMMANDSTATEEX_WR c": {
        "prefix": "WR_GetToggleCommandStateEx",
        "scope": "c",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "${1:int} = GetToggleCommandStateEx(${2:int section_id},${3:int command_id})$0"
    },
    "GETTOGGLECOMMANDSTATEEX_WR eel2": {
        "prefix": "WR_GetToggleCommandStateEx",
        "scope": "eel2",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "${1:int} = GetToggleCommandStateEx(${2:int section_id},${3:int command_id})$0"
    },
    "REAPER.GETTOGGLECOMMANDSTATEEX_WR lua": {
        "prefix": "reaperwr.GetToggleCommandStateEx",
        "scope": "lua",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "${1:local }${2:integer} = reaper.GetToggleCommandStateEx(${3:integer section_id},${4:integer command_id})$0"
    },
    "RPR_GETTOGGLECOMMANDSTATEEX_WR python": {
        "prefix": "WR_RPR_GetToggleCommandStateEx",
        "scope": "python",
        "description": "For the main action context, the MIDI editor, or the media explorer,\nreturns the toggle state of the action. 0=off, 1=on, -1=NA because the\naction does not have on/off states. For the MIDI editor, the action\nstate for the most recently focused window will be returned.\n",
        "body": "${1:Int} = RPR_GetToggleCommandStateEx(${2:Int section_id},${3:Int command_id})$0"
    },
    "GETTOOLTIPWINDOW_WR c": {
        "prefix": "WR_GetTooltipWindow",
        "scope": "c",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "${1:HWND} = GetTooltipWindow()$0"
    },
    "GETTOOLTIPWINDOW_WR eel2": {
        "prefix": "WR_GetTooltipWindow",
        "scope": "eel2",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "${1:HWND} = GetTooltipWindow()$0"
    },
    "REAPER.GETTOOLTIPWINDOW_WR lua": {
        "prefix": "reaperwr.GetTooltipWindow",
        "scope": "lua",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "${1:local }${2:HWND} = reaper.GetTooltipWindow()$0"
    },
    "RPR_GETTOOLTIPWINDOW_WR python": {
        "prefix": "WR_RPR_GetTooltipWindow",
        "scope": "python",
        "description": "gets a tooltip window,in case you want to ask it for font information. Can return NULL.\n",
        "body": "${1:HWND} = RPR_GetTooltipWindow()$0"
    },
    "GETTRACK_WR c": {
        "prefix": "WR_GetTrack",
        "scope": "c",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaTrack*} = GetTrack(${2:ReaProject* proj},${3:int trackidx})$0"
    },
    "GETTRACK_WR eel2": {
        "prefix": "WR_GetTrack",
        "scope": "eel2",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaTrack} = GetTrack(${2:ReaProject proj},${3:int trackidx})$0"
    },
    "REAPER.GETTRACK_WR lua": {
        "prefix": "reaperwr.GetTrack",
        "scope": "lua",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "${1:local }${2:MediaTrack} = reaper.GetTrack(${3:ReaProject proj},${4:integer trackidx})$0"
    },
    "RPR_GETTRACK_WR python": {
        "prefix": "WR_RPR_GetTrack",
        "scope": "python",
        "description": "get a track from a project by track count (zero-based) (proj=0 for active project)\n",
        "body": "${1:MediaTrack} = RPR_GetTrack(${2:ReaProject proj},${3:Int trackidx})$0"
    },
    "GETTRACKAUTOMATIONMODE_WR c": {
        "prefix": "WR_GetTrackAutomationMode",
        "scope": "c",
        "description": "return the track mode, regardless of global override\n",
        "body": "${1:int} = GetTrackAutomationMode(${2:MediaTrack* tr})$0"
    },
    "GETTRACKAUTOMATIONMODE_WR eel2": {
        "prefix": "WR_GetTrackAutomationMode",
        "scope": "eel2",
        "description": "return the track mode, regardless of global override\n",
        "body": "${1:int} = GetTrackAutomationMode(${2:MediaTrack tr})$0"
    },
    "REAPER.GETTRACKAUTOMATIONMODE_WR lua": {
        "prefix": "reaperwr.GetTrackAutomationMode",
        "scope": "lua",
        "description": "return the track mode, regardless of global override\n",
        "body": "${1:local }${2:integer} = reaper.GetTrackAutomationMode(${3:MediaTrack tr})$0"
    },
    "RPR_GETTRACKAUTOMATIONMODE_WR python": {
        "prefix": "WR_RPR_GetTrackAutomationMode",
        "scope": "python",
        "description": "return the track mode, regardless of global override\n",
        "body": "${1:Int} = RPR_GetTrackAutomationMode(${2:MediaTrack tr})$0"
    },
    "GETTRACKCOLOR_WR c": {
        "prefix": "WR_GetTrackColor",
        "scope": "c",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "${1:int} = GetTrackColor(${2:MediaTrack* track})$0"
    },
    "GETTRACKCOLOR_WR eel2": {
        "prefix": "WR_GetTrackColor",
        "scope": "eel2",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "${1:int} = GetTrackColor(${2:MediaTrack track})$0"
    },
    "REAPER.GETTRACKCOLOR_WR lua": {
        "prefix": "reaperwr.GetTrackColor",
        "scope": "lua",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "${1:local }${2:integer} = reaper.GetTrackColor(${3:MediaTrack track})$0"
    },
    "RPR_GETTRACKCOLOR_WR python": {
        "prefix": "WR_RPR_GetTrackColor",
        "scope": "python",
        "description": "Returns the track custom color as OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). Black is returned as 0x01000000, no\ncolor setting is returned as 0.\n",
        "body": "${1:Int} = RPR_GetTrackColor(${2:MediaTrack track})$0"
    },
    "GETTRACKDEPTH_WR c": {
        "prefix": "WR_GetTrackDepth",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = GetTrackDepth(${2:MediaTrack* track})$0"
    },
    "GETTRACKDEPTH_WR eel2": {
        "prefix": "WR_GetTrackDepth",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = GetTrackDepth(${2:MediaTrack track})$0"
    },
    "REAPER.GETTRACKDEPTH_WR lua": {
        "prefix": "reaperwr.GetTrackDepth",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.GetTrackDepth(${3:MediaTrack track})$0"
    },
    "RPR_GETTRACKDEPTH_WR python": {
        "prefix": "WR_RPR_GetTrackDepth",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_GetTrackDepth(${2:MediaTrack track})$0"
    },
    "GETTRACKENVELOPE_WR c": {
        "prefix": "WR_GetTrackEnvelope",
        "scope": "c",
        "description": "\n",
        "body": "${1:TrackEnvelope*} = GetTrackEnvelope(${2:MediaTrack* track},${3:int envidx})$0"
    },
    "GETTRACKENVELOPE_WR eel2": {
        "prefix": "WR_GetTrackEnvelope",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:TrackEnvelope} = GetTrackEnvelope(${2:MediaTrack track},${3:int envidx})$0"
    },
    "REAPER.GETTRACKENVELOPE_WR lua": {
        "prefix": "reaperwr.GetTrackEnvelope",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetTrackEnvelope(${3:MediaTrack track},${4:integer envidx})$0"
    },
    "RPR_GETTRACKENVELOPE_WR python": {
        "prefix": "WR_RPR_GetTrackEnvelope",
        "scope": "python",
        "description": "\n",
        "body": "${1:TrackEnvelope} = RPR_GetTrackEnvelope(${2:MediaTrack track},${3:Int envidx})$0"
    },
    "GETTRACKENVELOPEBYCHUNKNAME_WR c": {
        "prefix": "WR_GetTrackEnvelopeByChunkName",
        "scope": "c",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "${1:TrackEnvelope*} = GetTrackEnvelopeByChunkName(${2:MediaTrack* tr},${3:const char* cfgchunkname})$0"
    },
    "GETTRACKENVELOPEBYCHUNKNAME_WR eel2": {
        "prefix": "WR_GetTrackEnvelopeByChunkName",
        "scope": "eel2",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "${1:TrackEnvelope} = GetTrackEnvelopeByChunkName(${2:MediaTrack tr},${3:\"cfgchunkname\"})$0"
    },
    "REAPER.GETTRACKENVELOPEBYCHUNKNAME_WR lua": {
        "prefix": "reaperwr.GetTrackEnvelopeByChunkName",
        "scope": "lua",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetTrackEnvelopeByChunkName(${3:MediaTrack tr},${4:string cfgchunkname})$0"
    },
    "RPR_GETTRACKENVELOPEBYCHUNKNAME_WR python": {
        "prefix": "WR_RPR_GetTrackEnvelopeByChunkName",
        "scope": "python",
        "description": "Gets a built-in track envelope by configuration chunk name, e.g. \"<VOLENV\".\n",
        "body": "${1:TrackEnvelope} = RPR_GetTrackEnvelopeByChunkName(${2:MediaTrack tr},${3:String cfgchunkname})$0"
    },
    "GETTRACKENVELOPEBYNAME_WR c": {
        "prefix": "WR_GetTrackEnvelopeByName",
        "scope": "c",
        "description": "\n",
        "body": "${1:TrackEnvelope*} = GetTrackEnvelopeByName(${2:MediaTrack* track},${3:const char* envname})$0"
    },
    "GETTRACKENVELOPEBYNAME_WR eel2": {
        "prefix": "WR_GetTrackEnvelopeByName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:TrackEnvelope} = GetTrackEnvelopeByName(${2:MediaTrack track},${3:\"envname\"})$0"
    },
    "REAPER.GETTRACKENVELOPEBYNAME_WR lua": {
        "prefix": "reaperwr.GetTrackEnvelopeByName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.GetTrackEnvelopeByName(${3:MediaTrack track},${4:string envname})$0"
    },
    "RPR_GETTRACKENVELOPEBYNAME_WR python": {
        "prefix": "WR_RPR_GetTrackEnvelopeByName",
        "scope": "python",
        "description": "\n",
        "body": "${1:TrackEnvelope} = RPR_GetTrackEnvelopeByName(${2:MediaTrack track},${3:String envname})$0"
    },
    "GETTRACKFROMPOINT_WR c": {
        "prefix": "WR_GetTrackFromPoint",
        "scope": "c",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "${1:MediaTrack*} = GetTrackFromPoint(${2:int screen_x},${3:int screen_y},${4:int* infoOutOptional})$0"
    },
    "GETTRACKFROMPOINT_WR eel2": {
        "prefix": "WR_GetTrackFromPoint",
        "scope": "eel2",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "${1:MediaTrack} = GetTrackFromPoint(${2:int screen_x},${3:int screen_y},${4:optional int &info})$0"
    },
    "REAPER.GETTRACKFROMPOINT_WR lua": {
        "prefix": "reaperwr.GetTrackFromPoint",
        "scope": "lua",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "${1:local }${2:MediaTrack retval},${3:optional number info} = reaper.GetTrackFromPoint(${4:integer screen_x},${5:integer screen_y})$0"
    },
    "RPR_GETTRACKFROMPOINT_WR python": {
        "prefix": "WR_RPR_GetTrackFromPoint",
        "scope": "python",
        "description": "Returns the track from the screen coordinates specified. If the screen\ncoordinates refer to a window associated to the track (such as FX), the\ntrack will be returned. infoOutOptional will be set to 1 if it is likely\nan envelope, 2 if it is likely a track FX.\n",
        "body": "${1:MediaTrack retval},${2:Int screen_x},${3:Int screen_y},${4:Int infoOutOptional} = RPR_GetTrackFromPoint(${5:screen_x},${6:screen_y},${7:infoOutOptional})$0"
    },
    "GETTRACKGUID_WR c": {
        "prefix": "WR_GetTrackGUID",
        "scope": "c",
        "description": "\n",
        "body": "${1:GUID*} = GetTrackGUID(${2:MediaTrack* tr})$0"
    },
    "GETTRACKGUID_WR eel2": {
        "prefix": "WR_GetTrackGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetTrackGUID(${2:#retguid},${3:MediaTrack tr})$0"
    },
    "REAPER.GETTRACKGUID_WR lua": {
        "prefix": "reaperwr.GetTrackGUID",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string GUID} = reaper.GetTrackGUID(${3:MediaTrack tr})$0"
    },
    "RPR_GETTRACKGUID_WR python": {
        "prefix": "WR_RPR_GetTrackGUID",
        "scope": "python",
        "description": "\n",
        "body": "${1:GUID} = RPR_GetTrackGUID(${2:MediaTrack tr})$0"
    },
    "GETTRACKMEDIAITEM_WR c": {
        "prefix": "WR_GetTrackMediaItem",
        "scope": "c",
        "description": "\n",
        "body": "${1:MediaItem*} = GetTrackMediaItem(${2:MediaTrack* tr},${3:int itemidx})$0"
    },
    "GETTRACKMEDIAITEM_WR eel2": {
        "prefix": "WR_GetTrackMediaItem",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:MediaItem} = GetTrackMediaItem(${2:MediaTrack tr},${3:int itemidx})$0"
    },
    "REAPER.GETTRACKMEDIAITEM_WR lua": {
        "prefix": "reaperwr.GetTrackMediaItem",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:MediaItem} = reaper.GetTrackMediaItem(${3:MediaTrack tr},${4:integer itemidx})$0"
    },
    "RPR_GETTRACKMEDIAITEM_WR python": {
        "prefix": "WR_RPR_GetTrackMediaItem",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaItem} = RPR_GetTrackMediaItem(${2:MediaTrack tr},${3:Int itemidx})$0"
    },
    "GETTRACKMIDILYRICS_WR c": {
        "prefix": "WR_GetTrackMIDILyrics",
        "scope": "c",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "${1:bool} = GetTrackMIDILyrics(${2:MediaTrack* track},${3:int flag},${4:char* bufWantNeedBig},${5:int* bufWantNeedBig_sz})$0"
    },
    "GETTRACKMIDILYRICS_WR eel2": {
        "prefix": "WR_GetTrackMIDILyrics",
        "scope": "eel2",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "${1:bool} = GetTrackMIDILyrics(${2:MediaTrack track},${3:int flag},${4:#bufWant})$0"
    },
    "REAPER.GETTRACKMIDILYRICS_WR lua": {
        "prefix": "reaperwr.GetTrackMIDILyrics",
        "scope": "lua",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "${1:local }${2:boolean retval},${3:string bufWant} = reaper.GetTrackMIDILyrics(${4:MediaTrack track},${5:integer flag},${6:string bufWant})$0"
    },
    "RPR_GETTRACKMIDILYRICS_WR python": {
        "prefix": "WR_RPR_GetTrackMIDILyrics",
        "scope": "python",
        "description": "Get all MIDI lyrics on the track. Lyrics will be returned as one string\nwith tabs between each word. flag&1: double tabs at the end of each\nmeasure and triple tabs when skipping measures, flag&2: each lyric\nis preceded by its beat position in the project (example with flag=2:\n\"1.1.2\\tLyric for measure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\n\"). See SetTrackMIDILyrics\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int flag},${4:String bufWantNeedBig},${5:Int bufWantNeedBig_sz} = RPR_GetTrackMIDILyrics(${6:track},${7:flag},${8:bufWantNeedBig},${9:bufWantNeedBig_sz})$0"
    },
    "GETTRACKMIDINOTENAME_WR c": {
        "prefix": "WR_GetTrackMIDINoteName",
        "scope": "c",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "${1:const char*} = GetTrackMIDINoteName(${2:int track},${3:int pitch},${4:int chan})$0"
    },
    "GETTRACKMIDINOTENAME_WR eel2": {
        "prefix": "WR_GetTrackMIDINoteName",
        "scope": "eel2",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "${1:bool} = GetTrackMIDINoteName(${2:#retval},${3:int track},${4:int pitch},${5:int chan})$0"
    },
    "REAPER.GETTRACKMIDINOTENAME_WR lua": {
        "prefix": "reaperwr.GetTrackMIDINoteName",
        "scope": "lua",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "${1:local }${2:string} = reaper.GetTrackMIDINoteName(${3:integer track},${4:integer pitch},${5:integer chan})$0"
    },
    "RPR_GETTRACKMIDINOTENAME_WR python": {
        "prefix": "WR_RPR_GetTrackMIDINoteName",
        "scope": "python",
        "description": "see GetTrackMIDINoteNameEx\n",
        "body": "${1:String} = RPR_GetTrackMIDINoteName(${2:Int track},${3:Int pitch},${4:Int chan})$0"
    },
    "GETTRACKMIDINOTENAMEEX_WR c": {
        "prefix": "WR_GetTrackMIDINoteNameEx",
        "scope": "c",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "${1:const char*} = GetTrackMIDINoteNameEx(${2:ReaProject* proj},${3:MediaTrack* track},${4:int pitch},${5:int chan})$0"
    },
    "GETTRACKMIDINOTENAMEEX_WR eel2": {
        "prefix": "WR_GetTrackMIDINoteNameEx",
        "scope": "eel2",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "${1:bool} = GetTrackMIDINoteNameEx(${2:#retval},${3:ReaProject proj},${4:MediaTrack track},${5:int pitch},${6:int chan})$0"
    },
    "REAPER.GETTRACKMIDINOTENAMEEX_WR lua": {
        "prefix": "reaperwr.GetTrackMIDINoteNameEx",
        "scope": "lua",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "${1:local }${2:string} = reaper.GetTrackMIDINoteNameEx(${3:ReaProject proj},${4:MediaTrack track},${5:integer pitch},${6:integer chan})$0"
    },
    "RPR_GETTRACKMIDINOTENAMEEX_WR python": {
        "prefix": "WR_RPR_GetTrackMIDINoteNameEx",
        "scope": "python",
        "description": "Get note/CC name. pitch 128 for CC0 name, 129 for CC1 name, etc. See SetTrackMIDINoteNameEx\n",
        "body": "${1:String} = RPR_GetTrackMIDINoteNameEx(${2:ReaProject proj},${3:MediaTrack track},${4:Int pitch},${5:Int chan})$0"
    },
    "GETTRACKMIDINOTERANGE_WR c": {
        "prefix": "WR_GetTrackMIDINoteRange",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = GetTrackMIDINoteRange(${2:ReaProject* proj},${3:MediaTrack* track},${4:int* note_loOut},${5:int* note_hiOut})$0"
    },
    "REAPER.GETTRACKMIDINOTERANGE_WR lua": {
        "prefix": "reaperwr.GetTrackMIDINoteRange",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number note_lo},${3:number note_hi} = reaper.GetTrackMIDINoteRange(${4:ReaProject proj},${5:MediaTrack track})$0"
    },
    "RPR_GETTRACKMIDINOTERANGE_WR python": {
        "prefix": "WR_RPR_GetTrackMIDINoteRange",
        "scope": "python",
        "description": "\n",
        "body": "${1:ReaProject proj},${2:MediaTrack track},${3:Int note_loOut},${4:Int note_hiOut} = RPR_GetTrackMIDINoteRange(${5:proj},${6:track},${7:note_loOut},${8:note_hiOut})$0"
    },
    "GETTRACKNAME_WR c": {
        "prefix": "WR_GetTrackName",
        "scope": "c",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "${1:bool} = GetTrackName(${2:MediaTrack* track},${3:char* bufOut},${4:int bufOut_sz})$0"
    },
    "GETTRACKNAME_WR eel2": {
        "prefix": "WR_GetTrackName",
        "scope": "eel2",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "${1:bool} = GetTrackName(${2:MediaTrack track},${3:#buf})$0"
    },
    "REAPER.GETTRACKNAME_WR lua": {
        "prefix": "reaperwr.GetTrackName",
        "scope": "lua",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.GetTrackName(${4:MediaTrack track})$0"
    },
    "RPR_GETTRACKNAME_WR python": {
        "prefix": "WR_RPR_GetTrackName",
        "scope": "python",
        "description": "Returns \"MASTER\" for master track, \"Track N\" if track has no name.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:String bufOut},${4:Int bufOut_sz} = RPR_GetTrackName(${5:track},${6:bufOut},${7:bufOut_sz})$0"
    },
    "GETTRACKNUMMEDIAITEMS_WR c": {
        "prefix": "WR_GetTrackNumMediaItems",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = GetTrackNumMediaItems(${2:MediaTrack* tr})$0"
    },
    "GETTRACKNUMMEDIAITEMS_WR eel2": {
        "prefix": "WR_GetTrackNumMediaItems",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = GetTrackNumMediaItems(${2:MediaTrack tr})$0"
    },
    "REAPER.GETTRACKNUMMEDIAITEMS_WR lua": {
        "prefix": "reaperwr.GetTrackNumMediaItems",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.GetTrackNumMediaItems(${3:MediaTrack tr})$0"
    },
    "RPR_GETTRACKNUMMEDIAITEMS_WR python": {
        "prefix": "WR_RPR_GetTrackNumMediaItems",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_GetTrackNumMediaItems(${2:MediaTrack tr})$0"
    },
    "GETTRACKNUMSENDS_WR c": {
        "prefix": "WR_GetTrackNumSends",
        "scope": "c",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "${1:int} = GetTrackNumSends(${2:MediaTrack* tr},${3:int category})$0"
    },
    "GETTRACKNUMSENDS_WR eel2": {
        "prefix": "WR_GetTrackNumSends",
        "scope": "eel2",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "${1:int} = GetTrackNumSends(${2:MediaTrack tr},${3:int category})$0"
    },
    "REAPER.GETTRACKNUMSENDS_WR lua": {
        "prefix": "reaperwr.GetTrackNumSends",
        "scope": "lua",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "${1:local }${2:integer} = reaper.GetTrackNumSends(${3:MediaTrack tr},${4:integer category})$0"
    },
    "RPR_GETTRACKNUMSENDS_WR python": {
        "prefix": "WR_RPR_GetTrackNumSends",
        "scope": "python",
        "description": "returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs\n",
        "body": "${1:Int} = RPR_GetTrackNumSends(${2:MediaTrack tr},${3:Int category})$0"
    },
    "GETTRACKRECEIVENAME_WR c": {
        "prefix": "WR_GetTrackReceiveName",
        "scope": "c",
        "description": "See GetTrackSendName.\n",
        "body": "${1:bool} = GetTrackReceiveName(${2:MediaTrack* track},${3:int recv_index},${4:char* buf},${5:int buf_sz})$0"
    },
    "GETTRACKRECEIVENAME_WR eel2": {
        "prefix": "WR_GetTrackReceiveName",
        "scope": "eel2",
        "description": "See GetTrackSendName.\n",
        "body": "${1:bool} = GetTrackReceiveName(${2:MediaTrack track},${3:int recv_index},${4:#buf})$0"
    },
    "REAPER.GETTRACKRECEIVENAME_WR lua": {
        "prefix": "reaperwr.GetTrackReceiveName",
        "scope": "lua",
        "description": "See GetTrackSendName.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.GetTrackReceiveName(${4:MediaTrack track},${5:integer recv_index},${6:string buf})$0"
    },
    "RPR_GETTRACKRECEIVENAME_WR python": {
        "prefix": "WR_RPR_GetTrackReceiveName",
        "scope": "python",
        "description": "See GetTrackSendName.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int recv_index},${4:String buf},${5:Int buf_sz} = RPR_GetTrackReceiveName(${6:track},${7:recv_index},${8:buf},${9:buf_sz})$0"
    },
    "GETTRACKRECEIVEUIMUTE_WR c": {
        "prefix": "WR_GetTrackReceiveUIMute",
        "scope": "c",
        "description": "See GetTrackSendUIMute.\n",
        "body": "${1:bool} = GetTrackReceiveUIMute(${2:MediaTrack* track},${3:int recv_index},${4:bool* muteOut})$0"
    },
    "GETTRACKRECEIVEUIMUTE_WR eel2": {
        "prefix": "WR_GetTrackReceiveUIMute",
        "scope": "eel2",
        "description": "See GetTrackSendUIMute.\n",
        "body": "${1:bool} = GetTrackReceiveUIMute(${2:MediaTrack track},${3:int recv_index},${4:bool &mute})$0"
    },
    "REAPER.GETTRACKRECEIVEUIMUTE_WR lua": {
        "prefix": "reaperwr.GetTrackReceiveUIMute",
        "scope": "lua",
        "description": "See GetTrackSendUIMute.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean mute} = reaper.GetTrackReceiveUIMute(${4:MediaTrack track},${5:integer recv_index})$0"
    },
    "RPR_GETTRACKRECEIVEUIMUTE_WR python": {
        "prefix": "WR_RPR_GetTrackReceiveUIMute",
        "scope": "python",
        "description": "See GetTrackSendUIMute.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int recv_index},${4:Boolean muteOut} = RPR_GetTrackReceiveUIMute(${5:track},${6:recv_index},${7:muteOut})$0"
    },
    "GETTRACKRECEIVEUIVOLPAN_WR c": {
        "prefix": "WR_GetTrackReceiveUIVolPan",
        "scope": "c",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "${1:bool} = GetTrackReceiveUIVolPan(${2:MediaTrack* track},${3:int recv_index},${4:double* volumeOut},${5:double* panOut})$0"
    },
    "GETTRACKRECEIVEUIVOLPAN_WR eel2": {
        "prefix": "WR_GetTrackReceiveUIVolPan",
        "scope": "eel2",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "${1:bool} = GetTrackReceiveUIVolPan(${2:MediaTrack track},${3:int recv_index},${4:&volume},${5:&pan})$0"
    },
    "REAPER.GETTRACKRECEIVEUIVOLPAN_WR lua": {
        "prefix": "reaperwr.GetTrackReceiveUIVolPan",
        "scope": "lua",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "${1:local }${2:boolean retval},${3:number volume},${4:number pan} = reaper.GetTrackReceiveUIVolPan(${5:MediaTrack track},${6:integer recv_index})$0"
    },
    "RPR_GETTRACKRECEIVEUIVOLPAN_WR python": {
        "prefix": "WR_RPR_GetTrackReceiveUIVolPan",
        "scope": "python",
        "description": "See GetTrackSendUIVolPan.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int recv_index},${4:Float volumeOut},${5:Float panOut} = RPR_GetTrackReceiveUIVolPan(${6:track},${7:recv_index},${8:volumeOut},${9:panOut})$0"
    },
    "GETTRACKSENDINFO_VALUE_WR c": {
        "prefix": "WR_GetTrackSendInfo_Value",
        "scope": "c",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:double} = GetTrackSendInfo_Value(${2:MediaTrack* tr},${3:int category},${4:int sendidx},${5|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\",\"P_DESTTRACK\",\"P_SRCTRACK\",\"P_ENV:<envchunkname\"|})$0"
    },
    "GETTRACKSENDINFO_VALUE_WR eel2": {
        "prefix": "WR_GetTrackSendInfo_Value",
        "scope": "eel2",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:double} = GetTrackSendInfo_Value(${2:MediaTrack tr},${3:int category},${4:int sendidx},${5:\"parmname\"})$0"
    },
    "REAPER.GETTRACKSENDINFO_VALUE_WR lua": {
        "prefix": "reaperwr.GetTrackSendInfo_Value",
        "scope": "lua",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:local }${2:number} = reaper.GetTrackSendInfo_Value(${3:MediaTrack tr},${4:integer category},${5:integer sendidx},${6|string parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\",\"P_DESTTRACK\",\"P_SRCTRACK\",\"P_ENV:<envchunkname\"|})$0"
    },
    "RPR_GETTRACKSENDINFO_VALUE_WR python": {
        "prefix": "WR_RPR_GetTrackSendInfo_Value",
        "scope": "python",
        "description": "Get send/receive/hardware output numerical-value attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5\nbits=dest channel, 0=orig, 1-16=chanP_DESTTRACK : read only, returns\nMediaTrack *, destination track, only applies for sends/recvs\nP_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs\nP_ENV:<envchunkname : read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\nSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:Float} = RPR_GetTrackSendInfo_Value(${2:MediaTrack tr},${3:Int category},${4:Int sendidx},${5|String parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\",\"P_DESTTRACK\",\"P_SRCTRACK\",\"P_ENV:<envchunkname\"|})$0"
    },
    "GETTRACKSENDNAME_WR c": {
        "prefix": "WR_GetTrackSendName",
        "scope": "c",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "${1:bool} = GetTrackSendName(${2:MediaTrack* track},${3:int send_index},${4:char* buf},${5:int buf_sz})$0"
    },
    "GETTRACKSENDNAME_WR eel2": {
        "prefix": "WR_GetTrackSendName",
        "scope": "eel2",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "${1:bool} = GetTrackSendName(${2:MediaTrack track},${3:int send_index},${4:#buf})$0"
    },
    "REAPER.GETTRACKSENDNAME_WR lua": {
        "prefix": "reaperwr.GetTrackSendName",
        "scope": "lua",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.GetTrackSendName(${4:MediaTrack track},${5:integer send_index},${6:string buf})$0"
    },
    "RPR_GETTRACKSENDNAME_WR python": {
        "prefix": "WR_RPR_GetTrackSendName",
        "scope": "python",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveName.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int send_index},${4:String buf},${5:Int buf_sz} = RPR_GetTrackSendName(${6:track},${7:send_index},${8:buf},${9:buf_sz})$0"
    },
    "GETTRACKSENDUIMUTE_WR c": {
        "prefix": "WR_GetTrackSendUIMute",
        "scope": "c",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "${1:bool} = GetTrackSendUIMute(${2:MediaTrack* track},${3:int send_index},${4:bool* muteOut})$0"
    },
    "GETTRACKSENDUIMUTE_WR eel2": {
        "prefix": "WR_GetTrackSendUIMute",
        "scope": "eel2",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "${1:bool} = GetTrackSendUIMute(${2:MediaTrack track},${3:int send_index},${4:bool &mute})$0"
    },
    "REAPER.GETTRACKSENDUIMUTE_WR lua": {
        "prefix": "reaperwr.GetTrackSendUIMute",
        "scope": "lua",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean mute} = reaper.GetTrackSendUIMute(${4:MediaTrack track},${5:integer send_index})$0"
    },
    "RPR_GETTRACKSENDUIMUTE_WR python": {
        "prefix": "WR_RPR_GetTrackSendUIMute",
        "scope": "python",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIMute.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int send_index},${4:Boolean muteOut} = RPR_GetTrackSendUIMute(${5:track},${6:send_index},${7:muteOut})$0"
    },
    "GETTRACKSENDUIVOLPAN_WR c": {
        "prefix": "WR_GetTrackSendUIVolPan",
        "scope": "c",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "${1:bool} = GetTrackSendUIVolPan(${2:MediaTrack* track},${3:int send_index},${4:double* volumeOut},${5:double* panOut})$0"
    },
    "GETTRACKSENDUIVOLPAN_WR eel2": {
        "prefix": "WR_GetTrackSendUIVolPan",
        "scope": "eel2",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "${1:bool} = GetTrackSendUIVolPan(${2:MediaTrack track},${3:int send_index},${4:&volume},${5:&pan})$0"
    },
    "REAPER.GETTRACKSENDUIVOLPAN_WR lua": {
        "prefix": "reaperwr.GetTrackSendUIVolPan",
        "scope": "lua",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "${1:local }${2:boolean retval},${3:number volume},${4:number pan} = reaper.GetTrackSendUIVolPan(${5:MediaTrack track},${6:integer send_index})$0"
    },
    "RPR_GETTRACKSENDUIVOLPAN_WR python": {
        "prefix": "WR_RPR_GetTrackSendUIVolPan",
        "scope": "python",
        "description": "send_idx>=0 for hw ouputs, >=nb_of_hw_ouputs for sends. See GetTrackReceiveUIVolPan.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int send_index},${4:Float volumeOut},${5:Float panOut} = RPR_GetTrackSendUIVolPan(${6:track},${7:send_index},${8:volumeOut},${9:panOut})$0"
    },
    "GETTRACKSTATE_WR c": {
        "prefix": "WR_GetTrackState",
        "scope": "c",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "${1:const char*} = GetTrackState(${2:MediaTrack* track},${3:int* flagsOut})$0"
    },
    "GETTRACKSTATE_WR eel2": {
        "prefix": "WR_GetTrackState",
        "scope": "eel2",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "${1:bool} = GetTrackState(${2:#retval},${3:MediaTrack track},${4:int &flags})$0"
    },
    "REAPER.GETTRACKSTATE_WR lua": {
        "prefix": "reaperwr.GetTrackState",
        "scope": "lua",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "${1:local }${2:string retval},${3:number flags} = reaper.GetTrackState(${4:MediaTrack track})$0"
    },
    "RPR_GETTRACKSTATE_WR python": {
        "prefix": "WR_RPR_GetTrackState",
        "scope": "python",
        "description": "Gets track state, returns track name.\nflags will be set to:\n&1=folder\n&2=selected\n&4=has fx enabled\n&8=muted\n&16=soloed\n&32=SIP'd (with &16)\n&64=rec armed\n&128=rec monitoring on\n&256=rec monitoring auto\n&512=hide from TCP\n&1024=hide from MCP\n",
        "body": "${1:String retval},${2:MediaTrack track},${3:Int flagsOut} = RPR_GetTrackState(${4:track},${5:flagsOut})$0"
    },
    "GETTRACKSTATECHUNK_WR c": {
        "prefix": "WR_GetTrackStateChunk",
        "scope": "c",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = GetTrackStateChunk(${2:MediaTrack* track},${3:char* strNeedBig},${4:int strNeedBig_sz},${5:bool isundoOptional})$0"
    },
    "GETTRACKSTATECHUNK_WR eel2": {
        "prefix": "WR_GetTrackStateChunk",
        "scope": "eel2",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = GetTrackStateChunk(${2:MediaTrack track},${3:#str},${4:bool isundo})$0"
    },
    "REAPER.GETTRACKSTATECHUNK_WR lua": {
        "prefix": "reaperwr.GetTrackStateChunk",
        "scope": "lua",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:local }${2:boolean retval},${3:string str} = reaper.GetTrackStateChunk(${4:MediaTrack track},${5:string str},${6:boolean isundo})$0"
    },
    "RPR_GETTRACKSTATECHUNK_WR python": {
        "prefix": "WR_RPR_GetTrackStateChunk",
        "scope": "python",
        "description": "Gets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:String strNeedBig},${4:Int strNeedBig_sz},${5:Boolean isundoOptional} = RPR_GetTrackStateChunk(${6:track},${7:strNeedBig},${8:strNeedBig_sz},${9:isundoOptional})$0"
    },
    "GETTRACKUIMUTE_WR c": {
        "prefix": "WR_GetTrackUIMute",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = GetTrackUIMute(${2:MediaTrack* track},${3:bool* muteOut})$0"
    },
    "GETTRACKUIMUTE_WR eel2": {
        "prefix": "WR_GetTrackUIMute",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetTrackUIMute(${2:MediaTrack track},${3:bool &mute})$0"
    },
    "REAPER.GETTRACKUIMUTE_WR lua": {
        "prefix": "reaperwr.GetTrackUIMute",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:boolean mute} = reaper.GetTrackUIMute(${4:MediaTrack track})$0"
    },
    "RPR_GETTRACKUIMUTE_WR python": {
        "prefix": "WR_RPR_GetTrackUIMute",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Boolean muteOut} = RPR_GetTrackUIMute(${4:track},${5:muteOut})$0"
    },
    "GETTRACKUIPAN_WR c": {
        "prefix": "WR_GetTrackUIPan",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = GetTrackUIPan(${2:MediaTrack* track},${3:double* pan1Out},${4:double* pan2Out},${5:int* panmodeOut})$0"
    },
    "GETTRACKUIPAN_WR eel2": {
        "prefix": "WR_GetTrackUIPan",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetTrackUIPan(${2:MediaTrack track},${3:&pan1},${4:&pan2},${5:int &panmode})$0"
    },
    "REAPER.GETTRACKUIPAN_WR lua": {
        "prefix": "reaperwr.GetTrackUIPan",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:number pan1},${4:number pan2},${5:number panmode} = reaper.GetTrackUIPan(${6:MediaTrack track})$0"
    },
    "RPR_GETTRACKUIPAN_WR python": {
        "prefix": "WR_RPR_GetTrackUIPan",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Float pan1Out},${4:Float pan2Out},${5:Int panmodeOut} = RPR_GetTrackUIPan(${6:track},${7:pan1Out},${8:pan2Out},${9:panmodeOut})$0"
    },
    "GETTRACKUIVOLPAN_WR c": {
        "prefix": "WR_GetTrackUIVolPan",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = GetTrackUIVolPan(${2:MediaTrack* track},${3:double* volumeOut},${4:double* panOut})$0"
    },
    "GETTRACKUIVOLPAN_WR eel2": {
        "prefix": "WR_GetTrackUIVolPan",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = GetTrackUIVolPan(${2:MediaTrack track},${3:&volume},${4:&pan})$0"
    },
    "REAPER.GETTRACKUIVOLPAN_WR lua": {
        "prefix": "reaperwr.GetTrackUIVolPan",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:number volume},${4:number pan} = reaper.GetTrackUIVolPan(${5:MediaTrack track})$0"
    },
    "RPR_GETTRACKUIVOLPAN_WR python": {
        "prefix": "WR_RPR_GetTrackUIVolPan",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Float volumeOut},${4:Float panOut} = RPR_GetTrackUIVolPan(${5:track},${6:volumeOut},${7:panOut})$0"
    },
    "GETUNDERRUNTIME_WR c": {
        "prefix": "WR_GetUnderrunTime",
        "scope": "c",
        "description": "retrieves the last timestamps of audio xrun (yellow-flash, if\navailable), media xrun (red-flash), and the current time stamp (all\nmilliseconds)\n",
        "body": "${1:void} = GetUnderrunTime(${2:unsigned int* audio_xrunOutOptional},${3:unsigned int* media_xrunOutOptional},${4:unsigned int* curtimeOutOptional})$0"
    },
    "REAPER.GETUNDERRUNTIME_WR lua": {
        "prefix": "reaperwr.GetUnderrunTime",
        "scope": "lua",
        "description": "retrieves the last timestamps of audio xrun (yellow-flash, if\navailable), media xrun (red-flash), and the current time stamp (all\nmilliseconds)\n",
        "body": "${1:local }${2:optional number audio_xrun},${3:optional number media_xrun},${4:optional number curtime} = reaper.GetUnderrunTime()$0"
    },
    "GETUSERFILENAMEFORREAD_WR c": {
        "prefix": "WR_GetUserFileNameForRead",
        "scope": "c",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "${1:bool} = GetUserFileNameForRead(${2:char* filenameNeed4096},${3:const char* title},${4:const char* defext})$0"
    },
    "GETUSERFILENAMEFORREAD_WR eel2": {
        "prefix": "WR_GetUserFileNameForRead",
        "scope": "eel2",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "${1:bool} = GetUserFileNameForRead(${2:#filenameNeed4096},${3:\"title\"},${4:\"defext\"})$0"
    },
    "REAPER.GETUSERFILENAMEFORREAD_WR lua": {
        "prefix": "reaperwr.GetUserFileNameForRead",
        "scope": "lua",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "${1:local }${2:boolean retval},${3:string filenameNeed4096} = reaper.GetUserFileNameForRead(${4:string filenameNeed4096},${5:string title},${6:string defext})$0"
    },
    "RPR_GETUSERFILENAMEFORREAD_WR python": {
        "prefix": "WR_RPR_GetUserFileNameForRead",
        "scope": "python",
        "description": "returns true if the user selected a valid file, false if the user canceled the dialog\n",
        "body": "${1:Boolean retval},${2:String filenameNeed4096},${3:String title},${4:String defext} = RPR_GetUserFileNameForRead(${5:filenameNeed4096},${6:title},${7:defext})$0"
    },
    "GETUSERINPUTS_WR c": {
        "prefix": "WR_GetUserInputs",
        "scope": "c",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "${1:bool} = GetUserInputs(${2:const char* title},${3:int num_inputs},${4:const char* captions_csv},${5:char* retvals_csv},${6:int retvals_csv_sz})$0"
    },
    "GETUSERINPUTS_WR eel2": {
        "prefix": "WR_GetUserInputs",
        "scope": "eel2",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "${1:bool} = GetUserInputs(${2:\"title\"},${3:int num_inputs},${4:\"captions_csv\"},${5:#retvals_csv})$0"
    },
    "REAPER.GETUSERINPUTS_WR lua": {
        "prefix": "reaperwr.GetUserInputs",
        "scope": "lua",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "${1:local }${2:boolean retval},${3:string retvals_csv} = reaper.GetUserInputs(${4:string title},${5:integer num_inputs},${6:string captions_csv},${7:string retvals_csv})$0"
    },
    "RPR_GETUSERINPUTS_WR python": {
        "prefix": "WR_RPR_GetUserInputs",
        "scope": "python",
        "description": "Get values from the user.\nIf a caption begins with *, for example \"*password\", the edit field will not display the input text.\nMaximum fields is 16. Values are returned as a comma-separated string.\nReturns false if the user canceled the dialog. You can supply special\nextra information via additional caption fields: extrawidth=XXX to\nincrease text field width, separator=X to use a different separator for\nreturned fields.\n",
        "body": "${1:Boolean retval},${2:String title},${3:Int num_inputs},${4:String captions_csv},${5:String retvals_csv},${6:Int retvals_csv_sz} = RPR_GetUserInputs(${7:title},${8:num_inputs},${9:captions_csv},${10:retvals_csv},${11:retvals_csv_sz})$0"
    },
    "GOTOMARKER_WR c": {
        "prefix": "WR_GoToMarker",
        "scope": "c",
        "description": "Go to marker. If use_timeline_order==true, marker_index 1 refers to the\nfirst marker on the timeline.  If use_timeline_order==false,\nmarker_index 1 refers to the first marker with the user-editable index\nof 1.\n",
        "body": "${1:void} = GoToMarker(${2:ReaProject* proj},${3:int marker_index},${4:bool use_timeline_order})$0"
    },
    "GOTOREGION_WR c": {
        "prefix": "WR_GoToRegion",
        "scope": "c",
        "description": "Seek to region after current region finishes playing (smooth seek). If\nuse_timeline_order==true, region_index 1 refers to the first region on\nthe timeline.  If use_timeline_order==false, region_index 1 refers to\nthe first region with the user-editable index of 1.\n",
        "body": "${1:void} = GoToRegion(${2:ReaProject* proj},${3:int region_index},${4:bool use_timeline_order})$0"
    },
    "GR_SELECTCOLOR_WR c": {
        "prefix": "WR_GR_SelectColor",
        "scope": "c",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "${1:int} = GR_SelectColor(${2:HWND hwnd},${3:int* colorOut})$0"
    },
    "GR_SELECTCOLOR_WR eel2": {
        "prefix": "WR_GR_SelectColor",
        "scope": "eel2",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "${1:int} = GR_SelectColor(${2:HWND hwnd},${3:int &color})$0"
    },
    "REAPER.GR_SELECTCOLOR_WR lua": {
        "prefix": "reaperwr.GR_SelectColor",
        "scope": "lua",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "${1:local }${2:integer retval},${3:number color} = reaper.GR_SelectColor(${4:HWND hwnd})$0"
    },
    "RPR_GR_SELECTCOLOR_WR python": {
        "prefix": "WR_RPR_GR_SelectColor",
        "scope": "python",
        "description": "Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.\n",
        "body": "${1:Int retval},${2:HWND hwnd},${3:Int colorOut} = RPR_GR_SelectColor(${4:hwnd},${5:colorOut})$0"
    },
    "GSC_MAINWND_WR c": {
        "prefix": "WR_GSC_mainwnd",
        "scope": "c",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "${1:int} = GSC_mainwnd(${2:int t})$0"
    },
    "GSC_MAINWND_WR eel2": {
        "prefix": "WR_GSC_mainwnd",
        "scope": "eel2",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "${1:int} = GSC_mainwnd(${2:int t})$0"
    },
    "REAPER.GSC_MAINWND_WR lua": {
        "prefix": "reaperwr.GSC_mainwnd",
        "scope": "lua",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "${1:local }${2:integer} = reaper.GSC_mainwnd(${3:integer t})$0"
    },
    "RPR_GSC_MAINWND_WR python": {
        "prefix": "WR_RPR_GSC_mainwnd",
        "scope": "python",
        "description": "this is just like win32 GetSysColor() but can have overrides.\n",
        "body": "${1:Int} = RPR_GSC_mainwnd(${2:Int t})$0"
    },
    "GUIDTOSTRING_WR c": {
        "prefix": "WR_guidToString",
        "scope": "c",
        "description": "dest should be at least 64 chars long to be safe\n",
        "body": "${1:void} = guidToString(${2:const GUID* g},${3:char* destNeed64})$0"
    },
    "REAPER.GUIDTOSTRING_WR lua": {
        "prefix": "reaperwr.guidToString",
        "scope": "lua",
        "description": "dest should be at least 64 chars long to be safe\n",
        "body": "${1:local }${2:string destNeed64} = reaper.guidToString(${3:string gGUID},${4:string destNeed64})$0"
    },
    "RPR_GUIDTOSTRING_WR python": {
        "prefix": "WR_RPR_guidToString",
        "scope": "python",
        "description": "dest should be at least 64 chars long to be safe\n",
        "body": "${1:const GUID g},${2:String destNeed64} = RPR_guidToString(${3:g},${4:destNeed64})$0"
    },
    "HASEXTSTATE_WR c": {
        "prefix": "WR_HasExtState",
        "scope": "c",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "${1:bool} = HasExtState(${2:const char* section},${3:const char* key})$0"
    },
    "HASEXTSTATE_WR eel2": {
        "prefix": "WR_HasExtState",
        "scope": "eel2",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "${1:bool} = HasExtState(${2:\"section\"},${3:\"key\"})$0"
    },
    "REAPER.HASEXTSTATE_WR lua": {
        "prefix": "reaperwr.HasExtState",
        "scope": "lua",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "${1:local }${2:boolean} = reaper.HasExtState(${3:string section},${4:string key})$0"
    },
    "RPR_HASEXTSTATE_WR python": {
        "prefix": "WR_RPR_HasExtState",
        "scope": "python",
        "description": "Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.\n",
        "body": "${1:Boolean} = RPR_HasExtState(${2:String section},${3:String key})$0"
    },
    "HASTRACKMIDIPROGRAMS_WR c": {
        "prefix": "WR_HasTrackMIDIPrograms",
        "scope": "c",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:const char*} = HasTrackMIDIPrograms(${2:int track})$0"
    },
    "HASTRACKMIDIPROGRAMS_WR eel2": {
        "prefix": "WR_HasTrackMIDIPrograms",
        "scope": "eel2",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:bool} = HasTrackMIDIPrograms(${2:#retval},${3:int track})$0"
    },
    "REAPER.HASTRACKMIDIPROGRAMS_WR lua": {
        "prefix": "reaperwr.HasTrackMIDIPrograms",
        "scope": "lua",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:local }${2:string} = reaper.HasTrackMIDIPrograms(${3:integer track})$0"
    },
    "RPR_HASTRACKMIDIPROGRAMS_WR python": {
        "prefix": "WR_RPR_HasTrackMIDIPrograms",
        "scope": "python",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:String} = RPR_HasTrackMIDIPrograms(${2:Int track})$0"
    },
    "HASTRACKMIDIPROGRAMSEX_WR c": {
        "prefix": "WR_HasTrackMIDIProgramsEx",
        "scope": "c",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:const char*} = HasTrackMIDIProgramsEx(${2:ReaProject* proj},${3:MediaTrack* track})$0"
    },
    "HASTRACKMIDIPROGRAMSEX_WR eel2": {
        "prefix": "WR_HasTrackMIDIProgramsEx",
        "scope": "eel2",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:bool} = HasTrackMIDIProgramsEx(${2:#retval},${3:ReaProject proj},${4:MediaTrack track})$0"
    },
    "REAPER.HASTRACKMIDIPROGRAMSEX_WR lua": {
        "prefix": "reaperwr.HasTrackMIDIProgramsEx",
        "scope": "lua",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:local }${2:string} = reaper.HasTrackMIDIProgramsEx(${3:ReaProject proj},${4:MediaTrack track})$0"
    },
    "RPR_HASTRACKMIDIPROGRAMSEX_WR python": {
        "prefix": "WR_RPR_HasTrackMIDIProgramsEx",
        "scope": "python",
        "description": "returns name of track plugin that is supplying MIDI programs,or NULL if there is none\n",
        "body": "${1:String} = RPR_HasTrackMIDIProgramsEx(${2:ReaProject proj},${3:MediaTrack track})$0"
    },
    "HELP_SET_WR c": {
        "prefix": "WR_Help_Set",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = Help_Set(${2:const char* helpstring},${3:bool is_temporary_help})$0"
    },
    "IMAGE_RESOLVE_FN_WR c": {
        "prefix": "WR_image_resolve_fn",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = image_resolve_fn(${2:const char* in},${3:char* out},${4:int out_sz})$0"
    },
    "REAPER.IMAGE_RESOLVE_FN_WR lua": {
        "prefix": "reaperwr.image_resolve_fn",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string out} = reaper.image_resolve_fn(${3:string in},${4:string out})$0"
    },
    "RPR_IMAGE_RESOLVE_FN_WR python": {
        "prefix": "WR_RPR_image_resolve_fn",
        "scope": "python",
        "description": "\n",
        "body": "${1:String in},${2:String out},${3:Int out_sz} = RPR_image_resolve_fn(${4:in},${5:out},${6:out_sz})$0"
    },
    "INSERTAUTOMATIONITEM_WR c": {
        "prefix": "WR_InsertAutomationItem",
        "scope": "c",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "${1:int} = InsertAutomationItem(${2:TrackEnvelope* env},${3:int pool_id},${4:double position},${5:double length})$0"
    },
    "INSERTAUTOMATIONITEM_WR eel2": {
        "prefix": "WR_InsertAutomationItem",
        "scope": "eel2",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "${1:int} = InsertAutomationItem(${2:TrackEnvelope env},${3:int pool_id},${4:position},${5:length})$0"
    },
    "REAPER.INSERTAUTOMATIONITEM_WR lua": {
        "prefix": "reaperwr.InsertAutomationItem",
        "scope": "lua",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "${1:local }${2:integer} = reaper.InsertAutomationItem(${3:TrackEnvelope env},${4:integer pool_id},${5:number position},${6:number length})$0"
    },
    "RPR_INSERTAUTOMATIONITEM_WR python": {
        "prefix": "WR_RPR_InsertAutomationItem",
        "scope": "python",
        "description": "Insert a new automation item. pool_id < 0 collects existing envelope\npoints into the automation item; if pool_id is >= 0 the automation\nitem will be a new instance of that pool (which will be created as an\nempty instance if it does not exist). Returns the index of the item,\nsuitable for passing to other automation item API functions. See GetSetAutomationItemInfo.\n",
        "body": "${1:Int} = RPR_InsertAutomationItem(${2:TrackEnvelope env},${3:Int pool_id},${4:Float position},${5:Float length})$0"
    },
    "INSERTENVELOPEPOINT_WR c": {
        "prefix": "WR_InsertEnvelopePoint",
        "scope": "c",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "${1:bool} = InsertEnvelopePoint(${2:TrackEnvelope* envelope},${3:double time},${4:double value},${5:int shape},${6:double tension},${7:bool selected},${8:bool* noSortInOptional})$0"
    },
    "INSERTENVELOPEPOINT_WR eel2": {
        "prefix": "WR_InsertEnvelopePoint",
        "scope": "eel2",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "${1:bool} = InsertEnvelopePoint(${2:TrackEnvelope envelope},${3:time},${4:value},${5:int shape},${6:tension},${7:bool selected},${8:optional bool noSortIn})$0"
    },
    "REAPER.INSERTENVELOPEPOINT_WR lua": {
        "prefix": "reaperwr.InsertEnvelopePoint",
        "scope": "lua",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean} = reaper.InsertEnvelopePoint(${3:TrackEnvelope envelope},${4:number time},${5:number value},${6:integer shape},${7:number tension},${8:boolean selected},${9:optional boolean noSortIn})$0"
    },
    "RPR_INSERTENVELOPEPOINT_WR python": {
        "prefix": "WR_RPR_InsertEnvelopePoint",
        "scope": "python",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done. See InsertEnvelopePointEx.\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope envelope},${3:Float time},${4:Float value},${5:Int shape},${6:Float tension},${7:Boolean selected},${8:Boolean noSortInOptional} = RPR_InsertEnvelopePoint(${9:envelope},${10:time},${11:value},${12:shape},${13:tension},${14:selected},${15:noSortInOptional})$0"
    },
    "INSERTENVELOPEPOINTEX_WR c": {
        "prefix": "WR_InsertEnvelopePointEx",
        "scope": "c",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = InsertEnvelopePointEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx},${4:double time},${5:double value},${6:int shape},${7:double tension},${8:bool selected},${9:bool* noSortInOptional})$0"
    },
    "INSERTENVELOPEPOINTEX_WR eel2": {
        "prefix": "WR_InsertEnvelopePointEx",
        "scope": "eel2",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = InsertEnvelopePointEx(${2:TrackEnvelope envelope},${3:int autoitem_idx},${4:time},${5:value},${6:int shape},${7:tension},${8:bool selected},${9:optional bool noSortIn})$0"
    },
    "REAPER.INSERTENVELOPEPOINTEX_WR lua": {
        "prefix": "reaperwr.InsertEnvelopePointEx",
        "scope": "lua",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean} = reaper.InsertEnvelopePointEx(${3:TrackEnvelope envelope},${4:integer autoitem_idx},${5:number time},${6:number value},${7:integer shape},${8:number tension},${9:boolean selected},${10:optional boolean noSortIn})$0"
    },
    "RPR_INSERTENVELOPEPOINTEX_WR python": {
        "prefix": "WR_RPR_InsertEnvelopePointEx",
        "scope": "python",
        "description": "Insert an envelope point. If setting multiple points at once, set noSort=true, and call Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, SetEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope envelope},${3:Int autoitem_idx},${4:Float time},${5:Float value},${6:Int shape},${7:Float tension},${8:Boolean selected},${9:Boolean noSortInOptional} = RPR_InsertEnvelopePointEx(${10:envelope},${11:autoitem_idx},${12:time},${13:value},${14:shape},${15:tension},${16:selected},${17:noSortInOptional})$0"
    },
    "INSERTMEDIA_WR c": {
        "prefix": "WR_InsertMedia",
        "scope": "c",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "${1:int} = InsertMedia(${2:const char* file},${3:int mode})$0"
    },
    "INSERTMEDIA_WR eel2": {
        "prefix": "WR_InsertMedia",
        "scope": "eel2",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "${1:int} = InsertMedia(${2:\"file\"},${3:int mode})$0"
    },
    "REAPER.INSERTMEDIA_WR lua": {
        "prefix": "reaperwr.InsertMedia",
        "scope": "lua",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "${1:local }${2:integer} = reaper.InsertMedia(${3:string file},${4:integer mode})$0"
    },
    "RPR_INSERTMEDIA_WR python": {
        "prefix": "WR_RPR_InsertMedia",
        "scope": "python",
        "description": "mode: 0=add to current track, 1=add new track, 3=add to selected items\nas takes, &4=stretch/loop to fit time sel, &8=try to match tempo\n1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x,\n&64=don't preserve pitch when matching tempo, &128=no\nloop/section if startpct/endpct set, &256=force loop regardless of\nglobal preference for looping imported items. &512=use high word as\nabsolute track index if mode&3==0.\n",
        "body": "${1:Int} = RPR_InsertMedia(${2:String file},${3:Int mode})$0"
    },
    "INSERTMEDIASECTION_WR c": {
        "prefix": "WR_InsertMediaSection",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = InsertMediaSection(${2:const char* file},${3:int mode},${4:double startpct},${5:double endpct},${6:double pitchshift})$0"
    },
    "INSERTMEDIASECTION_WR eel2": {
        "prefix": "WR_InsertMediaSection",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = InsertMediaSection(${2:\"file\"},${3:int mode},${4:startpct},${5:endpct},${6:pitchshift})$0"
    },
    "REAPER.INSERTMEDIASECTION_WR lua": {
        "prefix": "reaperwr.InsertMediaSection",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.InsertMediaSection(${3:string file},${4:integer mode},${5:number startpct},${6:number endpct},${7:number pitchshift})$0"
    },
    "RPR_INSERTMEDIASECTION_WR python": {
        "prefix": "WR_RPR_InsertMediaSection",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_InsertMediaSection(${2:String file},${3:Int mode},${4:Float startpct},${5:Float endpct},${6:Float pitchshift})$0"
    },
    "INSERTTRACKATINDEX_WR c": {
        "prefix": "WR_InsertTrackAtIndex",
        "scope": "c",
        "description": "inserts a track at idx,of course this will be clamped to\n0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise\nno enabled fx/env\n",
        "body": "${1:void} = InsertTrackAtIndex(${2:int idx},${3:bool wantDefaults})$0"
    },
    "ISMEDIAEXTENSION_WR c": {
        "prefix": "WR_IsMediaExtension",
        "scope": "c",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "${1:bool} = IsMediaExtension(${2:const char* ext},${3:bool wantOthers})$0"
    },
    "ISMEDIAEXTENSION_WR eel2": {
        "prefix": "WR_IsMediaExtension",
        "scope": "eel2",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "${1:bool} = IsMediaExtension(${2:\"ext\"},${3:bool wantOthers})$0"
    },
    "REAPER.ISMEDIAEXTENSION_WR lua": {
        "prefix": "reaperwr.IsMediaExtension",
        "scope": "lua",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "${1:local }${2:boolean} = reaper.IsMediaExtension(${3:string ext},${4:boolean wantOthers})$0"
    },
    "RPR_ISMEDIAEXTENSION_WR python": {
        "prefix": "WR_RPR_IsMediaExtension",
        "scope": "python",
        "description": "Tests a file extension (i.e. \"wav\" or \"mid\") to see if it's a media extension.\nIf wantOthers is set, then \"RPP\", \"TXT\" and other project-type formats will also pass.\n",
        "body": "${1:Boolean} = RPR_IsMediaExtension(${2:String ext},${3:Boolean wantOthers})$0"
    },
    "ISMEDIAITEMSELECTED_WR c": {
        "prefix": "WR_IsMediaItemSelected",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = IsMediaItemSelected(${2:MediaItem* item})$0"
    },
    "ISMEDIAITEMSELECTED_WR eel2": {
        "prefix": "WR_IsMediaItemSelected",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = IsMediaItemSelected(${2:MediaItem item})$0"
    },
    "REAPER.ISMEDIAITEMSELECTED_WR lua": {
        "prefix": "reaperwr.IsMediaItemSelected",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.IsMediaItemSelected(${3:MediaItem item})$0"
    },
    "RPR_ISMEDIAITEMSELECTED_WR python": {
        "prefix": "WR_RPR_IsMediaItemSelected",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_IsMediaItemSelected(${2:MediaItem item})$0"
    },
    "ISPROJECTDIRTY_WR c": {
        "prefix": "WR_IsProjectDirty",
        "scope": "c",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "${1:int} = IsProjectDirty(${2:ReaProject* proj})$0"
    },
    "ISPROJECTDIRTY_WR eel2": {
        "prefix": "WR_IsProjectDirty",
        "scope": "eel2",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "${1:int} = IsProjectDirty(${2:ReaProject proj})$0"
    },
    "REAPER.ISPROJECTDIRTY_WR lua": {
        "prefix": "reaperwr.IsProjectDirty",
        "scope": "lua",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "${1:local }${2:integer} = reaper.IsProjectDirty(${3:ReaProject proj})$0"
    },
    "RPR_ISPROJECTDIRTY_WR python": {
        "prefix": "WR_RPR_IsProjectDirty",
        "scope": "python",
        "description": "Is the project dirty (needing save)? Always returns 0 if 'undo/prompt to save' is disabled in preferences.\n",
        "body": "${1:Int} = RPR_IsProjectDirty(${2:ReaProject proj})$0"
    },
    "ISTRACKSELECTED_WR c": {
        "prefix": "WR_IsTrackSelected",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = IsTrackSelected(${2:MediaTrack* track})$0"
    },
    "ISTRACKSELECTED_WR eel2": {
        "prefix": "WR_IsTrackSelected",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = IsTrackSelected(${2:MediaTrack track})$0"
    },
    "REAPER.ISTRACKSELECTED_WR lua": {
        "prefix": "reaperwr.IsTrackSelected",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.IsTrackSelected(${3:MediaTrack track})$0"
    },
    "RPR_ISTRACKSELECTED_WR python": {
        "prefix": "WR_RPR_IsTrackSelected",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_IsTrackSelected(${2:MediaTrack track})$0"
    },
    "ISTRACKVISIBLE_WR c": {
        "prefix": "WR_IsTrackVisible",
        "scope": "c",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "${1:bool} = IsTrackVisible(${2:MediaTrack* track},${3:bool mixer})$0"
    },
    "ISTRACKVISIBLE_WR eel2": {
        "prefix": "WR_IsTrackVisible",
        "scope": "eel2",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "${1:bool} = IsTrackVisible(${2:MediaTrack track},${3:bool mixer})$0"
    },
    "REAPER.ISTRACKVISIBLE_WR lua": {
        "prefix": "reaperwr.IsTrackVisible",
        "scope": "lua",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "${1:local }${2:boolean} = reaper.IsTrackVisible(${3:MediaTrack track},${4:boolean mixer})$0"
    },
    "RPR_ISTRACKVISIBLE_WR python": {
        "prefix": "WR_RPR_IsTrackVisible",
        "scope": "python",
        "description": "If mixer==true, returns true if the track is visible in the mixer.  If\nmixer==false, returns true if the track is visible in the track control\npanel.\n",
        "body": "${1:Boolean} = RPR_IsTrackVisible(${2:MediaTrack track},${3:Boolean mixer})$0"
    },
    "JOYSTICK_CREATE_WR c": {
        "prefix": "WR_joystick_create",
        "scope": "c",
        "description": "creates a joystick device\n",
        "body": "${1:joystick_device*} = joystick_create(${2:const GUID* guid})$0"
    },
    "JOYSTICK_CREATE_WR eel2": {
        "prefix": "WR_joystick_create",
        "scope": "eel2",
        "description": "creates a joystick device\n",
        "body": "${1:joystick_device} = joystick_create(${2:\"guidGUID\"})$0"
    },
    "REAPER.JOYSTICK_CREATE_WR lua": {
        "prefix": "reaperwr.joystick_create",
        "scope": "lua",
        "description": "creates a joystick device\n",
        "body": "${1:local }${2:joystick_device} = reaper.joystick_create(${3:string guidGUID})$0"
    },
    "RPR_JOYSTICK_CREATE_WR python": {
        "prefix": "WR_RPR_joystick_create",
        "scope": "python",
        "description": "creates a joystick device\n",
        "body": "${1:joystick_device} = RPR_joystick_create(${2:const GUID guid})$0"
    },
    "JOYSTICK_DESTROY_WR c": {
        "prefix": "WR_joystick_destroy",
        "scope": "c",
        "description": "destroys a joystick device\n",
        "body": "${1:void} = joystick_destroy(${2:joystick_device* device})$0"
    },
    "JOYSTICK_ENUM_WR c": {
        "prefix": "WR_joystick_enum",
        "scope": "c",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "${1:const char*} = joystick_enum(${2:int index},${3:const char** namestrOutOptional})$0"
    },
    "JOYSTICK_ENUM_WR eel2": {
        "prefix": "WR_joystick_enum",
        "scope": "eel2",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "${1:bool} = joystick_enum(${2:#retval},${3:int index},${4:optional #namestr})$0"
    },
    "REAPER.JOYSTICK_ENUM_WR lua": {
        "prefix": "reaperwr.joystick_enum",
        "scope": "lua",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "${1:local }${2:string retval},${3:optional string namestr} = reaper.joystick_enum(${4:integer index})$0"
    },
    "RPR_JOYSTICK_ENUM_WR python": {
        "prefix": "WR_RPR_joystick_enum",
        "scope": "python",
        "description": "enumerates installed devices, returns GUID as a string\n",
        "body": "${1:String} = RPR_joystick_enum(${2:Int index},${3:String namestrOutOptional})$0"
    },
    "JOYSTICK_GETAXIS_WR c": {
        "prefix": "WR_joystick_getaxis",
        "scope": "c",
        "description": "returns axis value (-1..1)\n",
        "body": "${1:double} = joystick_getaxis(${2:joystick_device* dev},${3:int axis})$0"
    },
    "JOYSTICK_GETAXIS_WR eel2": {
        "prefix": "WR_joystick_getaxis",
        "scope": "eel2",
        "description": "returns axis value (-1..1)\n",
        "body": "${1:double} = joystick_getaxis(${2:joystick_device dev},${3:int axis})$0"
    },
    "REAPER.JOYSTICK_GETAXIS_WR lua": {
        "prefix": "reaperwr.joystick_getaxis",
        "scope": "lua",
        "description": "returns axis value (-1..1)\n",
        "body": "${1:local }${2:number} = reaper.joystick_getaxis(${3:joystick_device dev},${4:integer axis})$0"
    },
    "RPR_JOYSTICK_GETAXIS_WR python": {
        "prefix": "WR_RPR_joystick_getaxis",
        "scope": "python",
        "description": "returns axis value (-1..1)\n",
        "body": "${1:Float} = RPR_joystick_getaxis(${2:joystick_device dev},${3:Int axis})$0"
    },
    "JOYSTICK_GETBUTTONMASK_WR c": {
        "prefix": "WR_joystick_getbuttonmask",
        "scope": "c",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "${1:unsigned int} = joystick_getbuttonmask(${2:joystick_device* dev})$0"
    },
    "JOYSTICK_GETBUTTONMASK_WR eel2": {
        "prefix": "WR_joystick_getbuttonmask",
        "scope": "eel2",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "${1:uint} = joystick_getbuttonmask(${2:joystick_device dev})$0"
    },
    "REAPER.JOYSTICK_GETBUTTONMASK_WR lua": {
        "prefix": "reaperwr.joystick_getbuttonmask",
        "scope": "lua",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "${1:local }${2:integer} = reaper.joystick_getbuttonmask(${3:joystick_device dev})$0"
    },
    "RPR_JOYSTICK_GETBUTTONMASK_WR python": {
        "prefix": "WR_RPR_joystick_getbuttonmask",
        "scope": "python",
        "description": "returns button pressed mask, 1=first button, 2=second...\n",
        "body": "${1:Unknown} = RPR_joystick_getbuttonmask(${2:joystick_device dev})$0"
    },
    "JOYSTICK_GETINFO_WR c": {
        "prefix": "WR_joystick_getinfo",
        "scope": "c",
        "description": "returns button count\n",
        "body": "${1:int} = joystick_getinfo(${2:joystick_device* dev},${3:int* axesOutOptional},${4:int* povsOutOptional})$0"
    },
    "JOYSTICK_GETINFO_WR eel2": {
        "prefix": "WR_joystick_getinfo",
        "scope": "eel2",
        "description": "returns button count\n",
        "body": "${1:int} = joystick_getinfo(${2:joystick_device dev},${3:optional int &axes},${4:optional int &povs})$0"
    },
    "REAPER.JOYSTICK_GETINFO_WR lua": {
        "prefix": "reaperwr.joystick_getinfo",
        "scope": "lua",
        "description": "returns button count\n",
        "body": "${1:local }${2:integer retval},${3:optional number axes},${4:optional number povs} = reaper.joystick_getinfo(${5:joystick_device dev})$0"
    },
    "RPR_JOYSTICK_GETINFO_WR python": {
        "prefix": "WR_RPR_joystick_getinfo",
        "scope": "python",
        "description": "returns button count\n",
        "body": "${1:Int retval},${2:joystick_device dev},${3:Int axesOutOptional},${4:Int povsOutOptional} = RPR_joystick_getinfo(${5:dev},${6:axesOutOptional},${7:povsOutOptional})$0"
    },
    "JOYSTICK_GETPOV_WR c": {
        "prefix": "WR_joystick_getpov",
        "scope": "c",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "${1:double} = joystick_getpov(${2:joystick_device* dev},${3:int pov})$0"
    },
    "JOYSTICK_GETPOV_WR eel2": {
        "prefix": "WR_joystick_getpov",
        "scope": "eel2",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "${1:double} = joystick_getpov(${2:joystick_device dev},${3:int pov})$0"
    },
    "REAPER.JOYSTICK_GETPOV_WR lua": {
        "prefix": "reaperwr.joystick_getpov",
        "scope": "lua",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "${1:local }${2:number} = reaper.joystick_getpov(${3:joystick_device dev},${4:integer pov})$0"
    },
    "RPR_JOYSTICK_GETPOV_WR python": {
        "prefix": "WR_RPR_joystick_getpov",
        "scope": "python",
        "description": "returns POV value (usually 0..655.35, or 655.35 on error)\n",
        "body": "${1:Float} = RPR_joystick_getpov(${2:joystick_device dev},${3:Int pov})$0"
    },
    "JOYSTICK_UPDATE_WR c": {
        "prefix": "WR_joystick_update",
        "scope": "c",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "${1:bool} = joystick_update(${2:joystick_device* dev})$0"
    },
    "JOYSTICK_UPDATE_WR eel2": {
        "prefix": "WR_joystick_update",
        "scope": "eel2",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "${1:bool} = joystick_update(${2:joystick_device dev})$0"
    },
    "REAPER.JOYSTICK_UPDATE_WR lua": {
        "prefix": "reaperwr.joystick_update",
        "scope": "lua",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "${1:local }${2:boolean} = reaper.joystick_update(${3:joystick_device dev})$0"
    },
    "RPR_JOYSTICK_UPDATE_WR python": {
        "prefix": "WR_RPR_joystick_update",
        "scope": "python",
        "description": "Updates joystick state from hardware, returns true if successful\n(joystick_get* will not be valid until joystick_update() is called\nsuccessfully)\n",
        "body": "${1:Boolean} = RPR_joystick_update(${2:joystick_device dev})$0"
    },
    "LICE_CLIPLINE_WR c": {
        "prefix": "WR_LICE_ClipLine",
        "scope": "c",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "${1:bool} = LICE_ClipLine(${2:int* pX1Out},${3:int* pY1Out},${4:int* pX2Out},${5:int* pY2Out},${6:int xLo},${7:int yLo},${8:int xHi},${9:int yHi})$0"
    },
    "LICE_CLIPLINE_WR eel2": {
        "prefix": "WR_LICE_ClipLine",
        "scope": "eel2",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "${1:bool} = LICE_ClipLine(${2:int &pX1},${3:int &pY1},${4:int &pX2},${5:int &pY2},${6:int xLo},${7:int yLo},${8:int xHi},${9:int yHi})$0"
    },
    "REAPER.LICE_CLIPLINE_WR lua": {
        "prefix": "reaperwr.LICE_ClipLine",
        "scope": "lua",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "${1:local }${2:boolean retval},${3:number pX1},${4:number pY1},${5:number pX2},${6:number pY2} = reaper.LICE_ClipLine(${7:number pX1},${8:number pY1},${9:number pX2},${10:number pY2},${11:integer xLo},${12:integer yLo},${13:integer xHi},${14:integer yHi})$0"
    },
    "RPR_LICE_CLIPLINE_WR python": {
        "prefix": "WR_RPR_LICE_ClipLine",
        "scope": "python",
        "description": "Returns false if the line is entirely offscreen.\n",
        "body": "${1:Boolean retval},${2:Int pX1Out},${3:Int pY1Out},${4:Int pX2Out},${5:Int pY2Out},${6:Int xLo},${7:Int yLo},${8:Int xHi},${9:Int yHi} = RPR_LICE_ClipLine(${10:pX1Out},${11:pY1Out},${12:pX2Out},${13:pY2Out},${14:xLo},${15:yLo},${16:xHi},${17:yHi})$0"
    },
    "LOOP_ONARROW_WR c": {
        "prefix": "WR_Loop_OnArrow",
        "scope": "c",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "${1:bool} = Loop_OnArrow(${2:ReaProject* project},${3:int direction})$0"
    },
    "LOOP_ONARROW_WR eel2": {
        "prefix": "WR_Loop_OnArrow",
        "scope": "eel2",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "${1:bool} = Loop_OnArrow(${2:ReaProject project},${3:int direction})$0"
    },
    "REAPER.LOOP_ONARROW_WR lua": {
        "prefix": "reaperwr.Loop_OnArrow",
        "scope": "lua",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "${1:local }${2:boolean} = reaper.Loop_OnArrow(${3:ReaProject project},${4:integer direction})$0"
    },
    "RPR_LOOP_ONARROW_WR python": {
        "prefix": "WR_RPR_Loop_OnArrow",
        "scope": "python",
        "description": "Move the loop selection left or right. Returns true if snap is enabled.\n",
        "body": "${1:Boolean} = RPR_Loop_OnArrow(${2:ReaProject project},${3:Int direction})$0"
    },
    "MAIN_ONCOMMAND_WR c": {
        "prefix": "WR_Main_OnCommand",
        "scope": "c",
        "description": "See Main_OnCommandEx.\n",
        "body": "${1:void} = Main_OnCommand(${2:int command},${3:int flag})$0"
    },
    "MAIN_ONCOMMANDEX_WR c": {
        "prefix": "WR_Main_OnCommandEx",
        "scope": "c",
        "description": "Performs an action belonging to the main action section. To perform\nnon-native actions (ReaScripts, custom or extension plugins' actions)\nsafely, see NamedCommandLookup().\n",
        "body": "${1:void} = Main_OnCommandEx(${2:int command},${3:int flag},${4:ReaProject* proj})$0"
    },
    "MAIN_OPENPROJECT_WR c": {
        "prefix": "WR_Main_openProject",
        "scope": "c",
        "description": "opens a project. will prompt the user to save unless name is prefixed\nwith 'noprompt:'. If name is prefixed with 'template:', project file\nwill be loaded as a template.\nIf passed a .RTrackTemplate file, adds the template to the existing project.\n",
        "body": "${1:void} = Main_openProject(${2:const char* name})$0"
    },
    "MAIN_SAVEPROJECT_WR c": {
        "prefix": "WR_Main_SaveProject",
        "scope": "c",
        "description": "Save the project.\n",
        "body": "${1:void} = Main_SaveProject(${2:ReaProject* proj},${3:bool forceSaveAsInOptional})$0"
    },
    "MAIN_UPDATELOOPINFO_WR c": {
        "prefix": "WR_Main_UpdateLoopInfo",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = Main_UpdateLoopInfo(${2:int ignoremask})$0"
    },
    "MARKPROJECTDIRTY_WR c": {
        "prefix": "WR_MarkProjectDirty",
        "scope": "c",
        "description": "Marks project as dirty (needing save) if 'undo/prompt to save' is enabled in preferences.\n",
        "body": "${1:void} = MarkProjectDirty(${2:ReaProject* proj})$0"
    },
    "MARKTRACKITEMSDIRTY_WR c": {
        "prefix": "WR_MarkTrackItemsDirty",
        "scope": "c",
        "description": "If track is supplied, item is ignored\n",
        "body": "${1:void} = MarkTrackItemsDirty(${2:MediaTrack* track},${3:MediaItem* item})$0"
    },
    "MASTER_GETPLAYRATE_WR c": {
        "prefix": "WR_Master_GetPlayRate",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = Master_GetPlayRate(${2:ReaProject* project})$0"
    },
    "MASTER_GETPLAYRATE_WR eel2": {
        "prefix": "WR_Master_GetPlayRate",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = Master_GetPlayRate(${2:ReaProject project})$0"
    },
    "REAPER.MASTER_GETPLAYRATE_WR lua": {
        "prefix": "reaperwr.Master_GetPlayRate",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.Master_GetPlayRate(${3:ReaProject project})$0"
    },
    "RPR_MASTER_GETPLAYRATE_WR python": {
        "prefix": "WR_RPR_Master_GetPlayRate",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_Master_GetPlayRate(${2:ReaProject project})$0"
    },
    "MASTER_GETPLAYRATEATTIME_WR c": {
        "prefix": "WR_Master_GetPlayRateAtTime",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = Master_GetPlayRateAtTime(${2:double time_s},${3:ReaProject* proj})$0"
    },
    "MASTER_GETPLAYRATEATTIME_WR eel2": {
        "prefix": "WR_Master_GetPlayRateAtTime",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = Master_GetPlayRateAtTime(${2:time_s},${3:ReaProject proj})$0"
    },
    "REAPER.MASTER_GETPLAYRATEATTIME_WR lua": {
        "prefix": "reaperwr.Master_GetPlayRateAtTime",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.Master_GetPlayRateAtTime(${3:number time_s},${4:ReaProject proj})$0"
    },
    "RPR_MASTER_GETPLAYRATEATTIME_WR python": {
        "prefix": "WR_RPR_Master_GetPlayRateAtTime",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_Master_GetPlayRateAtTime(${2:Float time_s},${3:ReaProject proj})$0"
    },
    "MASTER_GETTEMPO_WR c": {
        "prefix": "WR_Master_GetTempo",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = Master_GetTempo()$0"
    },
    "MASTER_GETTEMPO_WR eel2": {
        "prefix": "WR_Master_GetTempo",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = Master_GetTempo()$0"
    },
    "REAPER.MASTER_GETTEMPO_WR lua": {
        "prefix": "reaperwr.Master_GetTempo",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.Master_GetTempo()$0"
    },
    "RPR_MASTER_GETTEMPO_WR python": {
        "prefix": "WR_RPR_Master_GetTempo",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_Master_GetTempo()$0"
    },
    "MASTER_NORMALIZEPLAYRATE_WR c": {
        "prefix": "WR_Master_NormalizePlayRate",
        "scope": "c",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "${1:double} = Master_NormalizePlayRate(${2:double playrate},${3:bool isnormalized})$0"
    },
    "MASTER_NORMALIZEPLAYRATE_WR eel2": {
        "prefix": "WR_Master_NormalizePlayRate",
        "scope": "eel2",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "${1:double} = Master_NormalizePlayRate(${2:playrate},${3:bool isnormalized})$0"
    },
    "REAPER.MASTER_NORMALIZEPLAYRATE_WR lua": {
        "prefix": "reaperwr.Master_NormalizePlayRate",
        "scope": "lua",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "${1:local }${2:number} = reaper.Master_NormalizePlayRate(${3:number playrate},${4:boolean isnormalized})$0"
    },
    "RPR_MASTER_NORMALIZEPLAYRATE_WR python": {
        "prefix": "WR_RPR_Master_NormalizePlayRate",
        "scope": "python",
        "description": "Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.\n",
        "body": "${1:Float} = RPR_Master_NormalizePlayRate(${2:Float playrate},${3:Boolean isnormalized})$0"
    },
    "MASTER_NORMALIZETEMPO_WR c": {
        "prefix": "WR_Master_NormalizeTempo",
        "scope": "c",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "${1:double} = Master_NormalizeTempo(${2:double bpm},${3:bool isnormalized})$0"
    },
    "MASTER_NORMALIZETEMPO_WR eel2": {
        "prefix": "WR_Master_NormalizeTempo",
        "scope": "eel2",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "${1:double} = Master_NormalizeTempo(${2:bpm},${3:bool isnormalized})$0"
    },
    "REAPER.MASTER_NORMALIZETEMPO_WR lua": {
        "prefix": "reaperwr.Master_NormalizeTempo",
        "scope": "lua",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "${1:local }${2:number} = reaper.Master_NormalizeTempo(${3:number bpm},${4:boolean isnormalized})$0"
    },
    "RPR_MASTER_NORMALIZETEMPO_WR python": {
        "prefix": "WR_RPR_Master_NormalizeTempo",
        "scope": "python",
        "description": "Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.\n",
        "body": "${1:Float} = RPR_Master_NormalizeTempo(${2:Float bpm},${3:Boolean isnormalized})$0"
    },
    "MB_WR c": {
        "prefix": "WR_MB",
        "scope": "c",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:int} = MB(${2:const char* msg},${3:const char* title},${4:int type})$0"
    },
    "MB_WR eel2": {
        "prefix": "WR_MB",
        "scope": "eel2",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:int} = MB(${2:\"msg\"},${3:\"title\"},${4:int type})$0"
    },
    "REAPER.MB_WR lua": {
        "prefix": "reaperwr.MB",
        "scope": "lua",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:local }${2:integer} = reaper.MB(${3:string msg},${4:string title},${5:integer type})$0"
    },
    "RPR_MB_WR python": {
        "prefix": "WR_RPR_MB",
        "scope": "python",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:Int} = RPR_MB(${2:String msg},${3:String title},${4:Int type})$0"
    },
    "MEDIAITEMDESCENDSFROMTRACK_WR c": {
        "prefix": "WR_MediaItemDescendsFromTrack",
        "scope": "c",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "${1:int} = MediaItemDescendsFromTrack(${2:MediaItem* item},${3:MediaTrack* track})$0"
    },
    "MEDIAITEMDESCENDSFROMTRACK_WR eel2": {
        "prefix": "WR_MediaItemDescendsFromTrack",
        "scope": "eel2",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "${1:int} = MediaItemDescendsFromTrack(${2:MediaItem item},${3:MediaTrack track})$0"
    },
    "REAPER.MEDIAITEMDESCENDSFROMTRACK_WR lua": {
        "prefix": "reaperwr.MediaItemDescendsFromTrack",
        "scope": "lua",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "${1:local }${2:integer} = reaper.MediaItemDescendsFromTrack(${3:MediaItem item},${4:MediaTrack track})$0"
    },
    "RPR_MEDIAITEMDESCENDSFROMTRACK_WR python": {
        "prefix": "WR_RPR_MediaItemDescendsFromTrack",
        "scope": "python",
        "description": "Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.\n",
        "body": "${1:Int} = RPR_MediaItemDescendsFromTrack(${2:MediaItem item},${3:MediaTrack track})$0"
    },
    "MIDI_COUNTEVTS_WR c": {
        "prefix": "WR_MIDI_CountEvts",
        "scope": "c",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "${1:int} = MIDI_CountEvts(${2:MediaItem_Take* take},${3:int* notecntOut},${4:int* ccevtcntOut},${5:int* textsyxevtcntOut})$0"
    },
    "MIDI_COUNTEVTS_WR eel2": {
        "prefix": "WR_MIDI_CountEvts",
        "scope": "eel2",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "${1:int} = MIDI_CountEvts(${2:MediaItem_Take take},${3:int &notecnt},${4:int &ccevtcnt},${5:int &textsyxevtcnt})$0"
    },
    "REAPER.MIDI_COUNTEVTS_WR lua": {
        "prefix": "reaperwr.MIDI_CountEvts",
        "scope": "lua",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "${1:local }${2:integer retval},${3:number notecnt},${4:number ccevtcnt},${5:number textsyxevtcnt} = reaper.MIDI_CountEvts(${6:MediaItem_Take take})$0"
    },
    "RPR_MIDI_COUNTEVTS_WR python": {
        "prefix": "WR_RPR_MIDI_CountEvts",
        "scope": "python",
        "description": "Count the number of notes, CC events, and text/sysex events in a given MIDI item.\n",
        "body": "${1:Int retval},${2:MediaItem_Take take},${3:Int notecntOut},${4:Int ccevtcntOut},${5:Int textsyxevtcntOut} = RPR_MIDI_CountEvts(${6:take},${7:notecntOut},${8:ccevtcntOut},${9:textsyxevtcntOut})$0"
    },
    "MIDI_DELETECC_WR c": {
        "prefix": "WR_MIDI_DeleteCC",
        "scope": "c",
        "description": "Delete a MIDI CC event.\n",
        "body": "${1:bool} = MIDI_DeleteCC(${2:MediaItem_Take* take},${3:int ccidx})$0"
    },
    "MIDI_DELETECC_WR eel2": {
        "prefix": "WR_MIDI_DeleteCC",
        "scope": "eel2",
        "description": "Delete a MIDI CC event.\n",
        "body": "${1:bool} = MIDI_DeleteCC(${2:MediaItem_Take take},${3:int ccidx})$0"
    },
    "REAPER.MIDI_DELETECC_WR lua": {
        "prefix": "reaperwr.MIDI_DeleteCC",
        "scope": "lua",
        "description": "Delete a MIDI CC event.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_DeleteCC(${3:MediaItem_Take take},${4:integer ccidx})$0"
    },
    "RPR_MIDI_DELETECC_WR python": {
        "prefix": "WR_RPR_MIDI_DeleteCC",
        "scope": "python",
        "description": "Delete a MIDI CC event.\n",
        "body": "${1:Boolean} = RPR_MIDI_DeleteCC(${2:MediaItem_Take take},${3:Int ccidx})$0"
    },
    "MIDI_DELETEEVT_WR c": {
        "prefix": "WR_MIDI_DeleteEvt",
        "scope": "c",
        "description": "Delete a MIDI event.\n",
        "body": "${1:bool} = MIDI_DeleteEvt(${2:MediaItem_Take* take},${3:int evtidx})$0"
    },
    "MIDI_DELETEEVT_WR eel2": {
        "prefix": "WR_MIDI_DeleteEvt",
        "scope": "eel2",
        "description": "Delete a MIDI event.\n",
        "body": "${1:bool} = MIDI_DeleteEvt(${2:MediaItem_Take take},${3:int evtidx})$0"
    },
    "REAPER.MIDI_DELETEEVT_WR lua": {
        "prefix": "reaperwr.MIDI_DeleteEvt",
        "scope": "lua",
        "description": "Delete a MIDI event.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_DeleteEvt(${3:MediaItem_Take take},${4:integer evtidx})$0"
    },
    "RPR_MIDI_DELETEEVT_WR python": {
        "prefix": "WR_RPR_MIDI_DeleteEvt",
        "scope": "python",
        "description": "Delete a MIDI event.\n",
        "body": "${1:Boolean} = RPR_MIDI_DeleteEvt(${2:MediaItem_Take take},${3:Int evtidx})$0"
    },
    "MIDI_DELETENOTE_WR c": {
        "prefix": "WR_MIDI_DeleteNote",
        "scope": "c",
        "description": "Delete a MIDI note.\n",
        "body": "${1:bool} = MIDI_DeleteNote(${2:MediaItem_Take* take},${3:int noteidx})$0"
    },
    "MIDI_DELETENOTE_WR eel2": {
        "prefix": "WR_MIDI_DeleteNote",
        "scope": "eel2",
        "description": "Delete a MIDI note.\n",
        "body": "${1:bool} = MIDI_DeleteNote(${2:MediaItem_Take take},${3:int noteidx})$0"
    },
    "REAPER.MIDI_DELETENOTE_WR lua": {
        "prefix": "reaperwr.MIDI_DeleteNote",
        "scope": "lua",
        "description": "Delete a MIDI note.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_DeleteNote(${3:MediaItem_Take take},${4:integer noteidx})$0"
    },
    "RPR_MIDI_DELETENOTE_WR python": {
        "prefix": "WR_RPR_MIDI_DeleteNote",
        "scope": "python",
        "description": "Delete a MIDI note.\n",
        "body": "${1:Boolean} = RPR_MIDI_DeleteNote(${2:MediaItem_Take take},${3:Int noteidx})$0"
    },
    "MIDI_DELETETEXTSYSEXEVT_WR c": {
        "prefix": "WR_MIDI_DeleteTextSysexEvt",
        "scope": "c",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "${1:bool} = MIDI_DeleteTextSysexEvt(${2:MediaItem_Take* take},${3:int textsyxevtidx})$0"
    },
    "MIDI_DELETETEXTSYSEXEVT_WR eel2": {
        "prefix": "WR_MIDI_DeleteTextSysexEvt",
        "scope": "eel2",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "${1:bool} = MIDI_DeleteTextSysexEvt(${2:MediaItem_Take take},${3:int textsyxevtidx})$0"
    },
    "REAPER.MIDI_DELETETEXTSYSEXEVT_WR lua": {
        "prefix": "reaperwr.MIDI_DeleteTextSysexEvt",
        "scope": "lua",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_DeleteTextSysexEvt(${3:MediaItem_Take take},${4:integer textsyxevtidx})$0"
    },
    "RPR_MIDI_DELETETEXTSYSEXEVT_WR python": {
        "prefix": "WR_RPR_MIDI_DeleteTextSysexEvt",
        "scope": "python",
        "description": "Delete a MIDI text or sysex event.\n",
        "body": "${1:Boolean} = RPR_MIDI_DeleteTextSysexEvt(${2:MediaItem_Take take},${3:Int textsyxevtidx})$0"
    },
    "MIDI_DISABLESORT_WR c": {
        "prefix": "WR_MIDI_DisableSort",
        "scope": "c",
        "description": "Disable sorting for all MIDI insert, delete, get and set functions, until MIDI_Sort is called.\n",
        "body": "${1:void} = MIDI_DisableSort(${2:MediaItem_Take* take})$0"
    },
    "MIDI_ENUMSELCC_WR c": {
        "prefix": "WR_MIDI_EnumSelCC",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelCC(${2:MediaItem_Take* take},${3:int ccidx})$0"
    },
    "MIDI_ENUMSELCC_WR eel2": {
        "prefix": "WR_MIDI_EnumSelCC",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelCC(${2:MediaItem_Take take},${3:int ccidx})$0"
    },
    "REAPER.MIDI_ENUMSELCC_WR lua": {
        "prefix": "reaperwr.MIDI_EnumSelCC",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "${1:local }${2:integer} = reaper.MIDI_EnumSelCC(${3:MediaItem_Take take},${4:integer ccidx})$0"
    },
    "RPR_MIDI_ENUMSELCC_WR python": {
        "prefix": "WR_RPR_MIDI_EnumSelCC",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).\n",
        "body": "${1:Int} = RPR_MIDI_EnumSelCC(${2:MediaItem_Take take},${3:Int ccidx})$0"
    },
    "MIDI_ENUMSELEVTS_WR c": {
        "prefix": "WR_MIDI_EnumSelEvts",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelEvts(${2:MediaItem_Take* take},${3:int evtidx})$0"
    },
    "MIDI_ENUMSELEVTS_WR eel2": {
        "prefix": "WR_MIDI_EnumSelEvts",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelEvts(${2:MediaItem_Take take},${3:int evtidx})$0"
    },
    "REAPER.MIDI_ENUMSELEVTS_WR lua": {
        "prefix": "reaperwr.MIDI_EnumSelEvts",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "${1:local }${2:integer} = reaper.MIDI_EnumSelEvts(${3:MediaItem_Take take},${4:integer evtidx})$0"
    },
    "RPR_MIDI_ENUMSELEVTS_WR python": {
        "prefix": "WR_RPR_MIDI_EnumSelEvts",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).\n",
        "body": "${1:Int} = RPR_MIDI_EnumSelEvts(${2:MediaItem_Take take},${3:Int evtidx})$0"
    },
    "MIDI_ENUMSELNOTES_WR c": {
        "prefix": "WR_MIDI_EnumSelNotes",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelNotes(${2:MediaItem_Take* take},${3:int noteidx})$0"
    },
    "MIDI_ENUMSELNOTES_WR eel2": {
        "prefix": "WR_MIDI_EnumSelNotes",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelNotes(${2:MediaItem_Take take},${3:int noteidx})$0"
    },
    "REAPER.MIDI_ENUMSELNOTES_WR lua": {
        "prefix": "reaperwr.MIDI_EnumSelNotes",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "${1:local }${2:integer} = reaper.MIDI_EnumSelNotes(${3:MediaItem_Take take},${4:integer noteidx})$0"
    },
    "RPR_MIDI_ENUMSELNOTES_WR python": {
        "prefix": "WR_RPR_MIDI_EnumSelNotes",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).\n",
        "body": "${1:Int} = RPR_MIDI_EnumSelNotes(${2:MediaItem_Take take},${3:Int noteidx})$0"
    },
    "MIDI_ENUMSELTEXTSYSEXEVTS_WR c": {
        "prefix": "WR_MIDI_EnumSelTextSysexEvts",
        "scope": "c",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelTextSysexEvts(${2:MediaItem_Take* take},${3:int textsyxidx})$0"
    },
    "MIDI_ENUMSELTEXTSYSEXEVTS_WR eel2": {
        "prefix": "WR_MIDI_EnumSelTextSysexEvts",
        "scope": "eel2",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "${1:int} = MIDI_EnumSelTextSysexEvts(${2:MediaItem_Take take},${3:int textsyxidx})$0"
    },
    "REAPER.MIDI_ENUMSELTEXTSYSEXEVTS_WR lua": {
        "prefix": "reaperwr.MIDI_EnumSelTextSysexEvts",
        "scope": "lua",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "${1:local }${2:integer} = reaper.MIDI_EnumSelTextSysexEvts(${3:MediaItem_Take take},${4:integer textsyxidx})$0"
    },
    "RPR_MIDI_ENUMSELTEXTSYSEXEVTS_WR python": {
        "prefix": "WR_RPR_MIDI_EnumSelTextSysexEvts",
        "scope": "python",
        "description": "Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).\n",
        "body": "${1:Int} = RPR_MIDI_EnumSelTextSysexEvts(${2:MediaItem_Take take},${3:Int textsyxidx})$0"
    },
    "MIDI_GETALLEVTS_WR c": {
        "prefix": "WR_MIDI_GetAllEvts",
        "scope": "c",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "${1:bool} = MIDI_GetAllEvts(${2:MediaItem_Take* take},${3:char* bufNeedBig},${4:int* bufNeedBig_sz})$0"
    },
    "MIDI_GETALLEVTS_WR eel2": {
        "prefix": "WR_MIDI_GetAllEvts",
        "scope": "eel2",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "${1:bool} = MIDI_GetAllEvts(${2:MediaItem_Take take},${3:#buf})$0"
    },
    "REAPER.MIDI_GETALLEVTS_WR lua": {
        "prefix": "reaperwr.MIDI_GetAllEvts",
        "scope": "lua",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.MIDI_GetAllEvts(${4:MediaItem_Take take},${5:string buf})$0"
    },
    "RPR_MIDI_GETALLEVTS_WR python": {
        "prefix": "WR_RPR_MIDI_GetAllEvts",
        "scope": "python",
        "description": "Get all MIDI data. MIDI buffer is returned as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_SetAllEvts.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:String bufNeedBig},${4:Int bufNeedBig_sz} = RPR_MIDI_GetAllEvts(${5:take},${6:bufNeedBig},${7:bufNeedBig_sz})$0"
    },
    "MIDI_GETCC_WR c": {
        "prefix": "WR_MIDI_GetCC",
        "scope": "c",
        "description": "Get MIDI CC event properties.\n",
        "body": "${1:bool} = MIDI_GetCC(${2:MediaItem_Take* take},${3:int ccidx},${4:bool* selectedOut},${5:bool* mutedOut},${6:double* ppqposOut},${7:int* chanmsgOut},${8:int* chanOut},${9:int* msg2Out},${10:int* msg3Out})$0"
    },
    "MIDI_GETCC_WR eel2": {
        "prefix": "WR_MIDI_GetCC",
        "scope": "eel2",
        "description": "Get MIDI CC event properties.\n",
        "body": "${1:bool} = MIDI_GetCC(${2:MediaItem_Take take},${3:int ccidx},${4:bool &selected},${5:bool &muted},${6:&ppqpos},${7:int &chanmsg},${8:int &chan},${9:int &msg2},${10:int &msg3})$0"
    },
    "REAPER.MIDI_GETCC_WR lua": {
        "prefix": "reaperwr.MIDI_GetCC",
        "scope": "lua",
        "description": "Get MIDI CC event properties.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean selected},${4:boolean muted},${5:number ppqpos},${6:number chanmsg},${7:number chan},${8:number msg2},${9:number msg3} = reaper.MIDI_GetCC(${10:MediaItem_Take take},${11:integer ccidx})$0"
    },
    "RPR_MIDI_GETCC_WR python": {
        "prefix": "WR_RPR_MIDI_GetCC",
        "scope": "python",
        "description": "Get MIDI CC event properties.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int ccidx},${4:Boolean selectedOut},${5:Boolean mutedOut},${6:Float ppqposOut},${7:Int chanmsgOut},${8:Int chanOut},${9:Int msg2Out},${10:Int msg3Out} = RPR_MIDI_GetCC(${11:take},${12:ccidx},${13:selectedOut},${14:mutedOut},${15:ppqposOut},${16:chanmsgOut},${17:chanOut},${18:msg2Out},${19:msg3Out})$0"
    },
    "MIDI_GETCCSHAPE_WR c": {
        "prefix": "WR_MIDI_GetCCShape",
        "scope": "c",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "${1:bool} = MIDI_GetCCShape(${2:MediaItem_Take* take},${3:int ccidx},${4:int* shapeOut},${5:double* beztensionOut})$0"
    },
    "MIDI_GETCCSHAPE_WR eel2": {
        "prefix": "WR_MIDI_GetCCShape",
        "scope": "eel2",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "${1:bool} = MIDI_GetCCShape(${2:MediaItem_Take take},${3:int ccidx},${4:int &shape},${5:&beztension})$0"
    },
    "REAPER.MIDI_GETCCSHAPE_WR lua": {
        "prefix": "reaperwr.MIDI_GetCCShape",
        "scope": "lua",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "${1:local }${2:boolean retval},${3:number shape},${4:number beztension} = reaper.MIDI_GetCCShape(${5:MediaItem_Take take},${6:integer ccidx})$0"
    },
    "RPR_MIDI_GETCCSHAPE_WR python": {
        "prefix": "WR_RPR_MIDI_GetCCShape",
        "scope": "python",
        "description": "Get CC shape and bezier tension. See MIDI_GetCC, MIDI_SetCCShape\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int ccidx},${4:Int shapeOut},${5:Float beztensionOut} = RPR_MIDI_GetCCShape(${6:take},${7:ccidx},${8:shapeOut},${9:beztensionOut})$0"
    },
    "MIDI_GETEVT_WR c": {
        "prefix": "WR_MIDI_GetEvt",
        "scope": "c",
        "description": "Get MIDI event properties.\n",
        "body": "${1:bool} = MIDI_GetEvt(${2:MediaItem_Take* take},${3:int evtidx},${4:bool* selectedOut},${5:bool* mutedOut},${6:double* ppqposOut},${7:char* msg},${8:int* msg_sz})$0"
    },
    "MIDI_GETEVT_WR eel2": {
        "prefix": "WR_MIDI_GetEvt",
        "scope": "eel2",
        "description": "Get MIDI event properties.\n",
        "body": "${1:bool} = MIDI_GetEvt(${2:MediaItem_Take take},${3:int evtidx},${4:bool &selected},${5:bool &muted},${6:&ppqpos},${7:#msg})$0"
    },
    "REAPER.MIDI_GETEVT_WR lua": {
        "prefix": "reaperwr.MIDI_GetEvt",
        "scope": "lua",
        "description": "Get MIDI event properties.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean selected},${4:boolean muted},${5:number ppqpos},${6:string msg} = reaper.MIDI_GetEvt(${7:MediaItem_Take take},${8:integer evtidx},${9:boolean selected},${10:boolean muted},${11:number ppqpos},${12:string msg})$0"
    },
    "RPR_MIDI_GETEVT_WR python": {
        "prefix": "WR_RPR_MIDI_GetEvt",
        "scope": "python",
        "description": "Get MIDI event properties.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int evtidx},${4:Boolean selectedOut},${5:Boolean mutedOut},${6:Float ppqposOut},${7:String msg},${8:Int msg_sz} = RPR_MIDI_GetEvt(${9:take},${10:evtidx},${11:selectedOut},${12:mutedOut},${13:ppqposOut},${14:msg},${15:msg_sz})$0"
    },
    "MIDI_GETGRID_WR c": {
        "prefix": "WR_MIDI_GetGrid",
        "scope": "c",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "${1:double} = MIDI_GetGrid(${2:MediaItem_Take* take},${3:double* swingOutOptional},${4:double* noteLenOutOptional})$0"
    },
    "MIDI_GETGRID_WR eel2": {
        "prefix": "WR_MIDI_GetGrid",
        "scope": "eel2",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "${1:double} = MIDI_GetGrid(${2:MediaItem_Take take},${3:optional &swing},${4:optional &noteLen})$0"
    },
    "REAPER.MIDI_GETGRID_WR lua": {
        "prefix": "reaperwr.MIDI_GetGrid",
        "scope": "lua",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "${1:local }${2:number retval},${3:optional number swing},${4:optional number noteLen} = reaper.MIDI_GetGrid(${5:MediaItem_Take take})$0"
    },
    "RPR_MIDI_GETGRID_WR python": {
        "prefix": "WR_RPR_MIDI_GetGrid",
        "scope": "python",
        "description": "Returns the most recent MIDI editor grid size for this MIDI take, in QN.\nSwing is between 0 and 1. Note length is 0 if it follows the grid size.\n",
        "body": "${1:Float retval},${2:MediaItem_Take take},${3:Float swingOutOptional},${4:Float noteLenOutOptional} = RPR_MIDI_GetGrid(${5:take},${6:swingOutOptional},${7:noteLenOutOptional})$0"
    },
    "MIDI_GETHASH_WR c": {
        "prefix": "WR_MIDI_GetHash",
        "scope": "c",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "${1:bool} = MIDI_GetHash(${2:MediaItem_Take* take},${3:bool notesonly},${4:char* hash},${5:int hash_sz})$0"
    },
    "MIDI_GETHASH_WR eel2": {
        "prefix": "WR_MIDI_GetHash",
        "scope": "eel2",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "${1:bool} = MIDI_GetHash(${2:MediaItem_Take take},${3:bool notesonly},${4:#hash})$0"
    },
    "REAPER.MIDI_GETHASH_WR lua": {
        "prefix": "reaperwr.MIDI_GetHash",
        "scope": "lua",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "${1:local }${2:boolean retval},${3:string hash} = reaper.MIDI_GetHash(${4:MediaItem_Take take},${5:boolean notesonly},${6:string hash})$0"
    },
    "RPR_MIDI_GETHASH_WR python": {
        "prefix": "WR_RPR_MIDI_GetHash",
        "scope": "python",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetTrackHash\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Boolean notesonly},${4:String hash},${5:Int hash_sz} = RPR_MIDI_GetHash(${6:take},${7:notesonly},${8:hash},${9:hash_sz})$0"
    },
    "MIDI_GETNOTE_WR c": {
        "prefix": "WR_MIDI_GetNote",
        "scope": "c",
        "description": "Get MIDI note properties.\n",
        "body": "${1:bool} = MIDI_GetNote(${2:MediaItem_Take* take},${3:int noteidx},${4:bool* selectedOut},${5:bool* mutedOut},${6:double* startppqposOut},${7:double* endppqposOut},${8:int* chanOut},${9:int* pitchOut},${10:int* velOut})$0"
    },
    "MIDI_GETNOTE_WR eel2": {
        "prefix": "WR_MIDI_GetNote",
        "scope": "eel2",
        "description": "Get MIDI note properties.\n",
        "body": "${1:bool} = MIDI_GetNote(${2:MediaItem_Take take},${3:int noteidx},${4:bool &selected},${5:bool &muted},${6:&startppqpos},${7:&endppqpos},${8:int &chan},${9:int &pitch},${10:int &vel})$0"
    },
    "REAPER.MIDI_GETNOTE_WR lua": {
        "prefix": "reaperwr.MIDI_GetNote",
        "scope": "lua",
        "description": "Get MIDI note properties.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean selected},${4:boolean muted},${5:number startppqpos},${6:number endppqpos},${7:number chan},${8:number pitch},${9:number vel} = reaper.MIDI_GetNote(${10:MediaItem_Take take},${11:integer noteidx})$0"
    },
    "RPR_MIDI_GETNOTE_WR python": {
        "prefix": "WR_RPR_MIDI_GetNote",
        "scope": "python",
        "description": "Get MIDI note properties.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int noteidx},${4:Boolean selectedOut},${5:Boolean mutedOut},${6:Float startppqposOut},${7:Float endppqposOut},${8:Int chanOut},${9:Int pitchOut},${10:Int velOut} = RPR_MIDI_GetNote(${11:take},${12:noteidx},${13:selectedOut},${14:mutedOut},${15:startppqposOut},${16:endppqposOut},${17:chanOut},${18:pitchOut},${19:velOut})$0"
    },
    "MIDI_GETPPQPOS_ENDOFMEASURE_WR c": {
        "prefix": "WR_MIDI_GetPPQPos_EndOfMeasure",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "${1:double} = MIDI_GetPPQPos_EndOfMeasure(${2:MediaItem_Take* take},${3:double ppqpos})$0"
    },
    "MIDI_GETPPQPOS_ENDOFMEASURE_WR eel2": {
        "prefix": "WR_MIDI_GetPPQPos_EndOfMeasure",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "${1:double} = MIDI_GetPPQPos_EndOfMeasure(${2:MediaItem_Take take},${3:ppqpos})$0"
    },
    "REAPER.MIDI_GETPPQPOS_ENDOFMEASURE_WR lua": {
        "prefix": "reaperwr.MIDI_GetPPQPos_EndOfMeasure",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "${1:local }${2:number} = reaper.MIDI_GetPPQPos_EndOfMeasure(${3:MediaItem_Take take},${4:number ppqpos})$0"
    },
    "RPR_MIDI_GETPPQPOS_ENDOFMEASURE_WR python": {
        "prefix": "WR_RPR_MIDI_GetPPQPos_EndOfMeasure",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to the end of the measure.\n",
        "body": "${1:Float} = RPR_MIDI_GetPPQPos_EndOfMeasure(${2:MediaItem_Take take},${3:Float ppqpos})$0"
    },
    "MIDI_GETPPQPOS_STARTOFMEASURE_WR c": {
        "prefix": "WR_MIDI_GetPPQPos_StartOfMeasure",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "${1:double} = MIDI_GetPPQPos_StartOfMeasure(${2:MediaItem_Take* take},${3:double ppqpos})$0"
    },
    "MIDI_GETPPQPOS_STARTOFMEASURE_WR eel2": {
        "prefix": "WR_MIDI_GetPPQPos_StartOfMeasure",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "${1:double} = MIDI_GetPPQPos_StartOfMeasure(${2:MediaItem_Take take},${3:ppqpos})$0"
    },
    "REAPER.MIDI_GETPPQPOS_STARTOFMEASURE_WR lua": {
        "prefix": "reaperwr.MIDI_GetPPQPos_StartOfMeasure",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "${1:local }${2:number} = reaper.MIDI_GetPPQPos_StartOfMeasure(${3:MediaItem_Take take},${4:number ppqpos})$0"
    },
    "RPR_MIDI_GETPPQPOS_STARTOFMEASURE_WR python": {
        "prefix": "WR_RPR_MIDI_GetPPQPos_StartOfMeasure",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to the start of the measure.\n",
        "body": "${1:Float} = RPR_MIDI_GetPPQPos_StartOfMeasure(${2:MediaItem_Take take},${3:Float ppqpos})$0"
    },
    "MIDI_GETPPQPOSFROMPROJQN_WR c": {
        "prefix": "WR_MIDI_GetPPQPosFromProjQN",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "${1:double} = MIDI_GetPPQPosFromProjQN(${2:MediaItem_Take* take},${3:double projqn})$0"
    },
    "MIDI_GETPPQPOSFROMPROJQN_WR eel2": {
        "prefix": "WR_MIDI_GetPPQPosFromProjQN",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "${1:double} = MIDI_GetPPQPosFromProjQN(${2:MediaItem_Take take},${3:projqn})$0"
    },
    "REAPER.MIDI_GETPPQPOSFROMPROJQN_WR lua": {
        "prefix": "reaperwr.MIDI_GetPPQPosFromProjQN",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "${1:local }${2:number} = reaper.MIDI_GetPPQPosFromProjQN(${3:MediaItem_Take take},${4:number projqn})$0"
    },
    "RPR_MIDI_GETPPQPOSFROMPROJQN_WR python": {
        "prefix": "WR_RPR_MIDI_GetPPQPosFromProjQN",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in quarter notes.\n",
        "body": "${1:Float} = RPR_MIDI_GetPPQPosFromProjQN(${2:MediaItem_Take take},${3:Float projqn})$0"
    },
    "MIDI_GETPPQPOSFROMPROJTIME_WR c": {
        "prefix": "WR_MIDI_GetPPQPosFromProjTime",
        "scope": "c",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "${1:double} = MIDI_GetPPQPosFromProjTime(${2:MediaItem_Take* take},${3:double projtime})$0"
    },
    "MIDI_GETPPQPOSFROMPROJTIME_WR eel2": {
        "prefix": "WR_MIDI_GetPPQPosFromProjTime",
        "scope": "eel2",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "${1:double} = MIDI_GetPPQPosFromProjTime(${2:MediaItem_Take take},${3:projtime})$0"
    },
    "REAPER.MIDI_GETPPQPOSFROMPROJTIME_WR lua": {
        "prefix": "reaperwr.MIDI_GetPPQPosFromProjTime",
        "scope": "lua",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "${1:local }${2:number} = reaper.MIDI_GetPPQPosFromProjTime(${3:MediaItem_Take take},${4:number projtime})$0"
    },
    "RPR_MIDI_GETPPQPOSFROMPROJTIME_WR python": {
        "prefix": "WR_RPR_MIDI_GetPPQPosFromProjTime",
        "scope": "python",
        "description": "Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.\n",
        "body": "${1:Float} = RPR_MIDI_GetPPQPosFromProjTime(${2:MediaItem_Take take},${3:Float projtime})$0"
    },
    "MIDI_GETPROJQNFROMPPQPOS_WR c": {
        "prefix": "WR_MIDI_GetProjQNFromPPQPos",
        "scope": "c",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:double} = MIDI_GetProjQNFromPPQPos(${2:MediaItem_Take* take},${3:double ppqpos})$0"
    },
    "MIDI_GETPROJQNFROMPPQPOS_WR eel2": {
        "prefix": "WR_MIDI_GetProjQNFromPPQPos",
        "scope": "eel2",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:double} = MIDI_GetProjQNFromPPQPos(${2:MediaItem_Take take},${3:ppqpos})$0"
    },
    "REAPER.MIDI_GETPROJQNFROMPPQPOS_WR lua": {
        "prefix": "reaperwr.MIDI_GetProjQNFromPPQPos",
        "scope": "lua",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:local }${2:number} = reaper.MIDI_GetProjQNFromPPQPos(${3:MediaItem_Take take},${4:number ppqpos})$0"
    },
    "RPR_MIDI_GETPROJQNFROMPPQPOS_WR python": {
        "prefix": "WR_RPR_MIDI_GetProjQNFromPPQPos",
        "scope": "python",
        "description": "Returns the project time in quarter notes corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:Float} = RPR_MIDI_GetProjQNFromPPQPos(${2:MediaItem_Take take},${3:Float ppqpos})$0"
    },
    "MIDI_GETPROJTIMEFROMPPQPOS_WR c": {
        "prefix": "WR_MIDI_GetProjTimeFromPPQPos",
        "scope": "c",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:double} = MIDI_GetProjTimeFromPPQPos(${2:MediaItem_Take* take},${3:double ppqpos})$0"
    },
    "MIDI_GETPROJTIMEFROMPPQPOS_WR eel2": {
        "prefix": "WR_MIDI_GetProjTimeFromPPQPos",
        "scope": "eel2",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:double} = MIDI_GetProjTimeFromPPQPos(${2:MediaItem_Take take},${3:ppqpos})$0"
    },
    "REAPER.MIDI_GETPROJTIMEFROMPPQPOS_WR lua": {
        "prefix": "reaperwr.MIDI_GetProjTimeFromPPQPos",
        "scope": "lua",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:local }${2:number} = reaper.MIDI_GetProjTimeFromPPQPos(${3:MediaItem_Take take},${4:number ppqpos})$0"
    },
    "RPR_MIDI_GETPROJTIMEFROMPPQPOS_WR python": {
        "prefix": "WR_RPR_MIDI_GetProjTimeFromPPQPos",
        "scope": "python",
        "description": "Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.\n",
        "body": "${1:Float} = RPR_MIDI_GetProjTimeFromPPQPos(${2:MediaItem_Take take},${3:Float ppqpos})$0"
    },
    "MIDI_GETSCALE_WR c": {
        "prefix": "WR_MIDI_GetScale",
        "scope": "c",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "${1:bool} = MIDI_GetScale(${2:MediaItem_Take* take},${3:int* rootOut},${4:int* scaleOut},${5:char* name},${6:int name_sz})$0"
    },
    "MIDI_GETSCALE_WR eel2": {
        "prefix": "WR_MIDI_GetScale",
        "scope": "eel2",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "${1:bool} = MIDI_GetScale(${2:MediaItem_Take take},${3:int &root},${4:int &scale},${5:#name})$0"
    },
    "REAPER.MIDI_GETSCALE_WR lua": {
        "prefix": "reaperwr.MIDI_GetScale",
        "scope": "lua",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "${1:local }${2:boolean retval},${3:number root},${4:number scale},${5:string name} = reaper.MIDI_GetScale(${6:MediaItem_Take take},${7:number root},${8:number scale},${9:string name})$0"
    },
    "RPR_MIDI_GETSCALE_WR python": {
        "prefix": "WR_RPR_MIDI_GetScale",
        "scope": "python",
        "description": "Get the active scale in the media source, if any. root 0=C, 1=C#, etc.\nscale &0x1=root, &0x2=minor 2nd, &0x4=major 2nd,\n&0x8=minor 3rd, &0xF=fourth, etc.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int rootOut},${4:Int scaleOut},${5:String name},${6:Int name_sz} = RPR_MIDI_GetScale(${7:take},${8:rootOut},${9:scaleOut},${10:name},${11:name_sz})$0"
    },
    "MIDI_GETTEXTSYSEXEVT_WR c": {
        "prefix": "WR_MIDI_GetTextSysexEvt",
        "scope": "c",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "${1:bool} = MIDI_GetTextSysexEvt(${2:MediaItem_Take* take},${3:int textsyxevtidx},${4:bool* selectedOutOptional},${5:bool* mutedOutOptional},${6:double* ppqposOutOptional},${7:int* typeOutOptional},${8:char* msgOptional},${9:int* msgOptional_sz})$0"
    },
    "MIDI_GETTEXTSYSEXEVT_WR eel2": {
        "prefix": "WR_MIDI_GetTextSysexEvt",
        "scope": "eel2",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "${1:bool} = MIDI_GetTextSysexEvt(${2:MediaItem_Take take},${3:int textsyxevtidx},${4:optional bool &selected},${5:optional bool &muted},${6:optional &ppqpos},${7:optional int &type},${8:optional #msg})$0"
    },
    "REAPER.MIDI_GETTEXTSYSEXEVT_WR lua": {
        "prefix": "reaperwr.MIDI_GetTextSysexEvt",
        "scope": "lua",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "${1:local }${2:boolean retval},${3:optional boolean selected},${4:optional boolean muted},${5:optional number ppqpos},${6:optional number type},${7:optional string msg} = reaper.MIDI_GetTextSysexEvt(${8:MediaItem_Take take},${9:integer textsyxevtidx},${10:optional boolean selected},${11:optional boolean muted},${12:optional number ppqpos},${13:optional number type},${14:optional string msg})$0"
    },
    "RPR_MIDI_GETTEXTSYSEXEVT_WR python": {
        "prefix": "WR_RPR_MIDI_GetTextSysexEvt",
        "scope": "python",
        "description": "Get MIDI meta-event properties. Allowable types are -1:sysex (msg should\nnot include bounding F0..F7), 1-14:MIDI text event types, 15=REAPER\nnotation event. For all other meta-messages, type is returned as -2 and\nmsg returned as all zeroes. See MIDI_GetEvt.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int textsyxevtidx},${4:Boolean selectedOutOptional},${5:Boolean mutedOutOptional},${6:Float ppqposOutOptional},${7:Int typeOutOptional},${8:String msgOptional},${9:Int msgOptional_sz} = RPR_MIDI_GetTextSysexEvt(${10:take},${11:textsyxevtidx},${12:selectedOutOptional},${13:mutedOutOptional},${14:ppqposOutOptional},${15:typeOutOptional},${16:msgOptional},${17:msgOptional_sz})$0"
    },
    "MIDI_GETTRACKHASH_WR c": {
        "prefix": "WR_MIDI_GetTrackHash",
        "scope": "c",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "${1:bool} = MIDI_GetTrackHash(${2:MediaTrack* track},${3:bool notesonly},${4:char* hash},${5:int hash_sz})$0"
    },
    "MIDI_GETTRACKHASH_WR eel2": {
        "prefix": "WR_MIDI_GetTrackHash",
        "scope": "eel2",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "${1:bool} = MIDI_GetTrackHash(${2:MediaTrack track},${3:bool notesonly},${4:#hash})$0"
    },
    "REAPER.MIDI_GETTRACKHASH_WR lua": {
        "prefix": "reaperwr.MIDI_GetTrackHash",
        "scope": "lua",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "${1:local }${2:boolean retval},${3:string hash} = reaper.MIDI_GetTrackHash(${4:MediaTrack track},${5:boolean notesonly},${6:string hash})$0"
    },
    "RPR_MIDI_GETTRACKHASH_WR python": {
        "prefix": "WR_RPR_MIDI_GetTrackHash",
        "scope": "python",
        "description": "Get a string that only changes when the MIDI data changes. If\nnotesonly==true, then the string changes only when the MIDI notes\nchange. See MIDI_GetHash\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Boolean notesonly},${4:String hash},${5:Int hash_sz} = RPR_MIDI_GetTrackHash(${6:track},${7:notesonly},${8:hash},${9:hash_sz})$0"
    },
    "MIDI_INSERTCC_WR c": {
        "prefix": "WR_MIDI_InsertCC",
        "scope": "c",
        "description": "Insert a new MIDI CC event.\n",
        "body": "${1:bool} = MIDI_InsertCC(${2:MediaItem_Take* take},${3:bool selected},${4:bool muted},${5:double ppqpos},${6:int chanmsg},${7:int chan},${8:int msg2},${9:int msg3})$0"
    },
    "MIDI_INSERTCC_WR eel2": {
        "prefix": "WR_MIDI_InsertCC",
        "scope": "eel2",
        "description": "Insert a new MIDI CC event.\n",
        "body": "${1:bool} = MIDI_InsertCC(${2:MediaItem_Take take},${3:bool selected},${4:bool muted},${5:ppqpos},${6:int chanmsg},${7:int chan},${8:int msg2},${9:int msg3})$0"
    },
    "REAPER.MIDI_INSERTCC_WR lua": {
        "prefix": "reaperwr.MIDI_InsertCC",
        "scope": "lua",
        "description": "Insert a new MIDI CC event.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_InsertCC(${3:MediaItem_Take take},${4:boolean selected},${5:boolean muted},${6:number ppqpos},${7:integer chanmsg},${8:integer chan},${9:integer msg2},${10:integer msg3})$0"
    },
    "RPR_MIDI_INSERTCC_WR python": {
        "prefix": "WR_RPR_MIDI_InsertCC",
        "scope": "python",
        "description": "Insert a new MIDI CC event.\n",
        "body": "${1:Boolean} = RPR_MIDI_InsertCC(${2:MediaItem_Take take},${3:Boolean selected},${4:Boolean muted},${5:Float ppqpos},${6:Int chanmsg},${7:Int chan},${8:Int msg2},${9:Int msg3})$0"
    },
    "MIDI_INSERTEVT_WR c": {
        "prefix": "WR_MIDI_InsertEvt",
        "scope": "c",
        "description": "Insert a new MIDI event.\n",
        "body": "${1:bool} = MIDI_InsertEvt(${2:MediaItem_Take* take},${3:bool selected},${4:bool muted},${5:double ppqpos},${6:const char* bytestr},${7:int bytestr_sz})$0"
    },
    "MIDI_INSERTEVT_WR eel2": {
        "prefix": "WR_MIDI_InsertEvt",
        "scope": "eel2",
        "description": "Insert a new MIDI event.\n",
        "body": "${1:bool} = MIDI_InsertEvt(${2:MediaItem_Take take},${3:bool selected},${4:bool muted},${5:ppqpos},${6:\"bytestr\"})$0"
    },
    "REAPER.MIDI_INSERTEVT_WR lua": {
        "prefix": "reaperwr.MIDI_InsertEvt",
        "scope": "lua",
        "description": "Insert a new MIDI event.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_InsertEvt(${3:MediaItem_Take take},${4:boolean selected},${5:boolean muted},${6:number ppqpos},${7:string bytestr})$0"
    },
    "RPR_MIDI_INSERTEVT_WR python": {
        "prefix": "WR_RPR_MIDI_InsertEvt",
        "scope": "python",
        "description": "Insert a new MIDI event.\n",
        "body": "${1:Boolean} = RPR_MIDI_InsertEvt(${2:MediaItem_Take take},${3:Boolean selected},${4:Boolean muted},${5:Float ppqpos},${6:String bytestr},${7:Int bytestr_sz})$0"
    },
    "MIDI_INSERTNOTE_WR c": {
        "prefix": "WR_MIDI_InsertNote",
        "scope": "c",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_InsertNote(${2:MediaItem_Take* take},${3:bool selected},${4:bool muted},${5:double startppqpos},${6:double endppqpos},${7:int chan},${8:int pitch},${9:int vel},${10:const bool* noSortInOptional})$0"
    },
    "MIDI_INSERTNOTE_WR eel2": {
        "prefix": "WR_MIDI_InsertNote",
        "scope": "eel2",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_InsertNote(${2:MediaItem_Take take},${3:bool selected},${4:bool muted},${5:startppqpos},${6:endppqpos},${7:int chan},${8:int pitch},${9:int vel},${10:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_INSERTNOTE_WR lua": {
        "prefix": "reaperwr.MIDI_InsertNote",
        "scope": "lua",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_InsertNote(${3:MediaItem_Take take},${4:boolean selected},${5:boolean muted},${6:number startppqpos},${7:number endppqpos},${8:integer chan},${9:integer pitch},${10:integer vel},${11:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_INSERTNOTE_WR python": {
        "prefix": "WR_RPR_MIDI_InsertNote",
        "scope": "python",
        "description": "Insert a new MIDI note. Set noSort if inserting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:Boolean} = RPR_MIDI_InsertNote(${2:MediaItem_Take take},${3:Boolean selected},${4:Boolean muted},${5:Float startppqpos},${6:Float endppqpos},${7:Int chan},${8:Int pitch},${9:Int vel},${10:const bool noSortInOptional})$0"
    },
    "MIDI_INSERTTEXTSYSEXEVT_WR c": {
        "prefix": "WR_MIDI_InsertTextSysexEvt",
        "scope": "c",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "${1:bool} = MIDI_InsertTextSysexEvt(${2:MediaItem_Take* take},${3:bool selected},${4:bool muted},${5:double ppqpos},${6:int type},${7:const char* bytestr},${8:int bytestr_sz})$0"
    },
    "MIDI_INSERTTEXTSYSEXEVT_WR eel2": {
        "prefix": "WR_MIDI_InsertTextSysexEvt",
        "scope": "eel2",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "${1:bool} = MIDI_InsertTextSysexEvt(${2:MediaItem_Take take},${3:bool selected},${4:bool muted},${5:ppqpos},${6:int type},${7:\"bytestr\"})$0"
    },
    "REAPER.MIDI_INSERTTEXTSYSEXEVT_WR lua": {
        "prefix": "reaperwr.MIDI_InsertTextSysexEvt",
        "scope": "lua",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_InsertTextSysexEvt(${3:MediaItem_Take take},${4:boolean selected},${5:boolean muted},${6:number ppqpos},${7:integer type},${8:string bytestr})$0"
    },
    "RPR_MIDI_INSERTTEXTSYSEXEVT_WR python": {
        "prefix": "WR_RPR_MIDI_InsertTextSysexEvt",
        "scope": "python",
        "description": "Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg\nshould not include bounding F0..F7), 1-14:MIDI text event types,\n15=REAPER notation event.\n",
        "body": "${1:Boolean} = RPR_MIDI_InsertTextSysexEvt(${2:MediaItem_Take take},${3:Boolean selected},${4:Boolean muted},${5:Float ppqpos},${6:Int type},${7:String bytestr},${8:Int bytestr_sz})$0"
    },
    "MIDI_REINIT_WR c": {
        "prefix": "WR_midi_reinit",
        "scope": "c",
        "description": "Reset all MIDI devices\n",
        "body": "${1:void} = midi_reinit()$0"
    },
    "MIDI_SELECTALL_WR c": {
        "prefix": "WR_MIDI_SelectAll",
        "scope": "c",
        "description": "Select or deselect all MIDI content.\n",
        "body": "${1:void} = MIDI_SelectAll(${2:MediaItem_Take* take},${3:bool select})$0"
    },
    "MIDI_SETALLEVTS_WR c": {
        "prefix": "WR_MIDI_SetAllEvts",
        "scope": "c",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "${1:bool} = MIDI_SetAllEvts(${2:MediaItem_Take* take},${3:const char* buf},${4:int buf_sz})$0"
    },
    "MIDI_SETALLEVTS_WR eel2": {
        "prefix": "WR_MIDI_SetAllEvts",
        "scope": "eel2",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "${1:bool} = MIDI_SetAllEvts(${2:MediaItem_Take take},${3:\"buf\"})$0"
    },
    "REAPER.MIDI_SETALLEVTS_WR lua": {
        "prefix": "reaperwr.MIDI_SetAllEvts",
        "scope": "lua",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_SetAllEvts(${3:MediaItem_Take take},${4:string buf})$0"
    },
    "RPR_MIDI_SETALLEVTS_WR python": {
        "prefix": "WR_RPR_MIDI_SetAllEvts",
        "scope": "python",
        "description": "Set all MIDI data. MIDI buffer is passed in as a list of { int offset, char flag, int msglen, unsigned char msg[] }.\noffset: MIDI ticks from previous event\nflag: &1=selected &2=muted\nflag high 4 bits for CC shape: &16=linear, &32=slow start/end,\n&16|32=fast start, &64=fast end, &64|16=bezier\nmsg: the MIDI message.\nA meta-event of type 0xF followed by 'CCBZ ' and 5 more bytes represents\nbezier curve data for the previous MIDI event: 1 byte for the bezier\ntype (usually 0) and 4 bytes for the bezier tension as a float.\nFor tick intervals longer than a 32 bit word can represent, zero-length meta events may be placed between valid events.\nSee MIDI_GetAllEvts.\n",
        "body": "${1:Boolean} = RPR_MIDI_SetAllEvts(${2:MediaItem_Take take},${3:String buf},${4:Int buf_sz})$0"
    },
    "MIDI_SETCC_WR c": {
        "prefix": "WR_MIDI_SetCC",
        "scope": "c",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_SetCC(${2:MediaItem_Take* take},${3:int ccidx},${4:const bool* selectedInOptional},${5:const bool* mutedInOptional},${6:const double* ppqposInOptional},${7:const int* chanmsgInOptional},${8:const int* chanInOptional},${9:const int* msg2InOptional},${10:const int* msg3InOptional},${11:const bool* noSortInOptional})$0"
    },
    "MIDI_SETCC_WR eel2": {
        "prefix": "WR_MIDI_SetCC",
        "scope": "eel2",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_SetCC(${2:MediaItem_Take take},${3:int ccidx},${4:optional bool selectedIn},${5:optional bool mutedIn},${6:optional ppqposIn},${7:optional int chanmsgIn},${8:optional int chanIn},${9:optional int msg2In},${10:optional int msg3In},${11:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETCC_WR lua": {
        "prefix": "reaperwr.MIDI_SetCC",
        "scope": "lua",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_SetCC(${3:MediaItem_Take take},${4:integer ccidx},${5:optional boolean selectedIn},${6:optional boolean mutedIn},${7:optional number ppqposIn},${8:optional number chanmsgIn},${9:optional number chanIn},${10:optional number msg2In},${11:optional number msg3In},${12:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETCC_WR python": {
        "prefix": "WR_RPR_MIDI_SetCC",
        "scope": "python",
        "description": "Set MIDI CC event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:Boolean} = RPR_MIDI_SetCC(${2:MediaItem_Take take},${3:Int ccidx},${4:const bool selectedInOptional},${5:const bool mutedInOptional},${6:const double ppqposInOptional},${7:const int chanmsgInOptional},${8:const int chanInOptional},${9:const int msg2InOptional},${10:const int msg3InOptional},${11:const bool noSortInOptional})$0"
    },
    "MIDI_SETCCSHAPE_WR c": {
        "prefix": "WR_MIDI_SetCCShape",
        "scope": "c",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "${1:bool} = MIDI_SetCCShape(${2:MediaItem_Take* take},${3:int ccidx},${4:int shape},${5:double beztension},${6:const bool* noSortInOptional})$0"
    },
    "MIDI_SETCCSHAPE_WR eel2": {
        "prefix": "WR_MIDI_SetCCShape",
        "scope": "eel2",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "${1:bool} = MIDI_SetCCShape(${2:MediaItem_Take take},${3:int ccidx},${4:int shape},${5:beztension},${6:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETCCSHAPE_WR lua": {
        "prefix": "reaperwr.MIDI_SetCCShape",
        "scope": "lua",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_SetCCShape(${3:MediaItem_Take take},${4:integer ccidx},${5:integer shape},${6:number beztension},${7:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETCCSHAPE_WR python": {
        "prefix": "WR_RPR_MIDI_SetCCShape",
        "scope": "python",
        "description": "Set CC shape and bezier tension. set noSort if setting multiple events, then call MIDI_Sort when done. See MIDI_SetCC, MIDI_GetCCShape\n",
        "body": "${1:Boolean} = RPR_MIDI_SetCCShape(${2:MediaItem_Take take},${3:Int ccidx},${4:Int shape},${5:Float beztension},${6:const bool noSortInOptional})$0"
    },
    "MIDI_SETEVT_WR c": {
        "prefix": "WR_MIDI_SetEvt",
        "scope": "c",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_SetEvt(${2:MediaItem_Take* take},${3:int evtidx},${4:const bool* selectedInOptional},${5:const bool* mutedInOptional},${6:const double* ppqposInOptional},${7:const char* msgOptional},${8:int msgOptional_sz},${9:const bool* noSortInOptional})$0"
    },
    "MIDI_SETEVT_WR eel2": {
        "prefix": "WR_MIDI_SetEvt",
        "scope": "eel2",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_SetEvt(${2:MediaItem_Take take},${3:int evtidx},${4:optional bool selectedIn},${5:optional bool mutedIn},${6:optional ppqposIn},${7:optional \"msg\"},${8:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETEVT_WR lua": {
        "prefix": "reaperwr.MIDI_SetEvt",
        "scope": "lua",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_SetEvt(${3:MediaItem_Take take},${4:integer evtidx},${5:optional boolean selectedIn},${6:optional boolean mutedIn},${7:optional number ppqposIn},${8:optional string msg},${9:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETEVT_WR python": {
        "prefix": "WR_RPR_MIDI_SetEvt",
        "scope": "python",
        "description": "Set MIDI event properties. Properties passed as NULL will not be set.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:Boolean} = RPR_MIDI_SetEvt(${2:MediaItem_Take take},${3:Int evtidx},${4:const bool selectedInOptional},${5:const bool mutedInOptional},${6:const double ppqposInOptional},${7:String msgOptional},${8:Int msgOptional_sz},${9:const bool noSortInOptional})$0"
    },
    "MIDI_SETITEMEXTENTS_WR c": {
        "prefix": "WR_MIDI_SetItemExtents",
        "scope": "c",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "${1:bool} = MIDI_SetItemExtents(${2:MediaItem* item},${3:double startQN},${4:double endQN})$0"
    },
    "MIDI_SETITEMEXTENTS_WR eel2": {
        "prefix": "WR_MIDI_SetItemExtents",
        "scope": "eel2",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "${1:bool} = MIDI_SetItemExtents(${2:MediaItem item},${3:startQN},${4:endQN})$0"
    },
    "REAPER.MIDI_SETITEMEXTENTS_WR lua": {
        "prefix": "reaperwr.MIDI_SetItemExtents",
        "scope": "lua",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_SetItemExtents(${3:MediaItem item},${4:number startQN},${5:number endQN})$0"
    },
    "RPR_MIDI_SETITEMEXTENTS_WR python": {
        "prefix": "WR_RPR_MIDI_SetItemExtents",
        "scope": "python",
        "description": "Set the start/end positions of a media item that contains a MIDI take.\n",
        "body": "${1:Boolean} = RPR_MIDI_SetItemExtents(${2:MediaItem item},${3:Float startQN},${4:Float endQN})$0"
    },
    "MIDI_SETNOTE_WR c": {
        "prefix": "WR_MIDI_SetNote",
        "scope": "c",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "${1:bool} = MIDI_SetNote(${2:MediaItem_Take* take},${3:int noteidx},${4:const bool* selectedInOptional},${5:const bool* mutedInOptional},${6:const double* startppqposInOptional},${7:const double* endppqposInOptional},${8:const int* chanInOptional},${9:const int* pitchInOptional},${10:const int* velInOptional},${11:const bool* noSortInOptional})$0"
    },
    "MIDI_SETNOTE_WR eel2": {
        "prefix": "WR_MIDI_SetNote",
        "scope": "eel2",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "${1:bool} = MIDI_SetNote(${2:MediaItem_Take take},${3:int noteidx},${4:optional bool selectedIn},${5:optional bool mutedIn},${6:optional startppqposIn},${7:optional endppqposIn},${8:optional int chanIn},${9:optional int pitchIn},${10:optional int velIn},${11:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETNOTE_WR lua": {
        "prefix": "reaperwr.MIDI_SetNote",
        "scope": "lua",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_SetNote(${3:MediaItem_Take take},${4:integer noteidx},${5:optional boolean selectedIn},${6:optional boolean mutedIn},${7:optional number startppqposIn},${8:optional number endppqposIn},${9:optional number chanIn},${10:optional number pitchIn},${11:optional number velIn},${12:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETNOTE_WR python": {
        "prefix": "WR_RPR_MIDI_SetNote",
        "scope": "python",
        "description": "Set MIDI note properties. Properties passed as NULL (or negative values)\nwill not be set. Set noSort if setting multiple events, then call\nMIDI_Sort when done. Setting multiple note start positions at once is\ndone more safely by deleting and re-inserting the notes.\n",
        "body": "${1:Boolean} = RPR_MIDI_SetNote(${2:MediaItem_Take take},${3:Int noteidx},${4:const bool selectedInOptional},${5:const bool mutedInOptional},${6:const double startppqposInOptional},${7:const double endppqposInOptional},${8:const int chanInOptional},${9:const int pitchInOptional},${10:const int velInOptional},${11:const bool noSortInOptional})$0"
    },
    "MIDI_SETTEXTSYSEXEVT_WR c": {
        "prefix": "WR_MIDI_SetTextSysexEvt",
        "scope": "c",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_SetTextSysexEvt(${2:MediaItem_Take* take},${3:int textsyxevtidx},${4:const bool* selectedInOptional},${5:const bool* mutedInOptional},${6:const double* ppqposInOptional},${7:const int* typeInOptional},${8:const char* msgOptional},${9:int msgOptional_sz},${10:const bool* noSortInOptional})$0"
    },
    "MIDI_SETTEXTSYSEXEVT_WR eel2": {
        "prefix": "WR_MIDI_SetTextSysexEvt",
        "scope": "eel2",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:bool} = MIDI_SetTextSysexEvt(${2:MediaItem_Take take},${3:int textsyxevtidx},${4:optional bool selectedIn},${5:optional bool mutedIn},${6:optional ppqposIn},${7:optional int typeIn},${8:optional \"msg\"},${9:optional bool noSortIn})$0"
    },
    "REAPER.MIDI_SETTEXTSYSEXEVT_WR lua": {
        "prefix": "reaperwr.MIDI_SetTextSysexEvt",
        "scope": "lua",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:local }${2:boolean} = reaper.MIDI_SetTextSysexEvt(${3:MediaItem_Take take},${4:integer textsyxevtidx},${5:optional boolean selectedIn},${6:optional boolean mutedIn},${7:optional number ppqposIn},${8:optional number typeIn},${9:optional string msg},${10:optional boolean noSortIn})$0"
    },
    "RPR_MIDI_SETTEXTSYSEXEVT_WR python": {
        "prefix": "WR_RPR_MIDI_SetTextSysexEvt",
        "scope": "python",
        "description": "Set MIDI text or sysex event properties. Properties passed as NULL will\nnot be set. Allowable types are -1:sysex (msg should not include\nbounding F0..F7), 1-14:MIDI text event types, 15=REAPER notation event.\nset noSort if setting multiple events, then call MIDI_Sort when done.\n",
        "body": "${1:Boolean} = RPR_MIDI_SetTextSysexEvt(${2:MediaItem_Take take},${3:Int textsyxevtidx},${4:const bool selectedInOptional},${5:const bool mutedInOptional},${6:const double ppqposInOptional},${7:const int typeInOptional},${8:String msgOptional},${9:Int msgOptional_sz},${10:const bool noSortInOptional})$0"
    },
    "MIDI_SORT_WR c": {
        "prefix": "WR_MIDI_Sort",
        "scope": "c",
        "description": "Sort MIDI events after multiple calls to MIDI_SetNote, MIDI_SetCC, etc.\n",
        "body": "${1:void} = MIDI_Sort(${2:MediaItem_Take* take})$0"
    },
    "MIDIEDITOR_GETACTIVE_WR c": {
        "prefix": "WR_MIDIEditor_GetActive",
        "scope": "c",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "${1:HWND} = MIDIEditor_GetActive()$0"
    },
    "MIDIEDITOR_GETACTIVE_WR eel2": {
        "prefix": "WR_MIDIEditor_GetActive",
        "scope": "eel2",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "${1:HWND} = MIDIEditor_GetActive()$0"
    },
    "REAPER.MIDIEDITOR_GETACTIVE_WR lua": {
        "prefix": "reaperwr.MIDIEditor_GetActive",
        "scope": "lua",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "${1:local }${2:HWND} = reaper.MIDIEditor_GetActive()$0"
    },
    "RPR_MIDIEDITOR_GETACTIVE_WR python": {
        "prefix": "WR_RPR_MIDIEditor_GetActive",
        "scope": "python",
        "description": "get a pointer to the focused MIDI editor window\nsee MIDIEditor_GetMode, MIDIEditor_OnCommand\n",
        "body": "${1:HWND} = RPR_MIDIEditor_GetActive()$0"
    },
    "MIDIEDITOR_GETMODE_WR c": {
        "prefix": "WR_MIDIEditor_GetMode",
        "scope": "c",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "${1:int} = MIDIEditor_GetMode(${2:HWND midieditor})$0"
    },
    "MIDIEDITOR_GETMODE_WR eel2": {
        "prefix": "WR_MIDIEditor_GetMode",
        "scope": "eel2",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "${1:int} = MIDIEditor_GetMode(${2:HWND midieditor})$0"
    },
    "REAPER.MIDIEDITOR_GETMODE_WR lua": {
        "prefix": "reaperwr.MIDIEditor_GetMode",
        "scope": "lua",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "${1:local }${2:integer} = reaper.MIDIEditor_GetMode(${3:HWND midieditor})$0"
    },
    "RPR_MIDIEDITOR_GETMODE_WR python": {
        "prefix": "WR_RPR_MIDIEditor_GetMode",
        "scope": "python",
        "description": "get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)\nsee MIDIEditor_GetActive, MIDIEditor_OnCommand\n",
        "body": "${1:Int} = RPR_MIDIEditor_GetMode(${2:HWND midieditor})$0"
    },
    "MIDIEDITOR_GETSETTING_INT_WR c": {
        "prefix": "WR_MIDIEditor_GetSetting_int",
        "scope": "c",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "${1:int} = MIDIEditor_GetSetting_int(${2:HWND midieditor},${3:const char* setting_desc})$0"
    },
    "MIDIEDITOR_GETSETTING_INT_WR eel2": {
        "prefix": "WR_MIDIEditor_GetSetting_int",
        "scope": "eel2",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "${1:int} = MIDIEditor_GetSetting_int(${2:HWND midieditor},${3:\"setting_desc\"})$0"
    },
    "REAPER.MIDIEDITOR_GETSETTING_INT_WR lua": {
        "prefix": "reaperwr.MIDIEditor_GetSetting_int",
        "scope": "lua",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "${1:local }${2:integer} = reaper.MIDIEditor_GetSetting_int(${3:HWND midieditor},${4:string setting_desc})$0"
    },
    "RPR_MIDIEDITOR_GETSETTING_INT_WR python": {
        "prefix": "WR_RPR_MIDIEditor_GetSetting_int",
        "scope": "python",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nsnap_enabled: returns 0 or 1\nactive_note_row: returns 0-127\nlast_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events, 0x210=media item lane\ndefault_note_vel: returns 0-127\ndefault_note_chan: returns 0-15\ndefault_note_len: returns default length in MIDI ticks\nscale_enabled: returns 0-1\nscale_root: returns 0-12 (0=C)\nif setting_desc is unsupported, the function returns -1.\nSee MIDIEditor_SetSetting_int, MIDIEditor_GetActive, MIDIEditor_GetSetting_str\n",
        "body": "${1:Int} = RPR_MIDIEditor_GetSetting_int(${2:HWND midieditor},${3:String setting_desc})$0"
    },
    "MIDIEDITOR_GETSETTING_STR_WR c": {
        "prefix": "WR_MIDIEditor_GetSetting_str",
        "scope": "c",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "${1:bool} = MIDIEditor_GetSetting_str(${2:HWND midieditor},${3:const char* setting_desc},${4:char* buf},${5:int buf_sz})$0"
    },
    "MIDIEDITOR_GETSETTING_STR_WR eel2": {
        "prefix": "WR_MIDIEditor_GetSetting_str",
        "scope": "eel2",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "${1:bool} = MIDIEditor_GetSetting_str(${2:HWND midieditor},${3:\"setting_desc\"},${4:#buf})$0"
    },
    "REAPER.MIDIEDITOR_GETSETTING_STR_WR lua": {
        "prefix": "reaperwr.MIDIEditor_GetSetting_str",
        "scope": "lua",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.MIDIEditor_GetSetting_str(${4:HWND midieditor},${5:string setting_desc},${6:string buf})$0"
    },
    "RPR_MIDIEDITOR_GETSETTING_STR_WR python": {
        "prefix": "WR_RPR_MIDIEditor_GetSetting_str",
        "scope": "python",
        "description": "Get settings from a MIDI editor. setting_desc can be:\nlast_clicked_cc_lane: returns text description (\"velocity\", \"pitch\", etc)\nscale: returns the scale record, for example \"102034050607\" for a major scale\nif setting_desc is unsupported, the function returns false.\nSee MIDIEditor_GetActive, MIDIEditor_GetSetting_int\n",
        "body": "${1:Boolean retval},${2:HWND midieditor},${3:String setting_desc},${4:String buf},${5:Int buf_sz} = RPR_MIDIEditor_GetSetting_str(${6:midieditor},${7:setting_desc},${8:buf},${9:buf_sz})$0"
    },
    "MIDIEDITOR_GETTAKE_WR c": {
        "prefix": "WR_MIDIEditor_GetTake",
        "scope": "c",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "${1:MediaItem_Take*} = MIDIEditor_GetTake(${2:HWND midieditor})$0"
    },
    "MIDIEDITOR_GETTAKE_WR eel2": {
        "prefix": "WR_MIDIEditor_GetTake",
        "scope": "eel2",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "${1:MediaItem_Take} = MIDIEditor_GetTake(${2:HWND midieditor})$0"
    },
    "REAPER.MIDIEDITOR_GETTAKE_WR lua": {
        "prefix": "reaperwr.MIDIEditor_GetTake",
        "scope": "lua",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.MIDIEditor_GetTake(${3:HWND midieditor})$0"
    },
    "RPR_MIDIEDITOR_GETTAKE_WR python": {
        "prefix": "WR_RPR_MIDIEditor_GetTake",
        "scope": "python",
        "description": "get the take that is currently being edited in this MIDI editor\n",
        "body": "${1:MediaItem_Take} = RPR_MIDIEditor_GetTake(${2:HWND midieditor})$0"
    },
    "MIDIEDITOR_LASTFOCUSED_ONCOMMAND_WR c": {
        "prefix": "WR_MIDIEditor_LastFocused_OnCommand",
        "scope": "c",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "${1:bool} = MIDIEditor_LastFocused_OnCommand(${2:int command_id},${3:bool islistviewcommand})$0"
    },
    "MIDIEDITOR_LASTFOCUSED_ONCOMMAND_WR eel2": {
        "prefix": "WR_MIDIEditor_LastFocused_OnCommand",
        "scope": "eel2",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "${1:bool} = MIDIEditor_LastFocused_OnCommand(${2:int command_id},${3:bool islistviewcommand})$0"
    },
    "REAPER.MIDIEDITOR_LASTFOCUSED_ONCOMMAND_WR lua": {
        "prefix": "reaperwr.MIDIEditor_LastFocused_OnCommand",
        "scope": "lua",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "${1:local }${2:boolean} = reaper.MIDIEditor_LastFocused_OnCommand(${3:integer command_id},${4:boolean islistviewcommand})$0"
    },
    "RPR_MIDIEDITOR_LASTFOCUSED_ONCOMMAND_WR python": {
        "prefix": "WR_RPR_MIDIEditor_LastFocused_OnCommand",
        "scope": "python",
        "description": "Send an action command to the last focused MIDI editor. Returns false if\nthere is no MIDI editor open, or if the view mode (piano roll or event\nlist) does not match the input.\nsee MIDIEditor_OnCommand\n",
        "body": "${1:Boolean} = RPR_MIDIEditor_LastFocused_OnCommand(${2:Int command_id},${3:Boolean islistviewcommand})$0"
    },
    "MIDIEDITOR_ONCOMMAND_WR c": {
        "prefix": "WR_MIDIEditor_OnCommand",
        "scope": "c",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "${1:bool} = MIDIEditor_OnCommand(${2:HWND midieditor},${3:int command_id})$0"
    },
    "MIDIEDITOR_ONCOMMAND_WR eel2": {
        "prefix": "WR_MIDIEditor_OnCommand",
        "scope": "eel2",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "${1:bool} = MIDIEditor_OnCommand(${2:HWND midieditor},${3:int command_id})$0"
    },
    "REAPER.MIDIEDITOR_ONCOMMAND_WR lua": {
        "prefix": "reaperwr.MIDIEditor_OnCommand",
        "scope": "lua",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "${1:local }${2:boolean} = reaper.MIDIEditor_OnCommand(${3:HWND midieditor},${4:integer command_id})$0"
    },
    "RPR_MIDIEDITOR_ONCOMMAND_WR python": {
        "prefix": "WR_RPR_MIDIEditor_OnCommand",
        "scope": "python",
        "description": "Send an action command to a MIDI editor. Returns false if the supplied\nMIDI editor pointer is not valid (not an open MIDI editor).\nsee MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand\n",
        "body": "${1:Boolean} = RPR_MIDIEditor_OnCommand(${2:HWND midieditor},${3:Int command_id})$0"
    },
    "MIDIEDITOR_SETSETTING_INT_WR c": {
        "prefix": "WR_MIDIEditor_SetSetting_int",
        "scope": "c",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "${1:bool} = MIDIEditor_SetSetting_int(${2:HWND midieditor},${3:const char* setting_desc},${4:int setting})$0"
    },
    "MIDIEDITOR_SETSETTING_INT_WR eel2": {
        "prefix": "WR_MIDIEditor_SetSetting_int",
        "scope": "eel2",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "${1:bool} = MIDIEditor_SetSetting_int(${2:HWND midieditor},${3:\"setting_desc\"},${4:int setting})$0"
    },
    "REAPER.MIDIEDITOR_SETSETTING_INT_WR lua": {
        "prefix": "reaperwr.MIDIEditor_SetSetting_int",
        "scope": "lua",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "${1:local }${2:boolean} = reaper.MIDIEditor_SetSetting_int(${3:HWND midieditor},${4:string setting_desc},${5:integer setting})$0"
    },
    "RPR_MIDIEDITOR_SETSETTING_INT_WR python": {
        "prefix": "WR_RPR_MIDIEditor_SetSetting_int",
        "scope": "python",
        "description": "Set settings for a MIDI editor. setting_desc can be:\nactive_note_row: 0-127\nSee MIDIEditor_GetSetting_int\n",
        "body": "${1:Boolean} = RPR_MIDIEditor_SetSetting_int(${2:HWND midieditor},${3:String setting_desc},${4:Int setting})$0"
    },
    "MKPANSTR_WR c": {
        "prefix": "WR_mkpanstr",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = mkpanstr(${2:char* strNeed64},${3:double pan})$0"
    },
    "REAPER.MKPANSTR_WR lua": {
        "prefix": "reaperwr.mkpanstr",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string strNeed64} = reaper.mkpanstr(${3:string strNeed64},${4:number pan})$0"
    },
    "RPR_MKPANSTR_WR python": {
        "prefix": "WR_RPR_mkpanstr",
        "scope": "python",
        "description": "\n",
        "body": "${1:String strNeed64},${2:Float pan} = RPR_mkpanstr(${3:strNeed64},${4:pan})$0"
    },
    "MKVOLPANSTR_WR c": {
        "prefix": "WR_mkvolpanstr",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = mkvolpanstr(${2:char* strNeed64},${3:double vol},${4:double pan})$0"
    },
    "REAPER.MKVOLPANSTR_WR lua": {
        "prefix": "reaperwr.mkvolpanstr",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string strNeed64} = reaper.mkvolpanstr(${3:string strNeed64},${4:number vol},${5:number pan})$0"
    },
    "RPR_MKVOLPANSTR_WR python": {
        "prefix": "WR_RPR_mkvolpanstr",
        "scope": "python",
        "description": "\n",
        "body": "${1:String strNeed64},${2:Float vol},${3:Float pan} = RPR_mkvolpanstr(${4:strNeed64},${5:vol},${6:pan})$0"
    },
    "MKVOLSTR_WR c": {
        "prefix": "WR_mkvolstr",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = mkvolstr(${2:char* strNeed64},${3:double vol})$0"
    },
    "REAPER.MKVOLSTR_WR lua": {
        "prefix": "reaperwr.mkvolstr",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string strNeed64} = reaper.mkvolstr(${3:string strNeed64},${4:number vol})$0"
    },
    "RPR_MKVOLSTR_WR python": {
        "prefix": "WR_RPR_mkvolstr",
        "scope": "python",
        "description": "\n",
        "body": "${1:String strNeed64},${2:Float vol} = RPR_mkvolstr(${3:strNeed64},${4:vol})$0"
    },
    "MOVEEDITCURSOR_WR c": {
        "prefix": "WR_MoveEditCursor",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = MoveEditCursor(${2:double adjamt},${3:bool dosel})$0"
    },
    "MOVEMEDIAITEMTOTRACK_WR c": {
        "prefix": "WR_MoveMediaItemToTrack",
        "scope": "c",
        "description": "returns TRUE if move succeeded\n",
        "body": "${1:bool} = MoveMediaItemToTrack(${2:MediaItem* item},${3:MediaTrack* desttr})$0"
    },
    "MOVEMEDIAITEMTOTRACK_WR eel2": {
        "prefix": "WR_MoveMediaItemToTrack",
        "scope": "eel2",
        "description": "returns TRUE if move succeeded\n",
        "body": "${1:bool} = MoveMediaItemToTrack(${2:MediaItem item},${3:MediaTrack desttr})$0"
    },
    "REAPER.MOVEMEDIAITEMTOTRACK_WR lua": {
        "prefix": "reaperwr.MoveMediaItemToTrack",
        "scope": "lua",
        "description": "returns TRUE if move succeeded\n",
        "body": "${1:local }${2:boolean} = reaper.MoveMediaItemToTrack(${3:MediaItem item},${4:MediaTrack desttr})$0"
    },
    "RPR_MOVEMEDIAITEMTOTRACK_WR python": {
        "prefix": "WR_RPR_MoveMediaItemToTrack",
        "scope": "python",
        "description": "returns TRUE if move succeeded\n",
        "body": "${1:Boolean} = RPR_MoveMediaItemToTrack(${2:MediaItem item},${3:MediaTrack desttr})$0"
    },
    "MUTEALLTRACKS_WR c": {
        "prefix": "WR_MuteAllTracks",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = MuteAllTracks(${2:bool mute})$0"
    },
    "MY_GETVIEWPORT_WR c": {
        "prefix": "WR_my_getViewport",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = my_getViewport(${2:RECT* r},${3:const RECT* sr},${4:bool wantWorkArea})$0"
    },
    "NAMEDCOMMANDLOOKUP_WR c": {
        "prefix": "WR_NamedCommandLookup",
        "scope": "c",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "${1:int} = NamedCommandLookup(${2:const char* command_name})$0"
    },
    "NAMEDCOMMANDLOOKUP_WR eel2": {
        "prefix": "WR_NamedCommandLookup",
        "scope": "eel2",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "${1:int} = NamedCommandLookup(${2:\"command_name\"})$0"
    },
    "REAPER.NAMEDCOMMANDLOOKUP_WR lua": {
        "prefix": "reaperwr.NamedCommandLookup",
        "scope": "lua",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "${1:local }${2:integer} = reaper.NamedCommandLookup(${3:string command_name})$0"
    },
    "RPR_NAMEDCOMMANDLOOKUP_WR python": {
        "prefix": "WR_RPR_NamedCommandLookup",
        "scope": "python",
        "description": "Get the command ID number for named command that was registered by an\nextension such as \"_SWS_ABOUT\" or \"_113088d11ae641c193a2b7ede3041ad5\"\nfor a ReaScript or a custom action.\n",
        "body": "${1:Int} = RPR_NamedCommandLookup(${2:String command_name})$0"
    },
    "ONPAUSEBUTTON_WR c": {
        "prefix": "WR_OnPauseButton",
        "scope": "c",
        "description": "direct way to simulate pause button hit\n",
        "body": "${1:void} = OnPauseButton()$0"
    },
    "ONPAUSEBUTTONEX_WR c": {
        "prefix": "WR_OnPauseButtonEx",
        "scope": "c",
        "description": "direct way to simulate pause button hit\n",
        "body": "${1:void} = OnPauseButtonEx(${2:ReaProject* proj})$0"
    },
    "ONPLAYBUTTON_WR c": {
        "prefix": "WR_OnPlayButton",
        "scope": "c",
        "description": "direct way to simulate play button hit\n",
        "body": "${1:void} = OnPlayButton()$0"
    },
    "ONPLAYBUTTONEX_WR c": {
        "prefix": "WR_OnPlayButtonEx",
        "scope": "c",
        "description": "direct way to simulate play button hit\n",
        "body": "${1:void} = OnPlayButtonEx(${2:ReaProject* proj})$0"
    },
    "ONSTOPBUTTON_WR c": {
        "prefix": "WR_OnStopButton",
        "scope": "c",
        "description": "direct way to simulate stop button hit\n",
        "body": "${1:void} = OnStopButton()$0"
    },
    "ONSTOPBUTTONEX_WR c": {
        "prefix": "WR_OnStopButtonEx",
        "scope": "c",
        "description": "direct way to simulate stop button hit\n",
        "body": "${1:void} = OnStopButtonEx(${2:ReaProject* proj})$0"
    },
    "OPENCOLORTHEMEFILE_WR c": {
        "prefix": "WR_OpenColorThemeFile",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = OpenColorThemeFile(${2:const char* fn})$0"
    },
    "OPENCOLORTHEMEFILE_WR eel2": {
        "prefix": "WR_OpenColorThemeFile",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = OpenColorThemeFile(${2:\"fn\"})$0"
    },
    "REAPER.OPENCOLORTHEMEFILE_WR lua": {
        "prefix": "reaperwr.OpenColorThemeFile",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.OpenColorThemeFile(${3:string fn})$0"
    },
    "RPR_OPENCOLORTHEMEFILE_WR python": {
        "prefix": "WR_RPR_OpenColorThemeFile",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_OpenColorThemeFile(${2:String fn})$0"
    },
    "OPENMEDIAEXPLORER_WR c": {
        "prefix": "WR_OpenMediaExplorer",
        "scope": "c",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "${1:HWND} = OpenMediaExplorer(${2:const char* mediafn},${3:bool play})$0"
    },
    "OPENMEDIAEXPLORER_WR eel2": {
        "prefix": "WR_OpenMediaExplorer",
        "scope": "eel2",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "${1:HWND} = OpenMediaExplorer(${2:\"mediafn\"},${3:bool play})$0"
    },
    "REAPER.OPENMEDIAEXPLORER_WR lua": {
        "prefix": "reaperwr.OpenMediaExplorer",
        "scope": "lua",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "${1:local }${2:HWND} = reaper.OpenMediaExplorer(${3:string mediafn},${4:boolean play})$0"
    },
    "RPR_OPENMEDIAEXPLORER_WR python": {
        "prefix": "WR_RPR_OpenMediaExplorer",
        "scope": "python",
        "description": "Opens mediafn in the Media Explorer, play=true will play the file\nimmediately (or toggle playback if mediafn was already open), =false\nwill just select it.\n",
        "body": "${1:HWND} = RPR_OpenMediaExplorer(${2:String mediafn},${3:Boolean play})$0"
    },
    "OSCLOCALMESSAGETOHOST_WR c": {
        "prefix": "WR_OscLocalMessageToHost",
        "scope": "c",
        "description": "Send an OSC message directly to REAPER. The value argument may be NULL.\nThe message will be matched against the default OSC patterns. Only\nsupported if control surface support was enabled when installing REAPER.\n",
        "body": "${1:void} = OscLocalMessageToHost(${2:const char* message},${3:const double* valueInOptional})$0"
    },
    "PARSE_TIMESTR_WR c": {
        "prefix": "WR_parse_timestr",
        "scope": "c",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "${1:double} = parse_timestr(${2:const char* buf})$0"
    },
    "PARSE_TIMESTR_WR eel2": {
        "prefix": "WR_parse_timestr",
        "scope": "eel2",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "${1:double} = parse_timestr(${2:\"buf\"})$0"
    },
    "REAPER.PARSE_TIMESTR_WR lua": {
        "prefix": "reaperwr.parse_timestr",
        "scope": "lua",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "${1:local }${2:number} = reaper.parse_timestr(${3:string buf})$0"
    },
    "RPR_PARSE_TIMESTR_WR python": {
        "prefix": "WR_RPR_parse_timestr",
        "scope": "python",
        "description": "Parse hh:mm:ss.sss time string, return time in seconds (or 0.0 on error). See parse_timestr_pos, parse_timestr_len.\n",
        "body": "${1:Float} = RPR_parse_timestr(${2:String buf})$0"
    },
    "PARSE_TIMESTR_LEN_WR c": {
        "prefix": "WR_parse_timestr_len",
        "scope": "c",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:double} = parse_timestr_len(${2:const char* buf},${3:double offset},${4:int modeoverride})$0"
    },
    "PARSE_TIMESTR_LEN_WR eel2": {
        "prefix": "WR_parse_timestr_len",
        "scope": "eel2",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:double} = parse_timestr_len(${2:\"buf\"},${3:offset},${4:int modeoverride})$0"
    },
    "REAPER.PARSE_TIMESTR_LEN_WR lua": {
        "prefix": "reaperwr.parse_timestr_len",
        "scope": "lua",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:local }${2:number} = reaper.parse_timestr_len(${3:string buf},${4:number offset},${5:integer modeoverride})$0"
    },
    "RPR_PARSE_TIMESTR_LEN_WR python": {
        "prefix": "WR_RPR_parse_timestr_len",
        "scope": "python",
        "description": "time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:Float} = RPR_parse_timestr_len(${2:String buf},${3:Float offset},${4:Int modeoverride})$0"
    },
    "PARSE_TIMESTR_POS_WR c": {
        "prefix": "WR_parse_timestr_pos",
        "scope": "c",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:double} = parse_timestr_pos(${2:const char* buf},${3:int modeoverride})$0"
    },
    "PARSE_TIMESTR_POS_WR eel2": {
        "prefix": "WR_parse_timestr_pos",
        "scope": "eel2",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:double} = parse_timestr_pos(${2:\"buf\"},${3:int modeoverride})$0"
    },
    "REAPER.PARSE_TIMESTR_POS_WR lua": {
        "prefix": "reaperwr.parse_timestr_pos",
        "scope": "lua",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:local }${2:number} = reaper.parse_timestr_pos(${3:string buf},${4:integer modeoverride})$0"
    },
    "RPR_PARSE_TIMESTR_POS_WR python": {
        "prefix": "WR_RPR_parse_timestr_pos",
        "scope": "python",
        "description": "Parse time string, time formatting mode overrides: -1=proj default.\n0=time\n1=measures.beats + time\n2=measures.beats\n3=seconds\n4=samples\n5=h:m:s:f\n",
        "body": "${1:Float} = RPR_parse_timestr_pos(${2:String buf},${3:Int modeoverride})$0"
    },
    "PARSEPANSTR_WR c": {
        "prefix": "WR_parsepanstr",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = parsepanstr(${2:const char* str})$0"
    },
    "PARSEPANSTR_WR eel2": {
        "prefix": "WR_parsepanstr",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = parsepanstr(${2:\"str\"})$0"
    },
    "REAPER.PARSEPANSTR_WR lua": {
        "prefix": "reaperwr.parsepanstr",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.parsepanstr(${3:string str})$0"
    },
    "RPR_PARSEPANSTR_WR python": {
        "prefix": "WR_RPR_parsepanstr",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_parsepanstr(${2:String str})$0"
    },
    "PCM_SINK_ENUM_WR c": {
        "prefix": "WR_PCM_Sink_Enum",
        "scope": "c",
        "description": "\n",
        "body": "${1:unsigned int} = PCM_Sink_Enum(${2:int idx},${3:const char** descstrOut})$0"
    },
    "PCM_SINK_ENUM_WR eel2": {
        "prefix": "WR_PCM_Sink_Enum",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:uint} = PCM_Sink_Enum(${2:int idx},${3:#descstr})$0"
    },
    "REAPER.PCM_SINK_ENUM_WR lua": {
        "prefix": "reaperwr.PCM_Sink_Enum",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer retval},${3:string descstr} = reaper.PCM_Sink_Enum(${4:integer idx})$0"
    },
    "RPR_PCM_SINK_ENUM_WR python": {
        "prefix": "WR_RPR_PCM_Sink_Enum",
        "scope": "python",
        "description": "\n",
        "body": "${1:Unknown} = RPR_PCM_Sink_Enum(${2:Int idx},${3:String descstrOut})$0"
    },
    "PCM_SINK_GETEXTENSION_WR c": {
        "prefix": "WR_PCM_Sink_GetExtension",
        "scope": "c",
        "description": "\n",
        "body": "${1:const char*} = PCM_Sink_GetExtension(${2:const char* data},${3:int data_sz})$0"
    },
    "PCM_SINK_GETEXTENSION_WR eel2": {
        "prefix": "WR_PCM_Sink_GetExtension",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = PCM_Sink_GetExtension(${2:#retval},${3:\"data\"})$0"
    },
    "REAPER.PCM_SINK_GETEXTENSION_WR lua": {
        "prefix": "reaperwr.PCM_Sink_GetExtension",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string} = reaper.PCM_Sink_GetExtension(${3:string data})$0"
    },
    "RPR_PCM_SINK_GETEXTENSION_WR python": {
        "prefix": "WR_RPR_PCM_Sink_GetExtension",
        "scope": "python",
        "description": "\n",
        "body": "${1:String} = RPR_PCM_Sink_GetExtension(${2:String data},${3:Int data_sz})$0"
    },
    "PCM_SINK_SHOWCONFIG_WR c": {
        "prefix": "WR_PCM_Sink_ShowConfig",
        "scope": "c",
        "description": "\n",
        "body": "${1:HWND} = PCM_Sink_ShowConfig(${2:const char* cfg},${3:int cfg_sz},${4:HWND hwndParent})$0"
    },
    "PCM_SINK_SHOWCONFIG_WR eel2": {
        "prefix": "WR_PCM_Sink_ShowConfig",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:HWND} = PCM_Sink_ShowConfig(${2:\"cfg\"},${3:HWND hwndParent})$0"
    },
    "REAPER.PCM_SINK_SHOWCONFIG_WR lua": {
        "prefix": "reaperwr.PCM_Sink_ShowConfig",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:HWND} = reaper.PCM_Sink_ShowConfig(${3:string cfg},${4:HWND hwndParent})$0"
    },
    "RPR_PCM_SINK_SHOWCONFIG_WR python": {
        "prefix": "WR_RPR_PCM_Sink_ShowConfig",
        "scope": "python",
        "description": "\n",
        "body": "${1:HWND} = RPR_PCM_Sink_ShowConfig(${2:String cfg},${3:Int cfg_sz},${4:HWND hwndParent})$0"
    },
    "PCM_SOURCE_CREATEFROMFILE_WR c": {
        "prefix": "WR_PCM_Source_CreateFromFile",
        "scope": "c",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "${1:PCM_source*} = PCM_Source_CreateFromFile(${2:const char* filename})$0"
    },
    "PCM_SOURCE_CREATEFROMFILE_WR eel2": {
        "prefix": "WR_PCM_Source_CreateFromFile",
        "scope": "eel2",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "${1:PCM_source} = PCM_Source_CreateFromFile(${2:\"filename\"})$0"
    },
    "REAPER.PCM_SOURCE_CREATEFROMFILE_WR lua": {
        "prefix": "reaperwr.PCM_Source_CreateFromFile",
        "scope": "lua",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "${1:local }${2:PCM_source} = reaper.PCM_Source_CreateFromFile(${3:string filename})$0"
    },
    "RPR_PCM_SOURCE_CREATEFROMFILE_WR python": {
        "prefix": "WR_RPR_PCM_Source_CreateFromFile",
        "scope": "python",
        "description": "See PCM_Source_CreateFromFileEx.\n",
        "body": "${1:PCM_source} = RPR_PCM_Source_CreateFromFile(${2:String filename})$0"
    },
    "PCM_SOURCE_CREATEFROMFILEEX_WR c": {
        "prefix": "WR_PCM_Source_CreateFromFileEx",
        "scope": "c",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "${1:PCM_source*} = PCM_Source_CreateFromFileEx(${2:const char* filename},${3:bool forcenoMidiImp})$0"
    },
    "PCM_SOURCE_CREATEFROMFILEEX_WR eel2": {
        "prefix": "WR_PCM_Source_CreateFromFileEx",
        "scope": "eel2",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "${1:PCM_source} = PCM_Source_CreateFromFileEx(${2:\"filename\"},${3:bool forcenoMidiImp})$0"
    },
    "REAPER.PCM_SOURCE_CREATEFROMFILEEX_WR lua": {
        "prefix": "reaperwr.PCM_Source_CreateFromFileEx",
        "scope": "lua",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "${1:local }${2:PCM_source} = reaper.PCM_Source_CreateFromFileEx(${3:string filename},${4:boolean forcenoMidiImp})$0"
    },
    "RPR_PCM_SOURCE_CREATEFROMFILEEX_WR python": {
        "prefix": "WR_RPR_PCM_Source_CreateFromFileEx",
        "scope": "python",
        "description": "Create a PCM_source from filename, and override pref of MIDI files being imported as in-project MIDI events.\n",
        "body": "${1:PCM_source} = RPR_PCM_Source_CreateFromFileEx(${2:String filename},${3:Boolean forcenoMidiImp})$0"
    },
    "PCM_SOURCE_CREATEFROMTYPE_WR c": {
        "prefix": "WR_PCM_Source_CreateFromType",
        "scope": "c",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "${1:PCM_source*} = PCM_Source_CreateFromType(${2:const char* sourcetype})$0"
    },
    "PCM_SOURCE_CREATEFROMTYPE_WR eel2": {
        "prefix": "WR_PCM_Source_CreateFromType",
        "scope": "eel2",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "${1:PCM_source} = PCM_Source_CreateFromType(${2:\"sourcetype\"})$0"
    },
    "REAPER.PCM_SOURCE_CREATEFROMTYPE_WR lua": {
        "prefix": "reaperwr.PCM_Source_CreateFromType",
        "scope": "lua",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "${1:local }${2:PCM_source} = reaper.PCM_Source_CreateFromType(${3:string sourcetype})$0"
    },
    "RPR_PCM_SOURCE_CREATEFROMTYPE_WR python": {
        "prefix": "WR_RPR_PCM_Source_CreateFromType",
        "scope": "python",
        "description": "Create a PCM_source from a \"type\" (use this if you're going to load its state via LoadState/ProjectStateContext).\nValid types include \"WAVE\", \"MIDI\", or whatever plug-ins define as well.\n",
        "body": "${1:PCM_source} = RPR_PCM_Source_CreateFromType(${2:String sourcetype})$0"
    },
    "PCM_SOURCE_DESTROY_WR c": {
        "prefix": "WR_PCM_Source_Destroy",
        "scope": "c",
        "description": "Deletes a PCM_source -- be sure that you remove any project reference before deleting a source\n",
        "body": "${1:void} = PCM_Source_Destroy(${2:PCM_source* src})$0"
    },
    "PCM_SOURCE_GETPEAKS_WR c": {
        "prefix": "WR_PCM_Source_GetPeaks",
        "scope": "c",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:int} = PCM_Source_GetPeaks(${2:PCM_source* src},${3:double peakrate},${4:double starttime},${5:int numchannels},${6:int numsamplesperchannel},${7:int want_extra_type},${8:double* buf})$0"
    },
    "PCM_SOURCE_GETPEAKS_WR eel2": {
        "prefix": "WR_PCM_Source_GetPeaks",
        "scope": "eel2",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:int} = PCM_Source_GetPeaks(${2:PCM_source src},${3:peakrate},${4:starttime},${5:int numchannels},${6:int numsamplesperchannel},${7:int want_extra_type},${8:buffer_ptr buf})$0"
    },
    "REAPER.PCM_SOURCE_GETPEAKS_WR lua": {
        "prefix": "reaperwr.PCM_Source_GetPeaks",
        "scope": "lua",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:local }${2:integer} = reaper.PCM_Source_GetPeaks(${3:PCM_source src},${4:number peakrate},${5:number starttime},${6:integer numchannels},${7:integer numsamplesperchannel},${8:integer want_extra_type},${9:reaper_array buf})$0"
    },
    "RPR_PCM_SOURCE_GETPEAKS_WR python": {
        "prefix": "WR_RPR_PCM_Source_GetPeaks",
        "scope": "python",
        "description": "Gets block of peak samples to buf. Note that the peak samples are\ninterleaved, but in two or three blocks (maximums, then minimums, then\nextra). Return value has 20 bits of returned sample count, then 4 bits\nof output_mode (0xf00000), then a bit to signify whether extra_type was\navailable (0x1000000). extra_type can be 115 ('s') for spectral\ninformation, which will return peak samples as integers with the low 15\nbits frequency, next 14 bits tonality.\n",
        "body": "${1:Int retval},${2:PCM_source src},${3:Float peakrate},${4:Float starttime},${5:Int numchannels},${6:Int numsamplesperchannel},${7:Int want_extra_type},${8:Float buf} = RPR_PCM_Source_GetPeaks(${9:src},${10:peakrate},${11:starttime},${12:numchannels},${13:numsamplesperchannel},${14:want_extra_type},${15:buf})$0"
    },
    "PCM_SOURCE_GETSECTIONINFO_WR c": {
        "prefix": "WR_PCM_Source_GetSectionInfo",
        "scope": "c",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "${1:bool} = PCM_Source_GetSectionInfo(${2:PCM_source* src},${3:double* offsOut},${4:double* lenOut},${5:bool* revOut})$0"
    },
    "PCM_SOURCE_GETSECTIONINFO_WR eel2": {
        "prefix": "WR_PCM_Source_GetSectionInfo",
        "scope": "eel2",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "${1:bool} = PCM_Source_GetSectionInfo(${2:PCM_source src},${3:&offs},${4:&len},${5:bool &rev})$0"
    },
    "REAPER.PCM_SOURCE_GETSECTIONINFO_WR lua": {
        "prefix": "reaperwr.PCM_Source_GetSectionInfo",
        "scope": "lua",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "${1:local }${2:boolean retval},${3:number offs},${4:number len},${5:boolean rev} = reaper.PCM_Source_GetSectionInfo(${6:PCM_source src})$0"
    },
    "RPR_PCM_SOURCE_GETSECTIONINFO_WR python": {
        "prefix": "WR_RPR_PCM_Source_GetSectionInfo",
        "scope": "python",
        "description": "If a section/reverse block, retrieves offset/len/reverse. return true if success\n",
        "body": "${1:Boolean retval},${2:PCM_source src},${3:Float offsOut},${4:Float lenOut},${5:Boolean revOut} = RPR_PCM_Source_GetSectionInfo(${6:src},${7:offsOut},${8:lenOut},${9:revOut})$0"
    },
    "PLUGINWANTSALWAYSRUNFX_WR c": {
        "prefix": "WR_PluginWantsAlwaysRunFx",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = PluginWantsAlwaysRunFx(${2:int amt})$0"
    },
    "PREVENTUIREFRESH_WR c": {
        "prefix": "WR_PreventUIRefresh",
        "scope": "c",
        "description": "adds prevent_count to the UI refresh prevention state; always add then remove the same amount, or major disfunction will occur\n",
        "body": "${1:void} = PreventUIRefresh(${2:int prevent_count})$0"
    },
    "REASCRIPTERROR_WR c": {
        "prefix": "WR_ReaScriptError",
        "scope": "c",
        "description": "Causes REAPER to display the error message after the current ReaScript finishes.\n",
        "body": "${1:void} = ReaScriptError(${2:const char* errmsg})$0"
    },
    "RECURSIVECREATEDIRECTORY_WR c": {
        "prefix": "WR_RecursiveCreateDirectory",
        "scope": "c",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "${1:int} = RecursiveCreateDirectory(${2:const char* path},${3:size_t ignored})$0"
    },
    "RECURSIVECREATEDIRECTORY_WR eel2": {
        "prefix": "WR_RecursiveCreateDirectory",
        "scope": "eel2",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "${1:int} = RecursiveCreateDirectory(${2:\"path\"},${3:size_t ignored})$0"
    },
    "REAPER.RECURSIVECREATEDIRECTORY_WR lua": {
        "prefix": "reaperwr.RecursiveCreateDirectory",
        "scope": "lua",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "${1:local }${2:integer} = reaper.RecursiveCreateDirectory(${3:string path},${4:integer ignored})$0"
    },
    "RPR_RECURSIVECREATEDIRECTORY_WR python": {
        "prefix": "WR_RPR_RecursiveCreateDirectory",
        "scope": "python",
        "description": "returns positive value on success, 0 on failure.\n",
        "body": "${1:Int} = RPR_RecursiveCreateDirectory(${2:String path},${3:Unknown ignored})$0"
    },
    "REDUCE_OPEN_FILES_WR c": {
        "prefix": "WR_reduce_open_files",
        "scope": "c",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "${1:int} = reduce_open_files(${2:int flags})$0"
    },
    "REDUCE_OPEN_FILES_WR eel2": {
        "prefix": "WR_reduce_open_files",
        "scope": "eel2",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "${1:int} = reduce_open_files(${2:int flags})$0"
    },
    "REAPER.REDUCE_OPEN_FILES_WR lua": {
        "prefix": "reaperwr.reduce_open_files",
        "scope": "lua",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "${1:local }${2:integer} = reaper.reduce_open_files(${3:integer flags})$0"
    },
    "RPR_REDUCE_OPEN_FILES_WR python": {
        "prefix": "WR_RPR_reduce_open_files",
        "scope": "python",
        "description": "garbage-collects extra open files and closes them. if flags has 1 set,\nthis is done incrementally (call this from a regular timer, if desired).\nif flags has 2 set, files are aggressively closed (they may need to be\nre-opened very soon). returns number of files closed by this call.\n",
        "body": "${1:Int} = RPR_reduce_open_files(${2:Int flags})$0"
    },
    "REFRESHTOOLBAR_WR c": {
        "prefix": "WR_RefreshToolbar",
        "scope": "c",
        "description": "See RefreshToolbar2.\n",
        "body": "${1:void} = RefreshToolbar(${2:int command_id})$0"
    },
    "REFRESHTOOLBAR2_WR c": {
        "prefix": "WR_RefreshToolbar2",
        "scope": "c",
        "description": "Refresh the toolbar button states of a toggle action.\n",
        "body": "${1:void} = RefreshToolbar2(${2:int section_id},${3:int command_id})$0"
    },
    "RELATIVE_FN_WR c": {
        "prefix": "WR_relative_fn",
        "scope": "c",
        "description": "Makes a filename \"in\" relative to the current project, if any.\n",
        "body": "${1:void} = relative_fn(${2:const char* in},${3:char* out},${4:int out_sz})$0"
    },
    "REAPER.RELATIVE_FN_WR lua": {
        "prefix": "reaperwr.relative_fn",
        "scope": "lua",
        "description": "Makes a filename \"in\" relative to the current project, if any.\n",
        "body": "${1:local }${2:string out} = reaper.relative_fn(${3:string in},${4:string out})$0"
    },
    "RPR_RELATIVE_FN_WR python": {
        "prefix": "WR_RPR_relative_fn",
        "scope": "python",
        "description": "Makes a filename \"in\" relative to the current project, if any.\n",
        "body": "${1:String in},${2:String out},${3:Int out_sz} = RPR_relative_fn(${4:in},${5:out},${6:out_sz})$0"
    },
    "REMOVETRACKSEND_WR c": {
        "prefix": "WR_RemoveTrackSend",
        "scope": "c",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "${1:bool} = RemoveTrackSend(${2:MediaTrack* tr},${3:int category},${4:int sendidx})$0"
    },
    "REMOVETRACKSEND_WR eel2": {
        "prefix": "WR_RemoveTrackSend",
        "scope": "eel2",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "${1:bool} = RemoveTrackSend(${2:MediaTrack tr},${3:int category},${4:int sendidx})$0"
    },
    "REAPER.REMOVETRACKSEND_WR lua": {
        "prefix": "reaperwr.RemoveTrackSend",
        "scope": "lua",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "${1:local }${2:boolean} = reaper.RemoveTrackSend(${3:MediaTrack tr},${4:integer category},${5:integer sendidx})$0"
    },
    "RPR_REMOVETRACKSEND_WR python": {
        "prefix": "WR_RPR_RemoveTrackSend",
        "scope": "python",
        "description": "Remove a send/receive/hardware output, return true on success. category\nis <0 for receives, 0=sends, >0 for hardware outputs. See CreateTrackSend, GetSetTrackSendInfo, GetTrackSendInfo_Value, SetTrackSendInfo_Value, GetTrackNumSends.\n",
        "body": "${1:Boolean} = RPR_RemoveTrackSend(${2:MediaTrack tr},${3:Int category},${4:Int sendidx})$0"
    },
    "RENDERFILESECTION_WR c": {
        "prefix": "WR_RenderFileSection",
        "scope": "c",
        "description": "Not available while playing back.\n",
        "body": "${1:bool} = RenderFileSection(${2:const char* source_filename},${3:const char* target_filename},${4:double start_percent},${5:double end_percent},${6:double playrate})$0"
    },
    "RENDERFILESECTION_WR eel2": {
        "prefix": "WR_RenderFileSection",
        "scope": "eel2",
        "description": "Not available while playing back.\n",
        "body": "${1:bool} = RenderFileSection(${2:\"source_filename\"},${3:\"target_filename\"},${4:start_percent},${5:end_percent},${6:playrate})$0"
    },
    "REAPER.RENDERFILESECTION_WR lua": {
        "prefix": "reaperwr.RenderFileSection",
        "scope": "lua",
        "description": "Not available while playing back.\n",
        "body": "${1:local }${2:boolean} = reaper.RenderFileSection(${3:string source_filename},${4:string target_filename},${5:number start_percent},${6:number end_percent},${7:number playrate})$0"
    },
    "RPR_RENDERFILESECTION_WR python": {
        "prefix": "WR_RPR_RenderFileSection",
        "scope": "python",
        "description": "Not available while playing back.\n",
        "body": "${1:Boolean} = RPR_RenderFileSection(${2:String source_filename},${3:String target_filename},${4:Float start_percent},${5:Float end_percent},${6:Float playrate})$0"
    },
    "REORDERSELECTEDTRACKS_WR c": {
        "prefix": "WR_ReorderSelectedTracks",
        "scope": "c",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "${1:bool} = ReorderSelectedTracks(${2:int beforeTrackIdx},${3:int makePrevFolder})$0"
    },
    "REORDERSELECTEDTRACKS_WR eel2": {
        "prefix": "WR_ReorderSelectedTracks",
        "scope": "eel2",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "${1:bool} = ReorderSelectedTracks(${2:int beforeTrackIdx},${3:int makePrevFolder})$0"
    },
    "REAPER.REORDERSELECTEDTRACKS_WR lua": {
        "prefix": "reaperwr.ReorderSelectedTracks",
        "scope": "lua",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "${1:local }${2:boolean} = reaper.ReorderSelectedTracks(${3:integer beforeTrackIdx},${4:integer makePrevFolder})$0"
    },
    "RPR_REORDERSELECTEDTRACKS_WR python": {
        "prefix": "WR_RPR_ReorderSelectedTracks",
        "scope": "python",
        "description": "Moves all selected tracks to immediately above track specified by index\nbeforeTrackIdx, returns false if no tracks were selected.\nmakePrevFolder=0 for normal, 1 = as child of track preceding track\nspecified by beforeTrackIdx, 2 = if track preceding track specified by\nbeforeTrackIdx is last track in folder, extend folder\n",
        "body": "${1:Boolean} = RPR_ReorderSelectedTracks(${2:Int beforeTrackIdx},${3:Int makePrevFolder})$0"
    },
    "RESAMPLE_ENUMMODES_WR c": {
        "prefix": "WR_Resample_EnumModes",
        "scope": "c",
        "description": "\n",
        "body": "${1:const char*} = Resample_EnumModes(${2:int mode})$0"
    },
    "RESAMPLE_ENUMMODES_WR eel2": {
        "prefix": "WR_Resample_EnumModes",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = Resample_EnumModes(${2:#retval},${3:int mode})$0"
    },
    "REAPER.RESAMPLE_ENUMMODES_WR lua": {
        "prefix": "reaperwr.Resample_EnumModes",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string} = reaper.Resample_EnumModes(${3:integer mode})$0"
    },
    "RPR_RESAMPLE_ENUMMODES_WR python": {
        "prefix": "WR_RPR_Resample_EnumModes",
        "scope": "python",
        "description": "\n",
        "body": "${1:String} = RPR_Resample_EnumModes(${2:Int mode})$0"
    },
    "RESOLVE_FN_WR c": {
        "prefix": "WR_resolve_fn",
        "scope": "c",
        "description": "See resolve_fn2.\n",
        "body": "${1:void} = resolve_fn(${2:const char* in},${3:char* out},${4:int out_sz})$0"
    },
    "REAPER.RESOLVE_FN_WR lua": {
        "prefix": "reaperwr.resolve_fn",
        "scope": "lua",
        "description": "See resolve_fn2.\n",
        "body": "${1:local }${2:string out} = reaper.resolve_fn(${3:string in},${4:string out})$0"
    },
    "RPR_RESOLVE_FN_WR python": {
        "prefix": "WR_RPR_resolve_fn",
        "scope": "python",
        "description": "See resolve_fn2.\n",
        "body": "${1:String in},${2:String out},${3:Int out_sz} = RPR_resolve_fn(${4:in},${5:out},${6:out_sz})$0"
    },
    "RESOLVE_FN2_WR c": {
        "prefix": "WR_resolve_fn2",
        "scope": "c",
        "description": "Resolves a filename \"in\" by using project settings etc. If no file found, out will be a copy of in.\n",
        "body": "${1:void} = resolve_fn2(${2:const char* in},${3:char* out},${4:int out_sz},${5:const char* checkSubDirOptional})$0"
    },
    "REAPER.RESOLVE_FN2_WR lua": {
        "prefix": "reaperwr.resolve_fn2",
        "scope": "lua",
        "description": "Resolves a filename \"in\" by using project settings etc. If no file found, out will be a copy of in.\n",
        "body": "${1:local }${2:string out} = reaper.resolve_fn2(${3:string in},${4:string out},${5:optional string checkSubDir})$0"
    },
    "RPR_RESOLVE_FN2_WR python": {
        "prefix": "WR_RPR_resolve_fn2",
        "scope": "python",
        "description": "Resolves a filename \"in\" by using project settings etc. If no file found, out will be a copy of in.\n",
        "body": "${1:String in},${2:String out},${3:Int out_sz},${4:String checkSubDirOptional} = RPR_resolve_fn2(${5:in},${6:out},${7:out_sz},${8:checkSubDirOptional})$0"
    },
    "REVERSENAMEDCOMMANDLOOKUP_WR c": {
        "prefix": "WR_ReverseNamedCommandLookup",
        "scope": "c",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "${1:const char*} = ReverseNamedCommandLookup(${2:int command_id})$0"
    },
    "REVERSENAMEDCOMMANDLOOKUP_WR eel2": {
        "prefix": "WR_ReverseNamedCommandLookup",
        "scope": "eel2",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "${1:bool} = ReverseNamedCommandLookup(${2:#retval},${3:int command_id})$0"
    },
    "REAPER.REVERSENAMEDCOMMANDLOOKUP_WR lua": {
        "prefix": "reaperwr.ReverseNamedCommandLookup",
        "scope": "lua",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "${1:local }${2:string} = reaper.ReverseNamedCommandLookup(${3:integer command_id})$0"
    },
    "RPR_REVERSENAMEDCOMMANDLOOKUP_WR python": {
        "prefix": "WR_RPR_ReverseNamedCommandLookup",
        "scope": "python",
        "description": "Get the named command for the given command ID. The returned string will\nnot start with '_' (e.g. it will return \"SWS_ABOUT\"), it will be NULL\nif command_id is a native action.\n",
        "body": "${1:String} = RPR_ReverseNamedCommandLookup(${2:Int command_id})$0"
    },
    "SCALEFROMENVELOPEMODE_WR c": {
        "prefix": "WR_ScaleFromEnvelopeMode",
        "scope": "c",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:double} = ScaleFromEnvelopeMode(${2:int scaling_mode},${3:double val})$0"
    },
    "SCALEFROMENVELOPEMODE_WR eel2": {
        "prefix": "WR_ScaleFromEnvelopeMode",
        "scope": "eel2",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:double} = ScaleFromEnvelopeMode(${2:int scaling_mode},${3:val})$0"
    },
    "REAPER.SCALEFROMENVELOPEMODE_WR lua": {
        "prefix": "reaperwr.ScaleFromEnvelopeMode",
        "scope": "lua",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:local }${2:number} = reaper.ScaleFromEnvelopeMode(${3:integer scaling_mode},${4:number val})$0"
    },
    "RPR_SCALEFROMENVELOPEMODE_WR python": {
        "prefix": "WR_RPR_ScaleFromEnvelopeMode",
        "scope": "python",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:Float} = RPR_ScaleFromEnvelopeMode(${2:Int scaling_mode},${3:Float val})$0"
    },
    "SCALETOENVELOPEMODE_WR c": {
        "prefix": "WR_ScaleToEnvelopeMode",
        "scope": "c",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:double} = ScaleToEnvelopeMode(${2:int scaling_mode},${3:double val})$0"
    },
    "SCALETOENVELOPEMODE_WR eel2": {
        "prefix": "WR_ScaleToEnvelopeMode",
        "scope": "eel2",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:double} = ScaleToEnvelopeMode(${2:int scaling_mode},${3:val})$0"
    },
    "REAPER.SCALETOENVELOPEMODE_WR lua": {
        "prefix": "reaperwr.ScaleToEnvelopeMode",
        "scope": "lua",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:local }${2:number} = reaper.ScaleToEnvelopeMode(${3:integer scaling_mode},${4:number val})$0"
    },
    "RPR_SCALETOENVELOPEMODE_WR python": {
        "prefix": "WR_RPR_ScaleToEnvelopeMode",
        "scope": "python",
        "description": "See GetEnvelopeScalingMode.\n",
        "body": "${1:Float} = RPR_ScaleToEnvelopeMode(${2:Int scaling_mode},${3:Float val})$0"
    },
    "SELECTALLMEDIAITEMS_WR c": {
        "prefix": "WR_SelectAllMediaItems",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = SelectAllMediaItems(${2:ReaProject* proj},${3:bool selected})$0"
    },
    "SELECTPROJECTINSTANCE_WR c": {
        "prefix": "WR_SelectProjectInstance",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = SelectProjectInstance(${2:ReaProject* proj})$0"
    },
    "SETACTIVETAKE_WR c": {
        "prefix": "WR_SetActiveTake",
        "scope": "c",
        "description": "set this take active in this media item\n",
        "body": "${1:void} = SetActiveTake(${2:MediaItem_Take* take})$0"
    },
    "SETAUTOMATIONMODE_WR c": {
        "prefix": "WR_SetAutomationMode",
        "scope": "c",
        "description": "sets all or selected tracks to mode.\n",
        "body": "${1:void} = SetAutomationMode(${2:int mode},${3:bool onlySel})$0"
    },
    "SETCURRENTBPM_WR c": {
        "prefix": "WR_SetCurrentBPM",
        "scope": "c",
        "description": "set current BPM in project, set wantUndo=true to add undo point\n",
        "body": "${1:void} = SetCurrentBPM(${2:ReaProject* __proj},${3:double bpm},${4:bool wantUndo})$0"
    },
    "SETCURSORCONTEXT_WR c": {
        "prefix": "WR_SetCursorContext",
        "scope": "c",
        "description": "You must use this to change the focus programmatically. mode=0 to focus\ntrack panels, 1 to focus the arrange window, 2 to focus the arrange\nwindow and select env (or env==NULL to clear the current track/take\nenvelope selection)\n",
        "body": "${1:void} = SetCursorContext(${2:int mode},${3:TrackEnvelope* envInOptional})$0"
    },
    "SETEDITCURPOS_WR c": {
        "prefix": "WR_SetEditCurPos",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = SetEditCurPos(${2:double time},${3:bool moveview},${4:bool seekplay})$0"
    },
    "SETEDITCURPOS2_WR c": {
        "prefix": "WR_SetEditCurPos2",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = SetEditCurPos2(${2:ReaProject* proj},${3:double time},${4:bool moveview},${5:bool seekplay})$0"
    },
    "SETENVELOPEPOINT_WR c": {
        "prefix": "WR_SetEnvelopePoint",
        "scope": "c",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "${1:bool} = SetEnvelopePoint(${2:TrackEnvelope* envelope},${3:int ptidx},${4:double* timeInOptional},${5:double* valueInOptional},${6:int* shapeInOptional},${7:double* tensionInOptional},${8:bool* selectedInOptional},${9:bool* noSortInOptional})$0"
    },
    "SETENVELOPEPOINT_WR eel2": {
        "prefix": "WR_SetEnvelopePoint",
        "scope": "eel2",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "${1:bool} = SetEnvelopePoint(${2:TrackEnvelope envelope},${3:int ptidx},${4:optional timeIn},${5:optional valueIn},${6:optional int shapeIn},${7:optional tensionIn},${8:optional bool selectedIn},${9:optional bool noSortIn})$0"
    },
    "REAPER.SETENVELOPEPOINT_WR lua": {
        "prefix": "reaperwr.SetEnvelopePoint",
        "scope": "lua",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean} = reaper.SetEnvelopePoint(${3:TrackEnvelope envelope},${4:integer ptidx},${5:optional number timeIn},${6:optional number valueIn},${7:optional number shapeIn},${8:optional number tensionIn},${9:optional boolean selectedIn},${10:optional boolean noSortIn})$0"
    },
    "RPR_SETENVELOPEPOINT_WR python": {
        "prefix": "WR_RPR_SetEnvelopePoint",
        "scope": "python",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done. See SetEnvelopePointEx.\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope envelope},${3:Int ptidx},${4:Float timeInOptional},${5:Float valueInOptional},${6:Int shapeInOptional},${7:Float tensionInOptional},${8:Boolean selectedInOptional},${9:Boolean noSortInOptional} = RPR_SetEnvelopePoint(${10:envelope},${11:ptidx},${12:timeInOptional},${13:valueInOptional},${14:shapeInOptional},${15:tensionInOptional},${16:selectedInOptional},${17:noSortInOptional})$0"
    },
    "SETENVELOPEPOINTEX_WR c": {
        "prefix": "WR_SetEnvelopePointEx",
        "scope": "c",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = SetEnvelopePointEx(${2:TrackEnvelope* envelope},${3:int autoitem_idx},${4:int ptidx},${5:double* timeInOptional},${6:double* valueInOptional},${7:int* shapeInOptional},${8:double* tensionInOptional},${9:bool* selectedInOptional},${10:bool* noSortInOptional})$0"
    },
    "SETENVELOPEPOINTEX_WR eel2": {
        "prefix": "WR_SetEnvelopePointEx",
        "scope": "eel2",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:bool} = SetEnvelopePointEx(${2:TrackEnvelope envelope},${3:int autoitem_idx},${4:int ptidx},${5:optional timeIn},${6:optional valueIn},${7:optional int shapeIn},${8:optional tensionIn},${9:optional bool selectedIn},${10:optional bool noSortIn})$0"
    },
    "REAPER.SETENVELOPEPOINTEX_WR lua": {
        "prefix": "reaperwr.SetEnvelopePointEx",
        "scope": "lua",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:local }${2:boolean} = reaper.SetEnvelopePointEx(${3:TrackEnvelope envelope},${4:integer autoitem_idx},${5:integer ptidx},${6:optional number timeIn},${7:optional number valueIn},${8:optional number shapeIn},${9:optional number tensionIn},${10:optional boolean selectedIn},${11:optional boolean noSortIn})$0"
    },
    "RPR_SETENVELOPEPOINTEX_WR python": {
        "prefix": "WR_RPR_SetEnvelopePointEx",
        "scope": "python",
        "description": "Set attributes of an envelope point. Values that are not supplied will\nbe ignored. If setting multiple points at once, set noSort=true, and\ncall Envelope_SortPoints when done.\nautoitem_idx=-1 for the underlying envelope, 0 for the first automation item on the envelope, etc.\nFor automation items, pass autoitem_idx|0x10000000 to base ptidx on the number of points in one full loop iteration,\neven if the automation item is trimmed so that not all points are visible.\nOtherwise, ptidx will be based on the number of visible points in the automation item, including all loop iterations.\nSee CountEnvelopePointsEx, GetEnvelopePointEx, InsertEnvelopePointEx, DeleteEnvelopePointEx.\n",
        "body": "${1:Boolean retval},${2:TrackEnvelope envelope},${3:Int autoitem_idx},${4:Int ptidx},${5:Float timeInOptional},${6:Float valueInOptional},${7:Int shapeInOptional},${8:Float tensionInOptional},${9:Boolean selectedInOptional},${10:Boolean noSortInOptional} = RPR_SetEnvelopePointEx(${11:envelope},${12:autoitem_idx},${13:ptidx},${14:timeInOptional},${15:valueInOptional},${16:shapeInOptional},${17:tensionInOptional},${18:selectedInOptional},${19:noSortInOptional})$0"
    },
    "SETENVELOPESTATECHUNK_WR c": {
        "prefix": "WR_SetEnvelopeStateChunk",
        "scope": "c",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = SetEnvelopeStateChunk(${2:TrackEnvelope* env},${3:const char* str},${4:bool isundoOptional})$0"
    },
    "SETENVELOPESTATECHUNK_WR eel2": {
        "prefix": "WR_SetEnvelopeStateChunk",
        "scope": "eel2",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = SetEnvelopeStateChunk(${2:TrackEnvelope env},${3:\"str\"},${4:bool isundo})$0"
    },
    "REAPER.SETENVELOPESTATECHUNK_WR lua": {
        "prefix": "reaperwr.SetEnvelopeStateChunk",
        "scope": "lua",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:local }${2:boolean} = reaper.SetEnvelopeStateChunk(${3:TrackEnvelope env},${4:string str},${5:boolean isundo})$0"
    },
    "RPR_SETENVELOPESTATECHUNK_WR python": {
        "prefix": "WR_RPR_SetEnvelopeStateChunk",
        "scope": "python",
        "description": "Sets the RPPXML state of an envelope, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:Boolean} = RPR_SetEnvelopeStateChunk(${2:TrackEnvelope env},${3:String str},${4:Boolean isundoOptional})$0"
    },
    "SETEXTSTATE_WR c": {
        "prefix": "WR_SetExtState",
        "scope": "c",
        "description": "Set the extended state value for a specific section and key.\npersist=true means the value should be stored and reloaded the next time\nREAPER is opened. See GetExtState, DeleteExtState, HasExtState.\n",
        "body": "${1:void} = SetExtState(${2:const char* section},${3:const char* key},${4:const char* value},${5:bool persist})$0"
    },
    "SETGLOBALAUTOMATIONOVERRIDE_WR c": {
        "prefix": "WR_SetGlobalAutomationOverride",
        "scope": "c",
        "description": "mode: see GetGlobalAutomationOverride\n",
        "body": "${1:void} = SetGlobalAutomationOverride(${2:int mode})$0"
    },
    "SETITEMSTATECHUNK_WR c": {
        "prefix": "WR_SetItemStateChunk",
        "scope": "c",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = SetItemStateChunk(${2:MediaItem* item},${3:const char* str},${4:bool isundoOptional})$0"
    },
    "SETITEMSTATECHUNK_WR eel2": {
        "prefix": "WR_SetItemStateChunk",
        "scope": "eel2",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = SetItemStateChunk(${2:MediaItem item},${3:\"str\"},${4:bool isundo})$0"
    },
    "REAPER.SETITEMSTATECHUNK_WR lua": {
        "prefix": "reaperwr.SetItemStateChunk",
        "scope": "lua",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:local }${2:boolean} = reaper.SetItemStateChunk(${3:MediaItem item},${4:string str},${5:boolean isundo})$0"
    },
    "RPR_SETITEMSTATECHUNK_WR python": {
        "prefix": "WR_RPR_SetItemStateChunk",
        "scope": "python",
        "description": "Sets the RPPXML state of an item, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:Boolean} = RPR_SetItemStateChunk(${2:MediaItem item},${3:String str},${4:Boolean isundoOptional})$0"
    },
    "SETMASTERTRACKVISIBILITY_WR c": {
        "prefix": "WR_SetMasterTrackVisibility",
        "scope": "c",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "${1:int} = SetMasterTrackVisibility(${2:int flag})$0"
    },
    "SETMASTERTRACKVISIBILITY_WR eel2": {
        "prefix": "WR_SetMasterTrackVisibility",
        "scope": "eel2",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "${1:int} = SetMasterTrackVisibility(${2:int flag})$0"
    },
    "REAPER.SETMASTERTRACKVISIBILITY_WR lua": {
        "prefix": "reaperwr.SetMasterTrackVisibility",
        "scope": "lua",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "${1:local }${2:integer} = reaper.SetMasterTrackVisibility(${3:integer flag})$0"
    },
    "RPR_SETMASTERTRACKVISIBILITY_WR python": {
        "prefix": "WR_RPR_SetMasterTrackVisibility",
        "scope": "python",
        "description": "set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.\n",
        "body": "${1:Int} = RPR_SetMasterTrackVisibility(${2:Int flag})$0"
    },
    "SETMEDIAITEMINFO_VALUE_WR c": {
        "prefix": "WR_SetMediaItemInfo_Value",
        "scope": "c",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "${1:bool} = SetMediaItemInfo_Value(${2:MediaItem* item},${3|const char* parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\"|},${4:double newvalue})$0"
    },
    "SETMEDIAITEMINFO_VALUE_WR eel2": {
        "prefix": "WR_SetMediaItemInfo_Value",
        "scope": "eel2",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "${1:bool} = SetMediaItemInfo_Value(${2:MediaItem item},${3:\"parmname\"},${4:newvalue})$0"
    },
    "REAPER.SETMEDIAITEMINFO_VALUE_WR lua": {
        "prefix": "reaperwr.SetMediaItemInfo_Value",
        "scope": "lua",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "${1:local }${2:boolean} = reaper.SetMediaItemInfo_Value(${3:MediaItem item},${4|string parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\"|},${5:number newvalue})$0"
    },
    "RPR_SETMEDIAITEMINFO_VALUE_WR python": {
        "prefix": "WR_RPR_SetMediaItemInfo_Value",
        "scope": "python",
        "description": "Set media item numerical-value attributes.\nB_MUTE : bool * : muted\nB_LOOPSRC : bool * : loop source\nB_ALLTAKESPLAY : bool * : all takes play\nB_UISEL : bool * : selected in arrange view\nC_BEATATTACHMODE : char * : item timebase, -1=track or project default,\n1=beats (position, length, rate), 2=beats (position only). for\nauto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1\nC_AUTOSTRETCH: : char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\nC_LOCK : char * : locked, &1=locked\nD_VOL : double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_POSITION : double * : item position in seconds\nD_LENGTH : double * : item length in seconds\nD_SNAPOFFSET : double * : item snap offset in seconds\nD_FADEINLEN : double * : item manual fadein length in seconds\nD_FADEOUTLEN : double * : item manual fadeout length in seconds\nD_FADEINDIR : double * : item fadein curvature, -1..1\nD_FADEOUTDIR : double * : item fadeout curvature, -1..1\nD_FADEINLEN_AUTO : double * : item auto-fadein length in seconds, -1=no auto-fadein\nD_FADEOUTLEN_AUTO : double * : item auto-fadeout length in seconds, -1=no auto-fadeout\nC_FADEINSHAPE : int * : fadein shape, 0..6, 0=linear\nC_FADEOUTSHAPE : int * : fadeout shape, 0..6, 0=linear\nI_GROUPID : int * : group ID, 0=no group\nI_LASTY : int * : Y-position of track in pixels (read-only)\nI_LASTH : int * : height in track in pixels (read-only)\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_CURTAKE : int * : active take number\nIP_ITEMNUMBER : int, item number on this track (read-only, returns the item number directly)\nF_FREEMODE_Y : float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\nF_FREEMODE_H : float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n",
        "body": "${1:Boolean} = RPR_SetMediaItemInfo_Value(${2:MediaItem item},${3|String parmname,\"B_MUTE\",\"B_LOOPSRC\",\"B_ALLTAKESPLAY\",\"B_UISEL\",\"C_BEATATTACHMODE\",\"C_AUTOSTRETCH\",\"C_LOCK\",\"D_VOL\",\"D_POSITION\",\"D_LENGTH\",\"D_SNAPOFFSET\",\"D_FADEINLEN\",\"D_FADEOUTLEN\",\"D_FADEINDIR\",\"D_FADEOUTDIR\",\"D_FADEINLEN_AUTO\",\"D_FADEOUTLEN_AUTO\",\"C_FADEINSHAPE\",\"C_FADEOUTSHAPE\",\"I_GROUPID\",\"I_LASTY\",\"I_LASTH\",\"I_CUSTOMCOLOR\",\"I_CURTAKE\",\"IP_ITEMNUMBER\",\"F_FREEMODE_Y\",\"F_FREEMODE_H\"|},${4:Float newvalue})$0"
    },
    "SETMEDIAITEMLENGTH_WR c": {
        "prefix": "WR_SetMediaItemLength",
        "scope": "c",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:bool} = SetMediaItemLength(${2:MediaItem* item},${3:double length},${4:bool refreshUI})$0"
    },
    "SETMEDIAITEMLENGTH_WR eel2": {
        "prefix": "WR_SetMediaItemLength",
        "scope": "eel2",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:bool} = SetMediaItemLength(${2:MediaItem item},${3:length},${4:bool refreshUI})$0"
    },
    "REAPER.SETMEDIAITEMLENGTH_WR lua": {
        "prefix": "reaperwr.SetMediaItemLength",
        "scope": "lua",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:local }${2:boolean} = reaper.SetMediaItemLength(${3:MediaItem item},${4:number length},${5:boolean refreshUI})$0"
    },
    "RPR_SETMEDIAITEMLENGTH_WR python": {
        "prefix": "WR_RPR_SetMediaItemLength",
        "scope": "python",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:Boolean} = RPR_SetMediaItemLength(${2:MediaItem item},${3:Float length},${4:Boolean refreshUI})$0"
    },
    "SETMEDIAITEMPOSITION_WR c": {
        "prefix": "WR_SetMediaItemPosition",
        "scope": "c",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:bool} = SetMediaItemPosition(${2:MediaItem* item},${3:double position},${4:bool refreshUI})$0"
    },
    "SETMEDIAITEMPOSITION_WR eel2": {
        "prefix": "WR_SetMediaItemPosition",
        "scope": "eel2",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:bool} = SetMediaItemPosition(${2:MediaItem item},${3:position},${4:bool refreshUI})$0"
    },
    "REAPER.SETMEDIAITEMPOSITION_WR lua": {
        "prefix": "reaperwr.SetMediaItemPosition",
        "scope": "lua",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:local }${2:boolean} = reaper.SetMediaItemPosition(${3:MediaItem item},${4:number position},${5:boolean refreshUI})$0"
    },
    "RPR_SETMEDIAITEMPOSITION_WR python": {
        "prefix": "WR_RPR_SetMediaItemPosition",
        "scope": "python",
        "description": "Redraws the screen only if refreshUI == true.\nSee UpdateArrange().\n",
        "body": "${1:Boolean} = RPR_SetMediaItemPosition(${2:MediaItem item},${3:Float position},${4:Boolean refreshUI})$0"
    },
    "SETMEDIAITEMSELECTED_WR c": {
        "prefix": "WR_SetMediaItemSelected",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = SetMediaItemSelected(${2:MediaItem* item},${3:bool selected})$0"
    },
    "SETMEDIAITEMTAKE_SOURCE_WR c": {
        "prefix": "WR_SetMediaItemTake_Source",
        "scope": "c",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "${1:bool} = SetMediaItemTake_Source(${2:MediaItem_Take* take},${3:PCM_source* source})$0"
    },
    "SETMEDIAITEMTAKE_SOURCE_WR eel2": {
        "prefix": "WR_SetMediaItemTake_Source",
        "scope": "eel2",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "${1:bool} = SetMediaItemTake_Source(${2:MediaItem_Take take},${3:PCM_source source})$0"
    },
    "REAPER.SETMEDIAITEMTAKE_SOURCE_WR lua": {
        "prefix": "reaperwr.SetMediaItemTake_Source",
        "scope": "lua",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "${1:local }${2:boolean} = reaper.SetMediaItemTake_Source(${3:MediaItem_Take take},${4:PCM_source source})$0"
    },
    "RPR_SETMEDIAITEMTAKE_SOURCE_WR python": {
        "prefix": "WR_RPR_SetMediaItemTake_Source",
        "scope": "python",
        "description": "Set media source of media item take. The old source will not be\ndestroyed, it is the caller's responsibility to retrieve it and destroy\nit after. If source already exists in any project, it will be duplicated\nbefore being set. C/C++ code should not use this and instead use\nGetSetMediaItemTakeInfo() with P_SOURCE to manage ownership directly.\n",
        "body": "${1:Boolean} = RPR_SetMediaItemTake_Source(${2:MediaItem_Take take},${3:PCM_source source})$0"
    },
    "SETMEDIAITEMTAKEINFO_VALUE_WR c": {
        "prefix": "WR_SetMediaItemTakeInfo_Value",
        "scope": "c",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "${1:bool} = SetMediaItemTakeInfo_Value(${2:MediaItem_Take* take},${3|const char* parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\"|},${4:double newvalue})$0"
    },
    "SETMEDIAITEMTAKEINFO_VALUE_WR eel2": {
        "prefix": "WR_SetMediaItemTakeInfo_Value",
        "scope": "eel2",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "${1:bool} = SetMediaItemTakeInfo_Value(${2:MediaItem_Take take},${3:\"parmname\"},${4:newvalue})$0"
    },
    "REAPER.SETMEDIAITEMTAKEINFO_VALUE_WR lua": {
        "prefix": "reaperwr.SetMediaItemTakeInfo_Value",
        "scope": "lua",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "${1:local }${2:boolean} = reaper.SetMediaItemTakeInfo_Value(${3:MediaItem_Take take},${4|string parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\"|},${5:number newvalue})$0"
    },
    "RPR_SETMEDIAITEMTAKEINFO_VALUE_WR python": {
        "prefix": "WR_RPR_SetMediaItemTakeInfo_Value",
        "scope": "python",
        "description": "Set media item take numerical-value attributes.\nD_STARTOFFS : double * : start offset in source media, in seconds\nD_VOL : double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped\nD_PAN : double * : take pan, -1..1\nD_PANLAW : double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc\nD_PLAYRATE : double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc\nD_PITCH : double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\nB_PPITCH : bool * : preserve pitch when changing playback rate\nI_CHANMODE : int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\nI_PITCHMODE : int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nIP_TAKENUMBER : int : take number (read-only, returns the take number directly)\n",
        "body": "${1:Boolean} = RPR_SetMediaItemTakeInfo_Value(${2:MediaItem_Take take},${3|String parmname,\"D_STARTOFFS\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"D_PLAYRATE\",\"D_PITCH\",\"B_PPITCH\",\"I_CHANMODE\",\"I_PITCHMODE\",\"I_CUSTOMCOLOR\",\"IP_TAKENUMBER\"|},${4:Float newvalue})$0"
    },
    "SETMEDIATRACKINFO_VALUE_WR c": {
        "prefix": "WR_SetMediaTrackInfo_Value",
        "scope": "c",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "${1:bool} = SetMediaTrackInfo_Value(${2:MediaTrack* tr},${3|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\"|},${4:double newvalue})$0"
    },
    "SETMEDIATRACKINFO_VALUE_WR eel2": {
        "prefix": "WR_SetMediaTrackInfo_Value",
        "scope": "eel2",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "${1:bool} = SetMediaTrackInfo_Value(${2:MediaTrack tr},${3:\"parmname\"},${4:newvalue})$0"
    },
    "REAPER.SETMEDIATRACKINFO_VALUE_WR lua": {
        "prefix": "reaperwr.SetMediaTrackInfo_Value",
        "scope": "lua",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "${1:local }${2:boolean} = reaper.SetMediaTrackInfo_Value(${3:MediaTrack tr},${4|string parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\"|},${5:number newvalue})$0"
    },
    "RPR_SETMEDIATRACKINFO_VALUE_WR python": {
        "prefix": "WR_RPR_SetMediaTrackInfo_Value",
        "scope": "python",
        "description": "Set track numerical-value attributes.\nB_MUTE : bool * : muted\nB_PHASE : bool * : track phase inverted\nIP_TRACKNUMBER : int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\nI_SOLO : int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\nI_FXEN : int * : fx enabled, 0=bypassed, !0=fx active\nI_RECARM : int * : record armed, 0=not record armed, 1=record armed\nI_RECINPUT : int * : record input, <0=no input, 0..n=mono hardware\ninput, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI\ninput, if set then low 5 bits represent channel (0=all, 1-16=only\nchan), next 6 bits represent physical input (63=all, 62=VKB)\nI_RECMODE : int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo\nout w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/\nlatency compensation, 7=midi overdub, 8=midi replace\nI_RECMON : int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\nI_RECMONITEMS : int * : monitor items while recording, 0=off, 1=on\nI_AUTOMODE : int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch\nI_NCHAN : int * : number of track channels, 2-64, even numbers only\nI_SELECTED : int * : track selected, 0=unselected, 1=selected\nI_WNDH : int * : current TCP window height in pixels including envelopes (read-only)\nI_TCPH : int * : current TCP window height in pixels not including envelopes (read-only)\nI_TCPY : int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\nI_MCPX : int * : current MCP X-position in pixels relative to mixer container\nI_MCPY : int * : current MCP Y-position in pixels relative to mixer container\nI_MCPW : int * : current MCP width in pixels\nI_MCPH : int * : current MCP height in pixels\nI_FOLDERDEPTH : int * : folder depth change, 0=normal, 1=track is a\nfolder parent, -1=track is the last in the innermost folder, -2=track is\nthe last in the innermost and next-innermost folders, etc\nI_FOLDERCOMPACT : int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\nI_MIDIHWOUT : int * : track midi hardware output index, <0=disabled,\nlow 5 bits are which channels (0=all, 1-16), next 5 bits are output\ndevice index (0-31)\nI_PERFFLAGS : int * : track performance flags, &1=no media buffering, &2=no anticipative FX\nI_CUSTOMCOLOR : int * : custom color, OS dependent color|0x100000 (i.e.\nColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will\nnot be used, but will store the color anyway)\nI_HEIGHTOVERRIDE : int * : custom height override for TCP window, 0 for none, otherwise size in pixels\nB_HEIGHTLOCK : bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\nD_VOL : double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc\nD_PAN : double * : trim pan of track, -1..1\nD_WIDTH : double * : width of track, -1..1\nD_DUALPANL : double * : dualpan position 1, -1..1, only if I_PANMODE==6\nD_DUALPANR : double * : dualpan position 2, -1..1, only if I_PANMODE==6\nI_PANMODE : int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\nD_PANLAW : double * : pan law of track, <0=project default, 1=+0dB, etc\nP_ENV:<envchunkname : TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended.\nB_SHOWINMIXER : bool * : track control panel visible in mixer (do not use on master track)\nB_SHOWINTCP : bool * : track control panel visible in arrange view (do not use on master track)\nB_MAINSEND : bool * : track sends audio to parent\nC_MAINSEND_OFFS : char * : channel offset of track send to parent\nB_FREEMODE : bool * : track free item positioning enabled (call UpdateTimeline() after changing)\nC_BEATATTACHMODE : char * : track timebase, -1=project default, 0=time,\n1=beats (position, length, rate), 2=beats (position only)\nF_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\nF_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the\nfx+send total area (0=minimum allowed, 1=maximum allowed)\nI_PLAY_OFFSET_FLAG : int * : track playback offset state,\n&1=bypassed, &2=offset value is measured in samples (otherwise\nmeasured in seconds)\nD_PLAY_OFFSET : double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n",
        "body": "${1:Boolean} = RPR_SetMediaTrackInfo_Value(${2:MediaTrack tr},${3|String parmname,\"B_MUTE\",\"B_PHASE\",\"IP_TRACKNUMBER\",\"I_SOLO\",\"I_FXEN\",\"I_RECARM\",\"I_RECINPUT\",\"I_RECMODE\",\"I_RECMON\",\"I_RECMONITEMS\",\"I_AUTOMODE\",\"I_NCHAN\",\"I_SELECTED\",\"I_WNDH\",\"I_TCPH\",\"I_TCPY\",\"I_MCPX\",\"I_MCPY\",\"I_MCPW\",\"I_MCPH\",\"I_FOLDERDEPTH\",\"I_FOLDERCOMPACT\",\"I_MIDIHWOUT\",\"I_PERFFLAGS\",\"I_CUSTOMCOLOR\",\"I_HEIGHTOVERRIDE\",\"B_HEIGHTLOCK\",\"D_VOL\",\"D_PAN\",\"D_WIDTH\",\"D_DUALPANL\",\"D_DUALPANR\",\"I_PANMODE\",\"D_PANLAW\",\"P_ENV:<envchunkname\",\"B_SHOWINMIXER\",\"B_SHOWINTCP\",\"B_MAINSEND\",\"C_MAINSEND_OFFS\",\"B_FREEMODE\",\"C_BEATATTACHMODE\",\"F_MCP_FXSEND_SCALE\",\"F_MCP_SENDRGN_SCALE\",\"I_PLAY_OFFSET_FLAG\",\"D_PLAY_OFFSET\"|},${4:Float newvalue})$0"
    },
    "SETMIDIEDITORGRID_WR c": {
        "prefix": "WR_SetMIDIEditorGrid",
        "scope": "c",
        "description": "Set the MIDI editor grid division. 0.25=quarter note, 1.0/3.0=half note tripet, etc.\n",
        "body": "${1:void} = SetMIDIEditorGrid(${2:ReaProject* project},${3:double division})$0"
    },
    "SETMIXERSCROLL_WR c": {
        "prefix": "WR_SetMixerScroll",
        "scope": "c",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "${1:MediaTrack*} = SetMixerScroll(${2:MediaTrack* leftmosttrack})$0"
    },
    "SETMIXERSCROLL_WR eel2": {
        "prefix": "WR_SetMixerScroll",
        "scope": "eel2",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "${1:MediaTrack} = SetMixerScroll(${2:MediaTrack leftmosttrack})$0"
    },
    "REAPER.SETMIXERSCROLL_WR lua": {
        "prefix": "reaperwr.SetMixerScroll",
        "scope": "lua",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "${1:local }${2:MediaTrack} = reaper.SetMixerScroll(${3:MediaTrack leftmosttrack})$0"
    },
    "RPR_SETMIXERSCROLL_WR python": {
        "prefix": "WR_RPR_SetMixerScroll",
        "scope": "python",
        "description": "Scroll the mixer so that leftmosttrack is the leftmost visible track.\nReturns the leftmost track after scrolling, which may be different from\nthe passed-in track if there are not enough tracks to its right.\n",
        "body": "${1:MediaTrack} = RPR_SetMixerScroll(${2:MediaTrack leftmosttrack})$0"
    },
    "SETMOUSEMODIFIER_WR c": {
        "prefix": "WR_SetMouseModifier",
        "scope": "c",
        "description": "Set the mouse modifier assignment for a specific modifier key assignment, in a specific context.\nContext is a string like \"MM_CTX_ITEM\". Find these strings by modifying an assignment in\nPreferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nModifier flag is a number from 0 to 15: add 1 for shift, 2 for control, 4 for alt, 8 for win.\n(macOS: add 1 for shift, 2 for command, 4 for opt, 8 for control.)\nFor left-click and double-click contexts, the action can be any built-in command ID number\nor any custom action ID string. Find built-in command IDs in the REAPER actions window\n(enable \"show action IDs\" in the context menu), and find custom action ID strings in reaper-kb.ini.\nFor built-in mouse modifier behaviors, find action IDs (which will be low numbers)\nby modifying an assignment in Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.\nAssigning an action of -1 will reset that mouse modifier behavior to factory default.\nSee GetMouseModifier.\n",
        "body": "${1:void} = SetMouseModifier(${2:const char* context},${3:int modifier_flag},${4:const char* action})$0"
    },
    "SETONLYTRACKSELECTED_WR c": {
        "prefix": "WR_SetOnlyTrackSelected",
        "scope": "c",
        "description": "Set exactly one track selected, deselect all others\n",
        "body": "${1:void} = SetOnlyTrackSelected(${2:MediaTrack* track})$0"
    },
    "SETPROJECTGRID_WR c": {
        "prefix": "WR_SetProjectGrid",
        "scope": "c",
        "description": "Set the arrange view grid division. 0.25=quarter note, 1.0/3.0=half note triplet, etc.\n",
        "body": "${1:void} = SetProjectGrid(${2:ReaProject* project},${3:double division})$0"
    },
    "SETPROJECTMARKER_WR c": {
        "prefix": "WR_SetProjectMarker",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = SetProjectMarker(${2:int markrgnindexnumber},${3:bool isrgn},${4:double pos},${5:double rgnend},${6:const char* name})$0"
    },
    "SETPROJECTMARKER_WR eel2": {
        "prefix": "WR_SetProjectMarker",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = SetProjectMarker(${2:int markrgnindexnumber},${3:bool isrgn},${4:pos},${5:rgnend},${6:\"name\"})$0"
    },
    "REAPER.SETPROJECTMARKER_WR lua": {
        "prefix": "reaperwr.SetProjectMarker",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.SetProjectMarker(${3:integer markrgnindexnumber},${4:boolean isrgn},${5:number pos},${6:number rgnend},${7:string name})$0"
    },
    "RPR_SETPROJECTMARKER_WR python": {
        "prefix": "WR_RPR_SetProjectMarker",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_SetProjectMarker(${2:Int markrgnindexnumber},${3:Boolean isrgn},${4:Float pos},${5:Float rgnend},${6:String name})$0"
    },
    "SETPROJECTMARKER2_WR c": {
        "prefix": "WR_SetProjectMarker2",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = SetProjectMarker2(${2:ReaProject* proj},${3:int markrgnindexnumber},${4:bool isrgn},${5:double pos},${6:double rgnend},${7:const char* name})$0"
    },
    "SETPROJECTMARKER2_WR eel2": {
        "prefix": "WR_SetProjectMarker2",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = SetProjectMarker2(${2:ReaProject proj},${3:int markrgnindexnumber},${4:bool isrgn},${5:pos},${6:rgnend},${7:\"name\"})$0"
    },
    "REAPER.SETPROJECTMARKER2_WR lua": {
        "prefix": "reaperwr.SetProjectMarker2",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.SetProjectMarker2(${3:ReaProject proj},${4:integer markrgnindexnumber},${5:boolean isrgn},${6:number pos},${7:number rgnend},${8:string name})$0"
    },
    "RPR_SETPROJECTMARKER2_WR python": {
        "prefix": "WR_RPR_SetProjectMarker2",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_SetProjectMarker2(${2:ReaProject proj},${3:Int markrgnindexnumber},${4:Boolean isrgn},${5:Float pos},${6:Float rgnend},${7:String name})$0"
    },
    "SETPROJECTMARKER3_WR c": {
        "prefix": "WR_SetProjectMarker3",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = SetProjectMarker3(${2:ReaProject* proj},${3:int markrgnindexnumber},${4:bool isrgn},${5:double pos},${6:double rgnend},${7:const char* name},${8:int color})$0"
    },
    "SETPROJECTMARKER3_WR eel2": {
        "prefix": "WR_SetProjectMarker3",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = SetProjectMarker3(${2:ReaProject proj},${3:int markrgnindexnumber},${4:bool isrgn},${5:pos},${6:rgnend},${7:\"name\"},${8:int color})$0"
    },
    "REAPER.SETPROJECTMARKER3_WR lua": {
        "prefix": "reaperwr.SetProjectMarker3",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.SetProjectMarker3(${3:ReaProject proj},${4:integer markrgnindexnumber},${5:boolean isrgn},${6:number pos},${7:number rgnend},${8:string name},${9:integer color})$0"
    },
    "RPR_SETPROJECTMARKER3_WR python": {
        "prefix": "WR_RPR_SetProjectMarker3",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_SetProjectMarker3(${2:ReaProject proj},${3:Int markrgnindexnumber},${4:Boolean isrgn},${5:Float pos},${6:Float rgnend},${7:String name},${8:Int color})$0"
    },
    "SETPROJECTMARKER4_WR c": {
        "prefix": "WR_SetProjectMarker4",
        "scope": "c",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "${1:bool} = SetProjectMarker4(${2:ReaProject* proj},${3:int markrgnindexnumber},${4:bool isrgn},${5:double pos},${6:double rgnend},${7:const char* name},${8:int color},${9:int flags})$0"
    },
    "SETPROJECTMARKER4_WR eel2": {
        "prefix": "WR_SetProjectMarker4",
        "scope": "eel2",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "${1:bool} = SetProjectMarker4(${2:ReaProject proj},${3:int markrgnindexnumber},${4:bool isrgn},${5:pos},${6:rgnend},${7:\"name\"},${8:int color},${9:int flags})$0"
    },
    "REAPER.SETPROJECTMARKER4_WR lua": {
        "prefix": "reaperwr.SetProjectMarker4",
        "scope": "lua",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "${1:local }${2:boolean} = reaper.SetProjectMarker4(${3:ReaProject proj},${4:integer markrgnindexnumber},${5:boolean isrgn},${6:number pos},${7:number rgnend},${8:string name},${9:integer color},${10:integer flags})$0"
    },
    "RPR_SETPROJECTMARKER4_WR python": {
        "prefix": "WR_RPR_SetProjectMarker4",
        "scope": "python",
        "description": "color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000, flags&1 to clear name\n",
        "body": "${1:Boolean} = RPR_SetProjectMarker4(${2:ReaProject proj},${3:Int markrgnindexnumber},${4:Boolean isrgn},${5:Float pos},${6:Float rgnend},${7:String name},${8:Int color},${9:Int flags})$0"
    },
    "SETPROJECTMARKERBYINDEX_WR c": {
        "prefix": "WR_SetProjectMarkerByIndex",
        "scope": "c",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "${1:bool} = SetProjectMarkerByIndex(${2:ReaProject* proj},${3:int markrgnidx},${4:bool isrgn},${5:double pos},${6:double rgnend},${7:int IDnumber},${8:const char* name},${9:int color})$0"
    },
    "SETPROJECTMARKERBYINDEX_WR eel2": {
        "prefix": "WR_SetProjectMarkerByIndex",
        "scope": "eel2",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "${1:bool} = SetProjectMarkerByIndex(${2:ReaProject proj},${3:int markrgnidx},${4:bool isrgn},${5:pos},${6:rgnend},${7:int IDnumber},${8:\"name\"},${9:int color})$0"
    },
    "REAPER.SETPROJECTMARKERBYINDEX_WR lua": {
        "prefix": "reaperwr.SetProjectMarkerByIndex",
        "scope": "lua",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "${1:local }${2:boolean} = reaper.SetProjectMarkerByIndex(${3:ReaProject proj},${4:integer markrgnidx},${5:boolean isrgn},${6:number pos},${7:number rgnend},${8:integer IDnumber},${9:string name},${10:integer color})$0"
    },
    "RPR_SETPROJECTMARKERBYINDEX_WR python": {
        "prefix": "WR_RPR_SetProjectMarkerByIndex",
        "scope": "python",
        "description": "See SetProjectMarkerByIndex2.\n",
        "body": "${1:Boolean} = RPR_SetProjectMarkerByIndex(${2:ReaProject proj},${3:Int markrgnidx},${4:Boolean isrgn},${5:Float pos},${6:Float rgnend},${7:Int IDnumber},${8:String name},${9:Int color})$0"
    },
    "SETPROJECTMARKERBYINDEX2_WR c": {
        "prefix": "WR_SetProjectMarkerByIndex2",
        "scope": "c",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "${1:bool} = SetProjectMarkerByIndex2(${2:ReaProject* proj},${3:int markrgnidx},${4:bool isrgn},${5:double pos},${6:double rgnend},${7:int IDnumber},${8:const char* name},${9:int color},${10:int flags})$0"
    },
    "SETPROJECTMARKERBYINDEX2_WR eel2": {
        "prefix": "WR_SetProjectMarkerByIndex2",
        "scope": "eel2",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "${1:bool} = SetProjectMarkerByIndex2(${2:ReaProject proj},${3:int markrgnidx},${4:bool isrgn},${5:pos},${6:rgnend},${7:int IDnumber},${8:\"name\"},${9:int color},${10:int flags})$0"
    },
    "REAPER.SETPROJECTMARKERBYINDEX2_WR lua": {
        "prefix": "reaperwr.SetProjectMarkerByIndex2",
        "scope": "lua",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "${1:local }${2:boolean} = reaper.SetProjectMarkerByIndex2(${3:ReaProject proj},${4:integer markrgnidx},${5:boolean isrgn},${6:number pos},${7:number rgnend},${8:integer IDnumber},${9:string name},${10:integer color},${11:integer flags})$0"
    },
    "RPR_SETPROJECTMARKERBYINDEX2_WR python": {
        "prefix": "WR_RPR_SetProjectMarkerByIndex2",
        "scope": "python",
        "description": "Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3).\nFunction will fail if attempting to set a duplicate ID number for a\nregion (duplicate ID numbers for markers are OK). , flags&1 to clear\nname.\n",
        "body": "${1:Boolean} = RPR_SetProjectMarkerByIndex2(${2:ReaProject proj},${3:Int markrgnidx},${4:Boolean isrgn},${5:Float pos},${6:Float rgnend},${7:Int IDnumber},${8:String name},${9:Int color},${10:Int flags})$0"
    },
    "SETPROJEXTSTATE_WR c": {
        "prefix": "WR_SetProjExtState",
        "scope": "c",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "${1:int} = SetProjExtState(${2:ReaProject* proj},${3:const char* extname},${4:const char* key},${5:const char* value})$0"
    },
    "SETPROJEXTSTATE_WR eel2": {
        "prefix": "WR_SetProjExtState",
        "scope": "eel2",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "${1:int} = SetProjExtState(${2:ReaProject proj},${3:\"extname\"},${4:\"key\"},${5:\"value\"})$0"
    },
    "REAPER.SETPROJEXTSTATE_WR lua": {
        "prefix": "reaperwr.SetProjExtState",
        "scope": "lua",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "${1:local }${2:integer} = reaper.SetProjExtState(${3:ReaProject proj},${4:string extname},${5:string key},${6:string value})$0"
    },
    "RPR_SETPROJEXTSTATE_WR python": {
        "prefix": "WR_RPR_SetProjExtState",
        "scope": "python",
        "description": "Save a key/value pair for a specific extension, to be restored the next\ntime this specific project is loaded. Typically extname will be the name\nof a reascript or extension section. If key is NULL or \"\", all extended\ndata for that extname will be deleted.  If val is NULL or \"\", the data\npreviously associated with that key will be deleted. Returns the size of\nthe state for this extname. See GetProjExtState, EnumProjExtState.\n",
        "body": "${1:Int} = RPR_SetProjExtState(${2:ReaProject proj},${3:String extname},${4:String key},${5:String value})$0"
    },
    "SETREGIONRENDERMATRIX_WR c": {
        "prefix": "WR_SetRegionRenderMatrix",
        "scope": "c",
        "description": "Add (addorremove > 0) or remove (addorremove < 0) a track from this region when using the region render matrix.\n",
        "body": "${1:void} = SetRegionRenderMatrix(${2:ReaProject* proj},${3:int regionindex},${4:MediaTrack* track},${5:int addorremove})$0"
    },
    "SETTAKESTRETCHMARKER_WR c": {
        "prefix": "WR_SetTakeStretchMarker",
        "scope": "c",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "${1:int} = SetTakeStretchMarker(${2:MediaItem_Take* take},${3:int idx},${4:double pos},${5:const double* srcposInOptional})$0"
    },
    "SETTAKESTRETCHMARKER_WR eel2": {
        "prefix": "WR_SetTakeStretchMarker",
        "scope": "eel2",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "${1:int} = SetTakeStretchMarker(${2:MediaItem_Take take},${3:int idx},${4:pos},${5:optional srcposIn})$0"
    },
    "REAPER.SETTAKESTRETCHMARKER_WR lua": {
        "prefix": "reaperwr.SetTakeStretchMarker",
        "scope": "lua",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "${1:local }${2:integer} = reaper.SetTakeStretchMarker(${3:MediaItem_Take take},${4:integer idx},${5:number pos},${6:optional number srcposIn})$0"
    },
    "RPR_SETTAKESTRETCHMARKER_WR python": {
        "prefix": "WR_RPR_SetTakeStretchMarker",
        "scope": "python",
        "description": "Adds or updates a stretch marker. If idx<0, stretch marker will be\nadded. If idx>=0, stretch marker will be updated. When adding, if\nsrcposInOptional is omitted, source position will be auto-calculated.\nWhen updating a stretch marker, if srcposInOptional is omitted, srcpos\nwill not be modified. Position/srcposition values will be constrained to\nnearby stretch markers. Returns index of stretch marker, or -1 if did\nnot insert (or marker already existed at time).\n",
        "body": "${1:Int} = RPR_SetTakeStretchMarker(${2:MediaItem_Take take},${3:Int idx},${4:Float pos},${5:const double srcposInOptional})$0"
    },
    "SETTAKESTRETCHMARKERSLOPE_WR c": {
        "prefix": "WR_SetTakeStretchMarkerSlope",
        "scope": "c",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "${1:bool} = SetTakeStretchMarkerSlope(${2:MediaItem_Take* take},${3:int idx},${4:double slope})$0"
    },
    "SETTAKESTRETCHMARKERSLOPE_WR eel2": {
        "prefix": "WR_SetTakeStretchMarkerSlope",
        "scope": "eel2",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "${1:bool} = SetTakeStretchMarkerSlope(${2:MediaItem_Take take},${3:int idx},${4:slope})$0"
    },
    "REAPER.SETTAKESTRETCHMARKERSLOPE_WR lua": {
        "prefix": "reaperwr.SetTakeStretchMarkerSlope",
        "scope": "lua",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "${1:local }${2:boolean} = reaper.SetTakeStretchMarkerSlope(${3:MediaItem_Take take},${4:integer idx},${5:number slope})$0"
    },
    "RPR_SETTAKESTRETCHMARKERSLOPE_WR python": {
        "prefix": "WR_RPR_SetTakeStretchMarkerSlope",
        "scope": "python",
        "description": "See GetTakeStretchMarkerSlope\n",
        "body": "${1:Boolean} = RPR_SetTakeStretchMarkerSlope(${2:MediaItem_Take take},${3:Int idx},${4:Float slope})$0"
    },
    "SETTEMPOTIMESIGMARKER_WR c": {
        "prefix": "WR_SetTempoTimeSigMarker",
        "scope": "c",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:bool} = SetTempoTimeSigMarker(${2:ReaProject* proj},${3:int ptidx},${4:double timepos},${5:int measurepos},${6:double beatpos},${7:double bpm},${8:int timesig_num},${9:int timesig_denom},${10:bool lineartempo})$0"
    },
    "SETTEMPOTIMESIGMARKER_WR eel2": {
        "prefix": "WR_SetTempoTimeSigMarker",
        "scope": "eel2",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:bool} = SetTempoTimeSigMarker(${2:ReaProject proj},${3:int ptidx},${4:timepos},${5:int measurepos},${6:beatpos},${7:bpm},${8:int timesig_num},${9:int timesig_denom},${10:bool lineartempo})$0"
    },
    "REAPER.SETTEMPOTIMESIGMARKER_WR lua": {
        "prefix": "reaperwr.SetTempoTimeSigMarker",
        "scope": "lua",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:local }${2:boolean} = reaper.SetTempoTimeSigMarker(${3:ReaProject proj},${4:integer ptidx},${5:number timepos},${6:integer measurepos},${7:number beatpos},${8:number bpm},${9:integer timesig_num},${10:integer timesig_denom},${11:boolean lineartempo})$0"
    },
    "RPR_SETTEMPOTIMESIGMARKER_WR python": {
        "prefix": "WR_RPR_SetTempoTimeSigMarker",
        "scope": "python",
        "description": "Set parameters of a tempo/time signature marker. Provide either timepos\n(with measurepos=-1, beatpos=-1), or measurepos and beatpos (with\ntimepos=-1). If timesig_num and timesig_denom are zero, the previous\ntime signature will be used. ptidx=-1 will insert a new tempo/time\nsignature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.\n",
        "body": "${1:Boolean} = RPR_SetTempoTimeSigMarker(${2:ReaProject proj},${3:Int ptidx},${4:Float timepos},${5:Int measurepos},${6:Float beatpos},${7:Float bpm},${8:Int timesig_num},${9:Int timesig_denom},${10:Boolean lineartempo})$0"
    },
    "SETTOGGLECOMMANDSTATE_WR c": {
        "prefix": "WR_SetToggleCommandState",
        "scope": "c",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "${1:bool} = SetToggleCommandState(${2:int section_id},${3:int command_id},${4:int state})$0"
    },
    "SETTOGGLECOMMANDSTATE_WR eel2": {
        "prefix": "WR_SetToggleCommandState",
        "scope": "eel2",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "${1:bool} = SetToggleCommandState(${2:int section_id},${3:int command_id},${4:int state})$0"
    },
    "REAPER.SETTOGGLECOMMANDSTATE_WR lua": {
        "prefix": "reaperwr.SetToggleCommandState",
        "scope": "lua",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "${1:local }${2:boolean} = reaper.SetToggleCommandState(${3:integer section_id},${4:integer command_id},${5:integer state})$0"
    },
    "RPR_SETTOGGLECOMMANDSTATE_WR python": {
        "prefix": "WR_RPR_SetToggleCommandState",
        "scope": "python",
        "description": "Updates the toggle state of an action, returns true if succeeded. Only\nReaScripts can have their toggle states changed programmatically. See RefreshToolbar2.\n",
        "body": "${1:Boolean} = RPR_SetToggleCommandState(${2:Int section_id},${3:Int command_id},${4:Int state})$0"
    },
    "SETTRACKAUTOMATIONMODE_WR c": {
        "prefix": "WR_SetTrackAutomationMode",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = SetTrackAutomationMode(${2:MediaTrack* tr},${3:int mode})$0"
    },
    "SETTRACKCOLOR_WR c": {
        "prefix": "WR_SetTrackColor",
        "scope": "c",
        "description": "Set the custom track color, color is OS dependent (i.e. ColorToNative(r,g,b).\n",
        "body": "${1:void} = SetTrackColor(${2:MediaTrack* track},${3:int color})$0"
    },
    "SETTRACKMIDILYRICS_WR c": {
        "prefix": "WR_SetTrackMIDILyrics",
        "scope": "c",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "${1:bool} = SetTrackMIDILyrics(${2:MediaTrack* track},${3:int flag},${4:const char* str})$0"
    },
    "SETTRACKMIDILYRICS_WR eel2": {
        "prefix": "WR_SetTrackMIDILyrics",
        "scope": "eel2",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "${1:bool} = SetTrackMIDILyrics(${2:MediaTrack track},${3:int flag},${4:\"str\"})$0"
    },
    "REAPER.SETTRACKMIDILYRICS_WR lua": {
        "prefix": "reaperwr.SetTrackMIDILyrics",
        "scope": "lua",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "${1:local }${2:boolean} = reaper.SetTrackMIDILyrics(${3:MediaTrack track},${4:integer flag},${5:string str})$0"
    },
    "RPR_SETTRACKMIDILYRICS_WR python": {
        "prefix": "WR_RPR_SetTrackMIDILyrics",
        "scope": "python",
        "description": "Set all MIDI lyrics on the track. Lyrics will be stuffed into any MIDI\nitems found in range. Flag is unused at present. str is passed in as\nbeat position, tab, text, tab (example with flag=2: \"1.1.2\\tLyric for\nmeasure 1 beat 2\\t\u0002.1.1\\tLyric for measure 2 beat 1\t\"). See GetTrackMIDILyrics\n",
        "body": "${1:Boolean} = RPR_SetTrackMIDILyrics(${2:MediaTrack track},${3:Int flag},${4:String str})$0"
    },
    "SETTRACKMIDINOTENAME_WR c": {
        "prefix": "WR_SetTrackMIDINoteName",
        "scope": "c",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "${1:bool} = SetTrackMIDINoteName(${2:int track},${3:int pitch},${4:int chan},${5:const char* name})$0"
    },
    "SETTRACKMIDINOTENAME_WR eel2": {
        "prefix": "WR_SetTrackMIDINoteName",
        "scope": "eel2",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "${1:bool} = SetTrackMIDINoteName(${2:int track},${3:int pitch},${4:int chan},${5:\"name\"})$0"
    },
    "REAPER.SETTRACKMIDINOTENAME_WR lua": {
        "prefix": "reaperwr.SetTrackMIDINoteName",
        "scope": "lua",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "${1:local }${2:boolean} = reaper.SetTrackMIDINoteName(${3:integer track},${4:integer pitch},${5:integer chan},${6:string name})$0"
    },
    "RPR_SETTRACKMIDINOTENAME_WR python": {
        "prefix": "WR_RPR_SetTrackMIDINoteName",
        "scope": "python",
        "description": "channel < 0 assigns these note names to all channels.\n",
        "body": "${1:Boolean} = RPR_SetTrackMIDINoteName(${2:Int track},${3:Int pitch},${4:Int chan},${5:String name})$0"
    },
    "SETTRACKMIDINOTENAMEEX_WR c": {
        "prefix": "WR_SetTrackMIDINoteNameEx",
        "scope": "c",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "${1:bool} = SetTrackMIDINoteNameEx(${2:ReaProject* proj},${3:MediaTrack* track},${4:int pitch},${5:int chan},${6:const char* name})$0"
    },
    "SETTRACKMIDINOTENAMEEX_WR eel2": {
        "prefix": "WR_SetTrackMIDINoteNameEx",
        "scope": "eel2",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "${1:bool} = SetTrackMIDINoteNameEx(${2:ReaProject proj},${3:MediaTrack track},${4:int pitch},${5:int chan},${6:\"name\"})$0"
    },
    "REAPER.SETTRACKMIDINOTENAMEEX_WR lua": {
        "prefix": "reaperwr.SetTrackMIDINoteNameEx",
        "scope": "lua",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "${1:local }${2:boolean} = reaper.SetTrackMIDINoteNameEx(${3:ReaProject proj},${4:MediaTrack track},${5:integer pitch},${6:integer chan},${7:string name})$0"
    },
    "RPR_SETTRACKMIDINOTENAMEEX_WR python": {
        "prefix": "WR_RPR_SetTrackMIDINoteNameEx",
        "scope": "python",
        "description": "channel < 0 assigns note name to all channels. pitch 128 assigns name for CC0, pitch 129 for CC1, etc.\n",
        "body": "${1:Boolean} = RPR_SetTrackMIDINoteNameEx(${2:ReaProject proj},${3:MediaTrack track},${4:Int pitch},${5:Int chan},${6:String name})$0"
    },
    "SETTRACKSELECTED_WR c": {
        "prefix": "WR_SetTrackSelected",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = SetTrackSelected(${2:MediaTrack* track},${3:bool selected})$0"
    },
    "SETTRACKSENDINFO_VALUE_WR c": {
        "prefix": "WR_SetTrackSendInfo_Value",
        "scope": "c",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:bool} = SetTrackSendInfo_Value(${2:MediaTrack* tr},${3:int category},${4:int sendidx},${5|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\"|},${6:double newvalue})$0"
    },
    "SETTRACKSENDINFO_VALUE_WR eel2": {
        "prefix": "WR_SetTrackSendInfo_Value",
        "scope": "eel2",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:bool} = SetTrackSendInfo_Value(${2:MediaTrack tr},${3:int category},${4:int sendidx},${5:\"parmname\"},${6:newvalue})$0"
    },
    "REAPER.SETTRACKSENDINFO_VALUE_WR lua": {
        "prefix": "reaperwr.SetTrackSendInfo_Value",
        "scope": "lua",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:local }${2:boolean} = reaper.SetTrackSendInfo_Value(${3:MediaTrack tr},${4:integer category},${5:integer sendidx},${6|string parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\"|},${7:number newvalue})$0"
    },
    "RPR_SETTRACKSENDINFO_VALUE_WR python": {
        "prefix": "WR_RPR_SetTrackSendInfo_Value",
        "scope": "python",
        "description": "Set send/receive/hardware output numerical-value attributes, return true on success.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nparameter names:\nB_MUTE : bool *\nB_PHASE : bool *, true to flip phase\nB_MONO : bool *\nD_VOL : double *, 1.0 = +0dB etc\nD_PAN : double *, -1..+1\nD_PANLAW : double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc\nI_SENDMODE : int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx\nI_AUTOMODE : int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\nI_SRCCHAN : int *, index,&1024=mono, -1 for none\nI_DSTCHAN : int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute\nI_MIDIFLAGS : int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n",
        "body": "${1:Boolean} = RPR_SetTrackSendInfo_Value(${2:MediaTrack tr},${3:Int category},${4:Int sendidx},${5|String parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_AUTOMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDIFLAGS\"|},${6:Float newvalue})$0"
    },
    "SETTRACKSENDUIPAN_WR c": {
        "prefix": "WR_SetTrackSendUIPan",
        "scope": "c",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:bool} = SetTrackSendUIPan(${2:MediaTrack* track},${3:int send_idx},${4:double pan},${5:int isend})$0"
    },
    "SETTRACKSENDUIPAN_WR eel2": {
        "prefix": "WR_SetTrackSendUIPan",
        "scope": "eel2",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:bool} = SetTrackSendUIPan(${2:MediaTrack track},${3:int send_idx},${4:pan},${5:int isend})$0"
    },
    "REAPER.SETTRACKSENDUIPAN_WR lua": {
        "prefix": "reaperwr.SetTrackSendUIPan",
        "scope": "lua",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:local }${2:boolean} = reaper.SetTrackSendUIPan(${3:MediaTrack track},${4:integer send_idx},${5:number pan},${6:integer isend})$0"
    },
    "RPR_SETTRACKSENDUIPAN_WR python": {
        "prefix": "WR_RPR_SetTrackSendUIPan",
        "scope": "python",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:Boolean} = RPR_SetTrackSendUIPan(${2:MediaTrack track},${3:Int send_idx},${4:Float pan},${5:Int isend})$0"
    },
    "SETTRACKSENDUIVOL_WR c": {
        "prefix": "WR_SetTrackSendUIVol",
        "scope": "c",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:bool} = SetTrackSendUIVol(${2:MediaTrack* track},${3:int send_idx},${4:double vol},${5:int isend})$0"
    },
    "SETTRACKSENDUIVOL_WR eel2": {
        "prefix": "WR_SetTrackSendUIVol",
        "scope": "eel2",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:bool} = SetTrackSendUIVol(${2:MediaTrack track},${3:int send_idx},${4:vol},${5:int isend})$0"
    },
    "REAPER.SETTRACKSENDUIVOL_WR lua": {
        "prefix": "reaperwr.SetTrackSendUIVol",
        "scope": "lua",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:local }${2:boolean} = reaper.SetTrackSendUIVol(${3:MediaTrack track},${4:integer send_idx},${5:number vol},${6:integer isend})$0"
    },
    "RPR_SETTRACKSENDUIVOL_WR python": {
        "prefix": "WR_RPR_SetTrackSendUIVol",
        "scope": "python",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs\nfor sends. isend=1 for end of edit, -1 for an instant edit (such as\nreset), 0 for normal tweak.\n",
        "body": "${1:Boolean} = RPR_SetTrackSendUIVol(${2:MediaTrack track},${3:Int send_idx},${4:Float vol},${5:Int isend})$0"
    },
    "SETTRACKSTATECHUNK_WR c": {
        "prefix": "WR_SetTrackStateChunk",
        "scope": "c",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = SetTrackStateChunk(${2:MediaTrack* track},${3:const char* str},${4:bool isundoOptional})$0"
    },
    "SETTRACKSTATECHUNK_WR eel2": {
        "prefix": "WR_SetTrackStateChunk",
        "scope": "eel2",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:bool} = SetTrackStateChunk(${2:MediaTrack track},${3:\"str\"},${4:bool isundo})$0"
    },
    "REAPER.SETTRACKSTATECHUNK_WR lua": {
        "prefix": "reaperwr.SetTrackStateChunk",
        "scope": "lua",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:local }${2:boolean} = reaper.SetTrackStateChunk(${3:MediaTrack track},${4:string str},${5:boolean isundo})$0"
    },
    "RPR_SETTRACKSTATECHUNK_WR python": {
        "prefix": "WR_RPR_SetTrackStateChunk",
        "scope": "python",
        "description": "Sets the RPPXML state of a track, returns true if successful. Undo flag is a performance/caching hint.\n",
        "body": "${1:Boolean} = RPR_SetTrackStateChunk(${2:MediaTrack track},${3:String str},${4:Boolean isundoOptional})$0"
    },
    "SHOWACTIONLIST_WR c": {
        "prefix": "WR_ShowActionList",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = ShowActionList(${2:KbdSectionInfo* caller},${3:HWND callerWnd})$0"
    },
    "SHOWCONSOLEMSG_WR c": {
        "prefix": "WR_ShowConsoleMsg",
        "scope": "c",
        "description": "Show a message to the user (also useful for debugging). Send \"\\n\" for newline, \"\" to clear the console. See ClearConsole\n",
        "body": "${1:void} = ShowConsoleMsg(${2:const char* msg})$0"
    },
    "SHOWMESSAGEBOX_WR c": {
        "prefix": "WR_ShowMessageBox",
        "scope": "c",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:int} = ShowMessageBox(${2:const char* msg},${3:const char* title},${4:int type})$0"
    },
    "SHOWMESSAGEBOX_WR eel2": {
        "prefix": "WR_ShowMessageBox",
        "scope": "eel2",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:int} = ShowMessageBox(${2:\"msg\"},${3:\"title\"},${4:int type})$0"
    },
    "REAPER.SHOWMESSAGEBOX_WR lua": {
        "prefix": "reaperwr.ShowMessageBox",
        "scope": "lua",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:local }${2:integer} = reaper.ShowMessageBox(${3:string msg},${4:string title},${5:integer type})$0"
    },
    "RPR_SHOWMESSAGEBOX_WR python": {
        "prefix": "WR_RPR_ShowMessageBox",
        "scope": "python",
        "description": "type\n0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL :\nret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO\n",
        "body": "${1:Int} = RPR_ShowMessageBox(${2:String msg},${3:String title},${4:Int type})$0"
    },
    "SHOWPOPUPMENU_WR c": {
        "prefix": "WR_ShowPopupMenu",
        "scope": "c",
        "description": "shows a context menu, valid names include: track_input, track_panel,\ntrack_area, track_routing, item, ruler, envelope, envelope_point,\nenvelope_item. ctxOptional can be a track pointer for track_*, item\npointer for item* (but is optional). for envelope_point, ctx2Optional\nhas point index, ctx3Optional has item index (0=main envelope, 1=first\nAI). for envelope_item, ctx2Optional has AI index (1=first AI)\n",
        "body": "${1:void} = ShowPopupMenu(${2:const char* name},${3:int x},${4:int y},${5:HWND hwndParentOptional},${6:void* ctxOptional},${7:int ctx2Optional},${8:int ctx3Optional})$0"
    },
    "SLIDER2DB_WR c": {
        "prefix": "WR_SLIDER2DB",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = SLIDER2DB(${2:double y})$0"
    },
    "SLIDER2DB_WR eel2": {
        "prefix": "WR_SLIDER2DB",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = SLIDER2DB(${2:y})$0"
    },
    "REAPER.SLIDER2DB_WR lua": {
        "prefix": "reaperwr.SLIDER2DB",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.SLIDER2DB(${3:number y})$0"
    },
    "RPR_SLIDER2DB_WR python": {
        "prefix": "WR_RPR_SLIDER2DB",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_SLIDER2DB(${2:Float y})$0"
    },
    "SNAPTOGRID_WR c": {
        "prefix": "WR_SnapToGrid",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = SnapToGrid(${2:ReaProject* project},${3:double time_pos})$0"
    },
    "SNAPTOGRID_WR eel2": {
        "prefix": "WR_SnapToGrid",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = SnapToGrid(${2:ReaProject project},${3:time_pos})$0"
    },
    "REAPER.SNAPTOGRID_WR lua": {
        "prefix": "reaperwr.SnapToGrid",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.SnapToGrid(${3:ReaProject project},${4:number time_pos})$0"
    },
    "RPR_SNAPTOGRID_WR python": {
        "prefix": "WR_RPR_SnapToGrid",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_SnapToGrid(${2:ReaProject project},${3:Float time_pos})$0"
    },
    "SOLOALLTRACKS_WR c": {
        "prefix": "WR_SoloAllTracks",
        "scope": "c",
        "description": "solo=2 for SIP\n",
        "body": "${1:void} = SoloAllTracks(${2:int solo})$0"
    },
    "SPLASH_GETWND_WR c": {
        "prefix": "WR_Splash_GetWnd",
        "scope": "c",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "${1:HWND} = Splash_GetWnd()$0"
    },
    "SPLASH_GETWND_WR eel2": {
        "prefix": "WR_Splash_GetWnd",
        "scope": "eel2",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "${1:HWND} = Splash_GetWnd()$0"
    },
    "REAPER.SPLASH_GETWND_WR lua": {
        "prefix": "reaperwr.Splash_GetWnd",
        "scope": "lua",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "${1:local }${2:HWND} = reaper.Splash_GetWnd()$0"
    },
    "RPR_SPLASH_GETWND_WR python": {
        "prefix": "WR_RPR_Splash_GetWnd",
        "scope": "python",
        "description": "gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.\n",
        "body": "${1:HWND} = RPR_Splash_GetWnd()$0"
    },
    "SPLITMEDIAITEM_WR c": {
        "prefix": "WR_SplitMediaItem",
        "scope": "c",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "${1:MediaItem*} = SplitMediaItem(${2:MediaItem* item},${3:double position})$0"
    },
    "SPLITMEDIAITEM_WR eel2": {
        "prefix": "WR_SplitMediaItem",
        "scope": "eel2",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "${1:MediaItem} = SplitMediaItem(${2:MediaItem item},${3:position})$0"
    },
    "REAPER.SPLITMEDIAITEM_WR lua": {
        "prefix": "reaperwr.SplitMediaItem",
        "scope": "lua",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "${1:local }${2:MediaItem} = reaper.SplitMediaItem(${3:MediaItem item},${4:number position})$0"
    },
    "RPR_SPLITMEDIAITEM_WR python": {
        "prefix": "WR_RPR_SplitMediaItem",
        "scope": "python",
        "description": "the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)\n",
        "body": "${1:MediaItem} = RPR_SplitMediaItem(${2:MediaItem item},${3:Float position})$0"
    },
    "STRINGTOGUID_WR c": {
        "prefix": "WR_stringToGuid",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = stringToGuid(${2:const char* str},${3:GUID* g})$0"
    },
    "REAPER.STRINGTOGUID_WR lua": {
        "prefix": "reaperwr.stringToGuid",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string gGUID} = reaper.stringToGuid(${3:string str},${4:string gGUID})$0"
    },
    "STUFFMIDIMESSAGE_WR c": {
        "prefix": "WR_StuffMIDIMessage",
        "scope": "c",
        "description": "Stuffs a 3 byte MIDI message into either the Virtual MIDI Keyboard\nqueue, or the MIDI-as-control input queue, or sends to a MIDI hardware\noutput. mode=0 for VKB, 1 for control (actions map etc), 2 for\nVKB-on-current-channel; 16 for external MIDI device 0, 17 for external\nMIDI device 1, etc; see GetNumMIDIOutputs, GetMIDIOutputName.\n",
        "body": "${1:void} = StuffMIDIMessage(${2:int mode},${3:int msg1},${4:int msg2},${5:int msg3})$0"
    },
    "TAKEFX_ADDBYNAME_WR c": {
        "prefix": "WR_TakeFX_AddByName",
        "scope": "c",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "${1:int} = TakeFX_AddByName(${2:MediaItem_Take* take},${3:const char* fxname},${4:int instantiate})$0"
    },
    "TAKEFX_ADDBYNAME_WR eel2": {
        "prefix": "WR_TakeFX_AddByName",
        "scope": "eel2",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "${1:int} = TakeFX_AddByName(${2:MediaItem_Take take},${3:\"fxname\"},${4:int instantiate})$0"
    },
    "REAPER.TAKEFX_ADDBYNAME_WR lua": {
        "prefix": "reaperwr.TakeFX_AddByName",
        "scope": "lua",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "${1:local }${2:integer} = reaper.TakeFX_AddByName(${3:MediaItem_Take take},${4:string fxname},${5:integer instantiate})$0"
    },
    "RPR_TAKEFX_ADDBYNAME_WR python": {
        "prefix": "WR_RPR_TakeFX_AddByName",
        "scope": "python",
        "description": "Adds or queries the position of a named FX in a take. Specify a negative\nvalue for instantiate to always create a new effect, 0 to only query\nthe first instance of an effect, or a positive value to add an instance\nif one is not found.\n",
        "body": "${1:Int} = RPR_TakeFX_AddByName(${2:MediaItem_Take take},${3:String fxname},${4:Int instantiate})$0"
    },
    "TAKEFX_COPYTOTAKE_WR c": {
        "prefix": "WR_TakeFX_CopyToTake",
        "scope": "c",
        "description": "Copies (or moves) FX from src_take to dest_take. Can be used with src_track=dest_track to reorder.\n",
        "body": "${1:void} = TakeFX_CopyToTake(${2:MediaItem_Take* src_take},${3:int src_fx},${4:MediaItem_Take* dest_take},${5:int dest_fx},${6:bool is_move})$0"
    },
    "TAKEFX_COPYTOTRACK_WR c": {
        "prefix": "WR_TakeFX_CopyToTrack",
        "scope": "c",
        "description": "Copies (or moves) FX from src_take to dest_track. dest_fx can have 0x1000000 set to reference input FX.\n",
        "body": "${1:void} = TakeFX_CopyToTrack(${2:MediaItem_Take* src_take},${3:int src_fx},${4:MediaTrack* dest_track},${5:int dest_fx},${6:bool is_move})$0"
    },
    "TAKEFX_DELETE_WR c": {
        "prefix": "WR_TakeFX_Delete",
        "scope": "c",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "${1:bool} = TakeFX_Delete(${2:MediaItem_Take* take},${3:int fx})$0"
    },
    "TAKEFX_DELETE_WR eel2": {
        "prefix": "WR_TakeFX_Delete",
        "scope": "eel2",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "${1:bool} = TakeFX_Delete(${2:MediaItem_Take take},${3:int fx})$0"
    },
    "REAPER.TAKEFX_DELETE_WR lua": {
        "prefix": "reaperwr.TakeFX_Delete",
        "scope": "lua",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_Delete(${3:MediaItem_Take take},${4:integer fx})$0"
    },
    "RPR_TAKEFX_DELETE_WR python": {
        "prefix": "WR_RPR_TakeFX_Delete",
        "scope": "python",
        "description": "Remove a FX from take chain (returns true on success)\n",
        "body": "${1:Boolean} = RPR_TakeFX_Delete(${2:MediaItem_Take take},${3:Int fx})$0"
    },
    "TAKEFX_ENDPARAMEDIT_WR c": {
        "prefix": "WR_TakeFX_EndParamEdit",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TakeFX_EndParamEdit(${2:MediaItem_Take* take},${3:int fx},${4:int param})$0"
    },
    "TAKEFX_ENDPARAMEDIT_WR eel2": {
        "prefix": "WR_TakeFX_EndParamEdit",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_EndParamEdit(${2:MediaItem_Take take},${3:int fx},${4:int param})$0"
    },
    "REAPER.TAKEFX_ENDPARAMEDIT_WR lua": {
        "prefix": "reaperwr.TakeFX_EndParamEdit",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_EndParamEdit(${3:MediaItem_Take take},${4:integer fx},${5:integer param})$0"
    },
    "RPR_TAKEFX_ENDPARAMEDIT_WR python": {
        "prefix": "WR_RPR_TakeFX_EndParamEdit",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_TakeFX_EndParamEdit(${2:MediaItem_Take take},${3:Int fx},${4:Int param})$0"
    },
    "TAKEFX_FORMATPARAMVALUE_WR c": {
        "prefix": "WR_TakeFX_FormatParamValue",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TakeFX_FormatParamValue(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:double val},${6:char* buf},${7:int buf_sz})$0"
    },
    "TAKEFX_FORMATPARAMVALUE_WR eel2": {
        "prefix": "WR_TakeFX_FormatParamValue",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TakeFX_FormatParamValue(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:val},${6:#buf})$0"
    },
    "REAPER.TAKEFX_FORMATPARAMVALUE_WR lua": {
        "prefix": "reaperwr.TakeFX_FormatParamValue",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TakeFX_FormatParamValue(${4:MediaItem_Take take},${5:integer fx},${6:integer param},${7:number val},${8:string buf})$0"
    },
    "RPR_TAKEFX_FORMATPARAMVALUE_WR python": {
        "prefix": "WR_RPR_TakeFX_FormatParamValue",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:Float val},${6:String buf},${7:Int buf_sz} = RPR_TakeFX_FormatParamValue(${8:take},${9:fx},${10:param},${11:val},${12:buf},${13:buf_sz})$0"
    },
    "TAKEFX_FORMATPARAMVALUENORMALIZED_WR c": {
        "prefix": "WR_TakeFX_FormatParamValueNormalized",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TakeFX_FormatParamValueNormalized(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:double value},${6:char* buf},${7:int buf_sz})$0"
    },
    "TAKEFX_FORMATPARAMVALUENORMALIZED_WR eel2": {
        "prefix": "WR_TakeFX_FormatParamValueNormalized",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TakeFX_FormatParamValueNormalized(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:value},${6:#buf})$0"
    },
    "REAPER.TAKEFX_FORMATPARAMVALUENORMALIZED_WR lua": {
        "prefix": "reaperwr.TakeFX_FormatParamValueNormalized",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TakeFX_FormatParamValueNormalized(${4:MediaItem_Take take},${5:integer fx},${6:integer param},${7:number value},${8:string buf})$0"
    },
    "RPR_TAKEFX_FORMATPARAMVALUENORMALIZED_WR python": {
        "prefix": "WR_RPR_TakeFX_FormatParamValueNormalized",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:Float value},${6:String buf},${7:Int buf_sz} = RPR_TakeFX_FormatParamValueNormalized(${8:take},${9:fx},${10:param},${11:value},${12:buf},${13:buf_sz})$0"
    },
    "TAKEFX_GETCHAINVISIBLE_WR c": {
        "prefix": "WR_TakeFX_GetChainVisible",
        "scope": "c",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:int} = TakeFX_GetChainVisible(${2:MediaItem_Take* take})$0"
    },
    "TAKEFX_GETCHAINVISIBLE_WR eel2": {
        "prefix": "WR_TakeFX_GetChainVisible",
        "scope": "eel2",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:int} = TakeFX_GetChainVisible(${2:MediaItem_Take take})$0"
    },
    "REAPER.TAKEFX_GETCHAINVISIBLE_WR lua": {
        "prefix": "reaperwr.TakeFX_GetChainVisible",
        "scope": "lua",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:local }${2:integer} = reaper.TakeFX_GetChainVisible(${3:MediaItem_Take take})$0"
    },
    "RPR_TAKEFX_GETCHAINVISIBLE_WR python": {
        "prefix": "WR_RPR_TakeFX_GetChainVisible",
        "scope": "python",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:Int} = RPR_TakeFX_GetChainVisible(${2:MediaItem_Take take})$0"
    },
    "TAKEFX_GETCOUNT_WR c": {
        "prefix": "WR_TakeFX_GetCount",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = TakeFX_GetCount(${2:MediaItem_Take* take})$0"
    },
    "TAKEFX_GETCOUNT_WR eel2": {
        "prefix": "WR_TakeFX_GetCount",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = TakeFX_GetCount(${2:MediaItem_Take take})$0"
    },
    "REAPER.TAKEFX_GETCOUNT_WR lua": {
        "prefix": "reaperwr.TakeFX_GetCount",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.TakeFX_GetCount(${3:MediaItem_Take take})$0"
    },
    "RPR_TAKEFX_GETCOUNT_WR python": {
        "prefix": "WR_RPR_TakeFX_GetCount",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_TakeFX_GetCount(${2:MediaItem_Take take})$0"
    },
    "TAKEFX_GETENABLED_WR c": {
        "prefix": "WR_TakeFX_GetEnabled",
        "scope": "c",
        "description": "See TakeFX_SetEnabled\n",
        "body": "${1:bool} = TakeFX_GetEnabled(${2:MediaItem_Take* take},${3:int fx})$0"
    },
    "TAKEFX_GETENABLED_WR eel2": {
        "prefix": "WR_TakeFX_GetEnabled",
        "scope": "eel2",
        "description": "See TakeFX_SetEnabled\n",
        "body": "${1:bool} = TakeFX_GetEnabled(${2:MediaItem_Take take},${3:int fx})$0"
    },
    "REAPER.TAKEFX_GETENABLED_WR lua": {
        "prefix": "reaperwr.TakeFX_GetEnabled",
        "scope": "lua",
        "description": "See TakeFX_SetEnabled\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_GetEnabled(${3:MediaItem_Take take},${4:integer fx})$0"
    },
    "RPR_TAKEFX_GETENABLED_WR python": {
        "prefix": "WR_RPR_TakeFX_GetEnabled",
        "scope": "python",
        "description": "See TakeFX_SetEnabled\n",
        "body": "${1:Boolean} = RPR_TakeFX_GetEnabled(${2:MediaItem_Take take},${3:Int fx})$0"
    },
    "TAKEFX_GETENVELOPE_WR c": {
        "prefix": "WR_TakeFX_GetEnvelope",
        "scope": "c",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:TrackEnvelope*} = TakeFX_GetEnvelope(${2:MediaItem_Take* take},${3:int fxindex},${4:int parameterindex},${5:bool create})$0"
    },
    "TAKEFX_GETENVELOPE_WR eel2": {
        "prefix": "WR_TakeFX_GetEnvelope",
        "scope": "eel2",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:TrackEnvelope} = TakeFX_GetEnvelope(${2:MediaItem_Take take},${3:int fxindex},${4:int parameterindex},${5:bool create})$0"
    },
    "REAPER.TAKEFX_GETENVELOPE_WR lua": {
        "prefix": "reaperwr.TakeFX_GetEnvelope",
        "scope": "lua",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.TakeFX_GetEnvelope(${3:MediaItem_Take take},${4:integer fxindex},${5:integer parameterindex},${6:boolean create})$0"
    },
    "RPR_TAKEFX_GETENVELOPE_WR python": {
        "prefix": "WR_RPR_TakeFX_GetEnvelope",
        "scope": "python",
        "description": "Returns the FX parameter envelope. If the envelope does not exist and create=true, the envelope will be created.\n",
        "body": "${1:TrackEnvelope} = RPR_TakeFX_GetEnvelope(${2:MediaItem_Take take},${3:Int fxindex},${4:Int parameterindex},${5:Boolean create})$0"
    },
    "TAKEFX_GETFLOATINGWINDOW_WR c": {
        "prefix": "WR_TakeFX_GetFloatingWindow",
        "scope": "c",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:HWND} = TakeFX_GetFloatingWindow(${2:MediaItem_Take* take},${3:int index})$0"
    },
    "TAKEFX_GETFLOATINGWINDOW_WR eel2": {
        "prefix": "WR_TakeFX_GetFloatingWindow",
        "scope": "eel2",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:HWND} = TakeFX_GetFloatingWindow(${2:MediaItem_Take take},${3:int index})$0"
    },
    "REAPER.TAKEFX_GETFLOATINGWINDOW_WR lua": {
        "prefix": "reaperwr.TakeFX_GetFloatingWindow",
        "scope": "lua",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:local }${2:HWND} = reaper.TakeFX_GetFloatingWindow(${3:MediaItem_Take take},${4:integer index})$0"
    },
    "RPR_TAKEFX_GETFLOATINGWINDOW_WR python": {
        "prefix": "WR_RPR_TakeFX_GetFloatingWindow",
        "scope": "python",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:HWND} = RPR_TakeFX_GetFloatingWindow(${2:MediaItem_Take take},${3:Int index})$0"
    },
    "TAKEFX_GETFORMATTEDPARAMVALUE_WR c": {
        "prefix": "WR_TakeFX_GetFormattedParamValue",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetFormattedParamValue(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:char* buf},${6:int buf_sz})$0"
    },
    "TAKEFX_GETFORMATTEDPARAMVALUE_WR eel2": {
        "prefix": "WR_TakeFX_GetFormattedParamValue",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetFormattedParamValue(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:#buf})$0"
    },
    "REAPER.TAKEFX_GETFORMATTEDPARAMVALUE_WR lua": {
        "prefix": "reaperwr.TakeFX_GetFormattedParamValue",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TakeFX_GetFormattedParamValue(${4:MediaItem_Take take},${5:integer fx},${6:integer param},${7:string buf})$0"
    },
    "RPR_TAKEFX_GETFORMATTEDPARAMVALUE_WR python": {
        "prefix": "WR_RPR_TakeFX_GetFormattedParamValue",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:String buf},${6:Int buf_sz} = RPR_TakeFX_GetFormattedParamValue(${7:take},${8:fx},${9:param},${10:buf},${11:buf_sz})$0"
    },
    "TAKEFX_GETFXGUID_WR c": {
        "prefix": "WR_TakeFX_GetFXGUID",
        "scope": "c",
        "description": "\n",
        "body": "${1:GUID*} = TakeFX_GetFXGUID(${2:MediaItem_Take* take},${3:int fx})$0"
    },
    "TAKEFX_GETFXGUID_WR eel2": {
        "prefix": "WR_TakeFX_GetFXGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetFXGUID(${2:#retguid},${3:MediaItem_Take take},${4:int fx})$0"
    },
    "REAPER.TAKEFX_GETFXGUID_WR lua": {
        "prefix": "reaperwr.TakeFX_GetFXGUID",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string GUID} = reaper.TakeFX_GetFXGUID(${3:MediaItem_Take take},${4:integer fx})$0"
    },
    "RPR_TAKEFX_GETFXGUID_WR python": {
        "prefix": "WR_RPR_TakeFX_GetFXGUID",
        "scope": "python",
        "description": "\n",
        "body": "${1:GUID} = RPR_TakeFX_GetFXGUID(${2:MediaItem_Take take},${3:Int fx})$0"
    },
    "TAKEFX_GETFXNAME_WR c": {
        "prefix": "WR_TakeFX_GetFXName",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetFXName(${2:MediaItem_Take* take},${3:int fx},${4:char* buf},${5:int buf_sz})$0"
    },
    "TAKEFX_GETFXNAME_WR eel2": {
        "prefix": "WR_TakeFX_GetFXName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetFXName(${2:MediaItem_Take take},${3:int fx},${4:#buf})$0"
    },
    "REAPER.TAKEFX_GETFXNAME_WR lua": {
        "prefix": "reaperwr.TakeFX_GetFXName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TakeFX_GetFXName(${4:MediaItem_Take take},${5:integer fx},${6:string buf})$0"
    },
    "RPR_TAKEFX_GETFXNAME_WR python": {
        "prefix": "WR_RPR_TakeFX_GetFXName",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:String buf},${5:Int buf_sz} = RPR_TakeFX_GetFXName(${6:take},${7:fx},${8:buf},${9:buf_sz})$0"
    },
    "TAKEFX_GETIOSIZE_WR c": {
        "prefix": "WR_TakeFX_GetIOSize",
        "scope": "c",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:int} = TakeFX_GetIOSize(${2:MediaItem_Take* take},${3:int fx},${4:int* inputPinsOutOptional},${5:int* outputPinsOutOptional})$0"
    },
    "TAKEFX_GETIOSIZE_WR eel2": {
        "prefix": "WR_TakeFX_GetIOSize",
        "scope": "eel2",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:int} = TakeFX_GetIOSize(${2:MediaItem_Take take},${3:int fx},${4:optional int &inputPins},${5:optional int &outputPins})$0"
    },
    "REAPER.TAKEFX_GETIOSIZE_WR lua": {
        "prefix": "reaperwr.TakeFX_GetIOSize",
        "scope": "lua",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:local }${2:integer retval},${3:optional number inputPins},${4:optional number outputPins} = reaper.TakeFX_GetIOSize(${5:MediaItem_Take take},${6:integer fx})$0"
    },
    "RPR_TAKEFX_GETIOSIZE_WR python": {
        "prefix": "WR_RPR_TakeFX_GetIOSize",
        "scope": "python",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:Int retval},${2:MediaItem_Take take},${3:Int fx},${4:Int inputPinsOutOptional},${5:Int outputPinsOutOptional} = RPR_TakeFX_GetIOSize(${6:take},${7:fx},${8:inputPinsOutOptional},${9:outputPinsOutOptional})$0"
    },
    "TAKEFX_GETNAMEDCONFIGPARM_WR c": {
        "prefix": "WR_TakeFX_GetNamedConfigParm",
        "scope": "c",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "${1:bool} = TakeFX_GetNamedConfigParm(${2:MediaItem_Take* take},${3:int fx},${4:const char* parmname},${5:char* bufOut},${6:int bufOut_sz})$0"
    },
    "TAKEFX_GETNAMEDCONFIGPARM_WR eel2": {
        "prefix": "WR_TakeFX_GetNamedConfigParm",
        "scope": "eel2",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "${1:bool} = TakeFX_GetNamedConfigParm(${2:MediaItem_Take take},${3:int fx},${4:\"parmname\"},${5:#buf})$0"
    },
    "REAPER.TAKEFX_GETNAMEDCONFIGPARM_WR lua": {
        "prefix": "reaperwr.TakeFX_GetNamedConfigParm",
        "scope": "lua",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TakeFX_GetNamedConfigParm(${4:MediaItem_Take take},${5:integer fx},${6:string parmname})$0"
    },
    "RPR_TAKEFX_GETNAMEDCONFIGPARM_WR python": {
        "prefix": "WR_RPR_TakeFX_GetNamedConfigParm",
        "scope": "python",
        "description": "gets plug-in specific named configuration value (returns true on success). see TrackFX_GetNamedConfigParm\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:String parmname},${5:String bufOut},${6:Int bufOut_sz} = RPR_TakeFX_GetNamedConfigParm(${7:take},${8:fx},${9:parmname},${10:bufOut},${11:bufOut_sz})$0"
    },
    "TAKEFX_GETNUMPARAMS_WR c": {
        "prefix": "WR_TakeFX_GetNumParams",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = TakeFX_GetNumParams(${2:MediaItem_Take* take},${3:int fx})$0"
    },
    "TAKEFX_GETNUMPARAMS_WR eel2": {
        "prefix": "WR_TakeFX_GetNumParams",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = TakeFX_GetNumParams(${2:MediaItem_Take take},${3:int fx})$0"
    },
    "REAPER.TAKEFX_GETNUMPARAMS_WR lua": {
        "prefix": "reaperwr.TakeFX_GetNumParams",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.TakeFX_GetNumParams(${3:MediaItem_Take take},${4:integer fx})$0"
    },
    "RPR_TAKEFX_GETNUMPARAMS_WR python": {
        "prefix": "WR_RPR_TakeFX_GetNumParams",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_TakeFX_GetNumParams(${2:MediaItem_Take take},${3:Int fx})$0"
    },
    "TAKEFX_GETOFFLINE_WR c": {
        "prefix": "WR_TakeFX_GetOffline",
        "scope": "c",
        "description": "See TakeFX_SetOffline\n",
        "body": "${1:bool} = TakeFX_GetOffline(${2:MediaItem_Take* take},${3:int fx})$0"
    },
    "TAKEFX_GETOFFLINE_WR eel2": {
        "prefix": "WR_TakeFX_GetOffline",
        "scope": "eel2",
        "description": "See TakeFX_SetOffline\n",
        "body": "${1:bool} = TakeFX_GetOffline(${2:MediaItem_Take take},${3:int fx})$0"
    },
    "REAPER.TAKEFX_GETOFFLINE_WR lua": {
        "prefix": "reaperwr.TakeFX_GetOffline",
        "scope": "lua",
        "description": "See TakeFX_SetOffline\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_GetOffline(${3:MediaItem_Take take},${4:integer fx})$0"
    },
    "RPR_TAKEFX_GETOFFLINE_WR python": {
        "prefix": "WR_RPR_TakeFX_GetOffline",
        "scope": "python",
        "description": "See TakeFX_SetOffline\n",
        "body": "${1:Boolean} = RPR_TakeFX_GetOffline(${2:MediaItem_Take take},${3:Int fx})$0"
    },
    "TAKEFX_GETOPEN_WR c": {
        "prefix": "WR_TakeFX_GetOpen",
        "scope": "c",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "${1:bool} = TakeFX_GetOpen(${2:MediaItem_Take* take},${3:int fx})$0"
    },
    "TAKEFX_GETOPEN_WR eel2": {
        "prefix": "WR_TakeFX_GetOpen",
        "scope": "eel2",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "${1:bool} = TakeFX_GetOpen(${2:MediaItem_Take take},${3:int fx})$0"
    },
    "REAPER.TAKEFX_GETOPEN_WR lua": {
        "prefix": "reaperwr.TakeFX_GetOpen",
        "scope": "lua",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_GetOpen(${3:MediaItem_Take take},${4:integer fx})$0"
    },
    "RPR_TAKEFX_GETOPEN_WR python": {
        "prefix": "WR_RPR_TakeFX_GetOpen",
        "scope": "python",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TakeFX_SetOpen\n",
        "body": "${1:Boolean} = RPR_TakeFX_GetOpen(${2:MediaItem_Take take},${3:Int fx})$0"
    },
    "TAKEFX_GETPARAM_WR c": {
        "prefix": "WR_TakeFX_GetParam",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = TakeFX_GetParam(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:double* minvalOut},${6:double* maxvalOut})$0"
    },
    "TAKEFX_GETPARAM_WR eel2": {
        "prefix": "WR_TakeFX_GetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = TakeFX_GetParam(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:&minval},${6:&maxval})$0"
    },
    "REAPER.TAKEFX_GETPARAM_WR lua": {
        "prefix": "reaperwr.TakeFX_GetParam",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number retval},${3:number minval},${4:number maxval} = reaper.TakeFX_GetParam(${5:MediaItem_Take take},${6:integer fx},${7:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAM_WR python": {
        "prefix": "WR_RPR_TakeFX_GetParam",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float retval},${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:Float minvalOut},${6:Float maxvalOut} = RPR_TakeFX_GetParam(${7:take},${8:fx},${9:param},${10:minvalOut},${11:maxvalOut})$0"
    },
    "TAKEFX_GETPARAMETERSTEPSIZES_WR c": {
        "prefix": "WR_TakeFX_GetParameterStepSizes",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetParameterStepSizes(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:double* stepOut},${6:double* smallstepOut},${7:double* largestepOut},${8:bool* istoggleOut})$0"
    },
    "TAKEFX_GETPARAMETERSTEPSIZES_WR eel2": {
        "prefix": "WR_TakeFX_GetParameterStepSizes",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetParameterStepSizes(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:&step},${6:&smallstep},${7:&largestep},${8:bool &istoggle})$0"
    },
    "REAPER.TAKEFX_GETPARAMETERSTEPSIZES_WR lua": {
        "prefix": "reaperwr.TakeFX_GetParameterStepSizes",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:number step},${4:number smallstep},${5:number largestep},${6:boolean istoggle} = reaper.TakeFX_GetParameterStepSizes(${7:MediaItem_Take take},${8:integer fx},${9:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAMETERSTEPSIZES_WR python": {
        "prefix": "WR_RPR_TakeFX_GetParameterStepSizes",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:Float stepOut},${6:Float smallstepOut},${7:Float largestepOut},${8:Boolean istoggleOut} = RPR_TakeFX_GetParameterStepSizes(${9:take},${10:fx},${11:param},${12:stepOut},${13:smallstepOut},${14:largestepOut},${15:istoggleOut})$0"
    },
    "TAKEFX_GETPARAMEX_WR c": {
        "prefix": "WR_TakeFX_GetParamEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = TakeFX_GetParamEx(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:double* minvalOut},${6:double* maxvalOut},${7:double* midvalOut})$0"
    },
    "TAKEFX_GETPARAMEX_WR eel2": {
        "prefix": "WR_TakeFX_GetParamEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = TakeFX_GetParamEx(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:&minval},${6:&maxval},${7:&midval})$0"
    },
    "REAPER.TAKEFX_GETPARAMEX_WR lua": {
        "prefix": "reaperwr.TakeFX_GetParamEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number retval},${3:number minval},${4:number maxval},${5:number midval} = reaper.TakeFX_GetParamEx(${6:MediaItem_Take take},${7:integer fx},${8:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAMEX_WR python": {
        "prefix": "WR_RPR_TakeFX_GetParamEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float retval},${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:Float minvalOut},${6:Float maxvalOut},${7:Float midvalOut} = RPR_TakeFX_GetParamEx(${8:take},${9:fx},${10:param},${11:minvalOut},${12:maxvalOut},${13:midvalOut})$0"
    },
    "TAKEFX_GETPARAMNAME_WR c": {
        "prefix": "WR_TakeFX_GetParamName",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetParamName(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:char* buf},${6:int buf_sz})$0"
    },
    "TAKEFX_GETPARAMNAME_WR eel2": {
        "prefix": "WR_TakeFX_GetParamName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_GetParamName(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:#buf})$0"
    },
    "REAPER.TAKEFX_GETPARAMNAME_WR lua": {
        "prefix": "reaperwr.TakeFX_GetParamName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TakeFX_GetParamName(${4:MediaItem_Take take},${5:integer fx},${6:integer param},${7:string buf})$0"
    },
    "RPR_TAKEFX_GETPARAMNAME_WR python": {
        "prefix": "WR_RPR_TakeFX_GetParamName",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:String buf},${6:Int buf_sz} = RPR_TakeFX_GetParamName(${7:take},${8:fx},${9:param},${10:buf},${11:buf_sz})$0"
    },
    "TAKEFX_GETPARAMNORMALIZED_WR c": {
        "prefix": "WR_TakeFX_GetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = TakeFX_GetParamNormalized(${2:MediaItem_Take* take},${3:int fx},${4:int param})$0"
    },
    "TAKEFX_GETPARAMNORMALIZED_WR eel2": {
        "prefix": "WR_TakeFX_GetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = TakeFX_GetParamNormalized(${2:MediaItem_Take take},${3:int fx},${4:int param})$0"
    },
    "REAPER.TAKEFX_GETPARAMNORMALIZED_WR lua": {
        "prefix": "reaperwr.TakeFX_GetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.TakeFX_GetParamNormalized(${3:MediaItem_Take take},${4:integer fx},${5:integer param})$0"
    },
    "RPR_TAKEFX_GETPARAMNORMALIZED_WR python": {
        "prefix": "WR_RPR_TakeFX_GetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_TakeFX_GetParamNormalized(${2:MediaItem_Take take},${3:Int fx},${4:Int param})$0"
    },
    "TAKEFX_GETPINMAPPINGS_WR c": {
        "prefix": "WR_TakeFX_GetPinMappings",
        "scope": "c",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:int} = TakeFX_GetPinMappings(${2:MediaItem_Take* tr},${3:int fx},${4:int isoutput},${5:int pin},${6:int* high32OutOptional})$0"
    },
    "TAKEFX_GETPINMAPPINGS_WR eel2": {
        "prefix": "WR_TakeFX_GetPinMappings",
        "scope": "eel2",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:int} = TakeFX_GetPinMappings(${2:MediaItem_Take tr},${3:int fx},${4:int isoutput},${5:int pin},${6:optional int &high32})$0"
    },
    "REAPER.TAKEFX_GETPINMAPPINGS_WR lua": {
        "prefix": "reaperwr.TakeFX_GetPinMappings",
        "scope": "lua",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:local }${2:integer retval},${3:optional number high32} = reaper.TakeFX_GetPinMappings(${4:MediaItem_Take tr},${5:integer fx},${6:integer isoutput},${7:integer pin})$0"
    },
    "RPR_TAKEFX_GETPINMAPPINGS_WR python": {
        "prefix": "WR_RPR_TakeFX_GetPinMappings",
        "scope": "python",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:Int retval},${2:MediaItem_Take tr},${3:Int fx},${4:Int isoutput},${5:Int pin},${6:Int high32OutOptional} = RPR_TakeFX_GetPinMappings(${7:tr},${8:fx},${9:isoutput},${10:pin},${11:high32OutOptional})$0"
    },
    "TAKEFX_GETPRESET_WR c": {
        "prefix": "WR_TakeFX_GetPreset",
        "scope": "c",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "${1:bool} = TakeFX_GetPreset(${2:MediaItem_Take* take},${3:int fx},${4:char* presetname},${5:int presetname_sz})$0"
    },
    "TAKEFX_GETPRESET_WR eel2": {
        "prefix": "WR_TakeFX_GetPreset",
        "scope": "eel2",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "${1:bool} = TakeFX_GetPreset(${2:MediaItem_Take take},${3:int fx},${4:#presetname})$0"
    },
    "REAPER.TAKEFX_GETPRESET_WR lua": {
        "prefix": "reaperwr.TakeFX_GetPreset",
        "scope": "lua",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "${1:local }${2:boolean retval},${3:string presetname} = reaper.TakeFX_GetPreset(${4:MediaItem_Take take},${5:integer fx},${6:string presetname})$0"
    },
    "RPR_TAKEFX_GETPRESET_WR python": {
        "prefix": "WR_RPR_TakeFX_GetPreset",
        "scope": "python",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TakeFX_SetPreset.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Int fx},${4:String presetname},${5:Int presetname_sz} = RPR_TakeFX_GetPreset(${6:take},${7:fx},${8:presetname},${9:presetname_sz})$0"
    },
    "TAKEFX_GETPRESETINDEX_WR c": {
        "prefix": "WR_TakeFX_GetPresetIndex",
        "scope": "c",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "${1:int} = TakeFX_GetPresetIndex(${2:MediaItem_Take* take},${3:int fx},${4:int* numberOfPresetsOut})$0"
    },
    "TAKEFX_GETPRESETINDEX_WR eel2": {
        "prefix": "WR_TakeFX_GetPresetIndex",
        "scope": "eel2",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "${1:int} = TakeFX_GetPresetIndex(${2:MediaItem_Take take},${3:int fx},${4:int &numberOfPresets})$0"
    },
    "REAPER.TAKEFX_GETPRESETINDEX_WR lua": {
        "prefix": "reaperwr.TakeFX_GetPresetIndex",
        "scope": "lua",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "${1:local }${2:integer retval},${3:number numberOfPresets} = reaper.TakeFX_GetPresetIndex(${4:MediaItem_Take take},${5:integer fx})$0"
    },
    "RPR_TAKEFX_GETPRESETINDEX_WR python": {
        "prefix": "WR_RPR_TakeFX_GetPresetIndex",
        "scope": "python",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TakeFX_SetPresetByIndex\n",
        "body": "${1:Int retval},${2:MediaItem_Take take},${3:Int fx},${4:Int numberOfPresetsOut} = RPR_TakeFX_GetPresetIndex(${5:take},${6:fx},${7:numberOfPresetsOut})$0"
    },
    "TAKEFX_GETUSERPRESETFILENAME_WR c": {
        "prefix": "WR_TakeFX_GetUserPresetFilename",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = TakeFX_GetUserPresetFilename(${2:MediaItem_Take* take},${3:int fx},${4:char* fn},${5:int fn_sz})$0"
    },
    "REAPER.TAKEFX_GETUSERPRESETFILENAME_WR lua": {
        "prefix": "reaperwr.TakeFX_GetUserPresetFilename",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string fn} = reaper.TakeFX_GetUserPresetFilename(${3:MediaItem_Take take},${4:integer fx},${5:string fn})$0"
    },
    "RPR_TAKEFX_GETUSERPRESETFILENAME_WR python": {
        "prefix": "WR_RPR_TakeFX_GetUserPresetFilename",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaItem_Take take},${2:Int fx},${3:String fn},${4:Int fn_sz} = RPR_TakeFX_GetUserPresetFilename(${5:take},${6:fx},${7:fn},${8:fn_sz})$0"
    },
    "TAKEFX_NAVIGATEPRESETS_WR c": {
        "prefix": "WR_TakeFX_NavigatePresets",
        "scope": "c",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:bool} = TakeFX_NavigatePresets(${2:MediaItem_Take* take},${3:int fx},${4:int presetmove})$0"
    },
    "TAKEFX_NAVIGATEPRESETS_WR eel2": {
        "prefix": "WR_TakeFX_NavigatePresets",
        "scope": "eel2",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:bool} = TakeFX_NavigatePresets(${2:MediaItem_Take take},${3:int fx},${4:int presetmove})$0"
    },
    "REAPER.TAKEFX_NAVIGATEPRESETS_WR lua": {
        "prefix": "reaperwr.TakeFX_NavigatePresets",
        "scope": "lua",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_NavigatePresets(${3:MediaItem_Take take},${4:integer fx},${5:integer presetmove})$0"
    },
    "RPR_TAKEFX_NAVIGATEPRESETS_WR python": {
        "prefix": "WR_RPR_TakeFX_NavigatePresets",
        "scope": "python",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:Boolean} = RPR_TakeFX_NavigatePresets(${2:MediaItem_Take take},${3:Int fx},${4:Int presetmove})$0"
    },
    "TAKEFX_SETENABLED_WR c": {
        "prefix": "WR_TakeFX_SetEnabled",
        "scope": "c",
        "description": "See TakeFX_GetEnabled\n",
        "body": "${1:void} = TakeFX_SetEnabled(${2:MediaItem_Take* take},${3:int fx},${4:bool enabled})$0"
    },
    "TAKEFX_SETNAMEDCONFIGPARM_WR c": {
        "prefix": "WR_TakeFX_SetNamedConfigParm",
        "scope": "c",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:bool} = TakeFX_SetNamedConfigParm(${2:MediaItem_Take* take},${3:int fx},${4:const char* parmname},${5:const char* value})$0"
    },
    "TAKEFX_SETNAMEDCONFIGPARM_WR eel2": {
        "prefix": "WR_TakeFX_SetNamedConfigParm",
        "scope": "eel2",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:bool} = TakeFX_SetNamedConfigParm(${2:MediaItem_Take take},${3:int fx},${4:\"parmname\"},${5:\"value\"})$0"
    },
    "REAPER.TAKEFX_SETNAMEDCONFIGPARM_WR lua": {
        "prefix": "reaperwr.TakeFX_SetNamedConfigParm",
        "scope": "lua",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_SetNamedConfigParm(${3:MediaItem_Take take},${4:integer fx},${5:string parmname},${6:string value})$0"
    },
    "RPR_TAKEFX_SETNAMEDCONFIGPARM_WR python": {
        "prefix": "WR_RPR_TakeFX_SetNamedConfigParm",
        "scope": "python",
        "description": "gets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:Boolean} = RPR_TakeFX_SetNamedConfigParm(${2:MediaItem_Take take},${3:Int fx},${4:String parmname},${5:String value})$0"
    },
    "TAKEFX_SETOFFLINE_WR c": {
        "prefix": "WR_TakeFX_SetOffline",
        "scope": "c",
        "description": "See TakeFX_GetOffline\n",
        "body": "${1:void} = TakeFX_SetOffline(${2:MediaItem_Take* take},${3:int fx},${4:bool offline})$0"
    },
    "TAKEFX_SETOPEN_WR c": {
        "prefix": "WR_TakeFX_SetOpen",
        "scope": "c",
        "description": "Open this FX UI. See TakeFX_GetOpen\n",
        "body": "${1:void} = TakeFX_SetOpen(${2:MediaItem_Take* take},${3:int fx},${4:bool open})$0"
    },
    "TAKEFX_SETPARAM_WR c": {
        "prefix": "WR_TakeFX_SetParam",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TakeFX_SetParam(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:double val})$0"
    },
    "TAKEFX_SETPARAM_WR eel2": {
        "prefix": "WR_TakeFX_SetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_SetParam(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:val})$0"
    },
    "REAPER.TAKEFX_SETPARAM_WR lua": {
        "prefix": "reaperwr.TakeFX_SetParam",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_SetParam(${3:MediaItem_Take take},${4:integer fx},${5:integer param},${6:number val})$0"
    },
    "RPR_TAKEFX_SETPARAM_WR python": {
        "prefix": "WR_RPR_TakeFX_SetParam",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_TakeFX_SetParam(${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:Float val})$0"
    },
    "TAKEFX_SETPARAMNORMALIZED_WR c": {
        "prefix": "WR_TakeFX_SetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TakeFX_SetParamNormalized(${2:MediaItem_Take* take},${3:int fx},${4:int param},${5:double value})$0"
    },
    "TAKEFX_SETPARAMNORMALIZED_WR eel2": {
        "prefix": "WR_TakeFX_SetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TakeFX_SetParamNormalized(${2:MediaItem_Take take},${3:int fx},${4:int param},${5:value})$0"
    },
    "REAPER.TAKEFX_SETPARAMNORMALIZED_WR lua": {
        "prefix": "reaperwr.TakeFX_SetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_SetParamNormalized(${3:MediaItem_Take take},${4:integer fx},${5:integer param},${6:number value})$0"
    },
    "RPR_TAKEFX_SETPARAMNORMALIZED_WR python": {
        "prefix": "WR_RPR_TakeFX_SetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_TakeFX_SetParamNormalized(${2:MediaItem_Take take},${3:Int fx},${4:Int param},${5:Float value})$0"
    },
    "TAKEFX_SETPINMAPPINGS_WR c": {
        "prefix": "WR_TakeFX_SetPinMappings",
        "scope": "c",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:bool} = TakeFX_SetPinMappings(${2:MediaItem_Take* tr},${3:int fx},${4:int isoutput},${5:int pin},${6:int low32bits},${7:int hi32bits})$0"
    },
    "TAKEFX_SETPINMAPPINGS_WR eel2": {
        "prefix": "WR_TakeFX_SetPinMappings",
        "scope": "eel2",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:bool} = TakeFX_SetPinMappings(${2:MediaItem_Take tr},${3:int fx},${4:int isoutput},${5:int pin},${6:int low32bits},${7:int hi32bits})$0"
    },
    "REAPER.TAKEFX_SETPINMAPPINGS_WR lua": {
        "prefix": "reaperwr.TakeFX_SetPinMappings",
        "scope": "lua",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_SetPinMappings(${3:MediaItem_Take tr},${4:integer fx},${5:integer isoutput},${6:integer pin},${7:integer low32bits},${8:integer hi32bits})$0"
    },
    "RPR_TAKEFX_SETPINMAPPINGS_WR python": {
        "prefix": "WR_RPR_TakeFX_SetPinMappings",
        "scope": "python",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:Boolean} = RPR_TakeFX_SetPinMappings(${2:MediaItem_Take tr},${3:Int fx},${4:Int isoutput},${5:Int pin},${6:Int low32bits},${7:Int hi32bits})$0"
    },
    "TAKEFX_SETPRESET_WR c": {
        "prefix": "WR_TakeFX_SetPreset",
        "scope": "c",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "${1:bool} = TakeFX_SetPreset(${2:MediaItem_Take* take},${3:int fx},${4:const char* presetname})$0"
    },
    "TAKEFX_SETPRESET_WR eel2": {
        "prefix": "WR_TakeFX_SetPreset",
        "scope": "eel2",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "${1:bool} = TakeFX_SetPreset(${2:MediaItem_Take take},${3:int fx},${4:\"presetname\"})$0"
    },
    "REAPER.TAKEFX_SETPRESET_WR lua": {
        "prefix": "reaperwr.TakeFX_SetPreset",
        "scope": "lua",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_SetPreset(${3:MediaItem_Take take},${4:integer fx},${5:string presetname})$0"
    },
    "RPR_TAKEFX_SETPRESET_WR python": {
        "prefix": "WR_RPR_TakeFX_SetPreset",
        "scope": "python",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TakeFX_GetPreset.\n",
        "body": "${1:Boolean} = RPR_TakeFX_SetPreset(${2:MediaItem_Take take},${3:Int fx},${4:String presetname})$0"
    },
    "TAKEFX_SETPRESETBYINDEX_WR c": {
        "prefix": "WR_TakeFX_SetPresetByIndex",
        "scope": "c",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "${1:bool} = TakeFX_SetPresetByIndex(${2:MediaItem_Take* take},${3:int fx},${4:int idx})$0"
    },
    "TAKEFX_SETPRESETBYINDEX_WR eel2": {
        "prefix": "WR_TakeFX_SetPresetByIndex",
        "scope": "eel2",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "${1:bool} = TakeFX_SetPresetByIndex(${2:MediaItem_Take take},${3:int fx},${4:int idx})$0"
    },
    "REAPER.TAKEFX_SETPRESETBYINDEX_WR lua": {
        "prefix": "reaperwr.TakeFX_SetPresetByIndex",
        "scope": "lua",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "${1:local }${2:boolean} = reaper.TakeFX_SetPresetByIndex(${3:MediaItem_Take take},${4:integer fx},${5:integer idx})$0"
    },
    "RPR_TAKEFX_SETPRESETBYINDEX_WR python": {
        "prefix": "WR_RPR_TakeFX_SetPresetByIndex",
        "scope": "python",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TakeFX_GetPresetIndex.\n",
        "body": "${1:Boolean} = RPR_TakeFX_SetPresetByIndex(${2:MediaItem_Take take},${3:Int fx},${4:Int idx})$0"
    },
    "TAKEFX_SHOW_WR c": {
        "prefix": "WR_TakeFX_Show",
        "scope": "c",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "${1:void} = TakeFX_Show(${2:MediaItem_Take* take},${3:int index},${4:int showFlag})$0"
    },
    "TAKEISMIDI_WR c": {
        "prefix": "WR_TakeIsMIDI",
        "scope": "c",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "${1:bool} = TakeIsMIDI(${2:MediaItem_Take* take})$0"
    },
    "TAKEISMIDI_WR eel2": {
        "prefix": "WR_TakeIsMIDI",
        "scope": "eel2",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "${1:bool} = TakeIsMIDI(${2:MediaItem_Take take})$0"
    },
    "REAPER.TAKEISMIDI_WR lua": {
        "prefix": "reaperwr.TakeIsMIDI",
        "scope": "lua",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "${1:local }${2:boolean} = reaper.TakeIsMIDI(${3:MediaItem_Take take})$0"
    },
    "RPR_TAKEISMIDI_WR python": {
        "prefix": "WR_RPR_TakeIsMIDI",
        "scope": "python",
        "description": "Returns true if the active take contains MIDI.\n",
        "body": "${1:Boolean} = RPR_TakeIsMIDI(${2:MediaItem_Take take})$0"
    },
    "THEMELAYOUT_GETLAYOUT_WR c": {
        "prefix": "WR_ThemeLayout_GetLayout",
        "scope": "c",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "${1:bool} = ThemeLayout_GetLayout(${2:const char* section},${3:int idx},${4:char* nameOut},${5:int nameOut_sz})$0"
    },
    "THEMELAYOUT_GETLAYOUT_WR eel2": {
        "prefix": "WR_ThemeLayout_GetLayout",
        "scope": "eel2",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "${1:bool} = ThemeLayout_GetLayout(${2:\"section\"},${3:int idx},${4:#name})$0"
    },
    "REAPER.THEMELAYOUT_GETLAYOUT_WR lua": {
        "prefix": "reaperwr.ThemeLayout_GetLayout",
        "scope": "lua",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "${1:local }${2:boolean retval},${3:string name} = reaper.ThemeLayout_GetLayout(${4:string section},${5:integer idx})$0"
    },
    "RPR_THEMELAYOUT_GETLAYOUT_WR python": {
        "prefix": "WR_RPR_ThemeLayout_GetLayout",
        "scope": "python",
        "description": "Gets theme layout information. section can be 'global' for global layout\noverride, 'seclist' to enumerate a list of layout sections, otherwise a\nlayout section such as 'mcp', 'tcp', 'trans', etc. idx can be -1 to\nquery the current value, -2 to get the description of the section (if\nnot global), -3 will return the current context DPI-scaling (256=normal,\n512=retina, etc), or 0..x. returns false if failed.\n",
        "body": "${1:Boolean retval},${2:String section},${3:Int idx},${4:String nameOut},${5:Int nameOut_sz} = RPR_ThemeLayout_GetLayout(${6:section},${7:idx},${8:nameOut},${9:nameOut_sz})$0"
    },
    "THEMELAYOUT_GETPARAMETER_WR c": {
        "prefix": "WR_ThemeLayout_GetParameter",
        "scope": "c",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "${1:const char*} = ThemeLayout_GetParameter(${2:int wp},${3:const char** descOutOptional},${4:int* valueOutOptional},${5:int* defValueOutOptional},${6:int* minValueOutOptional},${7:int* maxValueOutOptional})$0"
    },
    "THEMELAYOUT_GETPARAMETER_WR eel2": {
        "prefix": "WR_ThemeLayout_GetParameter",
        "scope": "eel2",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "${1:bool} = ThemeLayout_GetParameter(${2:#retval},${3:int wp},${4:optional #desc},${5:optional int &value},${6:optional int &defValue},${7:optional int &minValue},${8:optional int &maxValue})$0"
    },
    "REAPER.THEMELAYOUT_GETPARAMETER_WR lua": {
        "prefix": "reaperwr.ThemeLayout_GetParameter",
        "scope": "lua",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "${1:local }${2:string retval},${3:optional string desc},${4:optional number value},${5:optional number defValue},${6:optional number minValue},${7:optional number maxValue} = reaper.ThemeLayout_GetParameter(${8:integer wp})$0"
    },
    "RPR_THEMELAYOUT_GETPARAMETER_WR python": {
        "prefix": "WR_RPR_ThemeLayout_GetParameter",
        "scope": "python",
        "description": "returns theme layout parameter. return value is cfg-name, or nil/empty if out of range.\n",
        "body": "${1:String retval},${2:Int wp},${3:String descOutOptional},${4:Int valueOutOptional},${5:Int defValueOutOptional},${6:Int minValueOutOptional},${7:Int maxValueOutOptional} = RPR_ThemeLayout_GetParameter(${8:wp},${9:descOutOptional},${10:valueOutOptional},${11:defValueOutOptional},${12:minValueOutOptional},${13:maxValueOutOptional})$0"
    },
    "THEMELAYOUT_REFRESHALL_WR c": {
        "prefix": "WR_ThemeLayout_RefreshAll",
        "scope": "c",
        "description": "Refreshes all layouts\n",
        "body": "${1:void} = ThemeLayout_RefreshAll()$0"
    },
    "THEMELAYOUT_SETLAYOUT_WR c": {
        "prefix": "WR_ThemeLayout_SetLayout",
        "scope": "c",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "${1:bool} = ThemeLayout_SetLayout(${2:const char* section},${3:const char*  layout})$0"
    },
    "THEMELAYOUT_SETLAYOUT_WR eel2": {
        "prefix": "WR_ThemeLayout_SetLayout",
        "scope": "eel2",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "${1:bool} = ThemeLayout_SetLayout(${2:\"section\"},${3:\" layout\"})$0"
    },
    "REAPER.THEMELAYOUT_SETLAYOUT_WR lua": {
        "prefix": "reaperwr.ThemeLayout_SetLayout",
        "scope": "lua",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "${1:local }${2:boolean} = reaper.ThemeLayout_SetLayout(${3:string section},${4:string  layout})$0"
    },
    "RPR_THEMELAYOUT_SETLAYOUT_WR python": {
        "prefix": "WR_RPR_ThemeLayout_SetLayout",
        "scope": "python",
        "description": "Sets theme layout override for a particular section -- section can be\n'global' or 'mcp' etc. If setting global layout, prefix a ! to the\nlayout string to clear any per-layout overrides. Returns false if\nfailed.\n",
        "body": "${1:Boolean} = RPR_ThemeLayout_SetLayout(${2:String section},${3:String  layout})$0"
    },
    "THEMELAYOUT_SETPARAMETER_WR c": {
        "prefix": "WR_ThemeLayout_SetParameter",
        "scope": "c",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "${1:bool} = ThemeLayout_SetParameter(${2:int wp},${3:int value},${4:bool persist})$0"
    },
    "THEMELAYOUT_SETPARAMETER_WR eel2": {
        "prefix": "WR_ThemeLayout_SetParameter",
        "scope": "eel2",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "${1:bool} = ThemeLayout_SetParameter(${2:int wp},${3:int value},${4:bool persist})$0"
    },
    "REAPER.THEMELAYOUT_SETPARAMETER_WR lua": {
        "prefix": "reaperwr.ThemeLayout_SetParameter",
        "scope": "lua",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "${1:local }${2:boolean} = reaper.ThemeLayout_SetParameter(${3:integer wp},${4:integer value},${5:boolean persist})$0"
    },
    "RPR_THEMELAYOUT_SETPARAMETER_WR python": {
        "prefix": "WR_RPR_ThemeLayout_SetParameter",
        "scope": "python",
        "description": "sets theme layout parameter to value. persist=true in order to have\nchange loaded on next theme load. note that the caller should update\nlayouts via ??? to make changes visible.\n",
        "body": "${1:Boolean} = RPR_ThemeLayout_SetParameter(${2:Int wp},${3:Int value},${4:Boolean persist})$0"
    },
    "TIME_PRECISE_WR c": {
        "prefix": "WR_time_precise",
        "scope": "c",
        "description": "Gets a precise system timestamp in seconds\n",
        "body": "${1:double} = time_precise()$0"
    },
    "REAPER.TIME_PRECISE_WR lua": {
        "prefix": "reaperwr.time_precise",
        "scope": "lua",
        "description": "Gets a precise system timestamp in seconds\n",
        "body": "${1:local }${2:number} = reaper.time_precise()$0"
    },
    "RPR_TIME_PRECISE_WR python": {
        "prefix": "WR_RPR_time_precise",
        "scope": "python",
        "description": "Gets a precise system timestamp in seconds\n",
        "body": "${1:Float} = RPR_time_precise()$0"
    },
    "TIMEMAP2_BEATSTOTIME_WR c": {
        "prefix": "WR_TimeMap2_beatsToTime",
        "scope": "c",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "${1:double} = TimeMap2_beatsToTime(${2:ReaProject* proj},${3:double tpos},${4:const int* measuresInOptional})$0"
    },
    "TIMEMAP2_BEATSTOTIME_WR eel2": {
        "prefix": "WR_TimeMap2_beatsToTime",
        "scope": "eel2",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "${1:double} = TimeMap2_beatsToTime(${2:ReaProject proj},${3:tpos},${4:optional int measuresIn})$0"
    },
    "REAPER.TIMEMAP2_BEATSTOTIME_WR lua": {
        "prefix": "reaperwr.TimeMap2_beatsToTime",
        "scope": "lua",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "${1:local }${2:number} = reaper.TimeMap2_beatsToTime(${3:ReaProject proj},${4:number tpos},${5:optional number measuresIn})$0"
    },
    "RPR_TIMEMAP2_BEATSTOTIME_WR python": {
        "prefix": "WR_RPR_TimeMap2_beatsToTime",
        "scope": "python",
        "description": "convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.\n",
        "body": "${1:Float} = RPR_TimeMap2_beatsToTime(${2:ReaProject proj},${3:Float tpos},${4:const int measuresInOptional})$0"
    },
    "TIMEMAP2_GETDIVIDEDBPMATTIME_WR c": {
        "prefix": "WR_TimeMap2_GetDividedBpmAtTime",
        "scope": "c",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:double} = TimeMap2_GetDividedBpmAtTime(${2:ReaProject* proj},${3:double time})$0"
    },
    "TIMEMAP2_GETDIVIDEDBPMATTIME_WR eel2": {
        "prefix": "WR_TimeMap2_GetDividedBpmAtTime",
        "scope": "eel2",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:double} = TimeMap2_GetDividedBpmAtTime(${2:ReaProject proj},${3:time})$0"
    },
    "REAPER.TIMEMAP2_GETDIVIDEDBPMATTIME_WR lua": {
        "prefix": "reaperwr.TimeMap2_GetDividedBpmAtTime",
        "scope": "lua",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:local }${2:number} = reaper.TimeMap2_GetDividedBpmAtTime(${3:ReaProject proj},${4:number time})$0"
    },
    "RPR_TIMEMAP2_GETDIVIDEDBPMATTIME_WR python": {
        "prefix": "WR_RPR_TimeMap2_GetDividedBpmAtTime",
        "scope": "python",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:Float} = RPR_TimeMap2_GetDividedBpmAtTime(${2:ReaProject proj},${3:Float time})$0"
    },
    "TIMEMAP2_GETNEXTCHANGETIME_WR c": {
        "prefix": "WR_TimeMap2_GetNextChangeTime",
        "scope": "c",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "${1:double} = TimeMap2_GetNextChangeTime(${2:ReaProject* proj},${3:double time})$0"
    },
    "TIMEMAP2_GETNEXTCHANGETIME_WR eel2": {
        "prefix": "WR_TimeMap2_GetNextChangeTime",
        "scope": "eel2",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "${1:double} = TimeMap2_GetNextChangeTime(${2:ReaProject proj},${3:time})$0"
    },
    "REAPER.TIMEMAP2_GETNEXTCHANGETIME_WR lua": {
        "prefix": "reaperwr.TimeMap2_GetNextChangeTime",
        "scope": "lua",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "${1:local }${2:number} = reaper.TimeMap2_GetNextChangeTime(${3:ReaProject proj},${4:number time})$0"
    },
    "RPR_TIMEMAP2_GETNEXTCHANGETIME_WR python": {
        "prefix": "WR_RPR_TimeMap2_GetNextChangeTime",
        "scope": "python",
        "description": "when does the next time map (tempo or time sig) change occur\n",
        "body": "${1:Float} = RPR_TimeMap2_GetNextChangeTime(${2:ReaProject proj},${3:Float time})$0"
    },
    "TIMEMAP2_QNTOTIME_WR c": {
        "prefix": "WR_TimeMap2_QNToTime",
        "scope": "c",
        "description": "converts project QN position to time.\n",
        "body": "${1:double} = TimeMap2_QNToTime(${2:ReaProject* proj},${3:double qn})$0"
    },
    "TIMEMAP2_QNTOTIME_WR eel2": {
        "prefix": "WR_TimeMap2_QNToTime",
        "scope": "eel2",
        "description": "converts project QN position to time.\n",
        "body": "${1:double} = TimeMap2_QNToTime(${2:ReaProject proj},${3:qn})$0"
    },
    "REAPER.TIMEMAP2_QNTOTIME_WR lua": {
        "prefix": "reaperwr.TimeMap2_QNToTime",
        "scope": "lua",
        "description": "converts project QN position to time.\n",
        "body": "${1:local }${2:number} = reaper.TimeMap2_QNToTime(${3:ReaProject proj},${4:number qn})$0"
    },
    "RPR_TIMEMAP2_QNTOTIME_WR python": {
        "prefix": "WR_RPR_TimeMap2_QNToTime",
        "scope": "python",
        "description": "converts project QN position to time.\n",
        "body": "${1:Float} = RPR_TimeMap2_QNToTime(${2:ReaProject proj},${3:Float qn})$0"
    },
    "TIMEMAP2_TIMETOBEATS_WR c": {
        "prefix": "WR_TimeMap2_timeToBeats",
        "scope": "c",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "${1:double} = TimeMap2_timeToBeats(${2:ReaProject* proj},${3:double tpos},${4:int* measuresOutOptional},${5:int* cmlOutOptional},${6:double* fullbeatsOutOptional},${7:int* cdenomOutOptional})$0"
    },
    "TIMEMAP2_TIMETOBEATS_WR eel2": {
        "prefix": "WR_TimeMap2_timeToBeats",
        "scope": "eel2",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "${1:double} = TimeMap2_timeToBeats(${2:ReaProject proj},${3:tpos},${4:optional int &measures},${5:optional int &cml},${6:optional &fullbeats},${7:optional int &cdenom})$0"
    },
    "REAPER.TIMEMAP2_TIMETOBEATS_WR lua": {
        "prefix": "reaperwr.TimeMap2_timeToBeats",
        "scope": "lua",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "${1:local }${2:number retval},${3:optional number measures},${4:optional number cml},${5:optional number fullbeats},${6:optional number cdenom} = reaper.TimeMap2_timeToBeats(${7:ReaProject proj},${8:number tpos})$0"
    },
    "RPR_TIMEMAP2_TIMETOBEATS_WR python": {
        "prefix": "WR_RPR_TimeMap2_timeToBeats",
        "scope": "python",
        "description": "convert a time into beats.\nif measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.\nif cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)\nif fullbeats is non-NULL, and measures is non-NULL, fullbeats will get\nthe full beat count (same value returned if measures is NULL).\nif cdenom is non-NULL, will be set to the current time signature denominator.\n",
        "body": "${1:Float retval},${2:ReaProject proj},${3:Float tpos},${4:Int measuresOutOptional},${5:Int cmlOutOptional},${6:Float fullbeatsOutOptional},${7:Int cdenomOutOptional} = RPR_TimeMap2_timeToBeats(${8:proj},${9:tpos},${10:measuresOutOptional},${11:cmlOutOptional},${12:fullbeatsOutOptional},${13:cdenomOutOptional})$0"
    },
    "TIMEMAP2_TIMETOQN_WR c": {
        "prefix": "WR_TimeMap2_timeToQN",
        "scope": "c",
        "description": "converts project time position to QN position.\n",
        "body": "${1:double} = TimeMap2_timeToQN(${2:ReaProject* proj},${3:double tpos})$0"
    },
    "TIMEMAP2_TIMETOQN_WR eel2": {
        "prefix": "WR_TimeMap2_timeToQN",
        "scope": "eel2",
        "description": "converts project time position to QN position.\n",
        "body": "${1:double} = TimeMap2_timeToQN(${2:ReaProject proj},${3:tpos})$0"
    },
    "REAPER.TIMEMAP2_TIMETOQN_WR lua": {
        "prefix": "reaperwr.TimeMap2_timeToQN",
        "scope": "lua",
        "description": "converts project time position to QN position.\n",
        "body": "${1:local }${2:number} = reaper.TimeMap2_timeToQN(${3:ReaProject proj},${4:number tpos})$0"
    },
    "RPR_TIMEMAP2_TIMETOQN_WR python": {
        "prefix": "WR_RPR_TimeMap2_timeToQN",
        "scope": "python",
        "description": "converts project time position to QN position.\n",
        "body": "${1:Float} = RPR_TimeMap2_timeToQN(${2:ReaProject proj},${3:Float tpos})$0"
    },
    "TIMEMAP_CURFRAMERATE_WR c": {
        "prefix": "WR_TimeMap_curFrameRate",
        "scope": "c",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "${1:double} = TimeMap_curFrameRate(${2:ReaProject* proj},${3:bool* dropFrameOutOptional})$0"
    },
    "TIMEMAP_CURFRAMERATE_WR eel2": {
        "prefix": "WR_TimeMap_curFrameRate",
        "scope": "eel2",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "${1:double} = TimeMap_curFrameRate(${2:ReaProject proj},${3:optional bool &dropFrame})$0"
    },
    "REAPER.TIMEMAP_CURFRAMERATE_WR lua": {
        "prefix": "reaperwr.TimeMap_curFrameRate",
        "scope": "lua",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "${1:local }${2:number retval},${3:optional boolean dropFrame} = reaper.TimeMap_curFrameRate(${4:ReaProject proj})$0"
    },
    "RPR_TIMEMAP_CURFRAMERATE_WR python": {
        "prefix": "WR_RPR_TimeMap_curFrameRate",
        "scope": "python",
        "description": "Gets project framerate, and optionally whether it is drop-frame timecode\n",
        "body": "${1:Float retval},${2:ReaProject proj},${3:Boolean dropFrameOutOptional} = RPR_TimeMap_curFrameRate(${4:proj},${5:dropFrameOutOptional})$0"
    },
    "TIMEMAP_GETDIVIDEDBPMATTIME_WR c": {
        "prefix": "WR_TimeMap_GetDividedBpmAtTime",
        "scope": "c",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:double} = TimeMap_GetDividedBpmAtTime(${2:double time})$0"
    },
    "TIMEMAP_GETDIVIDEDBPMATTIME_WR eel2": {
        "prefix": "WR_TimeMap_GetDividedBpmAtTime",
        "scope": "eel2",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:double} = TimeMap_GetDividedBpmAtTime(${2:time})$0"
    },
    "REAPER.TIMEMAP_GETDIVIDEDBPMATTIME_WR lua": {
        "prefix": "reaperwr.TimeMap_GetDividedBpmAtTime",
        "scope": "lua",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:local }${2:number} = reaper.TimeMap_GetDividedBpmAtTime(${3:number time})$0"
    },
    "RPR_TIMEMAP_GETDIVIDEDBPMATTIME_WR python": {
        "prefix": "WR_RPR_TimeMap_GetDividedBpmAtTime",
        "scope": "python",
        "description": "get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)\n",
        "body": "${1:Float} = RPR_TimeMap_GetDividedBpmAtTime(${2:Float time})$0"
    },
    "TIMEMAP_GETMEASUREINFO_WR c": {
        "prefix": "WR_TimeMap_GetMeasureInfo",
        "scope": "c",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "${1:double} = TimeMap_GetMeasureInfo(${2:ReaProject* proj},${3:int measure},${4:double* qn_startOut},${5:double* qn_endOut},${6:int* timesig_numOut},${7:int* timesig_denomOut},${8:double* tempoOut})$0"
    },
    "TIMEMAP_GETMEASUREINFO_WR eel2": {
        "prefix": "WR_TimeMap_GetMeasureInfo",
        "scope": "eel2",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "${1:double} = TimeMap_GetMeasureInfo(${2:ReaProject proj},${3:int measure},${4:&qn_start},${5:&qn_end},${6:int &timesig_num},${7:int &timesig_denom},${8:&tempo})$0"
    },
    "REAPER.TIMEMAP_GETMEASUREINFO_WR lua": {
        "prefix": "reaperwr.TimeMap_GetMeasureInfo",
        "scope": "lua",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "${1:local }${2:number retval},${3:number qn_start},${4:number qn_end},${5:number timesig_num},${6:number timesig_denom},${7:number tempo} = reaper.TimeMap_GetMeasureInfo(${8:ReaProject proj},${9:integer measure})$0"
    },
    "RPR_TIMEMAP_GETMEASUREINFO_WR python": {
        "prefix": "WR_RPR_TimeMap_GetMeasureInfo",
        "scope": "python",
        "description": "Get the QN position and time signature information for the start of a measure. Return the time in seconds of the measure start.\n",
        "body": "${1:Float retval},${2:ReaProject proj},${3:Int measure},${4:Float qn_startOut},${5:Float qn_endOut},${6:Int timesig_numOut},${7:Int timesig_denomOut},${8:Float tempoOut} = RPR_TimeMap_GetMeasureInfo(${9:proj},${10:measure},${11:qn_startOut},${12:qn_endOut},${13:timesig_numOut},${14:timesig_denomOut},${15:tempoOut})$0"
    },
    "TIMEMAP_GETMETRONOMEPATTERN_WR c": {
        "prefix": "WR_TimeMap_GetMetronomePattern",
        "scope": "c",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "${1:int} = TimeMap_GetMetronomePattern(${2:ReaProject* proj},${3:double time},${4:char* pattern},${5:int pattern_sz})$0"
    },
    "TIMEMAP_GETMETRONOMEPATTERN_WR eel2": {
        "prefix": "WR_TimeMap_GetMetronomePattern",
        "scope": "eel2",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "${1:int} = TimeMap_GetMetronomePattern(${2:ReaProject proj},${3:time},${4:#pattern})$0"
    },
    "REAPER.TIMEMAP_GETMETRONOMEPATTERN_WR lua": {
        "prefix": "reaperwr.TimeMap_GetMetronomePattern",
        "scope": "lua",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "${1:local }${2:integer retval},${3:string pattern} = reaper.TimeMap_GetMetronomePattern(${4:ReaProject proj},${5:number time},${6:string pattern})$0"
    },
    "RPR_TIMEMAP_GETMETRONOMEPATTERN_WR python": {
        "prefix": "WR_RPR_TimeMap_GetMetronomePattern",
        "scope": "python",
        "description": "Fills in a string representing the active metronome pattern. For\nexample, in a 7/8 measure divided 3+4, the pattern might be \"1221222\".\nThe length of the string is the time signature numerator, and the\nfunction returns the time signature denominator.\n",
        "body": "${1:Int retval},${2:ReaProject proj},${3:Float time},${4:String pattern},${5:Int pattern_sz} = RPR_TimeMap_GetMetronomePattern(${6:proj},${7:time},${8:pattern},${9:pattern_sz})$0"
    },
    "TIMEMAP_GETTIMESIGATTIME_WR c": {
        "prefix": "WR_TimeMap_GetTimeSigAtTime",
        "scope": "c",
        "description": "get the effective time signature and tempo\n",
        "body": "${1:void} = TimeMap_GetTimeSigAtTime(${2:ReaProject* proj},${3:double time},${4:int* timesig_numOut},${5:int* timesig_denomOut},${6:double* tempoOut})$0"
    },
    "REAPER.TIMEMAP_GETTIMESIGATTIME_WR lua": {
        "prefix": "reaperwr.TimeMap_GetTimeSigAtTime",
        "scope": "lua",
        "description": "get the effective time signature and tempo\n",
        "body": "${1:local }${2:number timesig_num},${3:number timesig_denom},${4:number tempo} = reaper.TimeMap_GetTimeSigAtTime(${5:ReaProject proj},${6:number time})$0"
    },
    "RPR_TIMEMAP_GETTIMESIGATTIME_WR python": {
        "prefix": "WR_RPR_TimeMap_GetTimeSigAtTime",
        "scope": "python",
        "description": "get the effective time signature and tempo\n",
        "body": "${1:ReaProject proj},${2:Float time},${3:Int timesig_numOut},${4:Int timesig_denomOut},${5:Float tempoOut} = RPR_TimeMap_GetTimeSigAtTime(${6:proj},${7:time},${8:timesig_numOut},${9:timesig_denomOut},${10:tempoOut})$0"
    },
    "TIMEMAP_QNTOMEASURES_WR c": {
        "prefix": "WR_TimeMap_QNToMeasures",
        "scope": "c",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "${1:int} = TimeMap_QNToMeasures(${2:ReaProject* proj},${3:double qn},${4:double* qnMeasureStartOutOptional},${5:double* qnMeasureEndOutOptional})$0"
    },
    "TIMEMAP_QNTOMEASURES_WR eel2": {
        "prefix": "WR_TimeMap_QNToMeasures",
        "scope": "eel2",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "${1:int} = TimeMap_QNToMeasures(${2:ReaProject proj},${3:qn},${4:optional &qnMeasureStart},${5:optional &qnMeasureEnd})$0"
    },
    "REAPER.TIMEMAP_QNTOMEASURES_WR lua": {
        "prefix": "reaperwr.TimeMap_QNToMeasures",
        "scope": "lua",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "${1:local }${2:integer retval},${3:optional number qnMeasureStart},${4:optional number qnMeasureEnd} = reaper.TimeMap_QNToMeasures(${5:ReaProject proj},${6:number qn})$0"
    },
    "RPR_TIMEMAP_QNTOMEASURES_WR python": {
        "prefix": "WR_RPR_TimeMap_QNToMeasures",
        "scope": "python",
        "description": "Find which measure the given QN position falls in.\n",
        "body": "${1:Int retval},${2:ReaProject proj},${3:Float qn},${4:Float qnMeasureStartOutOptional},${5:Float qnMeasureEndOutOptional} = RPR_TimeMap_QNToMeasures(${6:proj},${7:qn},${8:qnMeasureStartOutOptional},${9:qnMeasureEndOutOptional})$0"
    },
    "TIMEMAP_QNTOTIME_WR c": {
        "prefix": "WR_TimeMap_QNToTime",
        "scope": "c",
        "description": "converts project QN position to time.\n",
        "body": "${1:double} = TimeMap_QNToTime(${2:double qn})$0"
    },
    "TIMEMAP_QNTOTIME_WR eel2": {
        "prefix": "WR_TimeMap_QNToTime",
        "scope": "eel2",
        "description": "converts project QN position to time.\n",
        "body": "${1:double} = TimeMap_QNToTime(${2:qn})$0"
    },
    "REAPER.TIMEMAP_QNTOTIME_WR lua": {
        "prefix": "reaperwr.TimeMap_QNToTime",
        "scope": "lua",
        "description": "converts project QN position to time.\n",
        "body": "${1:local }${2:number} = reaper.TimeMap_QNToTime(${3:number qn})$0"
    },
    "RPR_TIMEMAP_QNTOTIME_WR python": {
        "prefix": "WR_RPR_TimeMap_QNToTime",
        "scope": "python",
        "description": "converts project QN position to time.\n",
        "body": "${1:Float} = RPR_TimeMap_QNToTime(${2:Float qn})$0"
    },
    "TIMEMAP_QNTOTIME_ABS_WR c": {
        "prefix": "WR_TimeMap_QNToTime_abs",
        "scope": "c",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "${1:double} = TimeMap_QNToTime_abs(${2:ReaProject* proj},${3:double qn})$0"
    },
    "TIMEMAP_QNTOTIME_ABS_WR eel2": {
        "prefix": "WR_TimeMap_QNToTime_abs",
        "scope": "eel2",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "${1:double} = TimeMap_QNToTime_abs(${2:ReaProject proj},${3:qn})$0"
    },
    "REAPER.TIMEMAP_QNTOTIME_ABS_WR lua": {
        "prefix": "reaperwr.TimeMap_QNToTime_abs",
        "scope": "lua",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "${1:local }${2:number} = reaper.TimeMap_QNToTime_abs(${3:ReaProject proj},${4:number qn})$0"
    },
    "RPR_TIMEMAP_QNTOTIME_ABS_WR python": {
        "prefix": "WR_RPR_TimeMap_QNToTime_abs",
        "scope": "python",
        "description": "Converts project quarter note count (QN) to time. QN is counted from the\nstart of the project, regardless of any partial measures. See TimeMap2_QNToTime\n",
        "body": "${1:Float} = RPR_TimeMap_QNToTime_abs(${2:ReaProject proj},${3:Float qn})$0"
    },
    "TIMEMAP_TIMETOQN_WR c": {
        "prefix": "WR_TimeMap_timeToQN",
        "scope": "c",
        "description": "converts project QN position to time.\n",
        "body": "${1:double} = TimeMap_timeToQN(${2:double tpos})$0"
    },
    "TIMEMAP_TIMETOQN_WR eel2": {
        "prefix": "WR_TimeMap_timeToQN",
        "scope": "eel2",
        "description": "converts project QN position to time.\n",
        "body": "${1:double} = TimeMap_timeToQN(${2:tpos})$0"
    },
    "REAPER.TIMEMAP_TIMETOQN_WR lua": {
        "prefix": "reaperwr.TimeMap_timeToQN",
        "scope": "lua",
        "description": "converts project QN position to time.\n",
        "body": "${1:local }${2:number} = reaper.TimeMap_timeToQN(${3:number tpos})$0"
    },
    "RPR_TIMEMAP_TIMETOQN_WR python": {
        "prefix": "WR_RPR_TimeMap_timeToQN",
        "scope": "python",
        "description": "converts project QN position to time.\n",
        "body": "${1:Float} = RPR_TimeMap_timeToQN(${2:Float tpos})$0"
    },
    "TIMEMAP_TIMETOQN_ABS_WR c": {
        "prefix": "WR_TimeMap_timeToQN_abs",
        "scope": "c",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "${1:double} = TimeMap_timeToQN_abs(${2:ReaProject* proj},${3:double tpos})$0"
    },
    "TIMEMAP_TIMETOQN_ABS_WR eel2": {
        "prefix": "WR_TimeMap_timeToQN_abs",
        "scope": "eel2",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "${1:double} = TimeMap_timeToQN_abs(${2:ReaProject proj},${3:tpos})$0"
    },
    "REAPER.TIMEMAP_TIMETOQN_ABS_WR lua": {
        "prefix": "reaperwr.TimeMap_timeToQN_abs",
        "scope": "lua",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "${1:local }${2:number} = reaper.TimeMap_timeToQN_abs(${3:ReaProject proj},${4:number tpos})$0"
    },
    "RPR_TIMEMAP_TIMETOQN_ABS_WR python": {
        "prefix": "WR_RPR_TimeMap_timeToQN_abs",
        "scope": "python",
        "description": "Converts project time position to quarter note count (QN). QN is counted\nfrom the start of the project, regardless of any partial measures. See TimeMap2_timeToQN\n",
        "body": "${1:Float} = RPR_TimeMap_timeToQN_abs(${2:ReaProject proj},${3:Float tpos})$0"
    },
    "TOGGLETRACKSENDUIMUTE_WR c": {
        "prefix": "WR_ToggleTrackSendUIMute",
        "scope": "c",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "${1:bool} = ToggleTrackSendUIMute(${2:MediaTrack* track},${3:int send_idx})$0"
    },
    "TOGGLETRACKSENDUIMUTE_WR eel2": {
        "prefix": "WR_ToggleTrackSendUIMute",
        "scope": "eel2",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "${1:bool} = ToggleTrackSendUIMute(${2:MediaTrack track},${3:int send_idx})$0"
    },
    "REAPER.TOGGLETRACKSENDUIMUTE_WR lua": {
        "prefix": "reaperwr.ToggleTrackSendUIMute",
        "scope": "lua",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "${1:local }${2:boolean} = reaper.ToggleTrackSendUIMute(${3:MediaTrack track},${4:integer send_idx})$0"
    },
    "RPR_TOGGLETRACKSENDUIMUTE_WR python": {
        "prefix": "WR_RPR_ToggleTrackSendUIMute",
        "scope": "python",
        "description": "send_idx<0 for receives, >=0 for hw ouputs, >=nb_of_hw_ouputs for sends.\n",
        "body": "${1:Boolean} = RPR_ToggleTrackSendUIMute(${2:MediaTrack track},${3:Int send_idx})$0"
    },
    "TRACK_GETPEAKHOLDDB_WR c": {
        "prefix": "WR_Track_GetPeakHoldDB",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = Track_GetPeakHoldDB(${2:MediaTrack* track},${3:int channel},${4:bool clear})$0"
    },
    "TRACK_GETPEAKHOLDDB_WR eel2": {
        "prefix": "WR_Track_GetPeakHoldDB",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = Track_GetPeakHoldDB(${2:MediaTrack track},${3:int channel},${4:bool clear})$0"
    },
    "REAPER.TRACK_GETPEAKHOLDDB_WR lua": {
        "prefix": "reaperwr.Track_GetPeakHoldDB",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.Track_GetPeakHoldDB(${3:MediaTrack track},${4:integer channel},${5:boolean clear})$0"
    },
    "RPR_TRACK_GETPEAKHOLDDB_WR python": {
        "prefix": "WR_RPR_Track_GetPeakHoldDB",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_Track_GetPeakHoldDB(${2:MediaTrack track},${3:Int channel},${4:Boolean clear})$0"
    },
    "TRACK_GETPEAKINFO_WR c": {
        "prefix": "WR_Track_GetPeakInfo",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = Track_GetPeakInfo(${2:MediaTrack* track},${3:int channel})$0"
    },
    "TRACK_GETPEAKINFO_WR eel2": {
        "prefix": "WR_Track_GetPeakInfo",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = Track_GetPeakInfo(${2:MediaTrack track},${3:int channel})$0"
    },
    "REAPER.TRACK_GETPEAKINFO_WR lua": {
        "prefix": "reaperwr.Track_GetPeakInfo",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.Track_GetPeakInfo(${3:MediaTrack track},${4:integer channel})$0"
    },
    "RPR_TRACK_GETPEAKINFO_WR python": {
        "prefix": "WR_RPR_Track_GetPeakInfo",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_Track_GetPeakInfo(${2:MediaTrack track},${3:Int channel})$0"
    },
    "TRACKCTL_SETTOOLTIP_WR c": {
        "prefix": "WR_TrackCtl_SetToolTip",
        "scope": "c",
        "description": "displays tooltip at location, or removes if empty string\n",
        "body": "${1:void} = TrackCtl_SetToolTip(${2:const char* fmt},${3:int xpos},${4:int ypos},${5:bool topmost})$0"
    },
    "TRACKFX_ADDBYNAME_WR c": {
        "prefix": "WR_TrackFX_AddByName",
        "scope": "c",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "${1:int} = TrackFX_AddByName(${2:MediaTrack* track},${3:const char* fxname},${4:bool recFX},${5:int instantiate})$0"
    },
    "TRACKFX_ADDBYNAME_WR eel2": {
        "prefix": "WR_TrackFX_AddByName",
        "scope": "eel2",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "${1:int} = TrackFX_AddByName(${2:MediaTrack track},${3:\"fxname\"},${4:bool recFX},${5:int instantiate})$0"
    },
    "REAPER.TRACKFX_ADDBYNAME_WR lua": {
        "prefix": "reaperwr.TrackFX_AddByName",
        "scope": "lua",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_AddByName(${3:MediaTrack track},${4:string fxname},${5:boolean recFX},${6:integer instantiate})$0"
    },
    "RPR_TRACKFX_ADDBYNAME_WR python": {
        "prefix": "WR_RPR_TrackFX_AddByName",
        "scope": "python",
        "description": "Adds or queries the position of a named FX from the track FX chain\n(recFX=false) or record input FX/monitoring FX (recFX=true, monitoring\nFX are on master track). Specify a negative value for instantiate to\nalways create a new effect, 0 to only query the first instance of an\neffect, or a positive value to add an instance if one is not found.\nfxname can have prefix to specify type: VST3:,VST2:,VST:,AU:,JS:, or\nDX:.\n",
        "body": "${1:Int} = RPR_TrackFX_AddByName(${2:MediaTrack track},${3:String fxname},${4:Boolean recFX},${5:Int instantiate})$0"
    },
    "TRACKFX_COPYTOTAKE_WR c": {
        "prefix": "WR_TrackFX_CopyToTake",
        "scope": "c",
        "description": "Copies (or moves) FX from src_track to dest_take. src_fx can have 0x1000000 set to reference input FX.\n",
        "body": "${1:void} = TrackFX_CopyToTake(${2:MediaTrack* src_track},${3:int src_fx},${4:MediaItem_Take* dest_take},${5:int dest_fx},${6:bool is_move})$0"
    },
    "TRACKFX_COPYTOTRACK_WR c": {
        "prefix": "WR_TrackFX_CopyToTrack",
        "scope": "c",
        "description": "Copies (or moves) FX from src_track to dest_track. Can be used with\nsrc_track=dest_track to reorder, FX indices have 0x1000000 set to\nreference input FX.\n",
        "body": "${1:void} = TrackFX_CopyToTrack(${2:MediaTrack* src_track},${3:int src_fx},${4:MediaTrack* dest_track},${5:int dest_fx},${6:bool is_move})$0"
    },
    "TRACKFX_DELETE_WR c": {
        "prefix": "WR_TrackFX_Delete",
        "scope": "c",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "${1:bool} = TrackFX_Delete(${2:MediaTrack* track},${3:int fx})$0"
    },
    "TRACKFX_DELETE_WR eel2": {
        "prefix": "WR_TrackFX_Delete",
        "scope": "eel2",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "${1:bool} = TrackFX_Delete(${2:MediaTrack track},${3:int fx})$0"
    },
    "REAPER.TRACKFX_DELETE_WR lua": {
        "prefix": "reaperwr.TrackFX_Delete",
        "scope": "lua",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_Delete(${3:MediaTrack track},${4:integer fx})$0"
    },
    "RPR_TRACKFX_DELETE_WR python": {
        "prefix": "WR_RPR_TrackFX_Delete",
        "scope": "python",
        "description": "Remove a FX from track chain (returns true on success)\n",
        "body": "${1:Boolean} = RPR_TrackFX_Delete(${2:MediaTrack track},${3:Int fx})$0"
    },
    "TRACKFX_ENDPARAMEDIT_WR c": {
        "prefix": "WR_TrackFX_EndParamEdit",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TrackFX_EndParamEdit(${2:MediaTrack* track},${3:int fx},${4:int param})$0"
    },
    "TRACKFX_ENDPARAMEDIT_WR eel2": {
        "prefix": "WR_TrackFX_EndParamEdit",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_EndParamEdit(${2:MediaTrack track},${3:int fx},${4:int param})$0"
    },
    "REAPER.TRACKFX_ENDPARAMEDIT_WR lua": {
        "prefix": "reaperwr.TrackFX_EndParamEdit",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_EndParamEdit(${3:MediaTrack track},${4:integer fx},${5:integer param})$0"
    },
    "RPR_TRACKFX_ENDPARAMEDIT_WR python": {
        "prefix": "WR_RPR_TrackFX_EndParamEdit",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_TrackFX_EndParamEdit(${2:MediaTrack track},${3:Int fx},${4:Int param})$0"
    },
    "TRACKFX_FORMATPARAMVALUE_WR c": {
        "prefix": "WR_TrackFX_FormatParamValue",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TrackFX_FormatParamValue(${2:MediaTrack* track},${3:int fx},${4:int param},${5:double val},${6:char* buf},${7:int buf_sz})$0"
    },
    "TRACKFX_FORMATPARAMVALUE_WR eel2": {
        "prefix": "WR_TrackFX_FormatParamValue",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TrackFX_FormatParamValue(${2:MediaTrack track},${3:int fx},${4:int param},${5:val},${6:#buf})$0"
    },
    "REAPER.TRACKFX_FORMATPARAMVALUE_WR lua": {
        "prefix": "reaperwr.TrackFX_FormatParamValue",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TrackFX_FormatParamValue(${4:MediaTrack track},${5:integer fx},${6:integer param},${7:number val},${8:string buf})$0"
    },
    "RPR_TRACKFX_FORMATPARAMVALUE_WR python": {
        "prefix": "WR_RPR_TrackFX_FormatParamValue",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:Int param},${5:Float val},${6:String buf},${7:Int buf_sz} = RPR_TrackFX_FormatParamValue(${8:track},${9:fx},${10:param},${11:val},${12:buf},${13:buf_sz})$0"
    },
    "TRACKFX_FORMATPARAMVALUENORMALIZED_WR c": {
        "prefix": "WR_TrackFX_FormatParamValueNormalized",
        "scope": "c",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TrackFX_FormatParamValueNormalized(${2:MediaTrack* track},${3:int fx},${4:int param},${5:double value},${6:char* buf},${7:int buf_sz})$0"
    },
    "TRACKFX_FORMATPARAMVALUENORMALIZED_WR eel2": {
        "prefix": "WR_TrackFX_FormatParamValueNormalized",
        "scope": "eel2",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:bool} = TrackFX_FormatParamValueNormalized(${2:MediaTrack track},${3:int fx},${4:int param},${5:value},${6:#buf})$0"
    },
    "REAPER.TRACKFX_FORMATPARAMVALUENORMALIZED_WR lua": {
        "prefix": "reaperwr.TrackFX_FormatParamValueNormalized",
        "scope": "lua",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TrackFX_FormatParamValueNormalized(${4:MediaTrack track},${5:integer fx},${6:integer param},${7:number value},${8:string buf})$0"
    },
    "RPR_TRACKFX_FORMATPARAMVALUENORMALIZED_WR python": {
        "prefix": "WR_RPR_TrackFX_FormatParamValueNormalized",
        "scope": "python",
        "description": "Note: only works with FX that support Cockos VST extensions.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:Int param},${5:Float value},${6:String buf},${7:Int buf_sz} = RPR_TrackFX_FormatParamValueNormalized(${8:track},${9:fx},${10:param},${11:value},${12:buf},${13:buf_sz})$0"
    },
    "TRACKFX_GETBYNAME_WR c": {
        "prefix": "WR_TrackFX_GetByName",
        "scope": "c",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "${1:int} = TrackFX_GetByName(${2:MediaTrack* track},${3:const char* fxname},${4:bool instantiate})$0"
    },
    "TRACKFX_GETBYNAME_WR eel2": {
        "prefix": "WR_TrackFX_GetByName",
        "scope": "eel2",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "${1:int} = TrackFX_GetByName(${2:MediaTrack track},${3:\"fxname\"},${4:bool instantiate})$0"
    },
    "REAPER.TRACKFX_GETBYNAME_WR lua": {
        "prefix": "reaperwr.TrackFX_GetByName",
        "scope": "lua",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetByName(${3:MediaTrack track},${4:string fxname},${5:boolean instantiate})$0"
    },
    "RPR_TRACKFX_GETBYNAME_WR python": {
        "prefix": "WR_RPR_TrackFX_GetByName",
        "scope": "python",
        "description": "Get the index of the first track FX insert that matches fxname. If the\nFX is not in the chain and instantiate is true, it will be inserted. See\nTrackFX_GetInstrument, TrackFX_GetEQ. Deprecated in favor of TrackFX_AddByName.\n",
        "body": "${1:Int} = RPR_TrackFX_GetByName(${2:MediaTrack track},${3:String fxname},${4:Boolean instantiate})$0"
    },
    "TRACKFX_GETCHAINVISIBLE_WR c": {
        "prefix": "WR_TrackFX_GetChainVisible",
        "scope": "c",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:int} = TrackFX_GetChainVisible(${2:MediaTrack* track})$0"
    },
    "TRACKFX_GETCHAINVISIBLE_WR eel2": {
        "prefix": "WR_TrackFX_GetChainVisible",
        "scope": "eel2",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:int} = TrackFX_GetChainVisible(${2:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETCHAINVISIBLE_WR lua": {
        "prefix": "reaperwr.TrackFX_GetChainVisible",
        "scope": "lua",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetChainVisible(${3:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETCHAINVISIBLE_WR python": {
        "prefix": "WR_RPR_TrackFX_GetChainVisible",
        "scope": "python",
        "description": "returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:Int} = RPR_TrackFX_GetChainVisible(${2:MediaTrack track})$0"
    },
    "TRACKFX_GETCOUNT_WR c": {
        "prefix": "WR_TrackFX_GetCount",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = TrackFX_GetCount(${2:MediaTrack* track})$0"
    },
    "TRACKFX_GETCOUNT_WR eel2": {
        "prefix": "WR_TrackFX_GetCount",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = TrackFX_GetCount(${2:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETCOUNT_WR lua": {
        "prefix": "reaperwr.TrackFX_GetCount",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetCount(${3:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETCOUNT_WR python": {
        "prefix": "WR_RPR_TrackFX_GetCount",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_TrackFX_GetCount(${2:MediaTrack track})$0"
    },
    "TRACKFX_GETENABLED_WR c": {
        "prefix": "WR_TrackFX_GetEnabled",
        "scope": "c",
        "description": "See TrackFX_SetEnabled\n",
        "body": "${1:bool} = TrackFX_GetEnabled(${2:MediaTrack* track},${3:int fx})$0"
    },
    "TRACKFX_GETENABLED_WR eel2": {
        "prefix": "WR_TrackFX_GetEnabled",
        "scope": "eel2",
        "description": "See TrackFX_SetEnabled\n",
        "body": "${1:bool} = TrackFX_GetEnabled(${2:MediaTrack track},${3:int fx})$0"
    },
    "REAPER.TRACKFX_GETENABLED_WR lua": {
        "prefix": "reaperwr.TrackFX_GetEnabled",
        "scope": "lua",
        "description": "See TrackFX_SetEnabled\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_GetEnabled(${3:MediaTrack track},${4:integer fx})$0"
    },
    "RPR_TRACKFX_GETENABLED_WR python": {
        "prefix": "WR_RPR_TrackFX_GetEnabled",
        "scope": "python",
        "description": "See TrackFX_SetEnabled\n",
        "body": "${1:Boolean} = RPR_TrackFX_GetEnabled(${2:MediaTrack track},${3:Int fx})$0"
    },
    "TRACKFX_GETEQ_WR c": {
        "prefix": "WR_TrackFX_GetEQ",
        "scope": "c",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "${1:int} = TrackFX_GetEQ(${2:MediaTrack* track},${3:bool instantiate})$0"
    },
    "TRACKFX_GETEQ_WR eel2": {
        "prefix": "WR_TrackFX_GetEQ",
        "scope": "eel2",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "${1:int} = TrackFX_GetEQ(${2:MediaTrack track},${3:bool instantiate})$0"
    },
    "REAPER.TRACKFX_GETEQ_WR lua": {
        "prefix": "reaperwr.TrackFX_GetEQ",
        "scope": "lua",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetEQ(${3:MediaTrack track},${4:boolean instantiate})$0"
    },
    "RPR_TRACKFX_GETEQ_WR python": {
        "prefix": "WR_RPR_TrackFX_GetEQ",
        "scope": "python",
        "description": "Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.\n",
        "body": "${1:Int} = RPR_TrackFX_GetEQ(${2:MediaTrack track},${3:Boolean instantiate})$0"
    },
    "TRACKFX_GETEQBANDENABLED_WR c": {
        "prefix": "WR_TrackFX_GetEQBandEnabled",
        "scope": "c",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_GetEQBandEnabled(${2:MediaTrack* track},${3:int fxidx},${4:int bandtype},${5:int bandidx})$0"
    },
    "TRACKFX_GETEQBANDENABLED_WR eel2": {
        "prefix": "WR_TrackFX_GetEQBandEnabled",
        "scope": "eel2",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_GetEQBandEnabled(${2:MediaTrack track},${3:int fxidx},${4:int bandtype},${5:int bandidx})$0"
    },
    "REAPER.TRACKFX_GETEQBANDENABLED_WR lua": {
        "prefix": "reaperwr.TrackFX_GetEQBandEnabled",
        "scope": "lua",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_GetEQBandEnabled(${3:MediaTrack track},${4:integer fxidx},${5:integer bandtype},${6:integer bandidx})$0"
    },
    "RPR_TRACKFX_GETEQBANDENABLED_WR python": {
        "prefix": "WR_RPR_TrackFX_GetEQBandEnabled",
        "scope": "python",
        "description": "Returns true if the EQ band is enabled.\nReturns false if the band is disabled, or if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:Boolean} = RPR_TrackFX_GetEQBandEnabled(${2:MediaTrack track},${3:Int fxidx},${4:Int bandtype},${5:Int bandidx})$0"
    },
    "TRACKFX_GETEQPARAM_WR c": {
        "prefix": "WR_TrackFX_GetEQParam",
        "scope": "c",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_GetEQParam(${2:MediaTrack* track},${3:int fxidx},${4:int paramidx},${5:int* bandtypeOut},${6:int* bandidxOut},${7:int* paramtypeOut},${8:double* normvalOut})$0"
    },
    "TRACKFX_GETEQPARAM_WR eel2": {
        "prefix": "WR_TrackFX_GetEQParam",
        "scope": "eel2",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_GetEQParam(${2:MediaTrack track},${3:int fxidx},${4:int paramidx},${5:int &bandtype},${6:int &bandidx},${7:int &paramtype},${8:&normval})$0"
    },
    "REAPER.TRACKFX_GETEQPARAM_WR lua": {
        "prefix": "reaperwr.TrackFX_GetEQParam",
        "scope": "lua",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:local }${2:boolean retval},${3:number bandtype},${4:number bandidx},${5:number paramtype},${6:number normval} = reaper.TrackFX_GetEQParam(${7:MediaTrack track},${8:integer fxidx},${9:integer paramidx})$0"
    },
    "RPR_TRACKFX_GETEQPARAM_WR python": {
        "prefix": "WR_RPR_TrackFX_GetEQParam",
        "scope": "python",
        "description": "Returns false if track/fxidx is not ReaEQ.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fxidx},${4:Int paramidx},${5:Int bandtypeOut},${6:Int bandidxOut},${7:Int paramtypeOut},${8:Float normvalOut} = RPR_TrackFX_GetEQParam(${9:track},${10:fxidx},${11:paramidx},${12:bandtypeOut},${13:bandidxOut},${14:paramtypeOut},${15:normvalOut})$0"
    },
    "TRACKFX_GETFLOATINGWINDOW_WR c": {
        "prefix": "WR_TrackFX_GetFloatingWindow",
        "scope": "c",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:HWND} = TrackFX_GetFloatingWindow(${2:MediaTrack* track},${3:int index})$0"
    },
    "TRACKFX_GETFLOATINGWINDOW_WR eel2": {
        "prefix": "WR_TrackFX_GetFloatingWindow",
        "scope": "eel2",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:HWND} = TrackFX_GetFloatingWindow(${2:MediaTrack track},${3:int index})$0"
    },
    "REAPER.TRACKFX_GETFLOATINGWINDOW_WR lua": {
        "prefix": "reaperwr.TrackFX_GetFloatingWindow",
        "scope": "lua",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:local }${2:HWND} = reaper.TrackFX_GetFloatingWindow(${3:MediaTrack track},${4:integer index})$0"
    },
    "RPR_TRACKFX_GETFLOATINGWINDOW_WR python": {
        "prefix": "WR_RPR_TrackFX_GetFloatingWindow",
        "scope": "python",
        "description": "returns HWND of floating window for effect index, if any\n",
        "body": "${1:HWND} = RPR_TrackFX_GetFloatingWindow(${2:MediaTrack track},${3:Int index})$0"
    },
    "TRACKFX_GETFORMATTEDPARAMVALUE_WR c": {
        "prefix": "WR_TrackFX_GetFormattedParamValue",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetFormattedParamValue(${2:MediaTrack* track},${3:int fx},${4:int param},${5:char* buf},${6:int buf_sz})$0"
    },
    "TRACKFX_GETFORMATTEDPARAMVALUE_WR eel2": {
        "prefix": "WR_TrackFX_GetFormattedParamValue",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetFormattedParamValue(${2:MediaTrack track},${3:int fx},${4:int param},${5:#buf})$0"
    },
    "REAPER.TRACKFX_GETFORMATTEDPARAMVALUE_WR lua": {
        "prefix": "reaperwr.TrackFX_GetFormattedParamValue",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TrackFX_GetFormattedParamValue(${4:MediaTrack track},${5:integer fx},${6:integer param},${7:string buf})$0"
    },
    "RPR_TRACKFX_GETFORMATTEDPARAMVALUE_WR python": {
        "prefix": "WR_RPR_TrackFX_GetFormattedParamValue",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:Int param},${5:String buf},${6:Int buf_sz} = RPR_TrackFX_GetFormattedParamValue(${7:track},${8:fx},${9:param},${10:buf},${11:buf_sz})$0"
    },
    "TRACKFX_GETFXGUID_WR c": {
        "prefix": "WR_TrackFX_GetFXGUID",
        "scope": "c",
        "description": "\n",
        "body": "${1:GUID*} = TrackFX_GetFXGUID(${2:MediaTrack* track},${3:int fx})$0"
    },
    "TRACKFX_GETFXGUID_WR eel2": {
        "prefix": "WR_TrackFX_GetFXGUID",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetFXGUID(${2:#retguid},${3:MediaTrack track},${4:int fx})$0"
    },
    "REAPER.TRACKFX_GETFXGUID_WR lua": {
        "prefix": "reaperwr.TrackFX_GetFXGUID",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string GUID} = reaper.TrackFX_GetFXGUID(${3:MediaTrack track},${4:integer fx})$0"
    },
    "RPR_TRACKFX_GETFXGUID_WR python": {
        "prefix": "WR_RPR_TrackFX_GetFXGUID",
        "scope": "python",
        "description": "\n",
        "body": "${1:GUID} = RPR_TrackFX_GetFXGUID(${2:MediaTrack track},${3:Int fx})$0"
    },
    "TRACKFX_GETFXNAME_WR c": {
        "prefix": "WR_TrackFX_GetFXName",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetFXName(${2:MediaTrack* track},${3:int fx},${4:char* buf},${5:int buf_sz})$0"
    },
    "TRACKFX_GETFXNAME_WR eel2": {
        "prefix": "WR_TrackFX_GetFXName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetFXName(${2:MediaTrack track},${3:int fx},${4:#buf})$0"
    },
    "REAPER.TRACKFX_GETFXNAME_WR lua": {
        "prefix": "reaperwr.TrackFX_GetFXName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TrackFX_GetFXName(${4:MediaTrack track},${5:integer fx},${6:string buf})$0"
    },
    "RPR_TRACKFX_GETFXNAME_WR python": {
        "prefix": "WR_RPR_TrackFX_GetFXName",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:String buf},${5:Int buf_sz} = RPR_TrackFX_GetFXName(${6:track},${7:fx},${8:buf},${9:buf_sz})$0"
    },
    "TRACKFX_GETINSTRUMENT_WR c": {
        "prefix": "WR_TrackFX_GetInstrument",
        "scope": "c",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "${1:int} = TrackFX_GetInstrument(${2:MediaTrack* track})$0"
    },
    "TRACKFX_GETINSTRUMENT_WR eel2": {
        "prefix": "WR_TrackFX_GetInstrument",
        "scope": "eel2",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "${1:int} = TrackFX_GetInstrument(${2:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETINSTRUMENT_WR lua": {
        "prefix": "reaperwr.TrackFX_GetInstrument",
        "scope": "lua",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetInstrument(${3:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETINSTRUMENT_WR python": {
        "prefix": "WR_RPR_TrackFX_GetInstrument",
        "scope": "python",
        "description": "Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.\n",
        "body": "${1:Int} = RPR_TrackFX_GetInstrument(${2:MediaTrack track})$0"
    },
    "TRACKFX_GETIOSIZE_WR c": {
        "prefix": "WR_TrackFX_GetIOSize",
        "scope": "c",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:int} = TrackFX_GetIOSize(${2:MediaTrack* track},${3:int fx},${4:int* inputPinsOutOptional},${5:int* outputPinsOutOptional})$0"
    },
    "TRACKFX_GETIOSIZE_WR eel2": {
        "prefix": "WR_TrackFX_GetIOSize",
        "scope": "eel2",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:int} = TrackFX_GetIOSize(${2:MediaTrack track},${3:int fx},${4:optional int &inputPins},${5:optional int &outputPins})$0"
    },
    "REAPER.TRACKFX_GETIOSIZE_WR lua": {
        "prefix": "reaperwr.TrackFX_GetIOSize",
        "scope": "lua",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:local }${2:integer retval},${3:optional number inputPins},${4:optional number outputPins} = reaper.TrackFX_GetIOSize(${5:MediaTrack track},${6:integer fx})$0"
    },
    "RPR_TRACKFX_GETIOSIZE_WR python": {
        "prefix": "WR_RPR_TrackFX_GetIOSize",
        "scope": "python",
        "description": "sets the number of input/output pins for FX if available, returns plug-in type or -1 on error\n",
        "body": "${1:Int retval},${2:MediaTrack track},${3:Int fx},${4:Int inputPinsOutOptional},${5:Int outputPinsOutOptional} = RPR_TrackFX_GetIOSize(${6:track},${7:fx},${8:inputPinsOutOptional},${9:outputPinsOutOptional})$0"
    },
    "TRACKFX_GETNAMEDCONFIGPARM_WR c": {
        "prefix": "WR_TrackFX_GetNamedConfigParm",
        "scope": "c",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "${1:bool} = TrackFX_GetNamedConfigParm(${2:MediaTrack* track},${3:int fx},${4:const char* parmname},${5:char* bufOut},${6:int bufOut_sz})$0"
    },
    "TRACKFX_GETNAMEDCONFIGPARM_WR eel2": {
        "prefix": "WR_TrackFX_GetNamedConfigParm",
        "scope": "eel2",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "${1:bool} = TrackFX_GetNamedConfigParm(${2:MediaTrack track},${3:int fx},${4:\"parmname\"},${5:#buf})$0"
    },
    "REAPER.TRACKFX_GETNAMEDCONFIGPARM_WR lua": {
        "prefix": "reaperwr.TrackFX_GetNamedConfigParm",
        "scope": "lua",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TrackFX_GetNamedConfigParm(${4:MediaTrack track},${5:integer fx},${6:string parmname})$0"
    },
    "RPR_TRACKFX_GETNAMEDCONFIGPARM_WR python": {
        "prefix": "WR_RPR_TrackFX_GetNamedConfigParm",
        "scope": "python",
        "description": "gets plug-in specific named configuration value (returns true on\nsuccess). Special values: 'pdc' returns PDC latency. 'in_pin_0' returns\nname of first input pin (if available), 'out_pin_0' returns name of\nfirst output pin (if available), etc.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:String parmname},${5:String bufOut},${6:Int bufOut_sz} = RPR_TrackFX_GetNamedConfigParm(${7:track},${8:fx},${9:parmname},${10:bufOut},${11:bufOut_sz})$0"
    },
    "TRACKFX_GETNUMPARAMS_WR c": {
        "prefix": "WR_TrackFX_GetNumParams",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = TrackFX_GetNumParams(${2:MediaTrack* track},${3:int fx})$0"
    },
    "TRACKFX_GETNUMPARAMS_WR eel2": {
        "prefix": "WR_TrackFX_GetNumParams",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:int} = TrackFX_GetNumParams(${2:MediaTrack track},${3:int fx})$0"
    },
    "REAPER.TRACKFX_GETNUMPARAMS_WR lua": {
        "prefix": "reaperwr.TrackFX_GetNumParams",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetNumParams(${3:MediaTrack track},${4:integer fx})$0"
    },
    "RPR_TRACKFX_GETNUMPARAMS_WR python": {
        "prefix": "WR_RPR_TrackFX_GetNumParams",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = RPR_TrackFX_GetNumParams(${2:MediaTrack track},${3:Int fx})$0"
    },
    "TRACKFX_GETOFFLINE_WR c": {
        "prefix": "WR_TrackFX_GetOffline",
        "scope": "c",
        "description": "See TrackFX_SetOffline\n",
        "body": "${1:bool} = TrackFX_GetOffline(${2:MediaTrack* track},${3:int fx})$0"
    },
    "TRACKFX_GETOFFLINE_WR eel2": {
        "prefix": "WR_TrackFX_GetOffline",
        "scope": "eel2",
        "description": "See TrackFX_SetOffline\n",
        "body": "${1:bool} = TrackFX_GetOffline(${2:MediaTrack track},${3:int fx})$0"
    },
    "REAPER.TRACKFX_GETOFFLINE_WR lua": {
        "prefix": "reaperwr.TrackFX_GetOffline",
        "scope": "lua",
        "description": "See TrackFX_SetOffline\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_GetOffline(${3:MediaTrack track},${4:integer fx})$0"
    },
    "RPR_TRACKFX_GETOFFLINE_WR python": {
        "prefix": "WR_RPR_TrackFX_GetOffline",
        "scope": "python",
        "description": "See TrackFX_SetOffline\n",
        "body": "${1:Boolean} = RPR_TrackFX_GetOffline(${2:MediaTrack track},${3:Int fx})$0"
    },
    "TRACKFX_GETOPEN_WR c": {
        "prefix": "WR_TrackFX_GetOpen",
        "scope": "c",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "${1:bool} = TrackFX_GetOpen(${2:MediaTrack* track},${3:int fx})$0"
    },
    "TRACKFX_GETOPEN_WR eel2": {
        "prefix": "WR_TrackFX_GetOpen",
        "scope": "eel2",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "${1:bool} = TrackFX_GetOpen(${2:MediaTrack track},${3:int fx})$0"
    },
    "REAPER.TRACKFX_GETOPEN_WR lua": {
        "prefix": "reaperwr.TrackFX_GetOpen",
        "scope": "lua",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_GetOpen(${3:MediaTrack track},${4:integer fx})$0"
    },
    "RPR_TRACKFX_GETOPEN_WR python": {
        "prefix": "WR_RPR_TrackFX_GetOpen",
        "scope": "python",
        "description": "Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen\n",
        "body": "${1:Boolean} = RPR_TrackFX_GetOpen(${2:MediaTrack track},${3:Int fx})$0"
    },
    "TRACKFX_GETPARAM_WR c": {
        "prefix": "WR_TrackFX_GetParam",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = TrackFX_GetParam(${2:MediaTrack* track},${3:int fx},${4:int param},${5:double* minvalOut},${6:double* maxvalOut})$0"
    },
    "TRACKFX_GETPARAM_WR eel2": {
        "prefix": "WR_TrackFX_GetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = TrackFX_GetParam(${2:MediaTrack track},${3:int fx},${4:int param},${5:&minval},${6:&maxval})$0"
    },
    "REAPER.TRACKFX_GETPARAM_WR lua": {
        "prefix": "reaperwr.TrackFX_GetParam",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number retval},${3:number minval},${4:number maxval} = reaper.TrackFX_GetParam(${5:MediaTrack track},${6:integer fx},${7:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAM_WR python": {
        "prefix": "WR_RPR_TrackFX_GetParam",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float retval},${2:MediaTrack track},${3:Int fx},${4:Int param},${5:Float minvalOut},${6:Float maxvalOut} = RPR_TrackFX_GetParam(${7:track},${8:fx},${9:param},${10:minvalOut},${11:maxvalOut})$0"
    },
    "TRACKFX_GETPARAMETERSTEPSIZES_WR c": {
        "prefix": "WR_TrackFX_GetParameterStepSizes",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetParameterStepSizes(${2:MediaTrack* track},${3:int fx},${4:int param},${5:double* stepOut},${6:double* smallstepOut},${7:double* largestepOut},${8:bool* istoggleOut})$0"
    },
    "TRACKFX_GETPARAMETERSTEPSIZES_WR eel2": {
        "prefix": "WR_TrackFX_GetParameterStepSizes",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetParameterStepSizes(${2:MediaTrack track},${3:int fx},${4:int param},${5:&step},${6:&smallstep},${7:&largestep},${8:bool &istoggle})$0"
    },
    "REAPER.TRACKFX_GETPARAMETERSTEPSIZES_WR lua": {
        "prefix": "reaperwr.TrackFX_GetParameterStepSizes",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:number step},${4:number smallstep},${5:number largestep},${6:boolean istoggle} = reaper.TrackFX_GetParameterStepSizes(${7:MediaTrack track},${8:integer fx},${9:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAMETERSTEPSIZES_WR python": {
        "prefix": "WR_RPR_TrackFX_GetParameterStepSizes",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:Int param},${5:Float stepOut},${6:Float smallstepOut},${7:Float largestepOut},${8:Boolean istoggleOut} = RPR_TrackFX_GetParameterStepSizes(${9:track},${10:fx},${11:param},${12:stepOut},${13:smallstepOut},${14:largestepOut},${15:istoggleOut})$0"
    },
    "TRACKFX_GETPARAMEX_WR c": {
        "prefix": "WR_TrackFX_GetParamEx",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = TrackFX_GetParamEx(${2:MediaTrack* track},${3:int fx},${4:int param},${5:double* minvalOut},${6:double* maxvalOut},${7:double* midvalOut})$0"
    },
    "TRACKFX_GETPARAMEX_WR eel2": {
        "prefix": "WR_TrackFX_GetParamEx",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = TrackFX_GetParamEx(${2:MediaTrack track},${3:int fx},${4:int param},${5:&minval},${6:&maxval},${7:&midval})$0"
    },
    "REAPER.TRACKFX_GETPARAMEX_WR lua": {
        "prefix": "reaperwr.TrackFX_GetParamEx",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number retval},${3:number minval},${4:number maxval},${5:number midval} = reaper.TrackFX_GetParamEx(${6:MediaTrack track},${7:integer fx},${8:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAMEX_WR python": {
        "prefix": "WR_RPR_TrackFX_GetParamEx",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float retval},${2:MediaTrack track},${3:Int fx},${4:Int param},${5:Float minvalOut},${6:Float maxvalOut},${7:Float midvalOut} = RPR_TrackFX_GetParamEx(${8:track},${9:fx},${10:param},${11:minvalOut},${12:maxvalOut},${13:midvalOut})$0"
    },
    "TRACKFX_GETPARAMNAME_WR c": {
        "prefix": "WR_TrackFX_GetParamName",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetParamName(${2:MediaTrack* track},${3:int fx},${4:int param},${5:char* buf},${6:int buf_sz})$0"
    },
    "TRACKFX_GETPARAMNAME_WR eel2": {
        "prefix": "WR_TrackFX_GetParamName",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_GetParamName(${2:MediaTrack track},${3:int fx},${4:int param},${5:#buf})$0"
    },
    "REAPER.TRACKFX_GETPARAMNAME_WR lua": {
        "prefix": "reaperwr.TrackFX_GetParamName",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.TrackFX_GetParamName(${4:MediaTrack track},${5:integer fx},${6:integer param},${7:string buf})$0"
    },
    "RPR_TRACKFX_GETPARAMNAME_WR python": {
        "prefix": "WR_RPR_TrackFX_GetParamName",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:Int param},${5:String buf},${6:Int buf_sz} = RPR_TrackFX_GetParamName(${7:track},${8:fx},${9:param},${10:buf},${11:buf_sz})$0"
    },
    "TRACKFX_GETPARAMNORMALIZED_WR c": {
        "prefix": "WR_TrackFX_GetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "${1:double} = TrackFX_GetParamNormalized(${2:MediaTrack* track},${3:int fx},${4:int param})$0"
    },
    "TRACKFX_GETPARAMNORMALIZED_WR eel2": {
        "prefix": "WR_TrackFX_GetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:double} = TrackFX_GetParamNormalized(${2:MediaTrack track},${3:int fx},${4:int param})$0"
    },
    "REAPER.TRACKFX_GETPARAMNORMALIZED_WR lua": {
        "prefix": "reaperwr.TrackFX_GetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number} = reaper.TrackFX_GetParamNormalized(${3:MediaTrack track},${4:integer fx},${5:integer param})$0"
    },
    "RPR_TRACKFX_GETPARAMNORMALIZED_WR python": {
        "prefix": "WR_RPR_TrackFX_GetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "${1:Float} = RPR_TrackFX_GetParamNormalized(${2:MediaTrack track},${3:Int fx},${4:Int param})$0"
    },
    "TRACKFX_GETPINMAPPINGS_WR c": {
        "prefix": "WR_TrackFX_GetPinMappings",
        "scope": "c",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:int} = TrackFX_GetPinMappings(${2:MediaTrack* tr},${3:int fx},${4:int isoutput},${5:int pin},${6:int* high32OutOptional})$0"
    },
    "TRACKFX_GETPINMAPPINGS_WR eel2": {
        "prefix": "WR_TrackFX_GetPinMappings",
        "scope": "eel2",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:int} = TrackFX_GetPinMappings(${2:MediaTrack tr},${3:int fx},${4:int isoutput},${5:int pin},${6:optional int &high32})$0"
    },
    "REAPER.TRACKFX_GETPINMAPPINGS_WR lua": {
        "prefix": "reaperwr.TrackFX_GetPinMappings",
        "scope": "lua",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:local }${2:integer retval},${3:optional number high32} = reaper.TrackFX_GetPinMappings(${4:MediaTrack tr},${5:integer fx},${6:integer isoutput},${7:integer pin})$0"
    },
    "RPR_TRACKFX_GETPINMAPPINGS_WR python": {
        "prefix": "WR_RPR_TrackFX_GetPinMappings",
        "scope": "python",
        "description": "gets the effective channel mapping bitmask for a particular pin. high32OutOptional will be set to the high 32 bits\n",
        "body": "${1:Int retval},${2:MediaTrack tr},${3:Int fx},${4:Int isoutput},${5:Int pin},${6:Int high32OutOptional} = RPR_TrackFX_GetPinMappings(${7:tr},${8:fx},${9:isoutput},${10:pin},${11:high32OutOptional})$0"
    },
    "TRACKFX_GETPRESET_WR c": {
        "prefix": "WR_TrackFX_GetPreset",
        "scope": "c",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "${1:bool} = TrackFX_GetPreset(${2:MediaTrack* track},${3:int fx},${4:char* presetname},${5:int presetname_sz})$0"
    },
    "TRACKFX_GETPRESET_WR eel2": {
        "prefix": "WR_TrackFX_GetPreset",
        "scope": "eel2",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "${1:bool} = TrackFX_GetPreset(${2:MediaTrack track},${3:int fx},${4:#presetname})$0"
    },
    "REAPER.TRACKFX_GETPRESET_WR lua": {
        "prefix": "reaperwr.TrackFX_GetPreset",
        "scope": "lua",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "${1:local }${2:boolean retval},${3:string presetname} = reaper.TrackFX_GetPreset(${4:MediaTrack track},${5:integer fx},${6:string presetname})$0"
    },
    "RPR_TRACKFX_GETPRESET_WR python": {
        "prefix": "WR_RPR_TrackFX_GetPreset",
        "scope": "python",
        "description": "Get the name of the preset currently showing in the REAPER dropdown, or\nthe full path to a factory preset file for VST3 plug-ins (.vstpreset).\nReturns false if the current FX parameters do not exactly match the\npreset (in other words, if the user loaded the preset but moved the\nknobs afterward). See TrackFX_SetPreset.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:String presetname},${5:Int presetname_sz} = RPR_TrackFX_GetPreset(${6:track},${7:fx},${8:presetname},${9:presetname_sz})$0"
    },
    "TRACKFX_GETPRESETINDEX_WR c": {
        "prefix": "WR_TrackFX_GetPresetIndex",
        "scope": "c",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "${1:int} = TrackFX_GetPresetIndex(${2:MediaTrack* track},${3:int fx},${4:int* numberOfPresetsOut})$0"
    },
    "TRACKFX_GETPRESETINDEX_WR eel2": {
        "prefix": "WR_TrackFX_GetPresetIndex",
        "scope": "eel2",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "${1:int} = TrackFX_GetPresetIndex(${2:MediaTrack track},${3:int fx},${4:int &numberOfPresets})$0"
    },
    "REAPER.TRACKFX_GETPRESETINDEX_WR lua": {
        "prefix": "reaperwr.TrackFX_GetPresetIndex",
        "scope": "lua",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "${1:local }${2:integer retval},${3:number numberOfPresets} = reaper.TrackFX_GetPresetIndex(${4:MediaTrack track},${5:integer fx})$0"
    },
    "RPR_TRACKFX_GETPRESETINDEX_WR python": {
        "prefix": "WR_RPR_TrackFX_GetPresetIndex",
        "scope": "python",
        "description": "Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex\n",
        "body": "${1:Int retval},${2:MediaTrack track},${3:Int fx},${4:Int numberOfPresetsOut} = RPR_TrackFX_GetPresetIndex(${5:track},${6:fx},${7:numberOfPresetsOut})$0"
    },
    "TRACKFX_GETRECCHAINVISIBLE_WR c": {
        "prefix": "WR_TrackFX_GetRecChainVisible",
        "scope": "c",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:int} = TrackFX_GetRecChainVisible(${2:MediaTrack* track})$0"
    },
    "TRACKFX_GETRECCHAINVISIBLE_WR eel2": {
        "prefix": "WR_TrackFX_GetRecChainVisible",
        "scope": "eel2",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:int} = TrackFX_GetRecChainVisible(${2:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETRECCHAINVISIBLE_WR lua": {
        "prefix": "reaperwr.TrackFX_GetRecChainVisible",
        "scope": "lua",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetRecChainVisible(${3:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETRECCHAINVISIBLE_WR python": {
        "prefix": "WR_RPR_TrackFX_GetRecChainVisible",
        "scope": "python",
        "description": "returns index of effect visible in record input chain, or -1 for chain hidden, or -2 for chain visible but no effect selected\n",
        "body": "${1:Int} = RPR_TrackFX_GetRecChainVisible(${2:MediaTrack track})$0"
    },
    "TRACKFX_GETRECCOUNT_WR c": {
        "prefix": "WR_TrackFX_GetRecCount",
        "scope": "c",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "${1:int} = TrackFX_GetRecCount(${2:MediaTrack* track})$0"
    },
    "TRACKFX_GETRECCOUNT_WR eel2": {
        "prefix": "WR_TrackFX_GetRecCount",
        "scope": "eel2",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "${1:int} = TrackFX_GetRecCount(${2:MediaTrack track})$0"
    },
    "REAPER.TRACKFX_GETRECCOUNT_WR lua": {
        "prefix": "reaperwr.TrackFX_GetRecCount",
        "scope": "lua",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "${1:local }${2:integer} = reaper.TrackFX_GetRecCount(${3:MediaTrack track})$0"
    },
    "RPR_TRACKFX_GETRECCOUNT_WR python": {
        "prefix": "WR_RPR_TrackFX_GetRecCount",
        "scope": "python",
        "description": "returns count of record input FX. To access record input FX, use a FX\nindices [0x1000000..0x1000000+n). On the master track, this accesses\nmonitoring FX rather than record input FX.\n",
        "body": "${1:Int} = RPR_TrackFX_GetRecCount(${2:MediaTrack track})$0"
    },
    "TRACKFX_GETUSERPRESETFILENAME_WR c": {
        "prefix": "WR_TrackFX_GetUserPresetFilename",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = TrackFX_GetUserPresetFilename(${2:MediaTrack* track},${3:int fx},${4:char* fn},${5:int fn_sz})$0"
    },
    "REAPER.TRACKFX_GETUSERPRESETFILENAME_WR lua": {
        "prefix": "reaperwr.TrackFX_GetUserPresetFilename",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string fn} = reaper.TrackFX_GetUserPresetFilename(${3:MediaTrack track},${4:integer fx},${5:string fn})$0"
    },
    "RPR_TRACKFX_GETUSERPRESETFILENAME_WR python": {
        "prefix": "WR_RPR_TrackFX_GetUserPresetFilename",
        "scope": "python",
        "description": "\n",
        "body": "${1:MediaTrack track},${2:Int fx},${3:String fn},${4:Int fn_sz} = RPR_TrackFX_GetUserPresetFilename(${5:track},${6:fx},${7:fn},${8:fn_sz})$0"
    },
    "TRACKFX_NAVIGATEPRESETS_WR c": {
        "prefix": "WR_TrackFX_NavigatePresets",
        "scope": "c",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:bool} = TrackFX_NavigatePresets(${2:MediaTrack* track},${3:int fx},${4:int presetmove})$0"
    },
    "TRACKFX_NAVIGATEPRESETS_WR eel2": {
        "prefix": "WR_TrackFX_NavigatePresets",
        "scope": "eel2",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:bool} = TrackFX_NavigatePresets(${2:MediaTrack track},${3:int fx},${4:int presetmove})$0"
    },
    "REAPER.TRACKFX_NAVIGATEPRESETS_WR lua": {
        "prefix": "reaperwr.TrackFX_NavigatePresets",
        "scope": "lua",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_NavigatePresets(${3:MediaTrack track},${4:integer fx},${5:integer presetmove})$0"
    },
    "RPR_TRACKFX_NAVIGATEPRESETS_WR python": {
        "prefix": "WR_RPR_TrackFX_NavigatePresets",
        "scope": "python",
        "description": "presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.\n",
        "body": "${1:Boolean} = RPR_TrackFX_NavigatePresets(${2:MediaTrack track},${3:Int fx},${4:Int presetmove})$0"
    },
    "TRACKFX_SETENABLED_WR c": {
        "prefix": "WR_TrackFX_SetEnabled",
        "scope": "c",
        "description": "See TrackFX_GetEnabled\n",
        "body": "${1:void} = TrackFX_SetEnabled(${2:MediaTrack* track},${3:int fx},${4:bool enabled})$0"
    },
    "TRACKFX_SETEQBANDENABLED_WR c": {
        "prefix": "WR_TrackFX_SetEQBandEnabled",
        "scope": "c",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_SetEQBandEnabled(${2:MediaTrack* track},${3:int fxidx},${4:int bandtype},${5:int bandidx},${6:bool enable})$0"
    },
    "TRACKFX_SETEQBANDENABLED_WR eel2": {
        "prefix": "WR_TrackFX_SetEQBandEnabled",
        "scope": "eel2",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_SetEQBandEnabled(${2:MediaTrack track},${3:int fxidx},${4:int bandtype},${5:int bandidx},${6:bool enable})$0"
    },
    "REAPER.TRACKFX_SETEQBANDENABLED_WR lua": {
        "prefix": "reaperwr.TrackFX_SetEQBandEnabled",
        "scope": "lua",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetEQBandEnabled(${3:MediaTrack track},${4:integer fxidx},${5:integer bandtype},${6:integer bandidx},${7:boolean enable})$0"
    },
    "RPR_TRACKFX_SETEQBANDENABLED_WR python": {
        "prefix": "WR_RPR_TrackFX_SetEQBandEnabled",
        "scope": "python",
        "description": "Enable or disable a ReaEQ band.\nReturns false if track/fxidx is not ReaEQ.\nBandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetEQBandEnabled(${2:MediaTrack track},${3:Int fxidx},${4:Int bandtype},${5:Int bandidx},${6:Boolean enable})$0"
    },
    "TRACKFX_SETEQPARAM_WR c": {
        "prefix": "WR_TrackFX_SetEQParam",
        "scope": "c",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_SetEQParam(${2:MediaTrack* track},${3:int fxidx},${4:int bandtype},${5:int bandidx},${6:int paramtype},${7:double val},${8:bool isnorm})$0"
    },
    "TRACKFX_SETEQPARAM_WR eel2": {
        "prefix": "WR_TrackFX_SetEQParam",
        "scope": "eel2",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:bool} = TrackFX_SetEQParam(${2:MediaTrack track},${3:int fxidx},${4:int bandtype},${5:int bandidx},${6:int paramtype},${7:val},${8:bool isnorm})$0"
    },
    "REAPER.TRACKFX_SETEQPARAM_WR lua": {
        "prefix": "reaperwr.TrackFX_SetEQParam",
        "scope": "lua",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetEQParam(${3:MediaTrack track},${4:integer fxidx},${5:integer bandtype},${6:integer bandidx},${7:integer paramtype},${8:number val},${9:boolean isnorm})$0"
    },
    "RPR_TRACKFX_SETEQPARAM_WR python": {
        "prefix": "WR_RPR_TrackFX_SetEQParam",
        "scope": "python",
        "description": "Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.\nBandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.\nBandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.\nParamtype (ignored for master gain): 0=freq, 1=gain, 2=Q.\nSee TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetEQParam(${2:MediaTrack track},${3:Int fxidx},${4:Int bandtype},${5:Int bandidx},${6:Int paramtype},${7:Float val},${8:Boolean isnorm})$0"
    },
    "TRACKFX_SETNAMEDCONFIGPARM_WR c": {
        "prefix": "WR_TrackFX_SetNamedConfigParm",
        "scope": "c",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:bool} = TrackFX_SetNamedConfigParm(${2:MediaTrack* track},${3:int fx},${4:const char* parmname},${5:const char* value})$0"
    },
    "TRACKFX_SETNAMEDCONFIGPARM_WR eel2": {
        "prefix": "WR_TrackFX_SetNamedConfigParm",
        "scope": "eel2",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:bool} = TrackFX_SetNamedConfigParm(${2:MediaTrack track},${3:int fx},${4:\"parmname\"},${5:\"value\"})$0"
    },
    "REAPER.TRACKFX_SETNAMEDCONFIGPARM_WR lua": {
        "prefix": "reaperwr.TrackFX_SetNamedConfigParm",
        "scope": "lua",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetNamedConfigParm(${3:MediaTrack track},${4:integer fx},${5:string parmname},${6:string value})$0"
    },
    "RPR_TRACKFX_SETNAMEDCONFIGPARM_WR python": {
        "prefix": "WR_RPR_TrackFX_SetNamedConfigParm",
        "scope": "python",
        "description": "sets plug-in specific named configuration value (returns true on success)\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetNamedConfigParm(${2:MediaTrack track},${3:Int fx},${4:String parmname},${5:String value})$0"
    },
    "TRACKFX_SETOFFLINE_WR c": {
        "prefix": "WR_TrackFX_SetOffline",
        "scope": "c",
        "description": "See TrackFX_GetOffline\n",
        "body": "${1:void} = TrackFX_SetOffline(${2:MediaTrack* track},${3:int fx},${4:bool offline})$0"
    },
    "TRACKFX_SETOPEN_WR c": {
        "prefix": "WR_TrackFX_SetOpen",
        "scope": "c",
        "description": "Open this FX UI. See TrackFX_GetOpen\n",
        "body": "${1:void} = TrackFX_SetOpen(${2:MediaTrack* track},${3:int fx},${4:bool open})$0"
    },
    "TRACKFX_SETPARAM_WR c": {
        "prefix": "WR_TrackFX_SetParam",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TrackFX_SetParam(${2:MediaTrack* track},${3:int fx},${4:int param},${5:double val})$0"
    },
    "TRACKFX_SETPARAM_WR eel2": {
        "prefix": "WR_TrackFX_SetParam",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_SetParam(${2:MediaTrack track},${3:int fx},${4:int param},${5:val})$0"
    },
    "REAPER.TRACKFX_SETPARAM_WR lua": {
        "prefix": "reaperwr.TrackFX_SetParam",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetParam(${3:MediaTrack track},${4:integer fx},${5:integer param},${6:number val})$0"
    },
    "RPR_TRACKFX_SETPARAM_WR python": {
        "prefix": "WR_RPR_TrackFX_SetParam",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetParam(${2:MediaTrack track},${3:Int fx},${4:Int param},${5:Float val})$0"
    },
    "TRACKFX_SETPARAMNORMALIZED_WR c": {
        "prefix": "WR_TrackFX_SetParamNormalized",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = TrackFX_SetParamNormalized(${2:MediaTrack* track},${3:int fx},${4:int param},${5:double value})$0"
    },
    "TRACKFX_SETPARAMNORMALIZED_WR eel2": {
        "prefix": "WR_TrackFX_SetParamNormalized",
        "scope": "eel2",
        "description": "\n",
        "body": "${1:bool} = TrackFX_SetParamNormalized(${2:MediaTrack track},${3:int fx},${4:int param},${5:value})$0"
    },
    "REAPER.TRACKFX_SETPARAMNORMALIZED_WR lua": {
        "prefix": "reaperwr.TrackFX_SetParamNormalized",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetParamNormalized(${3:MediaTrack track},${4:integer fx},${5:integer param},${6:number value})$0"
    },
    "RPR_TRACKFX_SETPARAMNORMALIZED_WR python": {
        "prefix": "WR_RPR_TrackFX_SetParamNormalized",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetParamNormalized(${2:MediaTrack track},${3:Int fx},${4:Int param},${5:Float value})$0"
    },
    "TRACKFX_SETPINMAPPINGS_WR c": {
        "prefix": "WR_TrackFX_SetPinMappings",
        "scope": "c",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:bool} = TrackFX_SetPinMappings(${2:MediaTrack* tr},${3:int fx},${4:int isoutput},${5:int pin},${6:int low32bits},${7:int hi32bits})$0"
    },
    "TRACKFX_SETPINMAPPINGS_WR eel2": {
        "prefix": "WR_TrackFX_SetPinMappings",
        "scope": "eel2",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:bool} = TrackFX_SetPinMappings(${2:MediaTrack tr},${3:int fx},${4:int isoutput},${5:int pin},${6:int low32bits},${7:int hi32bits})$0"
    },
    "REAPER.TRACKFX_SETPINMAPPINGS_WR lua": {
        "prefix": "reaperwr.TrackFX_SetPinMappings",
        "scope": "lua",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetPinMappings(${3:MediaTrack tr},${4:integer fx},${5:integer isoutput},${6:integer pin},${7:integer low32bits},${8:integer hi32bits})$0"
    },
    "RPR_TRACKFX_SETPINMAPPINGS_WR python": {
        "prefix": "WR_RPR_TrackFX_SetPinMappings",
        "scope": "python",
        "description": "sets the channel mapping bitmask for a particular pin. returns false if\nunsupported (not all types of plug-ins support this capability)\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetPinMappings(${2:MediaTrack tr},${3:Int fx},${4:Int isoutput},${5:Int pin},${6:Int low32bits},${7:Int hi32bits})$0"
    },
    "TRACKFX_SETPRESET_WR c": {
        "prefix": "WR_TrackFX_SetPreset",
        "scope": "c",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "${1:bool} = TrackFX_SetPreset(${2:MediaTrack* track},${3:int fx},${4:const char* presetname})$0"
    },
    "TRACKFX_SETPRESET_WR eel2": {
        "prefix": "WR_TrackFX_SetPreset",
        "scope": "eel2",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "${1:bool} = TrackFX_SetPreset(${2:MediaTrack track},${3:int fx},${4:\"presetname\"})$0"
    },
    "REAPER.TRACKFX_SETPRESET_WR lua": {
        "prefix": "reaperwr.TrackFX_SetPreset",
        "scope": "lua",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetPreset(${3:MediaTrack track},${4:integer fx},${5:string presetname})$0"
    },
    "RPR_TRACKFX_SETPRESET_WR python": {
        "prefix": "WR_RPR_TrackFX_SetPreset",
        "scope": "python",
        "description": "Activate a preset with the name shown in the REAPER dropdown. Full paths\nto .vstpreset files are also supported for VST3 plug-ins. See TrackFX_GetPreset.\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetPreset(${2:MediaTrack track},${3:Int fx},${4:String presetname})$0"
    },
    "TRACKFX_SETPRESETBYINDEX_WR c": {
        "prefix": "WR_TrackFX_SetPresetByIndex",
        "scope": "c",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "${1:bool} = TrackFX_SetPresetByIndex(${2:MediaTrack* track},${3:int fx},${4:int idx})$0"
    },
    "TRACKFX_SETPRESETBYINDEX_WR eel2": {
        "prefix": "WR_TrackFX_SetPresetByIndex",
        "scope": "eel2",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "${1:bool} = TrackFX_SetPresetByIndex(${2:MediaTrack track},${3:int fx},${4:int idx})$0"
    },
    "REAPER.TRACKFX_SETPRESETBYINDEX_WR lua": {
        "prefix": "reaperwr.TrackFX_SetPresetByIndex",
        "scope": "lua",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "${1:local }${2:boolean} = reaper.TrackFX_SetPresetByIndex(${3:MediaTrack track},${4:integer fx},${5:integer idx})$0"
    },
    "RPR_TRACKFX_SETPRESETBYINDEX_WR python": {
        "prefix": "WR_RPR_TrackFX_SetPresetByIndex",
        "scope": "python",
        "description": "Sets the preset idx, or the factory preset (idx==-2), or the default user preset (idx==-1). Returns true on success. See TrackFX_GetPresetIndex.\n",
        "body": "${1:Boolean} = RPR_TrackFX_SetPresetByIndex(${2:MediaTrack track},${3:Int fx},${4:Int idx})$0"
    },
    "TRACKFX_SHOW_WR c": {
        "prefix": "WR_TrackFX_Show",
        "scope": "c",
        "description": "showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide\nfloating window(index valid), =3 for show floating window (index valid)\n",
        "body": "${1:void} = TrackFX_Show(${2:MediaTrack* track},${3:int index},${4:int showFlag})$0"
    },
    "TRACKLIST_ADJUSTWINDOWS_WR c": {
        "prefix": "WR_TrackList_AdjustWindows",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = TrackList_AdjustWindows(${2:bool isMinor})$0"
    },
    "TRACKLIST_UPDATEALLEXTERNALSURFACES_WR c": {
        "prefix": "WR_TrackList_UpdateAllExternalSurfaces",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = TrackList_UpdateAllExternalSurfaces()$0"
    },
    "UNDO_BEGINBLOCK_WR c": {
        "prefix": "WR_Undo_BeginBlock",
        "scope": "c",
        "description": "call to start a new block\n",
        "body": "${1:void} = Undo_BeginBlock()$0"
    },
    "UNDO_BEGINBLOCK2_WR c": {
        "prefix": "WR_Undo_BeginBlock2",
        "scope": "c",
        "description": "call to start a new block\n",
        "body": "${1:void} = Undo_BeginBlock2(${2:ReaProject* proj})$0"
    },
    "UNDO_CANREDO2_WR c": {
        "prefix": "WR_Undo_CanRedo2",
        "scope": "c",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "${1:const char*} = Undo_CanRedo2(${2:ReaProject* proj})$0"
    },
    "UNDO_CANREDO2_WR eel2": {
        "prefix": "WR_Undo_CanRedo2",
        "scope": "eel2",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "${1:bool} = Undo_CanRedo2(${2:#retval},${3:ReaProject proj})$0"
    },
    "REAPER.UNDO_CANREDO2_WR lua": {
        "prefix": "reaperwr.Undo_CanRedo2",
        "scope": "lua",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "${1:local }${2:string} = reaper.Undo_CanRedo2(${3:ReaProject proj})$0"
    },
    "RPR_UNDO_CANREDO2_WR python": {
        "prefix": "WR_RPR_Undo_CanRedo2",
        "scope": "python",
        "description": "returns string of next action,if able,NULL if not\n",
        "body": "${1:String} = RPR_Undo_CanRedo2(${2:ReaProject proj})$0"
    },
    "UNDO_CANUNDO2_WR c": {
        "prefix": "WR_Undo_CanUndo2",
        "scope": "c",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "${1:const char*} = Undo_CanUndo2(${2:ReaProject* proj})$0"
    },
    "UNDO_CANUNDO2_WR eel2": {
        "prefix": "WR_Undo_CanUndo2",
        "scope": "eel2",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "${1:bool} = Undo_CanUndo2(${2:#retval},${3:ReaProject proj})$0"
    },
    "REAPER.UNDO_CANUNDO2_WR lua": {
        "prefix": "reaperwr.Undo_CanUndo2",
        "scope": "lua",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "${1:local }${2:string} = reaper.Undo_CanUndo2(${3:ReaProject proj})$0"
    },
    "RPR_UNDO_CANUNDO2_WR python": {
        "prefix": "WR_RPR_Undo_CanUndo2",
        "scope": "python",
        "description": "returns string of last action,if able,NULL if not\n",
        "body": "${1:String} = RPR_Undo_CanUndo2(${2:ReaProject proj})$0"
    },
    "UNDO_DOREDO2_WR c": {
        "prefix": "WR_Undo_DoRedo2",
        "scope": "c",
        "description": "nonzero if success\n",
        "body": "${1:int} = Undo_DoRedo2(${2:ReaProject* proj})$0"
    },
    "UNDO_DOREDO2_WR eel2": {
        "prefix": "WR_Undo_DoRedo2",
        "scope": "eel2",
        "description": "nonzero if success\n",
        "body": "${1:int} = Undo_DoRedo2(${2:ReaProject proj})$0"
    },
    "REAPER.UNDO_DOREDO2_WR lua": {
        "prefix": "reaperwr.Undo_DoRedo2",
        "scope": "lua",
        "description": "nonzero if success\n",
        "body": "${1:local }${2:integer} = reaper.Undo_DoRedo2(${3:ReaProject proj})$0"
    },
    "RPR_UNDO_DOREDO2_WR python": {
        "prefix": "WR_RPR_Undo_DoRedo2",
        "scope": "python",
        "description": "nonzero if success\n",
        "body": "${1:Int} = RPR_Undo_DoRedo2(${2:ReaProject proj})$0"
    },
    "UNDO_DOUNDO2_WR c": {
        "prefix": "WR_Undo_DoUndo2",
        "scope": "c",
        "description": "nonzero if success\n",
        "body": "${1:int} = Undo_DoUndo2(${2:ReaProject* proj})$0"
    },
    "UNDO_DOUNDO2_WR eel2": {
        "prefix": "WR_Undo_DoUndo2",
        "scope": "eel2",
        "description": "nonzero if success\n",
        "body": "${1:int} = Undo_DoUndo2(${2:ReaProject proj})$0"
    },
    "REAPER.UNDO_DOUNDO2_WR lua": {
        "prefix": "reaperwr.Undo_DoUndo2",
        "scope": "lua",
        "description": "nonzero if success\n",
        "body": "${1:local }${2:integer} = reaper.Undo_DoUndo2(${3:ReaProject proj})$0"
    },
    "RPR_UNDO_DOUNDO2_WR python": {
        "prefix": "WR_RPR_Undo_DoUndo2",
        "scope": "python",
        "description": "nonzero if success\n",
        "body": "${1:Int} = RPR_Undo_DoUndo2(${2:ReaProject proj})$0"
    },
    "UNDO_ENDBLOCK_WR c": {
        "prefix": "WR_Undo_EndBlock",
        "scope": "c",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "${1:void} = Undo_EndBlock(${2:const char* descchange},${3:int extraflags})$0"
    },
    "UNDO_ENDBLOCK2_WR c": {
        "prefix": "WR_Undo_EndBlock2",
        "scope": "c",
        "description": "call to end the block,with extra flags if any,and a description\n",
        "body": "${1:void} = Undo_EndBlock2(${2:ReaProject* proj},${3:const char* descchange},${4:int extraflags})$0"
    },
    "UNDO_ONSTATECHANGE_WR c": {
        "prefix": "WR_Undo_OnStateChange",
        "scope": "c",
        "description": "limited state change to items\n",
        "body": "${1:void} = Undo_OnStateChange(${2:const char* descchange})$0"
    },
    "UNDO_ONSTATECHANGE2_WR c": {
        "prefix": "WR_Undo_OnStateChange2",
        "scope": "c",
        "description": "limited state change to items\n",
        "body": "${1:void} = Undo_OnStateChange2(${2:ReaProject* proj},${3:const char* descchange})$0"
    },
    "UNDO_ONSTATECHANGE_ITEM_WR c": {
        "prefix": "WR_Undo_OnStateChange_Item",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = Undo_OnStateChange_Item(${2:ReaProject* proj},${3:const char* name},${4:MediaItem* item})$0"
    },
    "UNDO_ONSTATECHANGEEX_WR c": {
        "prefix": "WR_Undo_OnStateChangeEx",
        "scope": "c",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "${1:void} = Undo_OnStateChangeEx(${2:const char* descchange},${3:int whichStates},${4:int trackparm})$0"
    },
    "UNDO_ONSTATECHANGEEX2_WR c": {
        "prefix": "WR_Undo_OnStateChangeEx2",
        "scope": "c",
        "description": "trackparm=-1 by default,or if updating one fx chain,you can specify track index\n",
        "body": "${1:void} = Undo_OnStateChangeEx2(${2:ReaProject* proj},${3:const char* descchange},${4:int whichStates},${5:int trackparm})$0"
    },
    "UPDATEARRANGE_WR c": {
        "prefix": "WR_UpdateArrange",
        "scope": "c",
        "description": "Redraw the arrange view\n",
        "body": "${1:void} = UpdateArrange()$0"
    },
    "UPDATEITEMINPROJECT_WR c": {
        "prefix": "WR_UpdateItemInProject",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = UpdateItemInProject(${2:MediaItem* item})$0"
    },
    "UPDATETIMELINE_WR c": {
        "prefix": "WR_UpdateTimeline",
        "scope": "c",
        "description": "Redraw the arrange view and ruler\n",
        "body": "${1:void} = UpdateTimeline()$0"
    },
    "VALIDATEPTR_WR c": {
        "prefix": "WR_ValidatePtr",
        "scope": "c",
        "description": "see ValidatePtr2\n",
        "body": "${1:bool} = ValidatePtr(${2:void* pointer},${3:const char* ctypename})$0"
    },
    "VALIDATEPTR_WR eel2": {
        "prefix": "WR_ValidatePtr",
        "scope": "eel2",
        "description": "see ValidatePtr2\n",
        "body": "${1:bool} = ValidatePtr(${2:void* pointer},${3:\"ctypename\"})$0"
    },
    "REAPER.VALIDATEPTR_WR lua": {
        "prefix": "reaperwr.ValidatePtr",
        "scope": "lua",
        "description": "see ValidatePtr2\n",
        "body": "${1:local }${2:boolean} = reaper.ValidatePtr(${3:identifier pointer},${4:string ctypename})$0"
    },
    "RPR_VALIDATEPTR_WR python": {
        "prefix": "WR_RPR_ValidatePtr",
        "scope": "python",
        "description": "see ValidatePtr2\n",
        "body": "${1:Boolean} = RPR_ValidatePtr(${2:void pointer},${3:String ctypename})$0"
    },
    "VALIDATEPTR2_WR c": {
        "prefix": "WR_ValidatePtr2",
        "scope": "c",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "${1:bool} = ValidatePtr2(${2:ReaProject* proj},${3:void* pointer},${4:const char* ctypename})$0"
    },
    "VALIDATEPTR2_WR eel2": {
        "prefix": "WR_ValidatePtr2",
        "scope": "eel2",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "${1:bool} = ValidatePtr2(${2:ReaProject proj},${3:void* pointer},${4:\"ctypename\"})$0"
    },
    "REAPER.VALIDATEPTR2_WR lua": {
        "prefix": "reaperwr.ValidatePtr2",
        "scope": "lua",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "${1:local }${2:boolean} = reaper.ValidatePtr2(${3:ReaProject proj},${4:identifier pointer},${5:string ctypename})$0"
    },
    "RPR_VALIDATEPTR2_WR python": {
        "prefix": "WR_RPR_ValidatePtr2",
        "scope": "python",
        "description": "Return true if the pointer is a valid object of the right type in proj\n(proj is ignored if pointer is itself a project). Supported types are:\nReaProject*, MediaTrack*, MediaItem*, MediaItem_Take*, TrackEnvelope*\nand PCM_source*.\n",
        "body": "${1:Boolean} = RPR_ValidatePtr2(${2:ReaProject proj},${3:void pointer},${4:String ctypename})$0"
    },
    "VIEWPREFS_WR c": {
        "prefix": "WR_ViewPrefs",
        "scope": "c",
        "description": "Opens the prefs to a page, use pageByName if page is 0.\n",
        "body": "${1:void} = ViewPrefs(${2:int page},${3:const char* pageByName})$0"
    },
    "BR_ENVALLOC_WR c": {
        "prefix": "WR_BR_EnvAlloc",
        "scope": "c",
        "description": "[BR] Allocate envelope object from track or take envelope pointer. Always call BR_EnvFree when done to release the object and commit changes if needed.\ntakeEnvelopesUseProjectTime: take envelope points' positions are\ncounted from take position, not project start time. If you want to work\nwith project time instead, pass this as true.\nFor further manipulation see BR_EnvCountPoints, BR_EnvDeletePoint, BR_EnvFind, BR_EnvFindNext, BR_EnvFindPrevious, BR_EnvGetParentTake, BR_EnvGetParentTrack, BR_EnvGetPoint, BR_EnvGetProperties, BR_EnvSetPoint, BR_EnvSetProperties, BR_EnvValueAtPos.\n",
        "body": "${1:BR_Envelope*} = BR_EnvAlloc(${2:TrackEnvelope* envelope},${3:bool takeEnvelopesUseProjectTime})$0"
    },
    "EXTENSION_API_WR eel2": {
        "prefix": "WR_extension_api",
        "scope": "eel2",
        "description": "Stop audio preview. id -1 stops all.\n",
        "body": "${1:int} = extension_api(${2:\"Xen_StopSourcePreview\"},${3:int preview_id})$0"
    },
    "REAPER.BR_ENVALLOC_WR lua": {
        "prefix": "reaperwr.BR_EnvAlloc",
        "scope": "lua",
        "description": "[BR] Allocate envelope object from track or take envelope pointer. Always call BR_EnvFree when done to release the object and commit changes if needed.\ntakeEnvelopesUseProjectTime: take envelope points' positions are\ncounted from take position, not project start time. If you want to work\nwith project time instead, pass this as true.\nFor further manipulation see BR_EnvCountPoints, BR_EnvDeletePoint, BR_EnvFind, BR_EnvFindNext, BR_EnvFindPrevious, BR_EnvGetParentTake, BR_EnvGetParentTrack, BR_EnvGetPoint, BR_EnvGetProperties, BR_EnvSetPoint, BR_EnvSetProperties, BR_EnvValueAtPos.\n",
        "body": "${1:local }${2:BR_Envelope} = reaper.BR_EnvAlloc(${3:TrackEnvelope envelope},${4:boolean takeEnvelopesUseProjectTime})$0"
    },
    "BR_ENVALLOC_WR python": {
        "prefix": "WR_BR_EnvAlloc",
        "scope": "python",
        "description": "[BR] Allocate envelope object from track or take envelope pointer. Always call BR_EnvFree when done to release the object and commit changes if needed.\ntakeEnvelopesUseProjectTime: take envelope points' positions are\ncounted from take position, not project start time. If you want to work\nwith project time instead, pass this as true.\nFor further manipulation see BR_EnvCountPoints, BR_EnvDeletePoint, BR_EnvFind, BR_EnvFindNext, BR_EnvFindPrevious, BR_EnvGetParentTake, BR_EnvGetParentTrack, BR_EnvGetPoint, BR_EnvGetProperties, BR_EnvSetPoint, BR_EnvSetProperties, BR_EnvValueAtPos.\n",
        "body": "${1:BR_Envelope} = BR_EnvAlloc(${2:TrackEnvelope envelope},${3:Boolean takeEnvelopesUseProjectTime})$0"
    },
    "BR_ENVCOUNTPOINTS_WR c": {
        "prefix": "WR_BR_EnvCountPoints",
        "scope": "c",
        "description": "[BR] Count envelope points in the envelope object allocated with BR_EnvAlloc.\n",
        "body": "${1:int} = BR_EnvCountPoints(${2:BR_Envelope* envelope})$0"
    },
    "REAPER.BR_ENVCOUNTPOINTS_WR lua": {
        "prefix": "reaperwr.BR_EnvCountPoints",
        "scope": "lua",
        "description": "[BR] Count envelope points in the envelope object allocated with BR_EnvAlloc.\n",
        "body": "${1:local }${2:integer} = reaper.BR_EnvCountPoints(${3:BR_Envelope envelope})$0"
    },
    "BR_ENVCOUNTPOINTS_WR python": {
        "prefix": "WR_BR_EnvCountPoints",
        "scope": "python",
        "description": "[BR] Count envelope points in the envelope object allocated with BR_EnvAlloc.\n",
        "body": "${1:Int} = BR_EnvCountPoints(${2:BR_Envelope envelope})$0"
    },
    "BR_ENVDELETEPOINT_WR c": {
        "prefix": "WR_BR_EnvDeletePoint",
        "scope": "c",
        "description": "[BR] Delete envelope point by index (zero-based) in the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "${1:bool} = BR_EnvDeletePoint(${2:BR_Envelope* envelope},${3:int id})$0"
    },
    "REAPER.BR_ENVDELETEPOINT_WR lua": {
        "prefix": "reaperwr.BR_EnvDeletePoint",
        "scope": "lua",
        "description": "[BR] Delete envelope point by index (zero-based) in the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_EnvDeletePoint(${3:BR_Envelope envelope},${4:integer id})$0"
    },
    "BR_ENVDELETEPOINT_WR python": {
        "prefix": "WR_BR_EnvDeletePoint",
        "scope": "python",
        "description": "[BR] Delete envelope point by index (zero-based) in the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "${1:Boolean} = BR_EnvDeletePoint(${2:BR_Envelope envelope},${3:Int id})$0"
    },
    "BR_ENVFIND_WR c": {
        "prefix": "WR_BR_EnvFind",
        "scope": "c",
        "description": "[BR] Find envelope point at time position in the envelope object allocated with BR_EnvAlloc.\nPass delta > 0 to search surrounding range - in that case the\nclosest point to position within delta will be searched for. Returns\nenvelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:int} = BR_EnvFind(${2:BR_Envelope* envelope},${3:double position},${4:double delta})$0"
    },
    "REAPER.BR_ENVFIND_WR lua": {
        "prefix": "reaperwr.BR_EnvFind",
        "scope": "lua",
        "description": "[BR] Find envelope point at time position in the envelope object allocated with BR_EnvAlloc.\nPass delta > 0 to search surrounding range - in that case the\nclosest point to position within delta will be searched for. Returns\nenvelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:local }${2:integer} = reaper.BR_EnvFind(${3:BR_Envelope envelope},${4:number position},${5:number delta})$0"
    },
    "BR_ENVFIND_WR python": {
        "prefix": "WR_BR_EnvFind",
        "scope": "python",
        "description": "[BR] Find envelope point at time position in the envelope object allocated with BR_EnvAlloc.\nPass delta > 0 to search surrounding range - in that case the\nclosest point to position within delta will be searched for. Returns\nenvelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:Int} = BR_EnvFind(${2:BR_Envelope envelope},${3:Float position},${4:Float delta})$0"
    },
    "BR_ENVFINDNEXT_WR c": {
        "prefix": "WR_BR_EnvFindNext",
        "scope": "c",
        "description": "[BR] Find next envelope point after time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:int} = BR_EnvFindNext(${2:BR_Envelope* envelope},${3:double position})$0"
    },
    "REAPER.BR_ENVFINDNEXT_WR lua": {
        "prefix": "reaperwr.BR_EnvFindNext",
        "scope": "lua",
        "description": "[BR] Find next envelope point after time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:local }${2:integer} = reaper.BR_EnvFindNext(${3:BR_Envelope envelope},${4:number position})$0"
    },
    "BR_ENVFINDNEXT_WR python": {
        "prefix": "WR_BR_EnvFindNext",
        "scope": "python",
        "description": "[BR] Find next envelope point after time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:Int} = BR_EnvFindNext(${2:BR_Envelope envelope},${3:Float position})$0"
    },
    "BR_ENVFINDPREVIOUS_WR c": {
        "prefix": "WR_BR_EnvFindPrevious",
        "scope": "c",
        "description": "[BR] Find previous envelope point before time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:int} = BR_EnvFindPrevious(${2:BR_Envelope* envelope},${3:double position})$0"
    },
    "REAPER.BR_ENVFINDPREVIOUS_WR lua": {
        "prefix": "reaperwr.BR_EnvFindPrevious",
        "scope": "lua",
        "description": "[BR] Find previous envelope point before time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:local }${2:integer} = reaper.BR_EnvFindPrevious(${3:BR_Envelope envelope},${4:number position})$0"
    },
    "BR_ENVFINDPREVIOUS_WR python": {
        "prefix": "WR_BR_EnvFindPrevious",
        "scope": "python",
        "description": "[BR] Find previous envelope point before time position in the envelope object allocated with BR_EnvAlloc. Returns envelope point id (zero-based) on success or -1 on failure.\n",
        "body": "${1:Int} = BR_EnvFindPrevious(${2:BR_Envelope envelope},${3:Float position})$0"
    },
    "BR_ENVFREE_WR c": {
        "prefix": "WR_BR_EnvFree",
        "scope": "c",
        "description": "[BR] Free envelope object allocated with BR_EnvAlloc\nand commit changes if needed. Returns true if changes were committed\nsuccessfully. Note that when envelope object wasn't modified nothing\nwill get committed even if commit = true - in that case function returns\nfalse.\n",
        "body": "${1:bool} = BR_EnvFree(${2:BR_Envelope* envelope},${3:bool commit})$0"
    },
    "REAPER.BR_ENVFREE_WR lua": {
        "prefix": "reaperwr.BR_EnvFree",
        "scope": "lua",
        "description": "[BR] Free envelope object allocated with BR_EnvAlloc\nand commit changes if needed. Returns true if changes were committed\nsuccessfully. Note that when envelope object wasn't modified nothing\nwill get committed even if commit = true - in that case function returns\nfalse.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_EnvFree(${3:BR_Envelope envelope},${4:boolean commit})$0"
    },
    "BR_ENVFREE_WR python": {
        "prefix": "WR_BR_EnvFree",
        "scope": "python",
        "description": "[BR] Free envelope object allocated with BR_EnvAlloc\nand commit changes if needed. Returns true if changes were committed\nsuccessfully. Note that when envelope object wasn't modified nothing\nwill get committed even if commit = true - in that case function returns\nfalse.\n",
        "body": "${1:Boolean} = BR_EnvFree(${2:BR_Envelope envelope},${3:Boolean commit})$0"
    },
    "BR_ENVGETPARENTTAKE_WR c": {
        "prefix": "WR_BR_EnvGetParentTake",
        "scope": "c",
        "description": "[BR] If envelope object allocated with BR_EnvAlloc is take envelope, returns parent media item take, otherwise NULL.\n",
        "body": "${1:MediaItem_Take*} = BR_EnvGetParentTake(${2:BR_Envelope* envelope})$0"
    },
    "REAPER.BR_ENVGETPARENTTAKE_WR lua": {
        "prefix": "reaperwr.BR_EnvGetParentTake",
        "scope": "lua",
        "description": "[BR] If envelope object allocated with BR_EnvAlloc is take envelope, returns parent media item take, otherwise NULL.\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.BR_EnvGetParentTake(${3:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPARENTTAKE_WR python": {
        "prefix": "WR_BR_EnvGetParentTake",
        "scope": "python",
        "description": "[BR] If envelope object allocated with BR_EnvAlloc is take envelope, returns parent media item take, otherwise NULL.\n",
        "body": "${1:MediaItem_Take} = BR_EnvGetParentTake(${2:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPARENTTRACK_WR c": {
        "prefix": "WR_BR_EnvGetParentTrack",
        "scope": "c",
        "description": "[BR] Get parent track of envelope object allocated with BR_EnvAlloc. If take envelope, returns NULL.\n",
        "body": "${1:MediaItem*} = BR_EnvGetParentTrack(${2:BR_Envelope* envelope})$0"
    },
    "REAPER.BR_ENVGETPARENTTRACK_WR lua": {
        "prefix": "reaperwr.BR_EnvGetParentTrack",
        "scope": "lua",
        "description": "[BR] Get parent track of envelope object allocated with BR_EnvAlloc. If take envelope, returns NULL.\n",
        "body": "${1:local }${2:MediaItem} = reaper.BR_EnvGetParentTrack(${3:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPARENTTRACK_WR python": {
        "prefix": "WR_BR_EnvGetParentTrack",
        "scope": "python",
        "description": "[BR] Get parent track of envelope object allocated with BR_EnvAlloc. If take envelope, returns NULL.\n",
        "body": "${1:MediaItem} = BR_EnvGetParentTrack(${2:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPOINT_WR c": {
        "prefix": "WR_BR_EnvGetPoint",
        "scope": "c",
        "description": "[BR] Get envelope point by id (zero-based) from the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "${1:bool} = BR_EnvGetPoint(${2:BR_Envelope* envelope},${3:int id},${4:double* positionOut},${5:double* valueOut},${6:int* shapeOut},${7:bool* selectedOut},${8:double* bezierOut})$0"
    },
    "REAPER.BR_ENVGETPOINT_WR lua": {
        "prefix": "reaperwr.BR_EnvGetPoint",
        "scope": "lua",
        "description": "[BR] Get envelope point by id (zero-based) from the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "${1:local }${2:boolean retval},${3:number position},${4:number value},${5:number shape},${6:boolean selected},${7:number bezier} = reaper.BR_EnvGetPoint(${8:BR_Envelope envelope},${9:integer id})$0"
    },
    "BR_ENVGETPOINT_WR python": {
        "prefix": "WR_BR_EnvGetPoint",
        "scope": "python",
        "description": "[BR] Get envelope point by id (zero-based) from the envelope object allocated with BR_EnvAlloc. Returns true on success.\n",
        "body": "${1:Boolean retval},${2:BR_Envelope envelope},${3:Int id},${4:Float positionOut},${5:Float valueOut},${6:Int shapeOut},${7:Boolean selectedOut},${8:Float bezierOut} = BR_EnvGetPoint(${9:envelope},${10:id},${11:positionOut},${12:valueOut},${13:shapeOut},${14:selectedOut},${15:bezierOut})$0"
    },
    "BR_ENVGETPROPERTIES_WR c": {
        "prefix": "WR_BR_EnvGetProperties",
        "scope": "c",
        "description": "[BR] Get envelope properties for the envelope object allocated with BR_EnvAlloc.\nactive: true if envelope is active\nvisible: true if envelope is visible\narmed: true if envelope is armed\ninLane: true if envelope has it's own envelope lane\nlaneHeight: envelope lane override height. 0 for none, otherwise size in pixels\ndefaultShape: default point shape: 0->Linear, 1->Square,\n2->Slow start/end, 3->Fast start, 4->Fast end, 5->Bezier\nminValue: minimum envelope value\nmaxValue: maximum envelope value\ntype: envelope type: 0->Volume, 1->Volume (Pre-FX), 2->Pan,\n3->Pan (Pre-FX), 4->Width, 5->Width (Pre-FX), 6->Mute,\n7->Pitch, 8->Playrate, 9->Tempo map, 10->Parameter\nfaderScaling: true if envelope uses fader scaling\n",
        "body": "${1:void} = BR_EnvGetProperties(${2:BR_Envelope* envelope},${3:bool* activeOut},${4:bool* visibleOut},${5:bool* armedOut},${6:bool* inLaneOut},${7:int* laneHeightOut},${8:int* defaultShapeOut},${9:double* minValueOut},${10:double* maxValueOut},${11:double* centerValueOut},${12:int* typeOut},${13:bool* faderScalingOut})$0"
    },
    "REAPER.BR_ENVGETPROPERTIES_WR lua": {
        "prefix": "reaperwr.BR_EnvGetProperties",
        "scope": "lua",
        "description": "[BR] Get envelope properties for the envelope object allocated with BR_EnvAlloc.\nactive: true if envelope is active\nvisible: true if envelope is visible\narmed: true if envelope is armed\ninLane: true if envelope has it's own envelope lane\nlaneHeight: envelope lane override height. 0 for none, otherwise size in pixels\ndefaultShape: default point shape: 0->Linear, 1->Square,\n2->Slow start/end, 3->Fast start, 4->Fast end, 5->Bezier\nminValue: minimum envelope value\nmaxValue: maximum envelope value\ntype: envelope type: 0->Volume, 1->Volume (Pre-FX), 2->Pan,\n3->Pan (Pre-FX), 4->Width, 5->Width (Pre-FX), 6->Mute,\n7->Pitch, 8->Playrate, 9->Tempo map, 10->Parameter\nfaderScaling: true if envelope uses fader scaling\n",
        "body": "${1:local }${2:boolean active},${3:boolean visible},${4:boolean armed},${5:boolean inLane},${6:number laneHeight},${7:number defaultShape},${8:number minValue},${9:number maxValue},${10:number centerValue},${11:number type},${12:boolean faderScaling} = reaper.BR_EnvGetProperties(${13:BR_Envelope envelope})$0"
    },
    "BR_ENVGETPROPERTIES_WR python": {
        "prefix": "WR_BR_EnvGetProperties",
        "scope": "python",
        "description": "[BR] Get envelope properties for the envelope object allocated with BR_EnvAlloc.\nactive: true if envelope is active\nvisible: true if envelope is visible\narmed: true if envelope is armed\ninLane: true if envelope has it's own envelope lane\nlaneHeight: envelope lane override height. 0 for none, otherwise size in pixels\ndefaultShape: default point shape: 0->Linear, 1->Square,\n2->Slow start/end, 3->Fast start, 4->Fast end, 5->Bezier\nminValue: minimum envelope value\nmaxValue: maximum envelope value\ntype: envelope type: 0->Volume, 1->Volume (Pre-FX), 2->Pan,\n3->Pan (Pre-FX), 4->Width, 5->Width (Pre-FX), 6->Mute,\n7->Pitch, 8->Playrate, 9->Tempo map, 10->Parameter\nfaderScaling: true if envelope uses fader scaling\n",
        "body": "${1:BR_Envelope envelope},${2:Boolean activeOut},${3:Boolean visibleOut},${4:Boolean armedOut},${5:Boolean inLaneOut},${6:Int laneHeightOut},${7:Int defaultShapeOut},${8:Float minValueOut},${9:Float maxValueOut},${10:Float centerValueOut},${11:Int typeOut},${12:Boolean faderScalingOut} = BR_EnvGetProperties(${13:envelope},${14:activeOut},${15:visibleOut},${16:armedOut},${17:inLaneOut},${18:laneHeightOut},${19:defaultShapeOut},${20:minValueOut},${21:maxValueOut},${22:centerValueOut},${23:typeOut},${24:faderScalingOut})$0"
    },
    "BR_ENVSETPOINT_WR c": {
        "prefix": "WR_BR_EnvSetPoint",
        "scope": "c",
        "description": "[BR] Set envelope point by id (zero-based) in the envelope object allocated with BR_EnvAlloc.\nTo create point instead, pass id = -1. Note that if new point is\ninserted or existing point's time position is changed, points won't\nautomatically get sorted. To do that, see BR_EnvSortPoints.\nReturns true on success.\n",
        "body": "${1:bool} = BR_EnvSetPoint(${2:BR_Envelope* envelope},${3:int id},${4:double position},${5:double value},${6:int shape},${7:bool selected},${8:double bezier})$0"
    },
    "REAPER.BR_ENVSETPOINT_WR lua": {
        "prefix": "reaperwr.BR_EnvSetPoint",
        "scope": "lua",
        "description": "[BR] Set envelope point by id (zero-based) in the envelope object allocated with BR_EnvAlloc.\nTo create point instead, pass id = -1. Note that if new point is\ninserted or existing point's time position is changed, points won't\nautomatically get sorted. To do that, see BR_EnvSortPoints.\nReturns true on success.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_EnvSetPoint(${3:BR_Envelope envelope},${4:integer id},${5:number position},${6:number value},${7:integer shape},${8:boolean selected},${9:number bezier})$0"
    },
    "BR_ENVSETPOINT_WR python": {
        "prefix": "WR_BR_EnvSetPoint",
        "scope": "python",
        "description": "[BR] Set envelope point by id (zero-based) in the envelope object allocated with BR_EnvAlloc.\nTo create point instead, pass id = -1. Note that if new point is\ninserted or existing point's time position is changed, points won't\nautomatically get sorted. To do that, see BR_EnvSortPoints.\nReturns true on success.\n",
        "body": "${1:Boolean} = BR_EnvSetPoint(${2:BR_Envelope envelope},${3:Int id},${4:Float position},${5:Float value},${6:Int shape},${7:Boolean selected},${8:Float bezier})$0"
    },
    "BR_ENVSETPROPERTIES_WR c": {
        "prefix": "WR_BR_EnvSetProperties",
        "scope": "c",
        "description": "[BR] Set envelope properties for the envelope object allocated with BR_EnvAlloc. For parameter description see BR_EnvGetProperties.\n",
        "body": "${1:void} = BR_EnvSetProperties(${2:BR_Envelope* envelope},${3:bool active},${4:bool visible},${5:bool armed},${6:bool inLane},${7:int laneHeight},${8:int defaultShape},${9:bool faderScaling})$0"
    },
    "BR_ENVSORTPOINTS_WR c": {
        "prefix": "WR_BR_EnvSortPoints",
        "scope": "c",
        "description": "[BR] Sort envelope points by position. The only reason to call this is\nif sorted points are explicitly needed after editing them with BR_EnvSetPoint. Note that you do not have to call this before doing BR_EnvFree since it does handle unsorted points too.\n",
        "body": "${1:void} = BR_EnvSortPoints(${2:BR_Envelope* envelope})$0"
    },
    "BR_ENVVALUEATPOS_WR c": {
        "prefix": "WR_BR_EnvValueAtPos",
        "scope": "c",
        "description": "[BR] Get envelope value at time position for the envelope object allocated with BR_EnvAlloc.\n",
        "body": "${1:double} = BR_EnvValueAtPos(${2:BR_Envelope* envelope},${3:double position})$0"
    },
    "REAPER.BR_ENVVALUEATPOS_WR lua": {
        "prefix": "reaperwr.BR_EnvValueAtPos",
        "scope": "lua",
        "description": "[BR] Get envelope value at time position for the envelope object allocated with BR_EnvAlloc.\n",
        "body": "${1:local }${2:number} = reaper.BR_EnvValueAtPos(${3:BR_Envelope envelope},${4:number position})$0"
    },
    "BR_ENVVALUEATPOS_WR python": {
        "prefix": "WR_BR_EnvValueAtPos",
        "scope": "python",
        "description": "[BR] Get envelope value at time position for the envelope object allocated with BR_EnvAlloc.\n",
        "body": "${1:Float} = BR_EnvValueAtPos(${2:BR_Envelope envelope},${3:Float position})$0"
    },
    "BR_GETARRANGEVIEW_WR c": {
        "prefix": "WR_BR_GetArrangeView",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Get start and end time position of arrange view. To set arrange view instead, see BR_SetArrangeView.\n",
        "body": "${1:void} = BR_GetArrangeView(${2:ReaProject* proj},${3:double* startTimeOut},${4:double* endTimeOut})$0"
    },
    "REAPER.BR_GETARRANGEVIEW_WR lua": {
        "prefix": "reaperwr.BR_GetArrangeView",
        "scope": "lua",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Get start and end time position of arrange view. To set arrange view instead, see BR_SetArrangeView.\n",
        "body": "${1:local }${2:number startTime},${3:number endTime} = reaper.BR_GetArrangeView(${4:ReaProject proj})$0"
    },
    "BR_GETARRANGEVIEW_WR python": {
        "prefix": "WR_BR_GetArrangeView",
        "scope": "python",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Get start and end time position of arrange view. To set arrange view instead, see BR_SetArrangeView.\n",
        "body": "${1:ReaProject proj},${2:Float startTimeOut},${3:Float endTimeOut} = BR_GetArrangeView(${4:proj},${5:startTimeOut},${6:endTimeOut})$0"
    },
    "BR_GETCLOSESTGRIDDIVISION_WR c": {
        "prefix": "WR_BR_GetClosestGridDivision",
        "scope": "c",
        "description": "[BR] Get closest grid division to position. Note that this functions is different from SnapToGrid\nin two regards. SnapToGrid() needs snap enabled to work and this one\nworks always. Secondly, grid divisions are different from grid lines\nbecause some grid lines may be hidden due to zoom level - this function\nignores grid line visibility and always searches for the closest grid\ndivision at given position. For more grid division functions, see BR_GetNextGridDivision and BR_GetPrevGridDivision.\n",
        "body": "${1:double} = BR_GetClosestGridDivision(${2:double position})$0"
    },
    "REAPER.BR_GETCLOSESTGRIDDIVISION_WR lua": {
        "prefix": "reaperwr.BR_GetClosestGridDivision",
        "scope": "lua",
        "description": "[BR] Get closest grid division to position. Note that this functions is different from SnapToGrid\nin two regards. SnapToGrid() needs snap enabled to work and this one\nworks always. Secondly, grid divisions are different from grid lines\nbecause some grid lines may be hidden due to zoom level - this function\nignores grid line visibility and always searches for the closest grid\ndivision at given position. For more grid division functions, see BR_GetNextGridDivision and BR_GetPrevGridDivision.\n",
        "body": "${1:local }${2:number} = reaper.BR_GetClosestGridDivision(${3:number position})$0"
    },
    "BR_GETCLOSESTGRIDDIVISION_WR python": {
        "prefix": "WR_BR_GetClosestGridDivision",
        "scope": "python",
        "description": "[BR] Get closest grid division to position. Note that this functions is different from SnapToGrid\nin two regards. SnapToGrid() needs snap enabled to work and this one\nworks always. Secondly, grid divisions are different from grid lines\nbecause some grid lines may be hidden due to zoom level - this function\nignores grid line visibility and always searches for the closest grid\ndivision at given position. For more grid division functions, see BR_GetNextGridDivision and BR_GetPrevGridDivision.\n",
        "body": "${1:Float} = BR_GetClosestGridDivision(${2:Float position})$0"
    },
    "BR_GETCURRENTTHEME_WR c": {
        "prefix": "WR_BR_GetCurrentTheme",
        "scope": "c",
        "description": "[BR] Get current theme information. themePathOut is set to full theme\npath and themeNameOut is set to theme name excluding any path info and\nextension\n",
        "body": "${1:void} = BR_GetCurrentTheme(${2:char* themePathOut},${3:int themePathOut_sz},${4:char* themeNameOut},${5:int themeNameOut_sz})$0"
    },
    "REAPER.BR_GETCURRENTTHEME_WR lua": {
        "prefix": "reaperwr.BR_GetCurrentTheme",
        "scope": "lua",
        "description": "[BR] Get current theme information. themePathOut is set to full theme\npath and themeNameOut is set to theme name excluding any path info and\nextension\n",
        "body": "${1:local }${2:string themePath},${3:string themeName} = reaper.BR_GetCurrentTheme()$0"
    },
    "BR_GETCURRENTTHEME_WR python": {
        "prefix": "WR_BR_GetCurrentTheme",
        "scope": "python",
        "description": "[BR] Get current theme information. themePathOut is set to full theme\npath and themeNameOut is set to theme name excluding any path info and\nextension\n",
        "body": "${1:String themePathOut},${2:Int themePathOut_sz},${3:String themeNameOut},${4:Int themeNameOut_sz} = BR_GetCurrentTheme(${5:themePathOut},${6:themePathOut_sz},${7:themeNameOut},${8:themeNameOut_sz})$0"
    },
    "BR_GETMEDIAITEMBYGUID_WR c": {
        "prefix": "WR_BR_GetMediaItemByGUID",
        "scope": "c",
        "description": "[BR] Get media item from GUID string. Note that the GUID must be enclosed in braces {}. To get item's GUID as a string, see BR_GetMediaItemGUID.\n",
        "body": "${1:MediaItem*} = BR_GetMediaItemByGUID(${2:ReaProject* proj},${3:const char* guidStringIn})$0"
    },
    "REAPER.BR_GETMEDIAITEMBYGUID_WR lua": {
        "prefix": "reaperwr.BR_GetMediaItemByGUID",
        "scope": "lua",
        "description": "[BR] Get media item from GUID string. Note that the GUID must be enclosed in braces {}. To get item's GUID as a string, see BR_GetMediaItemGUID.\n",
        "body": "${1:local }${2:MediaItem} = reaper.BR_GetMediaItemByGUID(${3:ReaProject proj},${4:string guidStringIn})$0"
    },
    "BR_GETMEDIAITEMBYGUID_WR python": {
        "prefix": "WR_BR_GetMediaItemByGUID",
        "scope": "python",
        "description": "[BR] Get media item from GUID string. Note that the GUID must be enclosed in braces {}. To get item's GUID as a string, see BR_GetMediaItemGUID.\n",
        "body": "${1:MediaItem} = BR_GetMediaItemByGUID(${2:ReaProject proj},${3:String guidStringIn})$0"
    },
    "BR_GETMEDIAITEMGUID_WR c": {
        "prefix": "WR_BR_GetMediaItemGUID",
        "scope": "c",
        "description": "[BR] Get media item GUID as a string (guidStringOut_sz should be at least 64). To get media item back from GUID string, see BR_GetMediaItemByGUID.\n",
        "body": "${1:void} = BR_GetMediaItemGUID(${2:MediaItem* item},${3:char* guidStringOut},${4:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMEDIAITEMGUID_WR lua": {
        "prefix": "reaperwr.BR_GetMediaItemGUID",
        "scope": "lua",
        "description": "[BR] Get media item GUID as a string (guidStringOut_sz should be at least 64). To get media item back from GUID string, see BR_GetMediaItemByGUID.\n",
        "body": "${1:local }${2:string guidString} = reaper.BR_GetMediaItemGUID(${3:MediaItem item})$0"
    },
    "BR_GETMEDIAITEMGUID_WR python": {
        "prefix": "WR_BR_GetMediaItemGUID",
        "scope": "python",
        "description": "[BR] Get media item GUID as a string (guidStringOut_sz should be at least 64). To get media item back from GUID string, see BR_GetMediaItemByGUID.\n",
        "body": "${1:MediaItem item},${2:String guidStringOut},${3:Int guidStringOut_sz} = BR_GetMediaItemGUID(${4:item},${5:guidStringOut},${6:guidStringOut_sz})$0"
    },
    "BR_GETMEDIAITEMIMAGERESOURCE_WR c": {
        "prefix": "WR_BR_GetMediaItemImageResource",
        "scope": "c",
        "description": "[BR] Get currently loaded image resource and it's flags for a given\nitem. Returns false if there is no image resource set. To set image\nresource, see BR_SetMediaItemImageResource.\n",
        "body": "${1:bool} = BR_GetMediaItemImageResource(${2:MediaItem* item},${3:char* imageOut},${4:int imageOut_sz},${5:int* imageFlagsOut})$0"
    },
    "REAPER.BR_GETMEDIAITEMIMAGERESOURCE_WR lua": {
        "prefix": "reaperwr.BR_GetMediaItemImageResource",
        "scope": "lua",
        "description": "[BR] Get currently loaded image resource and it's flags for a given\nitem. Returns false if there is no image resource set. To set image\nresource, see BR_SetMediaItemImageResource.\n",
        "body": "${1:local }${2:boolean retval},${3:string image},${4:number imageFlags} = reaper.BR_GetMediaItemImageResource(${5:MediaItem item})$0"
    },
    "BR_GETMEDIAITEMIMAGERESOURCE_WR python": {
        "prefix": "WR_BR_GetMediaItemImageResource",
        "scope": "python",
        "description": "[BR] Get currently loaded image resource and it's flags for a given\nitem. Returns false if there is no image resource set. To set image\nresource, see BR_SetMediaItemImageResource.\n",
        "body": "${1:Boolean retval},${2:MediaItem item},${3:String imageOut},${4:Int imageOut_sz},${5:Int imageFlagsOut} = BR_GetMediaItemImageResource(${6:item},${7:imageOut},${8:imageOut_sz},${9:imageFlagsOut})$0"
    },
    "BR_GETMEDIAITEMTAKEGUID_WR c": {
        "prefix": "WR_BR_GetMediaItemTakeGUID",
        "scope": "c",
        "description": "[BR] Get media item take GUID as a string (guidStringOut_sz should be at least 64). To get take from GUID string, see SNM_GetMediaItemTakeByGUID.\n",
        "body": "${1:void} = BR_GetMediaItemTakeGUID(${2:MediaItem_Take* take},${3:char* guidStringOut},${4:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMEDIAITEMTAKEGUID_WR lua": {
        "prefix": "reaperwr.BR_GetMediaItemTakeGUID",
        "scope": "lua",
        "description": "[BR] Get media item take GUID as a string (guidStringOut_sz should be at least 64). To get take from GUID string, see SNM_GetMediaItemTakeByGUID.\n",
        "body": "${1:local }${2:string guidString} = reaper.BR_GetMediaItemTakeGUID(${3:MediaItem_Take take})$0"
    },
    "BR_GETMEDIAITEMTAKEGUID_WR python": {
        "prefix": "WR_BR_GetMediaItemTakeGUID",
        "scope": "python",
        "description": "[BR] Get media item take GUID as a string (guidStringOut_sz should be at least 64). To get take from GUID string, see SNM_GetMediaItemTakeByGUID.\n",
        "body": "${1:MediaItem_Take take},${2:String guidStringOut},${3:Int guidStringOut_sz} = BR_GetMediaItemTakeGUID(${4:take},${5:guidStringOut},${6:guidStringOut_sz})$0"
    },
    "BR_GETMEDIASOURCEPROPERTIES_WR c": {
        "prefix": "WR_BR_GetMediaSourceProperties",
        "scope": "c",
        "description": "[BR] Get take media source properties as they appear in Item properties. Returns false if take can't have them (MIDI items etc.).\nTo set source properties, see BR_SetMediaSourceProperties.\n",
        "body": "${1:bool} = BR_GetMediaSourceProperties(${2:MediaItem_Take* take},${3:bool* sectionOut},${4:double* startOut},${5:double* lengthOut},${6:double* fadeOut},${7:bool* reverseOut})$0"
    },
    "REAPER.BR_GETMEDIASOURCEPROPERTIES_WR lua": {
        "prefix": "reaperwr.BR_GetMediaSourceProperties",
        "scope": "lua",
        "description": "[BR] Get take media source properties as they appear in Item properties. Returns false if take can't have them (MIDI items etc.).\nTo set source properties, see BR_SetMediaSourceProperties.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean section},${4:number start},${5:number length},${6:number fade},${7:boolean reverse} = reaper.BR_GetMediaSourceProperties(${8:MediaItem_Take take})$0"
    },
    "BR_GETMEDIASOURCEPROPERTIES_WR python": {
        "prefix": "WR_BR_GetMediaSourceProperties",
        "scope": "python",
        "description": "[BR] Get take media source properties as they appear in Item properties. Returns false if take can't have them (MIDI items etc.).\nTo set source properties, see BR_SetMediaSourceProperties.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Boolean sectionOut},${4:Float startOut},${5:Float lengthOut},${6:Float fadeOut},${7:Boolean reverseOut} = BR_GetMediaSourceProperties(${8:take},${9:sectionOut},${10:startOut},${11:lengthOut},${12:fadeOut},${13:reverseOut})$0"
    },
    "BR_GETMEDIATRACKBYGUID_WR c": {
        "prefix": "WR_BR_GetMediaTrackByGUID",
        "scope": "c",
        "description": "[BR] Get media track from GUID string. Note that the GUID must be enclosed in braces {}. To get track's GUID as a string, see BR_GetMediaTrackGUID.\n",
        "body": "${1:MediaTrack*} = BR_GetMediaTrackByGUID(${2:ReaProject* proj},${3:const char* guidStringIn})$0"
    },
    "REAPER.BR_GETMEDIATRACKBYGUID_WR lua": {
        "prefix": "reaperwr.BR_GetMediaTrackByGUID",
        "scope": "lua",
        "description": "[BR] Get media track from GUID string. Note that the GUID must be enclosed in braces {}. To get track's GUID as a string, see BR_GetMediaTrackGUID.\n",
        "body": "${1:local }${2:MediaTrack} = reaper.BR_GetMediaTrackByGUID(${3:ReaProject proj},${4:string guidStringIn})$0"
    },
    "BR_GETMEDIATRACKBYGUID_WR python": {
        "prefix": "WR_BR_GetMediaTrackByGUID",
        "scope": "python",
        "description": "[BR] Get media track from GUID string. Note that the GUID must be enclosed in braces {}. To get track's GUID as a string, see BR_GetMediaTrackGUID.\n",
        "body": "${1:MediaTrack} = BR_GetMediaTrackByGUID(${2:ReaProject proj},${3:String guidStringIn})$0"
    },
    "BR_GETMEDIATRACKFREEZECOUNT_WR c": {
        "prefix": "WR_BR_GetMediaTrackFreezeCount",
        "scope": "c",
        "description": "[BR] Get media track freeze count (if track isn't frozen at all, returns 0).\n",
        "body": "${1:int} = BR_GetMediaTrackFreezeCount(${2:MediaTrack* track})$0"
    },
    "REAPER.BR_GETMEDIATRACKFREEZECOUNT_WR lua": {
        "prefix": "reaperwr.BR_GetMediaTrackFreezeCount",
        "scope": "lua",
        "description": "[BR] Get media track freeze count (if track isn't frozen at all, returns 0).\n",
        "body": "${1:local }${2:integer} = reaper.BR_GetMediaTrackFreezeCount(${3:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKFREEZECOUNT_WR python": {
        "prefix": "WR_BR_GetMediaTrackFreezeCount",
        "scope": "python",
        "description": "[BR] Get media track freeze count (if track isn't frozen at all, returns 0).\n",
        "body": "${1:Int} = BR_GetMediaTrackFreezeCount(${2:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKGUID_WR c": {
        "prefix": "WR_BR_GetMediaTrackGUID",
        "scope": "c",
        "description": "[BR] Get media track GUID as a string (guidStringOut_sz should be at least 64). To get media track back from GUID string, see BR_GetMediaTrackByGUID.\n",
        "body": "${1:void} = BR_GetMediaTrackGUID(${2:MediaTrack* track},${3:char* guidStringOut},${4:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMEDIATRACKGUID_WR lua": {
        "prefix": "reaperwr.BR_GetMediaTrackGUID",
        "scope": "lua",
        "description": "[BR] Get media track GUID as a string (guidStringOut_sz should be at least 64). To get media track back from GUID string, see BR_GetMediaTrackByGUID.\n",
        "body": "${1:local }${2:string guidString} = reaper.BR_GetMediaTrackGUID(${3:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKGUID_WR python": {
        "prefix": "WR_BR_GetMediaTrackGUID",
        "scope": "python",
        "description": "[BR] Get media track GUID as a string (guidStringOut_sz should be at least 64). To get media track back from GUID string, see BR_GetMediaTrackByGUID.\n",
        "body": "${1:MediaTrack track},${2:String guidStringOut},${3:Int guidStringOut_sz} = BR_GetMediaTrackGUID(${4:track},${5:guidStringOut},${6:guidStringOut_sz})$0"
    },
    "BR_GETMEDIATRACKLAYOUTS_WR c": {
        "prefix": "WR_BR_GetMediaTrackLayouts",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Get media track layouts for MCP and TCP. Empty string\n(\"\") means that layout is set to the default layout. To set media track\nlayouts, see BR_SetMediaTrackLayouts.\n",
        "body": "${1:void} = BR_GetMediaTrackLayouts(${2:MediaTrack* track},${3:char* mcpLayoutNameOut},${4:int mcpLayoutNameOut_sz},${5:char* tcpLayoutNameOut},${6:int tcpLayoutNameOut_sz})$0"
    },
    "REAPER.BR_GETMEDIATRACKLAYOUTS_WR lua": {
        "prefix": "reaperwr.BR_GetMediaTrackLayouts",
        "scope": "lua",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Get media track layouts for MCP and TCP. Empty string\n(\"\") means that layout is set to the default layout. To set media track\nlayouts, see BR_SetMediaTrackLayouts.\n",
        "body": "${1:local }${2:string mcpLayoutName},${3:string tcpLayoutName} = reaper.BR_GetMediaTrackLayouts(${4:MediaTrack track})$0"
    },
    "BR_GETMEDIATRACKLAYOUTS_WR python": {
        "prefix": "WR_BR_GetMediaTrackLayouts",
        "scope": "python",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Get media track layouts for MCP and TCP. Empty string\n(\"\") means that layout is set to the default layout. To set media track\nlayouts, see BR_SetMediaTrackLayouts.\n",
        "body": "${1:MediaTrack track},${2:String mcpLayoutNameOut},${3:Int mcpLayoutNameOut_sz},${4:String tcpLayoutNameOut},${5:Int tcpLayoutNameOut_sz} = BR_GetMediaTrackLayouts(${6:track},${7:mcpLayoutNameOut},${8:mcpLayoutNameOut_sz},${9:tcpLayoutNameOut},${10:tcpLayoutNameOut_sz})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_ENVELOPE_WR c": {
        "prefix": "WR_BR_GetMediaTrackSendInfo_Envelope",
        "scope": "c",
        "description": "[BR] Get track envelope for send/receive/hardware output.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nenvelopeType determines which envelope is returned (0=volume, 1=pan, 2=mute)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "${1:TrackEnvelope*} = BR_GetMediaTrackSendInfo_Envelope(${2:MediaTrack* track},${3:int category},${4:int sendidx},${5:int envelopeType})$0"
    },
    "REAPER.BR_GETMEDIATRACKSENDINFO_ENVELOPE_WR lua": {
        "prefix": "reaperwr.BR_GetMediaTrackSendInfo_Envelope",
        "scope": "lua",
        "description": "[BR] Get track envelope for send/receive/hardware output.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nenvelopeType determines which envelope is returned (0=volume, 1=pan, 2=mute)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "${1:local }${2:TrackEnvelope} = reaper.BR_GetMediaTrackSendInfo_Envelope(${3:MediaTrack track},${4:integer category},${5:integer sendidx},${6:integer envelopeType})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_ENVELOPE_WR python": {
        "prefix": "WR_BR_GetMediaTrackSendInfo_Envelope",
        "scope": "python",
        "description": "[BR] Get track envelope for send/receive/hardware output.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nenvelopeType determines which envelope is returned (0=volume, 1=pan, 2=mute)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "${1:TrackEnvelope} = BR_GetMediaTrackSendInfo_Envelope(${2:MediaTrack track},${3:Int category},${4:Int sendidx},${5:Int envelopeType})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_TRACK_WR c": {
        "prefix": "WR_BR_GetMediaTrackSendInfo_Track",
        "scope": "c",
        "description": "[BR] Get source or destination media track for send/receive.\ncategory is <0 for receives, 0=sends\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives)\ntrackType determines which track is returned (0=source track, 1=destination track)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Envelope.\n",
        "body": "${1:MediaTrack*} = BR_GetMediaTrackSendInfo_Track(${2:MediaTrack* track},${3:int category},${4:int sendidx},${5:int trackType})$0"
    },
    "REAPER.BR_GETMEDIATRACKSENDINFO_TRACK_WR lua": {
        "prefix": "reaperwr.BR_GetMediaTrackSendInfo_Track",
        "scope": "lua",
        "description": "[BR] Get source or destination media track for send/receive.\ncategory is <0 for receives, 0=sends\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives)\ntrackType determines which track is returned (0=source track, 1=destination track)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Envelope.\n",
        "body": "${1:local }${2:MediaTrack} = reaper.BR_GetMediaTrackSendInfo_Track(${3:MediaTrack track},${4:integer category},${5:integer sendidx},${6:integer trackType})$0"
    },
    "BR_GETMEDIATRACKSENDINFO_TRACK_WR python": {
        "prefix": "WR_BR_GetMediaTrackSendInfo_Track",
        "scope": "python",
        "description": "[BR] Get source or destination media track for send/receive.\ncategory is <0 for receives, 0=sends\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives)\ntrackType determines which track is returned (0=source track, 1=destination track)\nNote: To get or set other send attributes, see BR_GetSetTrackSendInfo and BR_GetMediaTrackSendInfo_Envelope.\n",
        "body": "${1:MediaTrack} = BR_GetMediaTrackSendInfo_Track(${2:MediaTrack track},${3:Int category},${4:Int sendidx},${5:Int trackType})$0"
    },
    "BR_GETMIDISOURCELENPPQ_WR c": {
        "prefix": "WR_BR_GetMidiSourceLenPPQ",
        "scope": "c",
        "description": "[BR] Get MIDI take source length in PPQ. In case the take isn't MIDI, return value will be -1.\n",
        "body": "${1:double} = BR_GetMidiSourceLenPPQ(${2:MediaItem_Take* take})$0"
    },
    "REAPER.BR_GETMIDISOURCELENPPQ_WR lua": {
        "prefix": "reaperwr.BR_GetMidiSourceLenPPQ",
        "scope": "lua",
        "description": "[BR] Get MIDI take source length in PPQ. In case the take isn't MIDI, return value will be -1.\n",
        "body": "${1:local }${2:number} = reaper.BR_GetMidiSourceLenPPQ(${3:MediaItem_Take take})$0"
    },
    "BR_GETMIDISOURCELENPPQ_WR python": {
        "prefix": "WR_BR_GetMidiSourceLenPPQ",
        "scope": "python",
        "description": "[BR] Get MIDI take source length in PPQ. In case the take isn't MIDI, return value will be -1.\n",
        "body": "${1:Float} = BR_GetMidiSourceLenPPQ(${2:MediaItem_Take take})$0"
    },
    "BR_GETMIDITAKEPOOLGUID_WR c": {
        "prefix": "WR_BR_GetMidiTakePoolGUID",
        "scope": "c",
        "description": "[BR] Get MIDI take pool GUID as a string (guidStringOut_sz should be at least 64). Returns true if take is pooled.\n",
        "body": "${1:bool} = BR_GetMidiTakePoolGUID(${2:MediaItem_Take* take},${3:char* guidStringOut},${4:int guidStringOut_sz})$0"
    },
    "REAPER.BR_GETMIDITAKEPOOLGUID_WR lua": {
        "prefix": "reaperwr.BR_GetMidiTakePoolGUID",
        "scope": "lua",
        "description": "[BR] Get MIDI take pool GUID as a string (guidStringOut_sz should be at least 64). Returns true if take is pooled.\n",
        "body": "${1:local }${2:boolean retval},${3:string guidString} = reaper.BR_GetMidiTakePoolGUID(${4:MediaItem_Take take})$0"
    },
    "BR_GETMIDITAKEPOOLGUID_WR python": {
        "prefix": "WR_BR_GetMidiTakePoolGUID",
        "scope": "python",
        "description": "[BR] Get MIDI take pool GUID as a string (guidStringOut_sz should be at least 64). Returns true if take is pooled.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:String guidStringOut},${4:Int guidStringOut_sz} = BR_GetMidiTakePoolGUID(${5:take},${6:guidStringOut},${7:guidStringOut_sz})$0"
    },
    "BR_GETMIDITAKETEMPOINFO_WR c": {
        "prefix": "WR_BR_GetMidiTakeTempoInfo",
        "scope": "c",
        "description": "[BR] Get \"ignore project tempo\" information for MIDI take. Returns true\nif take can ignore project tempo (no matter if it's actually ignored),\notherwise false.\n",
        "body": "${1:bool} = BR_GetMidiTakeTempoInfo(${2:MediaItem_Take* take},${3:bool* ignoreProjTempoOut},${4:double* bpmOut},${5:int* numOut},${6:int* denOut})$0"
    },
    "REAPER.BR_GETMIDITAKETEMPOINFO_WR lua": {
        "prefix": "reaperwr.BR_GetMidiTakeTempoInfo",
        "scope": "lua",
        "description": "[BR] Get \"ignore project tempo\" information for MIDI take. Returns true\nif take can ignore project tempo (no matter if it's actually ignored),\notherwise false.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean ignoreProjTempo},${4:number bpm},${5:number num},${6:number den} = reaper.BR_GetMidiTakeTempoInfo(${7:MediaItem_Take take})$0"
    },
    "BR_GETMIDITAKETEMPOINFO_WR python": {
        "prefix": "WR_BR_GetMidiTakeTempoInfo",
        "scope": "python",
        "description": "[BR] Get \"ignore project tempo\" information for MIDI take. Returns true\nif take can ignore project tempo (no matter if it's actually ignored),\notherwise false.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Boolean ignoreProjTempoOut},${4:Float bpmOut},${5:Int numOut},${6:Int denOut} = BR_GetMidiTakeTempoInfo(${7:take},${8:ignoreProjTempoOut},${9:bpmOut},${10:numOut},${11:denOut})$0"
    },
    "BR_GETMOUSECURSORCONTEXT_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext",
        "scope": "c",
        "description": "[BR] Get mouse cursor context. Each parameter returns information in a form of string as specified in the table below.\nTo get more info on stuff that was found under mouse cursor see BR_GetMouseCursorContext_Envelope, BR_GetMouseCursorContext_Item, BR_GetMouseCursorContext_MIDI, BR_GetMouseCursorContext_Position, BR_GetMouseCursorContext_Take, BR_GetMouseCursorContext_Track\nWindow Segment Details  unknown       \"\"          \"\"                                                             ruler         region_lane   \"\"                                                              marker_lane   \"\"                                                              tempo_lane    \"\"                                                              timeline      \"\"                                                             transport     \"\"          \"\"                                                             tcp           track         \"\"                                                              envelope      \"\"                                                              empty         \"\"                                                             mcp           track         \"\"                                                              empty         \"\"                                                             arrange       track         empty,item, item_stretch_marker,env_point, env_segment    envelope      empty, env_point, env_segment                                     empty         \"\"                                                             midi_editor   unknown       \"\"                                                              ruler         \"\"                                                              piano         \"\"                                                              notes         \"\"                                                              cc_lane       cc_selector, cc_lane\n",
        "body": "${1:void} = BR_GetMouseCursorContext(${2:char* windowOut},${3:int windowOut_sz},${4:char* segmentOut},${5:int segmentOut_sz},${6:char* detailsOut},${7:int detailsOut_sz})$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext",
        "scope": "lua",
        "description": "[BR] Get mouse cursor context. Each parameter returns information in a form of string as specified in the table below.\nTo get more info on stuff that was found under mouse cursor see BR_GetMouseCursorContext_Envelope, BR_GetMouseCursorContext_Item, BR_GetMouseCursorContext_MIDI, BR_GetMouseCursorContext_Position, BR_GetMouseCursorContext_Take, BR_GetMouseCursorContext_Track\nWindow Segment Details  unknown       \"\"          \"\"                                                             ruler         region_lane   \"\"                                                              marker_lane   \"\"                                                              tempo_lane    \"\"                                                              timeline      \"\"                                                             transport     \"\"          \"\"                                                             tcp           track         \"\"                                                              envelope      \"\"                                                              empty         \"\"                                                             mcp           track         \"\"                                                              empty         \"\"                                                             arrange       track         empty,item, item_stretch_marker,env_point, env_segment    envelope      empty, env_point, env_segment                                     empty         \"\"                                                             midi_editor   unknown       \"\"                                                              ruler         \"\"                                                              piano         \"\"                                                              notes         \"\"                                                              cc_lane       cc_selector, cc_lane\n",
        "body": "${1:local }${2:string window},${3:string segment},${4:string details} = reaper.BR_GetMouseCursorContext()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext",
        "scope": "python",
        "description": "[BR] Get mouse cursor context. Each parameter returns information in a form of string as specified in the table below.\nTo get more info on stuff that was found under mouse cursor see BR_GetMouseCursorContext_Envelope, BR_GetMouseCursorContext_Item, BR_GetMouseCursorContext_MIDI, BR_GetMouseCursorContext_Position, BR_GetMouseCursorContext_Take, BR_GetMouseCursorContext_Track\nWindow Segment Details  unknown       \"\"          \"\"                                                             ruler         region_lane   \"\"                                                              marker_lane   \"\"                                                              tempo_lane    \"\"                                                              timeline      \"\"                                                             transport     \"\"          \"\"                                                             tcp           track         \"\"                                                              envelope      \"\"                                                              empty         \"\"                                                             mcp           track         \"\"                                                              empty         \"\"                                                             arrange       track         empty,item, item_stretch_marker,env_point, env_segment    envelope      empty, env_point, env_segment                                     empty         \"\"                                                             midi_editor   unknown       \"\"                                                              ruler         \"\"                                                              piano         \"\"                                                              notes         \"\"                                                              cc_lane       cc_selector, cc_lane\n",
        "body": "${1:String windowOut},${2:Int windowOut_sz},${3:String segmentOut},${4:Int segmentOut_sz},${5:String detailsOut},${6:Int detailsOut_sz} = BR_GetMouseCursorContext(${7:windowOut},${8:windowOut_sz},${9:segmentOut},${10:segmentOut_sz},${11:detailsOut},${12:detailsOut_sz})$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ENVELOPE_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext_Envelope",
        "scope": "c",
        "description": "[BR] Returns envelope that was captured with the last call to BR_GetMouseCursorContext. In case the envelope belongs to take, takeEnvelope will be true.\n",
        "body": "${1:TrackEnvelope*} = BR_GetMouseCursorContext_Envelope(${2:bool* takeEnvelopeOut})$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_ENVELOPE_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext_Envelope",
        "scope": "lua",
        "description": "[BR] Returns envelope that was captured with the last call to BR_GetMouseCursorContext. In case the envelope belongs to take, takeEnvelope will be true.\n",
        "body": "${1:local }${2:TrackEnvelope retval},${3:boolean takeEnvelope} = reaper.BR_GetMouseCursorContext_Envelope()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ENVELOPE_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext_Envelope",
        "scope": "python",
        "description": "[BR] Returns envelope that was captured with the last call to BR_GetMouseCursorContext. In case the envelope belongs to take, takeEnvelope will be true.\n",
        "body": "${1:TrackEnvelope retval},${2:Boolean takeEnvelopeOut} = BR_GetMouseCursorContext_Envelope(${3:takeEnvelopeOut})$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ITEM_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext_Item",
        "scope": "c",
        "description": "[BR] Returns item under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\nNote that the function will return item even if mouse cursor is over\nsome other track lane element like stretch marker or envelope. This\nenables for easier identification of items when you want to ignore\nelements within the item.\n",
        "body": "${1:MediaItem*} = BR_GetMouseCursorContext_Item()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_ITEM_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext_Item",
        "scope": "lua",
        "description": "[BR] Returns item under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\nNote that the function will return item even if mouse cursor is over\nsome other track lane element like stretch marker or envelope. This\nenables for easier identification of items when you want to ignore\nelements within the item.\n",
        "body": "${1:local }${2:MediaItem} = reaper.BR_GetMouseCursorContext_Item()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_ITEM_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext_Item",
        "scope": "python",
        "description": "[BR] Returns item under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\nNote that the function will return item even if mouse cursor is over\nsome other track lane element like stretch marker or envelope. This\nenables for easier identification of items when you want to ignore\nelements within the item.\n",
        "body": "${1:MediaItem} = BR_GetMouseCursorContext_Item()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_MIDI_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext_MIDI",
        "scope": "c",
        "description": "[BR] Returns midi editor under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\ninlineEditor: if mouse was captured in inline MIDI editor, this will be\ntrue (consequentially, returned MIDI editor will be NULL)\nnoteRow: note row or piano key under mouse cursor (0-127)\nccLane: CC lane under mouse cursor (CC0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events)\nccLaneVal: value in CC lane under mouse cursor (0-127 or 0-16383)\nccLaneId: lane position, counting from the top (0 based)\nNote: due to API limitations, if mouse is over inline MIDI editor with some note rows hidden, noteRow will be -1\n",
        "body": "${1:void*} = BR_GetMouseCursorContext_MIDI(${2:bool* inlineEditorOut},${3:int* noteRowOut},${4:int* ccLaneOut},${5:int* ccLaneValOut},${6:int* ccLaneIdOut})$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_MIDI_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext_MIDI",
        "scope": "lua",
        "description": "[BR] Returns midi editor under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\ninlineEditor: if mouse was captured in inline MIDI editor, this will be\ntrue (consequentially, returned MIDI editor will be NULL)\nnoteRow: note row or piano key under mouse cursor (0-127)\nccLane: CC lane under mouse cursor (CC0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events)\nccLaneVal: value in CC lane under mouse cursor (0-127 or 0-16383)\nccLaneId: lane position, counting from the top (0 based)\nNote: due to API limitations, if mouse is over inline MIDI editor with some note rows hidden, noteRow will be -1\n",
        "body": "${1:local }${2:identifier retval},${3:boolean inlineEditor},${4:number noteRow},${5:number ccLane},${6:number ccLaneVal},${7:number ccLaneId} = reaper.BR_GetMouseCursorContext_MIDI()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_MIDI_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext_MIDI",
        "scope": "python",
        "description": "[BR] Returns midi editor under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\ninlineEditor: if mouse was captured in inline MIDI editor, this will be\ntrue (consequentially, returned MIDI editor will be NULL)\nnoteRow: note row or piano key under mouse cursor (0-127)\nccLane: CC lane under mouse cursor (CC0-127=CC, 0x100|(0-31)=14-bit CC,\n0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure,\n0x204=bank/program select, 0x205=text, 0x206=sysex, 0x207=off velocity,\n0x208=notation events)\nccLaneVal: value in CC lane under mouse cursor (0-127 or 0-16383)\nccLaneId: lane position, counting from the top (0 based)\nNote: due to API limitations, if mouse is over inline MIDI editor with some note rows hidden, noteRow will be -1\n",
        "body": "${1:void retval},${2:Boolean inlineEditorOut},${3:Int noteRowOut},${4:Int ccLaneOut},${5:Int ccLaneValOut},${6:Int ccLaneIdOut} = BR_GetMouseCursorContext_MIDI(${7:inlineEditorOut},${8:noteRowOut},${9:ccLaneOut},${10:ccLaneValOut},${11:ccLaneIdOut})$0"
    },
    "BR_GETMOUSECURSORCONTEXT_POSITION_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext_Position",
        "scope": "c",
        "description": "[BR] Returns project time position in arrange/ruler/midi editor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:double} = BR_GetMouseCursorContext_Position()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_POSITION_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext_Position",
        "scope": "lua",
        "description": "[BR] Returns project time position in arrange/ruler/midi editor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:local }${2:number} = reaper.BR_GetMouseCursorContext_Position()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_POSITION_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext_Position",
        "scope": "python",
        "description": "[BR] Returns project time position in arrange/ruler/midi editor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:Float} = BR_GetMouseCursorContext_Position()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_STRETCHMARKER_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext_StretchMarker",
        "scope": "c",
        "description": "[BR] Returns id of a stretch marker under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:int} = BR_GetMouseCursorContext_StretchMarker()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_STRETCHMARKER_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext_StretchMarker",
        "scope": "lua",
        "description": "[BR] Returns id of a stretch marker under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:local }${2:integer} = reaper.BR_GetMouseCursorContext_StretchMarker()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_STRETCHMARKER_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext_StretchMarker",
        "scope": "python",
        "description": "[BR] Returns id of a stretch marker under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:Int} = BR_GetMouseCursorContext_StretchMarker()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TAKE_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext_Take",
        "scope": "c",
        "description": "[BR] Returns take under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:MediaItem_Take*} = BR_GetMouseCursorContext_Take()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_TAKE_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext_Take",
        "scope": "lua",
        "description": "[BR] Returns take under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.BR_GetMouseCursorContext_Take()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TAKE_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext_Take",
        "scope": "python",
        "description": "[BR] Returns take under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:MediaItem_Take} = BR_GetMouseCursorContext_Take()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TRACK_WR c": {
        "prefix": "WR_BR_GetMouseCursorContext_Track",
        "scope": "c",
        "description": "[BR] Returns track under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:MediaTrack*} = BR_GetMouseCursorContext_Track()$0"
    },
    "REAPER.BR_GETMOUSECURSORCONTEXT_TRACK_WR lua": {
        "prefix": "reaperwr.BR_GetMouseCursorContext_Track",
        "scope": "lua",
        "description": "[BR] Returns track under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:local }${2:MediaTrack} = reaper.BR_GetMouseCursorContext_Track()$0"
    },
    "BR_GETMOUSECURSORCONTEXT_TRACK_WR python": {
        "prefix": "WR_BR_GetMouseCursorContext_Track",
        "scope": "python",
        "description": "[BR] Returns track under mouse cursor that was captured with the last call to BR_GetMouseCursorContext.\n",
        "body": "${1:MediaTrack} = BR_GetMouseCursorContext_Track()$0"
    },
    "BR_GETNEXTGRIDDIVISION_WR c": {
        "prefix": "WR_BR_GetNextGridDivision",
        "scope": "c",
        "description": "[BR] Get next grid division after the time position. For more grid divisions function, see BR_GetClosestGridDivision and BR_GetPrevGridDivision.\n",
        "body": "${1:double} = BR_GetNextGridDivision(${2:double position})$0"
    },
    "REAPER.BR_GETNEXTGRIDDIVISION_WR lua": {
        "prefix": "reaperwr.BR_GetNextGridDivision",
        "scope": "lua",
        "description": "[BR] Get next grid division after the time position. For more grid divisions function, see BR_GetClosestGridDivision and BR_GetPrevGridDivision.\n",
        "body": "${1:local }${2:number} = reaper.BR_GetNextGridDivision(${3:number position})$0"
    },
    "BR_GETNEXTGRIDDIVISION_WR python": {
        "prefix": "WR_BR_GetNextGridDivision",
        "scope": "python",
        "description": "[BR] Get next grid division after the time position. For more grid divisions function, see BR_GetClosestGridDivision and BR_GetPrevGridDivision.\n",
        "body": "${1:Float} = BR_GetNextGridDivision(${2:Float position})$0"
    },
    "BR_GETPREVGRIDDIVISION_WR c": {
        "prefix": "WR_BR_GetPrevGridDivision",
        "scope": "c",
        "description": "[BR] Get previous grid division before the time position. For more grid division functions, see BR_GetClosestGridDivision and BR_GetNextGridDivision.\n",
        "body": "${1:double} = BR_GetPrevGridDivision(${2:double position})$0"
    },
    "REAPER.BR_GETPREVGRIDDIVISION_WR lua": {
        "prefix": "reaperwr.BR_GetPrevGridDivision",
        "scope": "lua",
        "description": "[BR] Get previous grid division before the time position. For more grid division functions, see BR_GetClosestGridDivision and BR_GetNextGridDivision.\n",
        "body": "${1:local }${2:number} = reaper.BR_GetPrevGridDivision(${3:number position})$0"
    },
    "BR_GETPREVGRIDDIVISION_WR python": {
        "prefix": "WR_BR_GetPrevGridDivision",
        "scope": "python",
        "description": "[BR] Get previous grid division before the time position. For more grid division functions, see BR_GetClosestGridDivision and BR_GetNextGridDivision.\n",
        "body": "${1:Float} = BR_GetPrevGridDivision(${2:Float position})$0"
    },
    "BR_GETSETTRACKSENDINFO_WR c": {
        "prefix": "WR_BR_GetSetTrackSendInfo",
        "scope": "c",
        "description": "[BR] Get or set send attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nTo set attribute, pass setNewValue as true\nList of possible parameters:\nB_MUTE : send mute state (1.0 if muted, otherwise 0.0)\nB_PHASE : send phase state (1.0 if phase is inverted, otherwise 0.0)\nB_MONO : send mono state (1.0 if send is set to mono, otherwise 0.0)\nD_VOL : send volume (1.0=+0dB etc...)\nD_PAN : send pan (-1.0=100%L, 0=center, 1.0=100%R)\nD_PANLAW : send pan law (1.0=+0.0db, 0.5=-6dB, -1.0=project default etc...)\nI_SENDMODE : send mode (0=post-fader, 1=pre-fx, 2=post-fx(deprecated), 3=post-fx)\nI_SRCCHAN : audio source starting channel index or -1 if audio send is\ndisabled (&1024=mono...note that in that case, when reading index,\nyou should do (index XOR 1024) to get starting channel index)\nI_DSTCHAN : audio destination starting channel index (&1024=mono\n(and in case of hardware output &512=rearoute)...note that in that\ncase, when reading index, you should do (index XOR (1024 OR 512)) to get\nstarting channel index)\nI_MIDI_SRCCHAN : source MIDI channel, -1 if MIDI send is disabled (0=all, 1-16)\nI_MIDI_DSTCHAN : destination MIDI channel, -1 if MIDI send is disabled (0=original, 1-16)\nI_MIDI_SRCBUS : source MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_DSTBUS : receive MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_LINK_VOLPAN : link volume/pan controls to MIDI\nNote: To get or set other send attributes, see BR_GetMediaTrackSendInfo_Envelope and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "${1:double} = BR_GetSetTrackSendInfo(${2:MediaTrack* track},${3:int category},${4:int sendidx},${5|const char* parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDI_SRCCHAN\",\"I_MIDI_DSTCHAN\",\"I_MIDI_SRCBUS\",\"I_MIDI_DSTBUS\",\"I_MIDI_LINK_VOLPAN\"|},${6:bool setNewValue},${7:double newValue})$0"
    },
    "REAPER.BR_GETSETTRACKSENDINFO_WR lua": {
        "prefix": "reaperwr.BR_GetSetTrackSendInfo",
        "scope": "lua",
        "description": "[BR] Get or set send attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nTo set attribute, pass setNewValue as true\nList of possible parameters:\nB_MUTE : send mute state (1.0 if muted, otherwise 0.0)\nB_PHASE : send phase state (1.0 if phase is inverted, otherwise 0.0)\nB_MONO : send mono state (1.0 if send is set to mono, otherwise 0.0)\nD_VOL : send volume (1.0=+0dB etc...)\nD_PAN : send pan (-1.0=100%L, 0=center, 1.0=100%R)\nD_PANLAW : send pan law (1.0=+0.0db, 0.5=-6dB, -1.0=project default etc...)\nI_SENDMODE : send mode (0=post-fader, 1=pre-fx, 2=post-fx(deprecated), 3=post-fx)\nI_SRCCHAN : audio source starting channel index or -1 if audio send is\ndisabled (&1024=mono...note that in that case, when reading index,\nyou should do (index XOR 1024) to get starting channel index)\nI_DSTCHAN : audio destination starting channel index (&1024=mono\n(and in case of hardware output &512=rearoute)...note that in that\ncase, when reading index, you should do (index XOR (1024 OR 512)) to get\nstarting channel index)\nI_MIDI_SRCCHAN : source MIDI channel, -1 if MIDI send is disabled (0=all, 1-16)\nI_MIDI_DSTCHAN : destination MIDI channel, -1 if MIDI send is disabled (0=original, 1-16)\nI_MIDI_SRCBUS : source MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_DSTBUS : receive MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_LINK_VOLPAN : link volume/pan controls to MIDI\nNote: To get or set other send attributes, see BR_GetMediaTrackSendInfo_Envelope and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "${1:local }${2:number} = reaper.BR_GetSetTrackSendInfo(${3:MediaTrack track},${4:integer category},${5:integer sendidx},${6|string parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDI_SRCCHAN\",\"I_MIDI_DSTCHAN\",\"I_MIDI_SRCBUS\",\"I_MIDI_DSTBUS\",\"I_MIDI_LINK_VOLPAN\"|},${7:boolean setNewValue},${8:number newValue})$0"
    },
    "BR_GETSETTRACKSENDINFO_WR python": {
        "prefix": "WR_BR_GetSetTrackSendInfo",
        "scope": "python",
        "description": "[BR] Get or set send attributes.\ncategory is <0 for receives, 0=sends, >0 for hardware outputs\nsendidx is zero-based (see GetTrackNumSends to count track sends/receives/hardware outputs)\nTo set attribute, pass setNewValue as true\nList of possible parameters:\nB_MUTE : send mute state (1.0 if muted, otherwise 0.0)\nB_PHASE : send phase state (1.0 if phase is inverted, otherwise 0.0)\nB_MONO : send mono state (1.0 if send is set to mono, otherwise 0.0)\nD_VOL : send volume (1.0=+0dB etc...)\nD_PAN : send pan (-1.0=100%L, 0=center, 1.0=100%R)\nD_PANLAW : send pan law (1.0=+0.0db, 0.5=-6dB, -1.0=project default etc...)\nI_SENDMODE : send mode (0=post-fader, 1=pre-fx, 2=post-fx(deprecated), 3=post-fx)\nI_SRCCHAN : audio source starting channel index or -1 if audio send is\ndisabled (&1024=mono...note that in that case, when reading index,\nyou should do (index XOR 1024) to get starting channel index)\nI_DSTCHAN : audio destination starting channel index (&1024=mono\n(and in case of hardware output &512=rearoute)...note that in that\ncase, when reading index, you should do (index XOR (1024 OR 512)) to get\nstarting channel index)\nI_MIDI_SRCCHAN : source MIDI channel, -1 if MIDI send is disabled (0=all, 1-16)\nI_MIDI_DSTCHAN : destination MIDI channel, -1 if MIDI send is disabled (0=original, 1-16)\nI_MIDI_SRCBUS : source MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_DSTBUS : receive MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\nI_MIDI_LINK_VOLPAN : link volume/pan controls to MIDI\nNote: To get or set other send attributes, see BR_GetMediaTrackSendInfo_Envelope and BR_GetMediaTrackSendInfo_Track.\n",
        "body": "${1:Float} = BR_GetSetTrackSendInfo(${2:MediaTrack track},${3:Int category},${4:Int sendidx},${5|String parmname,\"B_MUTE\",\"B_PHASE\",\"B_MONO\",\"D_VOL\",\"D_PAN\",\"D_PANLAW\",\"I_SENDMODE\",\"I_SRCCHAN\",\"I_DSTCHAN\",\"I_MIDI_SRCCHAN\",\"I_MIDI_DSTCHAN\",\"I_MIDI_SRCBUS\",\"I_MIDI_DSTBUS\",\"I_MIDI_LINK_VOLPAN\"|},${6:Boolean setNewValue},${7:Float newValue})$0"
    },
    "BR_GETTAKEFXCOUNT_WR c": {
        "prefix": "WR_BR_GetTakeFXCount",
        "scope": "c",
        "description": "[BR] Returns FX count for supplied take\n",
        "body": "${1:int} = BR_GetTakeFXCount(${2:MediaItem_Take* take})$0"
    },
    "REAPER.BR_GETTAKEFXCOUNT_WR lua": {
        "prefix": "reaperwr.BR_GetTakeFXCount",
        "scope": "lua",
        "description": "[BR] Returns FX count for supplied take\n",
        "body": "${1:local }${2:integer} = reaper.BR_GetTakeFXCount(${3:MediaItem_Take take})$0"
    },
    "BR_GETTAKEFXCOUNT_WR python": {
        "prefix": "WR_BR_GetTakeFXCount",
        "scope": "python",
        "description": "[BR] Returns FX count for supplied take\n",
        "body": "${1:Int} = BR_GetTakeFXCount(${2:MediaItem_Take take})$0"
    },
    "BR_ISMIDIOPENININLINEEDITOR_WR c": {
        "prefix": "WR_BR_IsMidiOpenInInlineEditor",
        "scope": "c",
        "description": "[SWS] Check if take has MIDI inline editor open and returns true or false.\n",
        "body": "${1:bool} = BR_IsMidiOpenInInlineEditor(${2:MediaItem_Take* take})$0"
    },
    "REAPER.BR_ISMIDIOPENININLINEEDITOR_WR lua": {
        "prefix": "reaperwr.BR_IsMidiOpenInInlineEditor",
        "scope": "lua",
        "description": "[SWS] Check if take has MIDI inline editor open and returns true or false.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_IsMidiOpenInInlineEditor(${3:MediaItem_Take take})$0"
    },
    "BR_ISMIDIOPENININLINEEDITOR_WR python": {
        "prefix": "WR_BR_IsMidiOpenInInlineEditor",
        "scope": "python",
        "description": "[SWS] Check if take has MIDI inline editor open and returns true or false.\n",
        "body": "${1:Boolean} = BR_IsMidiOpenInInlineEditor(${2:MediaItem_Take take})$0"
    },
    "BR_ISTAKEMIDI_WR c": {
        "prefix": "WR_BR_IsTakeMidi",
        "scope": "c",
        "description": "[BR] Check if take is MIDI take, in case MIDI take is in-project MIDI\nsource data, inProjectMidiOut will be true, otherwise false.\n",
        "body": "${1:bool} = BR_IsTakeMidi(${2:MediaItem_Take* take},${3:bool* inProjectMidiOut})$0"
    },
    "REAPER.BR_ISTAKEMIDI_WR lua": {
        "prefix": "reaperwr.BR_IsTakeMidi",
        "scope": "lua",
        "description": "[BR] Check if take is MIDI take, in case MIDI take is in-project MIDI\nsource data, inProjectMidiOut will be true, otherwise false.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean inProjectMidi} = reaper.BR_IsTakeMidi(${4:MediaItem_Take take})$0"
    },
    "BR_ISTAKEMIDI_WR python": {
        "prefix": "WR_BR_IsTakeMidi",
        "scope": "python",
        "description": "[BR] Check if take is MIDI take, in case MIDI take is in-project MIDI\nsource data, inProjectMidiOut will be true, otherwise false.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Boolean inProjectMidiOut} = BR_IsTakeMidi(${4:take},${5:inProjectMidiOut})$0"
    },
    "BR_ITEMATMOUSECURSOR_WR c": {
        "prefix": "WR_BR_ItemAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get media item under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "${1:MediaItem*} = BR_ItemAtMouseCursor(${2:double* positionOut})$0"
    },
    "REAPER.BR_ITEMATMOUSECURSOR_WR lua": {
        "prefix": "reaperwr.BR_ItemAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get media item under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "${1:local }${2:MediaItem retval},${3:number position} = reaper.BR_ItemAtMouseCursor()$0"
    },
    "BR_ITEMATMOUSECURSOR_WR python": {
        "prefix": "WR_BR_ItemAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get media item under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "${1:MediaItem retval},${2:Float positionOut} = BR_ItemAtMouseCursor(${3:positionOut})$0"
    },
    "BR_MIDI_CCLANEREMOVE_WR c": {
        "prefix": "WR_BR_MIDI_CCLaneRemove",
        "scope": "c",
        "description": "[BR] Remove CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success\n",
        "body": "${1:bool} = BR_MIDI_CCLaneRemove(${2:void* midiEditor},${3:int laneId})$0"
    },
    "REAPER.BR_MIDI_CCLANEREMOVE_WR lua": {
        "prefix": "reaperwr.BR_MIDI_CCLaneRemove",
        "scope": "lua",
        "description": "[BR] Remove CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success\n",
        "body": "${1:local }${2:boolean} = reaper.BR_MIDI_CCLaneRemove(${3:identifier midiEditor},${4:integer laneId})$0"
    },
    "BR_MIDI_CCLANEREMOVE_WR python": {
        "prefix": "WR_BR_MIDI_CCLaneRemove",
        "scope": "python",
        "description": "[BR] Remove CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success\n",
        "body": "${1:Boolean} = BR_MIDI_CCLaneRemove(${2:void midiEditor},${3:Int laneId})$0"
    },
    "BR_MIDI_CCLANEREPLACE_WR c": {
        "prefix": "WR_BR_MIDI_CCLaneReplace",
        "scope": "c",
        "description": "[BR] Replace CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success.\nValid CC lanes: CC0-127=CC, 0x100|(0-31)=14-bit CC, 0x200=velocity,\n0x201=pitch, 0x202=program, 0x203=channel pressure, 0x204=bank/program\nselect, 0x205=text, 0x206=sysex, 0x207\n",
        "body": "${1:bool} = BR_MIDI_CCLaneReplace(${2:void* midiEditor},${3:int laneId},${4:int newCC})$0"
    },
    "REAPER.BR_MIDI_CCLANEREPLACE_WR lua": {
        "prefix": "reaperwr.BR_MIDI_CCLaneReplace",
        "scope": "lua",
        "description": "[BR] Replace CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success.\nValid CC lanes: CC0-127=CC, 0x100|(0-31)=14-bit CC, 0x200=velocity,\n0x201=pitch, 0x202=program, 0x203=channel pressure, 0x204=bank/program\nselect, 0x205=text, 0x206=sysex, 0x207\n",
        "body": "${1:local }${2:boolean} = reaper.BR_MIDI_CCLaneReplace(${3:identifier midiEditor},${4:integer laneId},${5:integer newCC})$0"
    },
    "BR_MIDI_CCLANEREPLACE_WR python": {
        "prefix": "WR_BR_MIDI_CCLaneReplace",
        "scope": "python",
        "description": "[BR] Replace CC lane in midi editor. Top visible CC lane is laneId 0. Returns true on success.\nValid CC lanes: CC0-127=CC, 0x100|(0-31)=14-bit CC, 0x200=velocity,\n0x201=pitch, 0x202=program, 0x203=channel pressure, 0x204=bank/program\nselect, 0x205=text, 0x206=sysex, 0x207\n",
        "body": "${1:Boolean} = BR_MIDI_CCLaneReplace(${2:void midiEditor},${3:Int laneId},${4:Int newCC})$0"
    },
    "BR_POSITIONATMOUSECURSOR_WR c": {
        "prefix": "WR_BR_PositionAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get position at mouse cursor. To check ruler along with arrange,\npass checkRuler=true. Returns -1 if cursor is not over arrange/ruler.\n",
        "body": "${1:double} = BR_PositionAtMouseCursor(${2:bool checkRuler})$0"
    },
    "REAPER.BR_POSITIONATMOUSECURSOR_WR lua": {
        "prefix": "reaperwr.BR_PositionAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get position at mouse cursor. To check ruler along with arrange,\npass checkRuler=true. Returns -1 if cursor is not over arrange/ruler.\n",
        "body": "${1:local }${2:number} = reaper.BR_PositionAtMouseCursor(${3:boolean checkRuler})$0"
    },
    "BR_POSITIONATMOUSECURSOR_WR python": {
        "prefix": "WR_BR_PositionAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get position at mouse cursor. To check ruler along with arrange,\npass checkRuler=true. Returns -1 if cursor is not over arrange/ruler.\n",
        "body": "${1:Float} = BR_PositionAtMouseCursor(${2:Boolean checkRuler})$0"
    },
    "BR_SETARRANGEVIEW_WR c": {
        "prefix": "WR_BR_SetArrangeView",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSet_ArrangeView2 (REAPER v5.12pre4+) -- Set start and end time position of arrange view. To get arrange view instead, see BR_GetArrangeView.\n",
        "body": "${1:void} = BR_SetArrangeView(${2:ReaProject* proj},${3:double startTime},${4:double endTime})$0"
    },
    "BR_SETITEMEDGES_WR c": {
        "prefix": "WR_BR_SetItemEdges",
        "scope": "c",
        "description": "[BR] Set item start and end edges' position - returns true in case of any changes\n",
        "body": "${1:bool} = BR_SetItemEdges(${2:MediaItem* item},${3:double startTime},${4:double endTime})$0"
    },
    "REAPER.BR_SETITEMEDGES_WR lua": {
        "prefix": "reaperwr.BR_SetItemEdges",
        "scope": "lua",
        "description": "[BR] Set item start and end edges' position - returns true in case of any changes\n",
        "body": "${1:local }${2:boolean} = reaper.BR_SetItemEdges(${3:MediaItem item},${4:number startTime},${5:number endTime})$0"
    },
    "BR_SETITEMEDGES_WR python": {
        "prefix": "WR_BR_SetItemEdges",
        "scope": "python",
        "description": "[BR] Set item start and end edges' position - returns true in case of any changes\n",
        "body": "${1:Boolean} = BR_SetItemEdges(${2:MediaItem item},${3:Float startTime},${4:Float endTime})$0"
    },
    "BR_SETMEDIAITEMIMAGERESOURCE_WR c": {
        "prefix": "WR_BR_SetMediaItemImageResource",
        "scope": "c",
        "description": "[BR] Set image resource and it's flags for a given item. To clear\ncurrent image resource, pass imageIn as . To get image resource, see BR_GetMediaItemImageResource.\n",
        "body": "${1:void} = BR_SetMediaItemImageResource(${2:MediaItem* item},${3:const char* imageIn},${4:int imageFlags})$0"
    },
    "BR_SETMEDIASOURCEPROPERTIES_WR c": {
        "prefix": "WR_BR_SetMediaSourceProperties",
        "scope": "c",
        "description": "[BR] Set take media source properties. Returns false if take can't have\nthem (MIDI items etc.). Section parameters have to be valid only when\npassing section=true.\nTo get source properties, see BR_GetMediaSourceProperties.\n",
        "body": "${1:bool} = BR_SetMediaSourceProperties(${2:MediaItem_Take* take},${3:bool section},${4:double start},${5:double length},${6:double fade},${7:bool reverse})$0"
    },
    "REAPER.BR_SETMEDIASOURCEPROPERTIES_WR lua": {
        "prefix": "reaperwr.BR_SetMediaSourceProperties",
        "scope": "lua",
        "description": "[BR] Set take media source properties. Returns false if take can't have\nthem (MIDI items etc.). Section parameters have to be valid only when\npassing section=true.\nTo get source properties, see BR_GetMediaSourceProperties.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_SetMediaSourceProperties(${3:MediaItem_Take take},${4:boolean section},${5:number start},${6:number length},${7:number fade},${8:boolean reverse})$0"
    },
    "BR_SETMEDIASOURCEPROPERTIES_WR python": {
        "prefix": "WR_BR_SetMediaSourceProperties",
        "scope": "python",
        "description": "[BR] Set take media source properties. Returns false if take can't have\nthem (MIDI items etc.). Section parameters have to be valid only when\npassing section=true.\nTo get source properties, see BR_GetMediaSourceProperties.\n",
        "body": "${1:Boolean} = BR_SetMediaSourceProperties(${2:MediaItem_Take take},${3:Boolean section},${4:Float start},${5:Float length},${6:Float fade},${7:Boolean reverse})$0"
    },
    "BR_SETMEDIATRACKLAYOUTS_WR c": {
        "prefix": "WR_BR_SetMediaTrackLayouts",
        "scope": "c",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Set media track layouts for MCP and TCP. To set\ndefault layout, pass empty string (\"\") as layout name. In case layouts\nwere successfully set, returns true (if layouts are already set to\nsupplied layout names, it will return false since no changes were made).\nTo get media track layouts, see BR_GetMediaTrackLayouts.\n",
        "body": "${1:bool} = BR_SetMediaTrackLayouts(${2:MediaTrack* track},${3:const char* mcpLayoutNameIn},${4:const char* tcpLayoutNameIn})$0"
    },
    "REAPER.BR_SETMEDIATRACKLAYOUTS_WR lua": {
        "prefix": "reaperwr.BR_SetMediaTrackLayouts",
        "scope": "lua",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Set media track layouts for MCP and TCP. To set\ndefault layout, pass empty string (\"\") as layout name. In case layouts\nwere successfully set, returns true (if layouts are already set to\nsupplied layout names, it will return false since no changes were made).\nTo get media track layouts, see BR_GetMediaTrackLayouts.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_SetMediaTrackLayouts(${3:MediaTrack track},${4:string mcpLayoutNameIn},${5:string tcpLayoutNameIn})$0"
    },
    "BR_SETMEDIATRACKLAYOUTS_WR python": {
        "prefix": "WR_BR_SetMediaTrackLayouts",
        "scope": "python",
        "description": "[BR] Deprecated, see GetSetMediaTrackInfo\n(REAPER v5.02+). Set media track layouts for MCP and TCP. To set\ndefault layout, pass empty string (\"\") as layout name. In case layouts\nwere successfully set, returns true (if layouts are already set to\nsupplied layout names, it will return false since no changes were made).\nTo get media track layouts, see BR_GetMediaTrackLayouts.\n",
        "body": "${1:Boolean} = BR_SetMediaTrackLayouts(${2:MediaTrack track},${3:String mcpLayoutNameIn},${4:String tcpLayoutNameIn})$0"
    },
    "BR_SETMIDITAKETEMPOINFO_WR c": {
        "prefix": "WR_BR_SetMidiTakeTempoInfo",
        "scope": "c",
        "description": "[BR] Set \"ignore project tempo\" information for MIDI take. Returns true in case the take was successfully updated.\n",
        "body": "${1:bool} = BR_SetMidiTakeTempoInfo(${2:MediaItem_Take* take},${3:bool ignoreProjTempo},${4:double bpm},${5:int num},${6:int den})$0"
    },
    "REAPER.BR_SETMIDITAKETEMPOINFO_WR lua": {
        "prefix": "reaperwr.BR_SetMidiTakeTempoInfo",
        "scope": "lua",
        "description": "[BR] Set \"ignore project tempo\" information for MIDI take. Returns true in case the take was successfully updated.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_SetMidiTakeTempoInfo(${3:MediaItem_Take take},${4:boolean ignoreProjTempo},${5:number bpm},${6:integer num},${7:integer den})$0"
    },
    "BR_SETMIDITAKETEMPOINFO_WR python": {
        "prefix": "WR_BR_SetMidiTakeTempoInfo",
        "scope": "python",
        "description": "[BR] Set \"ignore project tempo\" information for MIDI take. Returns true in case the take was successfully updated.\n",
        "body": "${1:Boolean} = BR_SetMidiTakeTempoInfo(${2:MediaItem_Take take},${3:Boolean ignoreProjTempo},${4:Float bpm},${5:Int num},${6:Int den})$0"
    },
    "BR_SETTAKESOURCEFROMFILE_WR c": {
        "prefix": "WR_BR_SetTakeSourceFromFile",
        "scope": "c",
        "description": "[BR] Set new take source from file. To import MIDI file as in-project\nsource data pass inProjectData=true. Returns false if failed.\nAny take source properties from the previous source will be lost - to preserve them, see BR_SetTakeSourceFromFile2.\nNote: To set source from existing take, see SNM_GetSetSourceState2.\n",
        "body": "${1:bool} = BR_SetTakeSourceFromFile(${2:MediaItem_Take* take},${3:const char* filenameIn},${4:bool inProjectData})$0"
    },
    "REAPER.BR_SETTAKESOURCEFROMFILE_WR lua": {
        "prefix": "reaperwr.BR_SetTakeSourceFromFile",
        "scope": "lua",
        "description": "[BR] Set new take source from file. To import MIDI file as in-project\nsource data pass inProjectData=true. Returns false if failed.\nAny take source properties from the previous source will be lost - to preserve them, see BR_SetTakeSourceFromFile2.\nNote: To set source from existing take, see SNM_GetSetSourceState2.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_SetTakeSourceFromFile(${3:MediaItem_Take take},${4:string filenameIn},${5:boolean inProjectData})$0"
    },
    "BR_SETTAKESOURCEFROMFILE_WR python": {
        "prefix": "WR_BR_SetTakeSourceFromFile",
        "scope": "python",
        "description": "[BR] Set new take source from file. To import MIDI file as in-project\nsource data pass inProjectData=true. Returns false if failed.\nAny take source properties from the previous source will be lost - to preserve them, see BR_SetTakeSourceFromFile2.\nNote: To set source from existing take, see SNM_GetSetSourceState2.\n",
        "body": "${1:Boolean} = BR_SetTakeSourceFromFile(${2:MediaItem_Take take},${3:String filenameIn},${4:Boolean inProjectData})$0"
    },
    "BR_SETTAKESOURCEFROMFILE2_WR c": {
        "prefix": "WR_BR_SetTakeSourceFromFile2",
        "scope": "c",
        "description": "[BR] Differs from BR_SetTakeSourceFromFile only that it can also preserve existing take media source properties.\n",
        "body": "${1:bool} = BR_SetTakeSourceFromFile2(${2:MediaItem_Take* take},${3:const char* filenameIn},${4:bool inProjectData},${5:bool keepSourceProperties})$0"
    },
    "REAPER.BR_SETTAKESOURCEFROMFILE2_WR lua": {
        "prefix": "reaperwr.BR_SetTakeSourceFromFile2",
        "scope": "lua",
        "description": "[BR] Differs from BR_SetTakeSourceFromFile only that it can also preserve existing take media source properties.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_SetTakeSourceFromFile2(${3:MediaItem_Take take},${4:string filenameIn},${5:boolean inProjectData},${6:boolean keepSourceProperties})$0"
    },
    "BR_SETTAKESOURCEFROMFILE2_WR python": {
        "prefix": "WR_BR_SetTakeSourceFromFile2",
        "scope": "python",
        "description": "[BR] Differs from BR_SetTakeSourceFromFile only that it can also preserve existing take media source properties.\n",
        "body": "${1:Boolean} = BR_SetTakeSourceFromFile2(${2:MediaItem_Take take},${3:String filenameIn},${4:Boolean inProjectData},${5:Boolean keepSourceProperties})$0"
    },
    "BR_TAKEATMOUSECURSOR_WR c": {
        "prefix": "WR_BR_TakeAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get take under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "${1:MediaItem_Take*} = BR_TakeAtMouseCursor(${2:double* positionOut})$0"
    },
    "REAPER.BR_TAKEATMOUSECURSOR_WR lua": {
        "prefix": "reaperwr.BR_TakeAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get take under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "${1:local }${2:MediaItem_Take retval},${3:number position} = reaper.BR_TakeAtMouseCursor()$0"
    },
    "BR_TAKEATMOUSECURSOR_WR python": {
        "prefix": "WR_BR_TakeAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get take under mouse cursor. Position is mouse cursor position in arrange.\n",
        "body": "${1:MediaItem_Take retval},${2:Float positionOut} = BR_TakeAtMouseCursor(${3:positionOut})$0"
    },
    "BR_TRACKATMOUSECURSOR_WR c": {
        "prefix": "WR_BR_TrackAtMouseCursor",
        "scope": "c",
        "description": "[BR] Get track under mouse cursor.\nContext signifies where the track was found: 0 = TCP, 1 = MCP, 2 = Arrange.\nPosition will hold mouse cursor position in arrange if applicable.\n",
        "body": "${1:MediaTrack*} = BR_TrackAtMouseCursor(${2:int* contextOut},${3:double* positionOut})$0"
    },
    "REAPER.BR_TRACKATMOUSECURSOR_WR lua": {
        "prefix": "reaperwr.BR_TrackAtMouseCursor",
        "scope": "lua",
        "description": "[BR] Get track under mouse cursor.\nContext signifies where the track was found: 0 = TCP, 1 = MCP, 2 = Arrange.\nPosition will hold mouse cursor position in arrange if applicable.\n",
        "body": "${1:local }${2:MediaTrack retval},${3:number context},${4:number position} = reaper.BR_TrackAtMouseCursor()$0"
    },
    "BR_TRACKATMOUSECURSOR_WR python": {
        "prefix": "WR_BR_TrackAtMouseCursor",
        "scope": "python",
        "description": "[BR] Get track under mouse cursor.\nContext signifies where the track was found: 0 = TCP, 1 = MCP, 2 = Arrange.\nPosition will hold mouse cursor position in arrange if applicable.\n",
        "body": "${1:MediaTrack retval},${2:Int contextOut},${3:Float positionOut} = BR_TrackAtMouseCursor(${4:contextOut},${5:positionOut})$0"
    },
    "BR_TRACKFX_GETFXMODULENAME_WR c": {
        "prefix": "WR_BR_TrackFX_GetFXModuleName",
        "scope": "c",
        "description": "[BR] Get the exact name (like effect.dll, effect.vst3, etc...) of an FX.\n",
        "body": "${1:bool} = BR_TrackFX_GetFXModuleName(${2:MediaTrack* track},${3:int fx},${4:char*  nameOut},${5:int  nameOutSz})$0"
    },
    "REAPER.BR_TRACKFX_GETFXMODULENAME_WR lua": {
        "prefix": "reaperwr.BR_TrackFX_GetFXModuleName",
        "scope": "lua",
        "description": "[BR] Get the exact name (like effect.dll, effect.vst3, etc...) of an FX.\n",
        "body": "${1:local }${2:boolean retval},${3:string  name} = reaper.BR_TrackFX_GetFXModuleName(${4:MediaTrack track},${5:integer fx})$0"
    },
    "BR_TRACKFX_GETFXMODULENAME_WR python": {
        "prefix": "WR_BR_TrackFX_GetFXModuleName",
        "scope": "python",
        "description": "[BR] Get the exact name (like effect.dll, effect.vst3, etc...) of an FX.\n",
        "body": "${1:Boolean retval},${2:MediaTrack track},${3:Int fx},${4:String  nameOut},${5:Int  nameOutSz} = BR_TrackFX_GetFXModuleName(${6:track},${7:fx},${8: nameOut},${9: nameOutSz})$0"
    },
    "BR_WIN32_CB_FINDSTRING_WR c": {
        "prefix": "WR_BR_Win32_CB_FindString",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ComboBox_FindString().\n",
        "body": "${1:int} = BR_Win32_CB_FindString(${2:void* comboBoxHwnd},${3:int startId},${4:const char* string})$0"
    },
    "REAPER.BR_WIN32_CB_FINDSTRING_WR lua": {
        "prefix": "reaperwr.BR_Win32_CB_FindString",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ComboBox_FindString().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_CB_FindString(${3:identifier comboBoxHwnd},${4:integer startId},${5:string string})$0"
    },
    "BR_WIN32_CB_FINDSTRING_WR python": {
        "prefix": "WR_BR_Win32_CB_FindString",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ComboBox_FindString().\n",
        "body": "${1:Int} = BR_Win32_CB_FindString(${2:void comboBoxHwnd},${3:Int startId},${4:String string})$0"
    },
    "BR_WIN32_CB_FINDSTRINGEXACT_WR c": {
        "prefix": "WR_BR_Win32_CB_FindStringExact",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ComboBox_FindStringExact().\n",
        "body": "${1:int} = BR_Win32_CB_FindStringExact(${2:void* comboBoxHwnd},${3:int startId},${4:const char* string})$0"
    },
    "REAPER.BR_WIN32_CB_FINDSTRINGEXACT_WR lua": {
        "prefix": "reaperwr.BR_Win32_CB_FindStringExact",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ComboBox_FindStringExact().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_CB_FindStringExact(${3:identifier comboBoxHwnd},${4:integer startId},${5:string string})$0"
    },
    "BR_WIN32_CB_FINDSTRINGEXACT_WR python": {
        "prefix": "WR_BR_Win32_CB_FindStringExact",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ComboBox_FindStringExact().\n",
        "body": "${1:Int} = BR_Win32_CB_FindStringExact(${2:void comboBoxHwnd},${3:Int startId},${4:String string})$0"
    },
    "BR_WIN32_CLIENTTOSCREEN_WR c": {
        "prefix": "WR_BR_Win32_ClientToScreen",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "${1:void} = BR_Win32_ClientToScreen(${2:void* hwnd},${3:int xIn},${4:int yIn},${5:int* xOut},${6:int* yOut})$0"
    },
    "REAPER.BR_WIN32_CLIENTTOSCREEN_WR lua": {
        "prefix": "reaperwr.BR_Win32_ClientToScreen",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "${1:local }${2:number x},${3:number y} = reaper.BR_Win32_ClientToScreen(${4:identifier hwnd},${5:integer xIn},${6:integer yIn})$0"
    },
    "BR_WIN32_CLIENTTOSCREEN_WR python": {
        "prefix": "WR_BR_Win32_ClientToScreen",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "${1:void hwnd},${2:Int xIn},${3:Int yIn},${4:Int xOut},${5:Int yOut} = BR_Win32_ClientToScreen(${6:hwnd},${7:xIn},${8:yIn},${9:xOut},${10:yOut})$0"
    },
    "BR_WIN32_FINDWINDOWEX_WR c": {
        "prefix": "WR_BR_Win32_FindWindowEx",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API FindWindowEx(). Since ReaScript doesn't\nallow passing NULL (None in Python, nil in Lua etc...) parameters, to\nsearch by supplied class or name set searchClass and searchName\naccordingly. HWND parameters should be passed as either \"0\" to signify\nNULL or as string obtained from BR_Win32_HwndToString.\n",
        "body": "${1:void*} = BR_Win32_FindWindowEx(${2:const char* hwndParent},${3:const char* hwndChildAfter},${4:const char* className},${5:const char* windowName},${6:bool searchClass},${7:bool searchName})$0"
    },
    "REAPER.BR_WIN32_FINDWINDOWEX_WR lua": {
        "prefix": "reaperwr.BR_Win32_FindWindowEx",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API FindWindowEx(). Since ReaScript doesn't\nallow passing NULL (None in Python, nil in Lua etc...) parameters, to\nsearch by supplied class or name set searchClass and searchName\naccordingly. HWND parameters should be passed as either \"0\" to signify\nNULL or as string obtained from BR_Win32_HwndToString.\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_FindWindowEx(${3:string hwndParent},${4:string hwndChildAfter},${5:string className},${6:string windowName},${7:boolean searchClass},${8:boolean searchName})$0"
    },
    "BR_WIN32_FINDWINDOWEX_WR python": {
        "prefix": "WR_BR_Win32_FindWindowEx",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API FindWindowEx(). Since ReaScript doesn't\nallow passing NULL (None in Python, nil in Lua etc...) parameters, to\nsearch by supplied class or name set searchClass and searchName\naccordingly. HWND parameters should be passed as either \"0\" to signify\nNULL or as string obtained from BR_Win32_HwndToString.\n",
        "body": "${1:void} = BR_Win32_FindWindowEx(${2:String hwndParent},${3:String hwndChildAfter},${4:String className},${5:String windowName},${6:Boolean searchClass},${7:Boolean searchName})$0"
    },
    "BR_WIN32_GET_X_LPARAM_WR c": {
        "prefix": "WR_BR_Win32_GET_X_LPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GET_X_LPARAM().\n",
        "body": "${1:int} = BR_Win32_GET_X_LPARAM(${2:int lParam})$0"
    },
    "REAPER.BR_WIN32_GET_X_LPARAM_WR lua": {
        "prefix": "reaperwr.BR_Win32_GET_X_LPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GET_X_LPARAM().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_GET_X_LPARAM(${3:integer lParam})$0"
    },
    "BR_WIN32_GET_X_LPARAM_WR python": {
        "prefix": "WR_BR_Win32_GET_X_LPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GET_X_LPARAM().\n",
        "body": "${1:Int} = BR_Win32_GET_X_LPARAM(${2:Int lParam})$0"
    },
    "BR_WIN32_GET_Y_LPARAM_WR c": {
        "prefix": "WR_BR_Win32_GET_Y_LPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GET_Y_LPARAM().\n",
        "body": "${1:int} = BR_Win32_GET_Y_LPARAM(${2:int lParam})$0"
    },
    "REAPER.BR_WIN32_GET_Y_LPARAM_WR lua": {
        "prefix": "reaperwr.BR_Win32_GET_Y_LPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GET_Y_LPARAM().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_GET_Y_LPARAM(${3:integer lParam})$0"
    },
    "BR_WIN32_GET_Y_LPARAM_WR python": {
        "prefix": "WR_BR_Win32_GET_Y_LPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GET_Y_LPARAM().\n",
        "body": "${1:Int} = BR_Win32_GET_Y_LPARAM(${2:Int lParam})$0"
    },
    "BR_WIN32_GETCONSTANT_WR c": {
        "prefix": "WR_BR_Win32_GetConstant",
        "scope": "c",
        "description": "[BR] Returns various constants needed for BR_Win32 functions.\nSupported constants are:\nCB_ERR, CB_GETCOUNT, CB_GETCURSEL, CB_SETCURSEL\nEM_SETSEL\nGW_CHILD, GW_HWNDFIRST, GW_HWNDLAST, GW_HWNDNEXT, GW_HWNDPREV, GW_OWNER\nGWL_STYLE\nSW_HIDE, SW_MAXIMIZE, SW_SHOW, SW_SHOWMINIMIZED, SW_SHOWNA, SW_SHOWNOACTIVATE, SW_SHOWNORMAL\nSWP_FRAMECHANGED, SWP_FRAMECHANGED, SWP_NOMOVE, SWP_NOOWNERZORDER, SWP_NOSIZE, SWP_NOZORDER\nVK_DOWN, VK_UP\nWM_CLOSE, WM_KEYDOWN\nWS_MAXIMIZE, WS_OVERLAPPEDWINDOW\n",
        "body": "${1:int} = BR_Win32_GetConstant(${2:const char* constantName})$0"
    },
    "REAPER.BR_WIN32_GETCONSTANT_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetConstant",
        "scope": "lua",
        "description": "[BR] Returns various constants needed for BR_Win32 functions.\nSupported constants are:\nCB_ERR, CB_GETCOUNT, CB_GETCURSEL, CB_SETCURSEL\nEM_SETSEL\nGW_CHILD, GW_HWNDFIRST, GW_HWNDLAST, GW_HWNDNEXT, GW_HWNDPREV, GW_OWNER\nGWL_STYLE\nSW_HIDE, SW_MAXIMIZE, SW_SHOW, SW_SHOWMINIMIZED, SW_SHOWNA, SW_SHOWNOACTIVATE, SW_SHOWNORMAL\nSWP_FRAMECHANGED, SWP_FRAMECHANGED, SWP_NOMOVE, SWP_NOOWNERZORDER, SWP_NOSIZE, SWP_NOZORDER\nVK_DOWN, VK_UP\nWM_CLOSE, WM_KEYDOWN\nWS_MAXIMIZE, WS_OVERLAPPEDWINDOW\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_GetConstant(${3:string constantName})$0"
    },
    "BR_WIN32_GETCONSTANT_WR python": {
        "prefix": "WR_BR_Win32_GetConstant",
        "scope": "python",
        "description": "[BR] Returns various constants needed for BR_Win32 functions.\nSupported constants are:\nCB_ERR, CB_GETCOUNT, CB_GETCURSEL, CB_SETCURSEL\nEM_SETSEL\nGW_CHILD, GW_HWNDFIRST, GW_HWNDLAST, GW_HWNDNEXT, GW_HWNDPREV, GW_OWNER\nGWL_STYLE\nSW_HIDE, SW_MAXIMIZE, SW_SHOW, SW_SHOWMINIMIZED, SW_SHOWNA, SW_SHOWNOACTIVATE, SW_SHOWNORMAL\nSWP_FRAMECHANGED, SWP_FRAMECHANGED, SWP_NOMOVE, SWP_NOOWNERZORDER, SWP_NOSIZE, SWP_NOZORDER\nVK_DOWN, VK_UP\nWM_CLOSE, WM_KEYDOWN\nWS_MAXIMIZE, WS_OVERLAPPEDWINDOW\n",
        "body": "${1:Int} = BR_Win32_GetConstant(${2:String constantName})$0"
    },
    "BR_WIN32_GETCURSORPOS_WR c": {
        "prefix": "WR_BR_Win32_GetCursorPos",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetCursorPos().\n",
        "body": "${1:bool} = BR_Win32_GetCursorPos(${2:int* xOut},${3:int* yOut})$0"
    },
    "REAPER.BR_WIN32_GETCURSORPOS_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetCursorPos",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetCursorPos().\n",
        "body": "${1:local }${2:boolean retval},${3:number x},${4:number y} = reaper.BR_Win32_GetCursorPos()$0"
    },
    "BR_WIN32_GETCURSORPOS_WR python": {
        "prefix": "WR_BR_Win32_GetCursorPos",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetCursorPos().\n",
        "body": "${1:Boolean retval},${2:Int xOut},${3:Int yOut} = BR_Win32_GetCursorPos(${4:xOut},${5:yOut})$0"
    },
    "BR_WIN32_GETFOCUS_WR c": {
        "prefix": "WR_BR_Win32_GetFocus",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetFocus().\n",
        "body": "${1:void*} = BR_Win32_GetFocus()$0"
    },
    "REAPER.BR_WIN32_GETFOCUS_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetFocus",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetFocus().\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_GetFocus()$0"
    },
    "BR_WIN32_GETFOCUS_WR python": {
        "prefix": "WR_BR_Win32_GetFocus",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetFocus().\n",
        "body": "${1:void} = BR_Win32_GetFocus()$0"
    },
    "BR_WIN32_GETFOREGROUNDWINDOW_WR c": {
        "prefix": "WR_BR_Win32_GetForegroundWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetForegroundWindow().\n",
        "body": "${1:void*} = BR_Win32_GetForegroundWindow()$0"
    },
    "REAPER.BR_WIN32_GETFOREGROUNDWINDOW_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetForegroundWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetForegroundWindow().\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_GetForegroundWindow()$0"
    },
    "BR_WIN32_GETFOREGROUNDWINDOW_WR python": {
        "prefix": "WR_BR_Win32_GetForegroundWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetForegroundWindow().\n",
        "body": "${1:void} = BR_Win32_GetForegroundWindow()$0"
    },
    "BR_WIN32_GETMAINHWND_WR c": {
        "prefix": "WR_BR_Win32_GetMainHwnd",
        "scope": "c",
        "description": "[BR] Alternative to GetMainHwnd. REAPER seems\nto have problems with extensions using HWND type for exported functions\nso all BR_Win32 functions use void* instead of HWND type\n",
        "body": "${1:void*} = BR_Win32_GetMainHwnd()$0"
    },
    "REAPER.BR_WIN32_GETMAINHWND_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetMainHwnd",
        "scope": "lua",
        "description": "[BR] Alternative to GetMainHwnd. REAPER seems\nto have problems with extensions using HWND type for exported functions\nso all BR_Win32 functions use void* instead of HWND type\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_GetMainHwnd()$0"
    },
    "BR_WIN32_GETMAINHWND_WR python": {
        "prefix": "WR_BR_Win32_GetMainHwnd",
        "scope": "python",
        "description": "[BR] Alternative to GetMainHwnd. REAPER seems\nto have problems with extensions using HWND type for exported functions\nso all BR_Win32 functions use void* instead of HWND type\n",
        "body": "${1:void} = BR_Win32_GetMainHwnd()$0"
    },
    "BR_WIN32_GETMIXERHWND_WR c": {
        "prefix": "WR_BR_Win32_GetMixerHwnd",
        "scope": "c",
        "description": "[BR] Get mixer window HWND. isDockedOut will be set to true if mixer is docked\n",
        "body": "${1:void*} = BR_Win32_GetMixerHwnd(${2:bool* isDockedOut})$0"
    },
    "REAPER.BR_WIN32_GETMIXERHWND_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetMixerHwnd",
        "scope": "lua",
        "description": "[BR] Get mixer window HWND. isDockedOut will be set to true if mixer is docked\n",
        "body": "${1:local }${2:identifier retval},${3:boolean isDocked} = reaper.BR_Win32_GetMixerHwnd()$0"
    },
    "BR_WIN32_GETMIXERHWND_WR python": {
        "prefix": "WR_BR_Win32_GetMixerHwnd",
        "scope": "python",
        "description": "[BR] Get mixer window HWND. isDockedOut will be set to true if mixer is docked\n",
        "body": "${1:void retval},${2:Boolean isDockedOut} = BR_Win32_GetMixerHwnd(${3:isDockedOut})$0"
    },
    "BR_WIN32_GETMONITORRECTFROMRECT_WR c": {
        "prefix": "WR_BR_Win32_GetMonitorRectFromRect",
        "scope": "c",
        "description": "[BR] Get coordinates for screen which is nearest to supplied\ncoordinates. Pass workingAreaOnly as true to get screen coordinates\nexcluding taskbar (or menu bar on OSX).\n",
        "body": "${1:void} = BR_Win32_GetMonitorRectFromRect(${2:bool workingAreaOnly},${3:int leftIn},${4:int topIn},${5:int rightIn},${6:int bottomIn},${7:int* leftOut},${8:int* topOut},${9:int* rightOut},${10:int* bottomOut})$0"
    },
    "REAPER.BR_WIN32_GETMONITORRECTFROMRECT_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetMonitorRectFromRect",
        "scope": "lua",
        "description": "[BR] Get coordinates for screen which is nearest to supplied\ncoordinates. Pass workingAreaOnly as true to get screen coordinates\nexcluding taskbar (or menu bar on OSX).\n",
        "body": "${1:local }${2:number left},${3:number top},${4:number right},${5:number bottom} = reaper.BR_Win32_GetMonitorRectFromRect(${6:boolean workingAreaOnly},${7:integer leftIn},${8:integer topIn},${9:integer rightIn},${10:integer bottomIn})$0"
    },
    "BR_WIN32_GETMONITORRECTFROMRECT_WR python": {
        "prefix": "WR_BR_Win32_GetMonitorRectFromRect",
        "scope": "python",
        "description": "[BR] Get coordinates for screen which is nearest to supplied\ncoordinates. Pass workingAreaOnly as true to get screen coordinates\nexcluding taskbar (or menu bar on OSX).\n",
        "body": "${1:Boolean workingAreaOnly},${2:Int leftIn},${3:Int topIn},${4:Int rightIn},${5:Int bottomIn},${6:Int leftOut},${7:Int topOut},${8:Int rightOut},${9:Int bottomOut} = BR_Win32_GetMonitorRectFromRect(${10:workingAreaOnly},${11:leftIn},${12:topIn},${13:rightIn},${14:bottomIn},${15:leftOut},${16:topOut},${17:rightOut},${18:bottomOut})$0"
    },
    "BR_WIN32_GETPARENT_WR c": {
        "prefix": "WR_BR_Win32_GetParent",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetParent().\n",
        "body": "${1:void*} = BR_Win32_GetParent(${2:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_GETPARENT_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetParent",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetParent().\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_GetParent(${3:identifier hwnd})$0"
    },
    "BR_WIN32_GETPARENT_WR python": {
        "prefix": "WR_BR_Win32_GetParent",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetParent().\n",
        "body": "${1:void} = BR_Win32_GetParent(${2:void hwnd})$0"
    },
    "BR_WIN32_GETPRIVATEPROFILESTRING_WR c": {
        "prefix": "WR_BR_Win32_GetPrivateProfileString",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetPrivateProfileString(). For example, you can use this to get values from REAPER.ini\n",
        "body": "${1:int} = BR_Win32_GetPrivateProfileString(${2:const char* sectionName},${3:const char* keyName},${4:const char* defaultString},${5:const char* filePath},${6:char* stringOut},${7:int stringOut_sz})$0"
    },
    "REAPER.BR_WIN32_GETPRIVATEPROFILESTRING_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetPrivateProfileString",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetPrivateProfileString(). For example, you can use this to get values from REAPER.ini\n",
        "body": "${1:local }${2:integer retval},${3:string string} = reaper.BR_Win32_GetPrivateProfileString(${4:string sectionName},${5:string keyName},${6:string defaultString},${7:string filePath})$0"
    },
    "BR_WIN32_GETPRIVATEPROFILESTRING_WR python": {
        "prefix": "WR_BR_Win32_GetPrivateProfileString",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetPrivateProfileString(). For example, you can use this to get values from REAPER.ini\n",
        "body": "${1:Int retval},${2:String sectionName},${3:String keyName},${4:String defaultString},${5:String filePath},${6:String stringOut},${7:Int stringOut_sz} = BR_Win32_GetPrivateProfileString(${8:sectionName},${9:keyName},${10:defaultString},${11:filePath},${12:stringOut},${13:stringOut_sz})$0"
    },
    "BR_WIN32_GETWINDOW_WR c": {
        "prefix": "WR_BR_Win32_GetWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindow().\n",
        "body": "${1:void*} = BR_Win32_GetWindow(${2:void* hwnd},${3:int cmd})$0"
    },
    "REAPER.BR_WIN32_GETWINDOW_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindow().\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_GetWindow(${3:identifier hwnd},${4:integer cmd})$0"
    },
    "BR_WIN32_GETWINDOW_WR python": {
        "prefix": "WR_BR_Win32_GetWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindow().\n",
        "body": "${1:void} = BR_Win32_GetWindow(${2:void hwnd},${3:Int cmd})$0"
    },
    "BR_WIN32_GETWINDOWLONG_WR c": {
        "prefix": "WR_BR_Win32_GetWindowLong",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindowLong().\n",
        "body": "${1:int} = BR_Win32_GetWindowLong(${2:void* hwnd},${3:int index})$0"
    },
    "REAPER.BR_WIN32_GETWINDOWLONG_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetWindowLong",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindowLong().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_GetWindowLong(${3:identifier hwnd},${4:integer index})$0"
    },
    "BR_WIN32_GETWINDOWLONG_WR python": {
        "prefix": "WR_BR_Win32_GetWindowLong",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindowLong().\n",
        "body": "${1:Int} = BR_Win32_GetWindowLong(${2:void hwnd},${3:Int index})$0"
    },
    "BR_WIN32_GETWINDOWRECT_WR c": {
        "prefix": "WR_BR_Win32_GetWindowRect",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindowRect().\n",
        "body": "${1:bool} = BR_Win32_GetWindowRect(${2:void* hwnd},${3:int* leftOut},${4:int* topOut},${5:int* rightOut},${6:int* bottomOut})$0"
    },
    "REAPER.BR_WIN32_GETWINDOWRECT_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetWindowRect",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindowRect().\n",
        "body": "${1:local }${2:boolean retval},${3:number left},${4:number top},${5:number right},${6:number bottom} = reaper.BR_Win32_GetWindowRect(${7:identifier hwnd})$0"
    },
    "BR_WIN32_GETWINDOWRECT_WR python": {
        "prefix": "WR_BR_Win32_GetWindowRect",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindowRect().\n",
        "body": "${1:Boolean retval},${2:void hwnd},${3:Int leftOut},${4:Int topOut},${5:Int rightOut},${6:Int bottomOut} = BR_Win32_GetWindowRect(${7:hwnd},${8:leftOut},${9:topOut},${10:rightOut},${11:bottomOut})$0"
    },
    "BR_WIN32_GETWINDOWTEXT_WR c": {
        "prefix": "WR_BR_Win32_GetWindowText",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API GetWindowText().\n",
        "body": "${1:int} = BR_Win32_GetWindowText(${2:void* hwnd},${3:char* textOut},${4:int textOut_sz})$0"
    },
    "REAPER.BR_WIN32_GETWINDOWTEXT_WR lua": {
        "prefix": "reaperwr.BR_Win32_GetWindowText",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API GetWindowText().\n",
        "body": "${1:local }${2:integer retval},${3:string text} = reaper.BR_Win32_GetWindowText(${4:identifier hwnd})$0"
    },
    "BR_WIN32_GETWINDOWTEXT_WR python": {
        "prefix": "WR_BR_Win32_GetWindowText",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API GetWindowText().\n",
        "body": "${1:Int retval},${2:void hwnd},${3:String textOut},${4:Int textOut_sz} = BR_Win32_GetWindowText(${5:hwnd},${6:textOut},${7:textOut_sz})$0"
    },
    "BR_WIN32_HIBYTE_WR c": {
        "prefix": "WR_BR_Win32_HIBYTE",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API HIBYTE().\n",
        "body": "${1:int} = BR_Win32_HIBYTE(${2:int value})$0"
    },
    "REAPER.BR_WIN32_HIBYTE_WR lua": {
        "prefix": "reaperwr.BR_Win32_HIBYTE",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API HIBYTE().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_HIBYTE(${3:integer value})$0"
    },
    "BR_WIN32_HIBYTE_WR python": {
        "prefix": "WR_BR_Win32_HIBYTE",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API HIBYTE().\n",
        "body": "${1:Int} = BR_Win32_HIBYTE(${2:Int value})$0"
    },
    "BR_WIN32_HIWORD_WR c": {
        "prefix": "WR_BR_Win32_HIWORD",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API HIWORD().\n",
        "body": "${1:int} = BR_Win32_HIWORD(${2:int value})$0"
    },
    "REAPER.BR_WIN32_HIWORD_WR lua": {
        "prefix": "reaperwr.BR_Win32_HIWORD",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API HIWORD().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_HIWORD(${3:integer value})$0"
    },
    "BR_WIN32_HIWORD_WR python": {
        "prefix": "WR_BR_Win32_HIWORD",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API HIWORD().\n",
        "body": "${1:Int} = BR_Win32_HIWORD(${2:Int value})$0"
    },
    "BR_WIN32_HWNDTOSTRING_WR c": {
        "prefix": "WR_BR_Win32_HwndToString",
        "scope": "c",
        "description": "[BR] Convert HWND to string. To convert string back to HWND, see BR_Win32_StringToHwnd.\n",
        "body": "${1:void} = BR_Win32_HwndToString(${2:void* hwnd},${3:char* stringOut},${4:int stringOut_sz})$0"
    },
    "REAPER.BR_WIN32_HWNDTOSTRING_WR lua": {
        "prefix": "reaperwr.BR_Win32_HwndToString",
        "scope": "lua",
        "description": "[BR] Convert HWND to string. To convert string back to HWND, see BR_Win32_StringToHwnd.\n",
        "body": "${1:local }${2:string string} = reaper.BR_Win32_HwndToString(${3:identifier hwnd})$0"
    },
    "BR_WIN32_HWNDTOSTRING_WR python": {
        "prefix": "WR_BR_Win32_HwndToString",
        "scope": "python",
        "description": "[BR] Convert HWND to string. To convert string back to HWND, see BR_Win32_StringToHwnd.\n",
        "body": "${1:void hwnd},${2:String stringOut},${3:Int stringOut_sz} = BR_Win32_HwndToString(${4:hwnd},${5:stringOut},${6:stringOut_sz})$0"
    },
    "BR_WIN32_ISWINDOW_WR c": {
        "prefix": "WR_BR_Win32_IsWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API IsWindow().\n",
        "body": "${1:bool} = BR_Win32_IsWindow(${2:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_ISWINDOW_WR lua": {
        "prefix": "reaperwr.BR_Win32_IsWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API IsWindow().\n",
        "body": "${1:local }${2:boolean} = reaper.BR_Win32_IsWindow(${3:identifier hwnd})$0"
    },
    "BR_WIN32_ISWINDOW_WR python": {
        "prefix": "WR_BR_Win32_IsWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API IsWindow().\n",
        "body": "${1:Boolean} = BR_Win32_IsWindow(${2:void hwnd})$0"
    },
    "BR_WIN32_ISWINDOWVISIBLE_WR c": {
        "prefix": "WR_BR_Win32_IsWindowVisible",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API IsWindowVisible().\n",
        "body": "${1:bool} = BR_Win32_IsWindowVisible(${2:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_ISWINDOWVISIBLE_WR lua": {
        "prefix": "reaperwr.BR_Win32_IsWindowVisible",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API IsWindowVisible().\n",
        "body": "${1:local }${2:boolean} = reaper.BR_Win32_IsWindowVisible(${3:identifier hwnd})$0"
    },
    "BR_WIN32_ISWINDOWVISIBLE_WR python": {
        "prefix": "WR_BR_Win32_IsWindowVisible",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API IsWindowVisible().\n",
        "body": "${1:Boolean} = BR_Win32_IsWindowVisible(${2:void hwnd})$0"
    },
    "BR_WIN32_LOBYTE_WR c": {
        "prefix": "WR_BR_Win32_LOBYTE",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API LOBYTE().\n",
        "body": "${1:int} = BR_Win32_LOBYTE(${2:int value})$0"
    },
    "REAPER.BR_WIN32_LOBYTE_WR lua": {
        "prefix": "reaperwr.BR_Win32_LOBYTE",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API LOBYTE().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_LOBYTE(${3:integer value})$0"
    },
    "BR_WIN32_LOBYTE_WR python": {
        "prefix": "WR_BR_Win32_LOBYTE",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API LOBYTE().\n",
        "body": "${1:Int} = BR_Win32_LOBYTE(${2:Int value})$0"
    },
    "BR_WIN32_LOWORD_WR c": {
        "prefix": "WR_BR_Win32_LOWORD",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API LOWORD().\n",
        "body": "${1:int} = BR_Win32_LOWORD(${2:int value})$0"
    },
    "REAPER.BR_WIN32_LOWORD_WR lua": {
        "prefix": "reaperwr.BR_Win32_LOWORD",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API LOWORD().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_LOWORD(${3:integer value})$0"
    },
    "BR_WIN32_LOWORD_WR python": {
        "prefix": "WR_BR_Win32_LOWORD",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API LOWORD().\n",
        "body": "${1:Int} = BR_Win32_LOWORD(${2:Int value})$0"
    },
    "BR_WIN32_MAKELONG_WR c": {
        "prefix": "WR_BR_Win32_MAKELONG",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKELONG().\n",
        "body": "${1:int} = BR_Win32_MAKELONG(${2:int low},${3:int high})$0"
    },
    "REAPER.BR_WIN32_MAKELONG_WR lua": {
        "prefix": "reaperwr.BR_Win32_MAKELONG",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKELONG().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_MAKELONG(${3:integer low},${4:integer high})$0"
    },
    "BR_WIN32_MAKELONG_WR python": {
        "prefix": "WR_BR_Win32_MAKELONG",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKELONG().\n",
        "body": "${1:Int} = BR_Win32_MAKELONG(${2:Int low},${3:Int high})$0"
    },
    "BR_WIN32_MAKELPARAM_WR c": {
        "prefix": "WR_BR_Win32_MAKELPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKELPARAM().\n",
        "body": "${1:int} = BR_Win32_MAKELPARAM(${2:int low},${3:int high})$0"
    },
    "REAPER.BR_WIN32_MAKELPARAM_WR lua": {
        "prefix": "reaperwr.BR_Win32_MAKELPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKELPARAM().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_MAKELPARAM(${3:integer low},${4:integer high})$0"
    },
    "BR_WIN32_MAKELPARAM_WR python": {
        "prefix": "WR_BR_Win32_MAKELPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKELPARAM().\n",
        "body": "${1:Int} = BR_Win32_MAKELPARAM(${2:Int low},${3:Int high})$0"
    },
    "BR_WIN32_MAKELRESULT_WR c": {
        "prefix": "WR_BR_Win32_MAKELRESULT",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKELRESULT().\n",
        "body": "${1:int} = BR_Win32_MAKELRESULT(${2:int low},${3:int high})$0"
    },
    "REAPER.BR_WIN32_MAKELRESULT_WR lua": {
        "prefix": "reaperwr.BR_Win32_MAKELRESULT",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKELRESULT().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_MAKELRESULT(${3:integer low},${4:integer high})$0"
    },
    "BR_WIN32_MAKELRESULT_WR python": {
        "prefix": "WR_BR_Win32_MAKELRESULT",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKELRESULT().\n",
        "body": "${1:Int} = BR_Win32_MAKELRESULT(${2:Int low},${3:Int high})$0"
    },
    "BR_WIN32_MAKEWORD_WR c": {
        "prefix": "WR_BR_Win32_MAKEWORD",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKEWORD().\n",
        "body": "${1:int} = BR_Win32_MAKEWORD(${2:int low},${3:int high})$0"
    },
    "REAPER.BR_WIN32_MAKEWORD_WR lua": {
        "prefix": "reaperwr.BR_Win32_MAKEWORD",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKEWORD().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_MAKEWORD(${3:integer low},${4:integer high})$0"
    },
    "BR_WIN32_MAKEWORD_WR python": {
        "prefix": "WR_BR_Win32_MAKEWORD",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKEWORD().\n",
        "body": "${1:Int} = BR_Win32_MAKEWORD(${2:Int low},${3:Int high})$0"
    },
    "BR_WIN32_MAKEWPARAM_WR c": {
        "prefix": "WR_BR_Win32_MAKEWPARAM",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API MAKEWPARAM().\n",
        "body": "${1:int} = BR_Win32_MAKEWPARAM(${2:int low},${3:int high})$0"
    },
    "REAPER.BR_WIN32_MAKEWPARAM_WR lua": {
        "prefix": "reaperwr.BR_Win32_MAKEWPARAM",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API MAKEWPARAM().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_MAKEWPARAM(${3:integer low},${4:integer high})$0"
    },
    "BR_WIN32_MAKEWPARAM_WR python": {
        "prefix": "WR_BR_Win32_MAKEWPARAM",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API MAKEWPARAM().\n",
        "body": "${1:Int} = BR_Win32_MAKEWPARAM(${2:Int low},${3:Int high})$0"
    },
    "BR_WIN32_MIDIEDITOR_GETACTIVE_WR c": {
        "prefix": "WR_BR_Win32_MIDIEditor_GetActive",
        "scope": "c",
        "description": "[BR] Alternative to MIDIEditor_GetActive.\nREAPER seems to have problems with extensions using HWND type for\nexported functions so all BR_Win32 functions use void* instead of HWND\ntype.\n",
        "body": "${1:void*} = BR_Win32_MIDIEditor_GetActive()$0"
    },
    "REAPER.BR_WIN32_MIDIEDITOR_GETACTIVE_WR lua": {
        "prefix": "reaperwr.BR_Win32_MIDIEditor_GetActive",
        "scope": "lua",
        "description": "[BR] Alternative to MIDIEditor_GetActive.\nREAPER seems to have problems with extensions using HWND type for\nexported functions so all BR_Win32 functions use void* instead of HWND\ntype.\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_MIDIEditor_GetActive()$0"
    },
    "BR_WIN32_MIDIEDITOR_GETACTIVE_WR python": {
        "prefix": "WR_BR_Win32_MIDIEditor_GetActive",
        "scope": "python",
        "description": "[BR] Alternative to MIDIEditor_GetActive.\nREAPER seems to have problems with extensions using HWND type for\nexported functions so all BR_Win32 functions use void* instead of HWND\ntype.\n",
        "body": "${1:void} = BR_Win32_MIDIEditor_GetActive()$0"
    },
    "BR_WIN32_SCREENTOCLIENT_WR c": {
        "prefix": "WR_BR_Win32_ScreenToClient",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "${1:void} = BR_Win32_ScreenToClient(${2:void* hwnd},${3:int xIn},${4:int yIn},${5:int* xOut},${6:int* yOut})$0"
    },
    "REAPER.BR_WIN32_SCREENTOCLIENT_WR lua": {
        "prefix": "reaperwr.BR_Win32_ScreenToClient",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "${1:local }${2:number x},${3:number y} = reaper.BR_Win32_ScreenToClient(${4:identifier hwnd},${5:integer xIn},${6:integer yIn})$0"
    },
    "BR_WIN32_SCREENTOCLIENT_WR python": {
        "prefix": "WR_BR_Win32_ScreenToClient",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ClientToScreen().\n",
        "body": "${1:void hwnd},${2:Int xIn},${3:Int yIn},${4:Int xOut},${5:Int yOut} = BR_Win32_ScreenToClient(${6:hwnd},${7:xIn},${8:yIn},${9:xOut},${10:yOut})$0"
    },
    "BR_WIN32_SENDMESSAGE_WR c": {
        "prefix": "WR_BR_Win32_SendMessage",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SendMessage().\n",
        "body": "${1:int} = BR_Win32_SendMessage(${2:void* hwnd},${3:int msg},${4:int lParam},${5:int wParam})$0"
    },
    "REAPER.BR_WIN32_SENDMESSAGE_WR lua": {
        "prefix": "reaperwr.BR_Win32_SendMessage",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SendMessage().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_SendMessage(${3:identifier hwnd},${4:integer msg},${5:integer lParam},${6:integer wParam})$0"
    },
    "BR_WIN32_SENDMESSAGE_WR python": {
        "prefix": "WR_BR_Win32_SendMessage",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SendMessage().\n",
        "body": "${1:Int} = BR_Win32_SendMessage(${2:void hwnd},${3:Int msg},${4:Int lParam},${5:Int wParam})$0"
    },
    "BR_WIN32_SETFOCUS_WR c": {
        "prefix": "WR_BR_Win32_SetFocus",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetFocus().\n",
        "body": "${1:void*} = BR_Win32_SetFocus(${2:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_SETFOCUS_WR lua": {
        "prefix": "reaperwr.BR_Win32_SetFocus",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetFocus().\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_SetFocus(${3:identifier hwnd})$0"
    },
    "BR_WIN32_SETFOCUS_WR python": {
        "prefix": "WR_BR_Win32_SetFocus",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetFocus().\n",
        "body": "${1:void} = BR_Win32_SetFocus(${2:void hwnd})$0"
    },
    "BR_WIN32_SETFOREGROUNDWINDOW_WR c": {
        "prefix": "WR_BR_Win32_SetForegroundWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetForegroundWindow().\n",
        "body": "${1:int} = BR_Win32_SetForegroundWindow(${2:void* hwnd})$0"
    },
    "REAPER.BR_WIN32_SETFOREGROUNDWINDOW_WR lua": {
        "prefix": "reaperwr.BR_Win32_SetForegroundWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetForegroundWindow().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_SetForegroundWindow(${3:identifier hwnd})$0"
    },
    "BR_WIN32_SETFOREGROUNDWINDOW_WR python": {
        "prefix": "WR_BR_Win32_SetForegroundWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetForegroundWindow().\n",
        "body": "${1:Int} = BR_Win32_SetForegroundWindow(${2:void hwnd})$0"
    },
    "BR_WIN32_SETWINDOWLONG_WR c": {
        "prefix": "WR_BR_Win32_SetWindowLong",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetWindowLong().\n",
        "body": "${1:int} = BR_Win32_SetWindowLong(${2:void* hwnd},${3:int index},${4:int newLong})$0"
    },
    "REAPER.BR_WIN32_SETWINDOWLONG_WR lua": {
        "prefix": "reaperwr.BR_Win32_SetWindowLong",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetWindowLong().\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_SetWindowLong(${3:identifier hwnd},${4:integer index},${5:integer newLong})$0"
    },
    "BR_WIN32_SETWINDOWLONG_WR python": {
        "prefix": "WR_BR_Win32_SetWindowLong",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetWindowLong().\n",
        "body": "${1:Int} = BR_Win32_SetWindowLong(${2:void hwnd},${3:Int index},${4:Int newLong})$0"
    },
    "BR_WIN32_SETWINDOWPOS_WR c": {
        "prefix": "WR_BR_Win32_SetWindowPos",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API SetWindowPos().\nhwndInsertAfter may be a string: \"HWND_BOTTOM\", \"HWND_NOTOPMOST\", \"HWND_TOP\", \"HWND_TOPMOST\" or a string obtained with BR_Win32_HwndToString.\n",
        "body": "${1:bool} = BR_Win32_SetWindowPos(${2:void* hwnd},${3:const char* hwndInsertAfter},${4:int x},${5:int y},${6:int width},${7:int height},${8:int flags})$0"
    },
    "REAPER.BR_WIN32_SETWINDOWPOS_WR lua": {
        "prefix": "reaperwr.BR_Win32_SetWindowPos",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API SetWindowPos().\nhwndInsertAfter may be a string: \"HWND_BOTTOM\", \"HWND_NOTOPMOST\", \"HWND_TOP\", \"HWND_TOPMOST\" or a string obtained with BR_Win32_HwndToString.\n",
        "body": "${1:local }${2:boolean} = reaper.BR_Win32_SetWindowPos(${3:identifier hwnd},${4:string hwndInsertAfter},${5:integer x},${6:integer y},${7:integer width},${8:integer height},${9:integer flags})$0"
    },
    "BR_WIN32_SETWINDOWPOS_WR python": {
        "prefix": "WR_BR_Win32_SetWindowPos",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API SetWindowPos().\nhwndInsertAfter may be a string: \"HWND_BOTTOM\", \"HWND_NOTOPMOST\", \"HWND_TOP\", \"HWND_TOPMOST\" or a string obtained with BR_Win32_HwndToString.\n",
        "body": "${1:Boolean} = BR_Win32_SetWindowPos(${2:void hwnd},${3:String hwndInsertAfter},${4:Int x},${5:Int y},${6:Int width},${7:Int height},${8:Int flags})$0"
    },
    "BR_WIN32_SHELLEXECUTE_WR c": {
        "prefix": "WR_BR_Win32_ShellExecute",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ShellExecute() with HWND set to main window\n",
        "body": "${1:int} = BR_Win32_ShellExecute(${2:const char* operation},${3:const char* file},${4:const char* parameters},${5:const char* directory},${6:int showFlags})$0"
    },
    "REAPER.BR_WIN32_SHELLEXECUTE_WR lua": {
        "prefix": "reaperwr.BR_Win32_ShellExecute",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ShellExecute() with HWND set to main window\n",
        "body": "${1:local }${2:integer} = reaper.BR_Win32_ShellExecute(${3:string operation},${4:string file},${5:string parameters},${6:string directory},${7:integer showFlags})$0"
    },
    "BR_WIN32_SHELLEXECUTE_WR python": {
        "prefix": "WR_BR_Win32_ShellExecute",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ShellExecute() with HWND set to main window\n",
        "body": "${1:Int} = BR_Win32_ShellExecute(${2:String operation},${3:String file},${4:String parameters},${5:String directory},${6:Int showFlags})$0"
    },
    "BR_WIN32_SHOWWINDOW_WR c": {
        "prefix": "WR_BR_Win32_ShowWindow",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API ShowWindow().\n",
        "body": "${1:bool} = BR_Win32_ShowWindow(${2:void* hwnd},${3:int cmdShow})$0"
    },
    "REAPER.BR_WIN32_SHOWWINDOW_WR lua": {
        "prefix": "reaperwr.BR_Win32_ShowWindow",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API ShowWindow().\n",
        "body": "${1:local }${2:boolean} = reaper.BR_Win32_ShowWindow(${3:identifier hwnd},${4:integer cmdShow})$0"
    },
    "BR_WIN32_SHOWWINDOW_WR python": {
        "prefix": "WR_BR_Win32_ShowWindow",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API ShowWindow().\n",
        "body": "${1:Boolean} = BR_Win32_ShowWindow(${2:void hwnd},${3:Int cmdShow})$0"
    },
    "BR_WIN32_STRINGTOHWND_WR c": {
        "prefix": "WR_BR_Win32_StringToHwnd",
        "scope": "c",
        "description": "[BR] Convert string to HWND. To convert HWND back to string, see BR_Win32_HwndToString.\n",
        "body": "${1:void*} = BR_Win32_StringToHwnd(${2:const char* string})$0"
    },
    "REAPER.BR_WIN32_STRINGTOHWND_WR lua": {
        "prefix": "reaperwr.BR_Win32_StringToHwnd",
        "scope": "lua",
        "description": "[BR] Convert string to HWND. To convert HWND back to string, see BR_Win32_HwndToString.\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_StringToHwnd(${3:string string})$0"
    },
    "BR_WIN32_STRINGTOHWND_WR python": {
        "prefix": "WR_BR_Win32_StringToHwnd",
        "scope": "python",
        "description": "[BR] Convert string to HWND. To convert HWND back to string, see BR_Win32_HwndToString.\n",
        "body": "${1:void} = BR_Win32_StringToHwnd(${2:String string})$0"
    },
    "BR_WIN32_WINDOWFROMPOINT_WR c": {
        "prefix": "WR_BR_Win32_WindowFromPoint",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API WindowFromPoint().\n",
        "body": "${1:void*} = BR_Win32_WindowFromPoint(${2:int x},${3:int y})$0"
    },
    "REAPER.BR_WIN32_WINDOWFROMPOINT_WR lua": {
        "prefix": "reaperwr.BR_Win32_WindowFromPoint",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API WindowFromPoint().\n",
        "body": "${1:local }${2:identifier} = reaper.BR_Win32_WindowFromPoint(${3:integer x},${4:integer y})$0"
    },
    "BR_WIN32_WINDOWFROMPOINT_WR python": {
        "prefix": "WR_BR_Win32_WindowFromPoint",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API WindowFromPoint().\n",
        "body": "${1:void} = BR_Win32_WindowFromPoint(${2:Int x},${3:Int y})$0"
    },
    "BR_WIN32_WRITEPRIVATEPROFILESTRING_WR c": {
        "prefix": "WR_BR_Win32_WritePrivateProfileString",
        "scope": "c",
        "description": "[BR] Equivalent to win32 API WritePrivateProfileString(). For example, you can use this to write to REAPER.ini\n",
        "body": "${1:bool} = BR_Win32_WritePrivateProfileString(${2:const char* sectionName},${3:const char* keyName},${4:const char* value},${5:const char* filePath})$0"
    },
    "REAPER.BR_WIN32_WRITEPRIVATEPROFILESTRING_WR lua": {
        "prefix": "reaperwr.BR_Win32_WritePrivateProfileString",
        "scope": "lua",
        "description": "[BR] Equivalent to win32 API WritePrivateProfileString(). For example, you can use this to write to REAPER.ini\n",
        "body": "${1:local }${2:boolean} = reaper.BR_Win32_WritePrivateProfileString(${3:string sectionName},${4:string keyName},${5:string value},${6:string filePath})$0"
    },
    "BR_WIN32_WRITEPRIVATEPROFILESTRING_WR python": {
        "prefix": "WR_BR_Win32_WritePrivateProfileString",
        "scope": "python",
        "description": "[BR] Equivalent to win32 API WritePrivateProfileString(). For example, you can use this to write to REAPER.ini\n",
        "body": "${1:Boolean} = BR_Win32_WritePrivateProfileString(${2:String sectionName},${3:String keyName},${4:String value},${5:String filePath})$0"
    },
    "CF_ENUMMEDIASOURCECUES_WR c": {
        "prefix": "WR_CF_EnumMediaSourceCues",
        "scope": "c",
        "description": "Enumerate the source's media cues. Returns the next index or 0 when finished.\n",
        "body": "${1:int} = CF_EnumMediaSourceCues(${2:PCM_source* src},${3:int index},${4:double* timeOut},${5:double* endTimeOut},${6:bool* isRegionOut},${7:char* nameOut},${8:int nameOut_sz})$0"
    },
    "REAPER.CF_ENUMMEDIASOURCECUES_WR lua": {
        "prefix": "reaperwr.CF_EnumMediaSourceCues",
        "scope": "lua",
        "description": "Enumerate the source's media cues. Returns the next index or 0 when finished.\n",
        "body": "${1:local }${2:integer retval},${3:number time},${4:number endTime},${5:boolean isRegion},${6:string name} = reaper.CF_EnumMediaSourceCues(${7:PCM_source src},${8:integer index})$0"
    },
    "CF_ENUMMEDIASOURCECUES_WR python": {
        "prefix": "WR_CF_EnumMediaSourceCues",
        "scope": "python",
        "description": "Enumerate the source's media cues. Returns the next index or 0 when finished.\n",
        "body": "${1:Int retval},${2:PCM_source src},${3:Int index},${4:Float timeOut},${5:Float endTimeOut},${6:Boolean isRegionOut},${7:String nameOut},${8:Int nameOut_sz} = CF_EnumMediaSourceCues(${9:src},${10:index},${11:timeOut},${12:endTimeOut},${13:isRegionOut},${14:nameOut},${15:nameOut_sz})$0"
    },
    "CF_ENUMSELECTEDFX_WR c": {
        "prefix": "WR_CF_EnumSelectedFX",
        "scope": "c",
        "description": "Return the index of the next selected effect in the given FX chain.\nStart index should be -1. Returns -1 if there are no more selected\neffects.\n",
        "body": "${1:int} = CF_EnumSelectedFX(${2:FxChain* hwnd},${3:int index})$0"
    },
    "REAPER.CF_ENUMSELECTEDFX_WR lua": {
        "prefix": "reaperwr.CF_EnumSelectedFX",
        "scope": "lua",
        "description": "Return the index of the next selected effect in the given FX chain.\nStart index should be -1. Returns -1 if there are no more selected\neffects.\n",
        "body": "${1:local }${2:integer} = reaper.CF_EnumSelectedFX(${3:FxChain hwnd},${4:integer index})$0"
    },
    "CF_ENUMSELECTEDFX_WR python": {
        "prefix": "WR_CF_EnumSelectedFX",
        "scope": "python",
        "description": "Return the index of the next selected effect in the given FX chain.\nStart index should be -1. Returns -1 if there are no more selected\neffects.\n",
        "body": "${1:Int} = CF_EnumSelectedFX(${2:FxChain hwnd},${3:Int index})$0"
    },
    "CF_ENUMERATEACTIONS_WR c": {
        "prefix": "WR_CF_EnumerateActions",
        "scope": "c",
        "description": "Wrapper for the unexposed kbd_enumerateActions API function.\nMain=0, Main (alt recording)=100, MIDI Editor=32060, MIDI Event List\nEditor=32061, MIDI Inline Editor=32062, Media Explorer=32063\n",
        "body": "${1:int} = CF_EnumerateActions(${2:int section},${3:int index},${4:char* name},${5:int name_sz})$0"
    },
    "REAPER.CF_ENUMERATEACTIONS_WR lua": {
        "prefix": "reaperwr.CF_EnumerateActions",
        "scope": "lua",
        "description": "Wrapper for the unexposed kbd_enumerateActions API function.\nMain=0, Main (alt recording)=100, MIDI Editor=32060, MIDI Event List\nEditor=32061, MIDI Inline Editor=32062, Media Explorer=32063\n",
        "body": "${1:local }${2:integer retval},${3:string name} = reaper.CF_EnumerateActions(${4:integer section},${5:integer index},${6:string name})$0"
    },
    "CF_ENUMERATEACTIONS_WR python": {
        "prefix": "WR_CF_EnumerateActions",
        "scope": "python",
        "description": "Wrapper for the unexposed kbd_enumerateActions API function.\nMain=0, Main (alt recording)=100, MIDI Editor=32060, MIDI Event List\nEditor=32061, MIDI Inline Editor=32062, Media Explorer=32063\n",
        "body": "${1:Int retval},${2:Int section},${3:Int index},${4:String name},${5:Int name_sz} = CF_EnumerateActions(${6:section},${7:index},${8:name},${9:name_sz})$0"
    },
    "CF_EXPORTMEDIASOURCE_WR c": {
        "prefix": "WR_CF_ExportMediaSource",
        "scope": "c",
        "description": "Export the source to the given file (MIDI only).\n",
        "body": "${1:bool} = CF_ExportMediaSource(${2:PCM_source* src},${3:const char* fn})$0"
    },
    "REAPER.CF_EXPORTMEDIASOURCE_WR lua": {
        "prefix": "reaperwr.CF_ExportMediaSource",
        "scope": "lua",
        "description": "Export the source to the given file (MIDI only).\n",
        "body": "${1:local }${2:boolean} = reaper.CF_ExportMediaSource(${3:PCM_source src},${4:string fn})$0"
    },
    "CF_EXPORTMEDIASOURCE_WR python": {
        "prefix": "WR_CF_ExportMediaSource",
        "scope": "python",
        "description": "Export the source to the given file (MIDI only).\n",
        "body": "${1:Boolean} = CF_ExportMediaSource(${2:PCM_source src},${3:String fn})$0"
    },
    "CF_GETCLIPBOARD_WR c": {
        "prefix": "WR_CF_GetClipboard",
        "scope": "c",
        "description": "Read the contents of the system clipboard (limited to 1023 characters in Lua).\n",
        "body": "${1:void} = CF_GetClipboard(${2:char* buf},${3:int buf_sz})$0"
    },
    "REAPER.CF_GETCLIPBOARD_WR lua": {
        "prefix": "reaperwr.CF_GetClipboard",
        "scope": "lua",
        "description": "Read the contents of the system clipboard (limited to 1023 characters in Lua).\n",
        "body": "${1:local }${2:string buf} = reaper.CF_GetClipboard(${3:string buf})$0"
    },
    "CF_GETCLIPBOARD_WR python": {
        "prefix": "WR_CF_GetClipboard",
        "scope": "python",
        "description": "Read the contents of the system clipboard (limited to 1023 characters in Lua).\n",
        "body": "${1:String buf},${2:Int buf_sz} = CF_GetClipboard(${3:buf},${4:buf_sz})$0"
    },
    "CF_GETCLIPBOARDBIG_WR c": {
        "prefix": "WR_CF_GetClipboardBig",
        "scope": "c",
        "description": "Read the contents of the system clipboard. See SNM_CreateFastString and SNM_DeleteFastString.\n",
        "body": "${1:const char*} = CF_GetClipboardBig(${2:WDL_FastString* output})$0"
    },
    "REAPER.CF_GETCLIPBOARDBIG_WR lua": {
        "prefix": "reaperwr.CF_GetClipboardBig",
        "scope": "lua",
        "description": "Read the contents of the system clipboard. See SNM_CreateFastString and SNM_DeleteFastString.\n",
        "body": "${1:local }${2:string} = reaper.CF_GetClipboardBig(${3:WDL_FastString output})$0"
    },
    "CF_GETCLIPBOARDBIG_WR python": {
        "prefix": "WR_CF_GetClipboardBig",
        "scope": "python",
        "description": "Read the contents of the system clipboard. See SNM_CreateFastString and SNM_DeleteFastString.\n",
        "body": "${1:String} = CF_GetClipboardBig(${2:WDL_FastString output})$0"
    },
    "CF_GETCOMMANDTEXT_WR c": {
        "prefix": "WR_CF_GetCommandText",
        "scope": "c",
        "description": "Wrapper for the unexposed kbd_getTextFromCmd API function. See CF_EnumerateActions for common section IDs.\n",
        "body": "${1:const char*} = CF_GetCommandText(${2:int section},${3:int command})$0"
    },
    "REAPER.CF_GETCOMMANDTEXT_WR lua": {
        "prefix": "reaperwr.CF_GetCommandText",
        "scope": "lua",
        "description": "Wrapper for the unexposed kbd_getTextFromCmd API function. See CF_EnumerateActions for common section IDs.\n",
        "body": "${1:local }${2:string} = reaper.CF_GetCommandText(${3:integer section},${4:integer command})$0"
    },
    "CF_GETCOMMANDTEXT_WR python": {
        "prefix": "WR_CF_GetCommandText",
        "scope": "python",
        "description": "Wrapper for the unexposed kbd_getTextFromCmd API function. See CF_EnumerateActions for common section IDs.\n",
        "body": "${1:String} = CF_GetCommandText(${2:Int section},${3:Int command})$0"
    },
    "CF_GETFOCUSEDFXCHAIN_WR c": {
        "prefix": "WR_CF_GetFocusedFXChain",
        "scope": "c",
        "description": "Return a handle to the currently focused FX chain window.\n",
        "body": "${1:FxChain*} = CF_GetFocusedFXChain()$0"
    },
    "REAPER.CF_GETFOCUSEDFXCHAIN_WR lua": {
        "prefix": "reaperwr.CF_GetFocusedFXChain",
        "scope": "lua",
        "description": "Return a handle to the currently focused FX chain window.\n",
        "body": "${1:local }${2:FxChain} = reaper.CF_GetFocusedFXChain()$0"
    },
    "CF_GETFOCUSEDFXCHAIN_WR python": {
        "prefix": "WR_CF_GetFocusedFXChain",
        "scope": "python",
        "description": "Return a handle to the currently focused FX chain window.\n",
        "body": "${1:FxChain} = CF_GetFocusedFXChain()$0"
    },
    "CF_GETMEDIASOURCEBITDEPTH_WR c": {
        "prefix": "WR_CF_GetMediaSourceBitDepth",
        "scope": "c",
        "description": "Returns the bit depth if available (0 otherwise).\n",
        "body": "${1:int} = CF_GetMediaSourceBitDepth(${2:PCM_source* src})$0"
    },
    "REAPER.CF_GETMEDIASOURCEBITDEPTH_WR lua": {
        "prefix": "reaperwr.CF_GetMediaSourceBitDepth",
        "scope": "lua",
        "description": "Returns the bit depth if available (0 otherwise).\n",
        "body": "${1:local }${2:integer} = reaper.CF_GetMediaSourceBitDepth(${3:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCEBITDEPTH_WR python": {
        "prefix": "WR_CF_GetMediaSourceBitDepth",
        "scope": "python",
        "description": "Returns the bit depth if available (0 otherwise).\n",
        "body": "${1:Int} = CF_GetMediaSourceBitDepth(${2:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCEMETADATA_WR c": {
        "prefix": "WR_CF_GetMediaSourceMetadata",
        "scope": "c",
        "description": "Get the value of the given metadata field (eg. DESC, ORIG, ORIGREF, DATE, TIME, UMI, CODINGHISTORY for BWF).\n",
        "body": "${1:bool} = CF_GetMediaSourceMetadata(${2:PCM_source* src},${3:const char* name},${4:char* out},${5:int out_sz})$0"
    },
    "REAPER.CF_GETMEDIASOURCEMETADATA_WR lua": {
        "prefix": "reaperwr.CF_GetMediaSourceMetadata",
        "scope": "lua",
        "description": "Get the value of the given metadata field (eg. DESC, ORIG, ORIGREF, DATE, TIME, UMI, CODINGHISTORY for BWF).\n",
        "body": "${1:local }${2:boolean retval},${3:string out} = reaper.CF_GetMediaSourceMetadata(${4:PCM_source src},${5:string name},${6:string out})$0"
    },
    "CF_GETMEDIASOURCEMETADATA_WR python": {
        "prefix": "WR_CF_GetMediaSourceMetadata",
        "scope": "python",
        "description": "Get the value of the given metadata field (eg. DESC, ORIG, ORIGREF, DATE, TIME, UMI, CODINGHISTORY for BWF).\n",
        "body": "${1:Boolean retval},${2:PCM_source src},${3:String name},${4:String out},${5:Int out_sz} = CF_GetMediaSourceMetadata(${6:src},${7:name},${8:out},${9:out_sz})$0"
    },
    "CF_GETMEDIASOURCEONLINE_WR c": {
        "prefix": "WR_CF_GetMediaSourceOnline",
        "scope": "c",
        "description": "Returns the online/offline status of the given source.\n",
        "body": "${1:bool} = CF_GetMediaSourceOnline(${2:PCM_source* src})$0"
    },
    "REAPER.CF_GETMEDIASOURCEONLINE_WR lua": {
        "prefix": "reaperwr.CF_GetMediaSourceOnline",
        "scope": "lua",
        "description": "Returns the online/offline status of the given source.\n",
        "body": "${1:local }${2:boolean} = reaper.CF_GetMediaSourceOnline(${3:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCEONLINE_WR python": {
        "prefix": "WR_CF_GetMediaSourceOnline",
        "scope": "python",
        "description": "Returns the online/offline status of the given source.\n",
        "body": "${1:Boolean} = CF_GetMediaSourceOnline(${2:PCM_source src})$0"
    },
    "CF_GETMEDIASOURCERPP_WR c": {
        "prefix": "WR_CF_GetMediaSourceRPP",
        "scope": "c",
        "description": "Get the project associated with this source (BWF, subproject...).\n",
        "body": "${1:bool} = CF_GetMediaSourceRPP(${2:PCM_source* src},${3:char* fn},${4:int fn_sz})$0"
    },
    "REAPER.CF_GETMEDIASOURCERPP_WR lua": {
        "prefix": "reaperwr.CF_GetMediaSourceRPP",
        "scope": "lua",
        "description": "Get the project associated with this source (BWF, subproject...).\n",
        "body": "${1:local }${2:boolean retval},${3:string fn} = reaper.CF_GetMediaSourceRPP(${4:PCM_source src},${5:string fn})$0"
    },
    "CF_GETMEDIASOURCERPP_WR python": {
        "prefix": "WR_CF_GetMediaSourceRPP",
        "scope": "python",
        "description": "Get the project associated with this source (BWF, subproject...).\n",
        "body": "${1:Boolean retval},${2:PCM_source src},${3:String fn},${4:Int fn_sz} = CF_GetMediaSourceRPP(${5:src},${6:fn},${7:fn_sz})$0"
    },
    "CF_GETSWSVERSION_WR c": {
        "prefix": "WR_CF_GetSWSVersion",
        "scope": "c",
        "description": "Return the current SWS version number.\n",
        "body": "${1:void} = CF_GetSWSVersion(${2:char* buf},${3:int buf_sz})$0"
    },
    "REAPER.CF_GETSWSVERSION_WR lua": {
        "prefix": "reaperwr.CF_GetSWSVersion",
        "scope": "lua",
        "description": "Return the current SWS version number.\n",
        "body": "${1:local }${2:string buf} = reaper.CF_GetSWSVersion(${3:string buf})$0"
    },
    "CF_GETSWSVERSION_WR python": {
        "prefix": "WR_CF_GetSWSVersion",
        "scope": "python",
        "description": "Return the current SWS version number.\n",
        "body": "${1:String buf},${2:Int buf_sz} = CF_GetSWSVersion(${3:buf},${4:buf_sz})$0"
    },
    "CF_GETTAKEFXCHAIN_WR c": {
        "prefix": "WR_CF_GetTakeFXChain",
        "scope": "c",
        "description": "Return a handle to the given take FX chain window. HACK: This\ntemporarily renames the take in order to disambiguate the take FX chain\nwindow from similarily named takes.\n",
        "body": "${1:FxChain*} = CF_GetTakeFXChain(${2:MediaItem_Take* take})$0"
    },
    "REAPER.CF_GETTAKEFXCHAIN_WR lua": {
        "prefix": "reaperwr.CF_GetTakeFXChain",
        "scope": "lua",
        "description": "Return a handle to the given take FX chain window. HACK: This\ntemporarily renames the take in order to disambiguate the take FX chain\nwindow from similarily named takes.\n",
        "body": "${1:local }${2:FxChain} = reaper.CF_GetTakeFXChain(${3:MediaItem_Take take})$0"
    },
    "CF_GETTAKEFXCHAIN_WR python": {
        "prefix": "WR_CF_GetTakeFXChain",
        "scope": "python",
        "description": "Return a handle to the given take FX chain window. HACK: This\ntemporarily renames the take in order to disambiguate the take FX chain\nwindow from similarily named takes.\n",
        "body": "${1:FxChain} = CF_GetTakeFXChain(${2:MediaItem_Take take})$0"
    },
    "CF_GETTRACKFXCHAIN_WR c": {
        "prefix": "WR_CF_GetTrackFXChain",
        "scope": "c",
        "description": "Return a handle to the given track FX chain window.\n",
        "body": "${1:FxChain*} = CF_GetTrackFXChain(${2:MediaTrack* track})$0"
    },
    "REAPER.CF_GETTRACKFXCHAIN_WR lua": {
        "prefix": "reaperwr.CF_GetTrackFXChain",
        "scope": "lua",
        "description": "Return a handle to the given track FX chain window.\n",
        "body": "${1:local }${2:FxChain} = reaper.CF_GetTrackFXChain(${3:MediaTrack track})$0"
    },
    "CF_GETTRACKFXCHAIN_WR python": {
        "prefix": "WR_CF_GetTrackFXChain",
        "scope": "python",
        "description": "Return a handle to the given track FX chain window.\n",
        "body": "${1:FxChain} = CF_GetTrackFXChain(${2:MediaTrack track})$0"
    },
    "CF_LOCATEINEXPLORER_WR c": {
        "prefix": "WR_CF_LocateInExplorer",
        "scope": "c",
        "description": "Select the given file in explorer/finder.\n",
        "body": "${1:bool} = CF_LocateInExplorer(${2:const char* file})$0"
    },
    "REAPER.CF_LOCATEINEXPLORER_WR lua": {
        "prefix": "reaperwr.CF_LocateInExplorer",
        "scope": "lua",
        "description": "Select the given file in explorer/finder.\n",
        "body": "${1:local }${2:boolean} = reaper.CF_LocateInExplorer(${3:string file})$0"
    },
    "CF_LOCATEINEXPLORER_WR python": {
        "prefix": "WR_CF_LocateInExplorer",
        "scope": "python",
        "description": "Select the given file in explorer/finder.\n",
        "body": "${1:Boolean} = CF_LocateInExplorer(${2:String file})$0"
    },
    "CF_SETCLIPBOARD_WR c": {
        "prefix": "WR_CF_SetClipboard",
        "scope": "c",
        "description": "Write the given string into the system clipboard.\n",
        "body": "${1:void} = CF_SetClipboard(${2:const char* str})$0"
    },
    "CF_SETMEDIASOURCEONLINE_WR c": {
        "prefix": "WR_CF_SetMediaSourceOnline",
        "scope": "c",
        "description": "Set the online/offline status of the given source (closes files when set=false).\n",
        "body": "${1:void} = CF_SetMediaSourceOnline(${2:PCM_source* src},${3:bool set})$0"
    },
    "CF_SHELLEXECUTE_WR c": {
        "prefix": "WR_CF_ShellExecute",
        "scope": "c",
        "description": "Open the given file or URL in the default application. See also CF_LocateInExplorer.\n",
        "body": "${1:bool} = CF_ShellExecute(${2:const char* file})$0"
    },
    "REAPER.CF_SHELLEXECUTE_WR lua": {
        "prefix": "reaperwr.CF_ShellExecute",
        "scope": "lua",
        "description": "Open the given file or URL in the default application. See also CF_LocateInExplorer.\n",
        "body": "${1:local }${2:boolean} = reaper.CF_ShellExecute(${3:string file})$0"
    },
    "CF_SHELLEXECUTE_WR python": {
        "prefix": "WR_CF_ShellExecute",
        "scope": "python",
        "description": "Open the given file or URL in the default application. See also CF_LocateInExplorer.\n",
        "body": "${1:Boolean} = CF_ShellExecute(${2:String file})$0"
    },
    "FNG_ADDMIDINOTE_WR c": {
        "prefix": "WR_FNG_AddMidiNote",
        "scope": "c",
        "description": "[FNG] Add MIDI note to MIDI take\n",
        "body": "${1:RprMidiNote*} = FNG_AddMidiNote(${2:RprMidiTake* midiTake})$0"
    },
    "REAPER.FNG_ADDMIDINOTE_WR lua": {
        "prefix": "reaperwr.FNG_AddMidiNote",
        "scope": "lua",
        "description": "[FNG] Add MIDI note to MIDI take\n",
        "body": "${1:local }${2:RprMidiNote} = reaper.FNG_AddMidiNote(${3:RprMidiTake midiTake})$0"
    },
    "FNG_ADDMIDINOTE_WR python": {
        "prefix": "WR_FNG_AddMidiNote",
        "scope": "python",
        "description": "[FNG] Add MIDI note to MIDI take\n",
        "body": "${1:RprMidiNote} = FNG_AddMidiNote(${2:RprMidiTake midiTake})$0"
    },
    "FNG_ALLOCMIDITAKE_WR c": {
        "prefix": "WR_FNG_AllocMidiTake",
        "scope": "c",
        "description": "[FNG] Allocate a RprMidiTake from a take pointer. Returns a NULL pointer if the take is not an in-project MIDI take\n",
        "body": "${1:RprMidiTake*} = FNG_AllocMidiTake(${2:MediaItem_Take* take})$0"
    },
    "REAPER.FNG_ALLOCMIDITAKE_WR lua": {
        "prefix": "reaperwr.FNG_AllocMidiTake",
        "scope": "lua",
        "description": "[FNG] Allocate a RprMidiTake from a take pointer. Returns a NULL pointer if the take is not an in-project MIDI take\n",
        "body": "${1:local }${2:RprMidiTake} = reaper.FNG_AllocMidiTake(${3:MediaItem_Take take})$0"
    },
    "FNG_ALLOCMIDITAKE_WR python": {
        "prefix": "WR_FNG_AllocMidiTake",
        "scope": "python",
        "description": "[FNG] Allocate a RprMidiTake from a take pointer. Returns a NULL pointer if the take is not an in-project MIDI take\n",
        "body": "${1:RprMidiTake} = FNG_AllocMidiTake(${2:MediaItem_Take take})$0"
    },
    "FNG_COUNTMIDINOTES_WR c": {
        "prefix": "WR_FNG_CountMidiNotes",
        "scope": "c",
        "description": "[FNG] Count of how many MIDI notes are in the MIDI take\n",
        "body": "${1:int} = FNG_CountMidiNotes(${2:RprMidiTake* midiTake})$0"
    },
    "REAPER.FNG_COUNTMIDINOTES_WR lua": {
        "prefix": "reaperwr.FNG_CountMidiNotes",
        "scope": "lua",
        "description": "[FNG] Count of how many MIDI notes are in the MIDI take\n",
        "body": "${1:local }${2:integer} = reaper.FNG_CountMidiNotes(${3:RprMidiTake midiTake})$0"
    },
    "FNG_COUNTMIDINOTES_WR python": {
        "prefix": "WR_FNG_CountMidiNotes",
        "scope": "python",
        "description": "[FNG] Count of how many MIDI notes are in the MIDI take\n",
        "body": "${1:Int} = FNG_CountMidiNotes(${2:RprMidiTake midiTake})$0"
    },
    "FNG_FREEMIDITAKE_WR c": {
        "prefix": "WR_FNG_FreeMidiTake",
        "scope": "c",
        "description": "[FNG] Commit changes to MIDI take and free allocated memory\n",
        "body": "${1:void} = FNG_FreeMidiTake(${2:RprMidiTake* midiTake})$0"
    },
    "FNG_GETMIDINOTE_WR c": {
        "prefix": "WR_FNG_GetMidiNote",
        "scope": "c",
        "description": "[FNG] Get a MIDI note from a MIDI take at specified index\n",
        "body": "${1:RprMidiNote*} = FNG_GetMidiNote(${2:RprMidiTake* midiTake},${3:int index})$0"
    },
    "REAPER.FNG_GETMIDINOTE_WR lua": {
        "prefix": "reaperwr.FNG_GetMidiNote",
        "scope": "lua",
        "description": "[FNG] Get a MIDI note from a MIDI take at specified index\n",
        "body": "${1:local }${2:RprMidiNote} = reaper.FNG_GetMidiNote(${3:RprMidiTake midiTake},${4:integer index})$0"
    },
    "FNG_GETMIDINOTE_WR python": {
        "prefix": "WR_FNG_GetMidiNote",
        "scope": "python",
        "description": "[FNG] Get a MIDI note from a MIDI take at specified index\n",
        "body": "${1:RprMidiNote} = FNG_GetMidiNote(${2:RprMidiTake midiTake},${3:Int index})$0"
    },
    "FNG_GETMIDINOTEINTPROPERTY_WR c": {
        "prefix": "WR_FNG_GetMidiNoteIntProperty",
        "scope": "c",
        "description": "[FNG] Get MIDI note property\n",
        "body": "${1:int} = FNG_GetMidiNoteIntProperty(${2:RprMidiNote* midiNote},${3:const char* property})$0"
    },
    "REAPER.FNG_GETMIDINOTEINTPROPERTY_WR lua": {
        "prefix": "reaperwr.FNG_GetMidiNoteIntProperty",
        "scope": "lua",
        "description": "[FNG] Get MIDI note property\n",
        "body": "${1:local }${2:integer} = reaper.FNG_GetMidiNoteIntProperty(${3:RprMidiNote midiNote},${4:string property})$0"
    },
    "FNG_GETMIDINOTEINTPROPERTY_WR python": {
        "prefix": "WR_FNG_GetMidiNoteIntProperty",
        "scope": "python",
        "description": "[FNG] Get MIDI note property\n",
        "body": "${1:Int} = FNG_GetMidiNoteIntProperty(${2:RprMidiNote midiNote},${3:String property})$0"
    },
    "FNG_SETMIDINOTEINTPROPERTY_WR c": {
        "prefix": "WR_FNG_SetMidiNoteIntProperty",
        "scope": "c",
        "description": "[FNG] Set MIDI note property\n",
        "body": "${1:void} = FNG_SetMidiNoteIntProperty(${2:RprMidiNote* midiNote},${3:const char* property},${4:int value})$0"
    },
    "JS_BYTE_WR c": {
        "prefix": "WR_JS_Byte",
        "scope": "c",
        "description": "Returns the unsigned byte at address[offset]. Offset is added as steps of 1 byte each.\n",
        "body": "${1:void} = JS_Byte(${2:void* pointer},${3:int offset},${4:int* byteOut})$0"
    },
    "REAPER.JS_BYTE_WR lua": {
        "prefix": "reaperwr.JS_Byte",
        "scope": "lua",
        "description": "Returns the unsigned byte at address[offset]. Offset is added as steps of 1 byte each.\n",
        "body": "${1:local }${2:number byte} = reaper.JS_Byte(${3:identifier pointer},${4:integer offset})$0"
    },
    "JS_BYTE_WR python": {
        "prefix": "WR_JS_Byte",
        "scope": "python",
        "description": "Returns the unsigned byte at address[offset]. Offset is added as steps of 1 byte each.\n",
        "body": "${1:void pointer},${2:Int offset},${3:Int byteOut} = JS_Byte(${4:pointer},${5:offset},${6:byteOut})$0"
    },
    "JS_COMPOSITE_WR c": {
        "prefix": "WR_JS_Composite",
        "scope": "c",
        "description": "Composites a LICE bitmap with a REAPER window.  Each time that the\nwindow is re-drawn, the bitmap will be blitted over the window's client\narea (with per-pixel alpha blending).\n* If dstw or dsth is -1, the bitmap will be stretched to fill the width or height of the window, respectively.\n* autoUpdate is an optional parameter that is false by default. If\ntrue, JS_Composite will automatically invalidate and re-draw the part of\nthe window that covers the current position of the bitmap, and if the\nbitmap is being moved, also the previous position. (If only one or a\nhandful of bitmaps are being moved across the screen, autoUpdate should\nresult in smoother animation on WindowsOS; if numerous bitmaps are\nspread over the entire window, it may be faster to disable autoUpdate\nand instead call JS_Window_InvalidateRect explicitly once all bitmaps\nhave been moved.)\n* InvalidateRect should also be called whenever the contents of the\nbitmap contents have been changed, but not the position, to trigger a\nwindow update.\n* On WindowsOS, the key to reducing flickering is to slow down the\nfrequency at which the window is re-drawn. InvalidateRect should only be\ncalled when absolutely necessary, preferably not more than 10 times per\nsecond.  (Also refer to the JS_Composite_Delay function.)\n* On WindowsOS, flickering can further be reduced by keeping the\ninvalidated area as small as possible, covering only the bitmaps that\nhave been edited or moved.  However, if numerous bitmaps are spread over\nthe entire window, it may be faster to simply invalidate the entire\nclient area.\n* This function should not be applied directly to top-level windows, but rather to child windows.\n* Some classes of UI elements, particularly buttons, do not take kindly to being composited, and may crash REAPER.\n* On WindowsOS, GDI blitting does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\nReturns:\n1 if successful, otherwise -1 = windowHWND is not a window, -3 = Could\nnot obtain the original window process, -4 = sysBitmap is not a LICE\nbitmap, -5 = sysBitmap is not a system bitmap, -6 = Could not obtain the\nwindow HDC.\n",
        "body": "${1:int} = JS_Composite(${2:void* windowHWND},${3:int srcx},${4:int srcy},${5:int srcw},${6:int srch},${7:void* sysBitmap},${8:int dstx},${9:int dsty},${10:int dstw},${11:int dsth},${12:bool* autoUpdateOptional})$0"
    },
    "REAPER.JS_COMPOSITE_WR lua": {
        "prefix": "reaperwr.JS_Composite",
        "scope": "lua",
        "description": "Composites a LICE bitmap with a REAPER window.  Each time that the\nwindow is re-drawn, the bitmap will be blitted over the window's client\narea (with per-pixel alpha blending).\n* If dstw or dsth is -1, the bitmap will be stretched to fill the width or height of the window, respectively.\n* autoUpdate is an optional parameter that is false by default. If\ntrue, JS_Composite will automatically invalidate and re-draw the part of\nthe window that covers the current position of the bitmap, and if the\nbitmap is being moved, also the previous position. (If only one or a\nhandful of bitmaps are being moved across the screen, autoUpdate should\nresult in smoother animation on WindowsOS; if numerous bitmaps are\nspread over the entire window, it may be faster to disable autoUpdate\nand instead call JS_Window_InvalidateRect explicitly once all bitmaps\nhave been moved.)\n* InvalidateRect should also be called whenever the contents of the\nbitmap contents have been changed, but not the position, to trigger a\nwindow update.\n* On WindowsOS, the key to reducing flickering is to slow down the\nfrequency at which the window is re-drawn. InvalidateRect should only be\ncalled when absolutely necessary, preferably not more than 10 times per\nsecond.  (Also refer to the JS_Composite_Delay function.)\n* On WindowsOS, flickering can further be reduced by keeping the\ninvalidated area as small as possible, covering only the bitmaps that\nhave been edited or moved.  However, if numerous bitmaps are spread over\nthe entire window, it may be faster to simply invalidate the entire\nclient area.\n* This function should not be applied directly to top-level windows, but rather to child windows.\n* Some classes of UI elements, particularly buttons, do not take kindly to being composited, and may crash REAPER.\n* On WindowsOS, GDI blitting does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\nReturns:\n1 if successful, otherwise -1 = windowHWND is not a window, -3 = Could\nnot obtain the original window process, -4 = sysBitmap is not a LICE\nbitmap, -5 = sysBitmap is not a system bitmap, -6 = Could not obtain the\nwindow HDC.\n",
        "body": "${1:local }${2:integer} = reaper.JS_Composite(${3:identifier windowHWND},${4:integer srcx},${5:integer srcy},${6:integer srcw},${7:integer srch},${8:identifier sysBitmap},${9:integer dstx},${10:integer dsty},${11:integer dstw},${12:integer dsth},${13:unsupported autoUpdate})$0"
    },
    "JS_COMPOSITE_WR python": {
        "prefix": "WR_JS_Composite",
        "scope": "python",
        "description": "Composites a LICE bitmap with a REAPER window.  Each time that the\nwindow is re-drawn, the bitmap will be blitted over the window's client\narea (with per-pixel alpha blending).\n* If dstw or dsth is -1, the bitmap will be stretched to fill the width or height of the window, respectively.\n* autoUpdate is an optional parameter that is false by default. If\ntrue, JS_Composite will automatically invalidate and re-draw the part of\nthe window that covers the current position of the bitmap, and if the\nbitmap is being moved, also the previous position. (If only one or a\nhandful of bitmaps are being moved across the screen, autoUpdate should\nresult in smoother animation on WindowsOS; if numerous bitmaps are\nspread over the entire window, it may be faster to disable autoUpdate\nand instead call JS_Window_InvalidateRect explicitly once all bitmaps\nhave been moved.)\n* InvalidateRect should also be called whenever the contents of the\nbitmap contents have been changed, but not the position, to trigger a\nwindow update.\n* On WindowsOS, the key to reducing flickering is to slow down the\nfrequency at which the window is re-drawn. InvalidateRect should only be\ncalled when absolutely necessary, preferably not more than 10 times per\nsecond.  (Also refer to the JS_Composite_Delay function.)\n* On WindowsOS, flickering can further be reduced by keeping the\ninvalidated area as small as possible, covering only the bitmaps that\nhave been edited or moved.  However, if numerous bitmaps are spread over\nthe entire window, it may be faster to simply invalidate the entire\nclient area.\n* This function should not be applied directly to top-level windows, but rather to child windows.\n* Some classes of UI elements, particularly buttons, do not take kindly to being composited, and may crash REAPER.\n* On WindowsOS, GDI blitting does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\nReturns:\n1 if successful, otherwise -1 = windowHWND is not a window, -3 = Could\nnot obtain the original window process, -4 = sysBitmap is not a LICE\nbitmap, -5 = sysBitmap is not a system bitmap, -6 = Could not obtain the\nwindow HDC.\n",
        "body": "${1:Int retval},${2:void windowHWND},${3:Int srcx},${4:Int srcy},${5:Int srcw},${6:Int srch},${7:void sysBitmap},${8:Int dstx},${9:Int dsty},${10:Int dstw},${11:Int dsth},${12:Boolean autoUpdateOptional} = JS_Composite(${13:windowHWND},${14:srcx},${15:srcy},${16:srcw},${17:srch},${18:sysBitmap},${19:dstx},${20:dsty},${21:dstw},${22:dsth},${23:autoUpdateOptional})$0"
    },
    "JS_COMPOSITE_DELAY_WR c": {
        "prefix": "WR_JS_Composite_Delay",
        "scope": "c",
        "description": "On WindowsOS, flickering of composited images can be improved\nconsiderably by slowing the refresh rate of the window.  The optimal\nrefresh rate may depend on the number of composited bitmaps.\nminTime is the minimum refresh delay, in seconds, when only one bitmap\nis composited onto the window.  The delay time will increase linearly\nwith the number of bitmaps, up to a maximum of maxTime when\nnumBitmapsWhenMax is reached.\nReturns:\n* retval = 1 if successful, 0 if arguments are invalid (i.e. if maxTime < minTime, or maxBitmaps < 1).\n* If delay times have not previously been set for this window, prev values are -1.\n",
        "body": "${1:int} = JS_Composite_Delay(${2:void* windowHWND},${3:double minTime},${4:double maxTime},${5:int numBitmapsWhenMax},${6:double* prevMinTimeOut},${7:double* prevMaxTimeOut},${8:int* prevBitmapsOut})$0"
    },
    "REAPER.JS_COMPOSITE_DELAY_WR lua": {
        "prefix": "reaperwr.JS_Composite_Delay",
        "scope": "lua",
        "description": "On WindowsOS, flickering of composited images can be improved\nconsiderably by slowing the refresh rate of the window.  The optimal\nrefresh rate may depend on the number of composited bitmaps.\nminTime is the minimum refresh delay, in seconds, when only one bitmap\nis composited onto the window.  The delay time will increase linearly\nwith the number of bitmaps, up to a maximum of maxTime when\nnumBitmapsWhenMax is reached.\nReturns:\n* retval = 1 if successful, 0 if arguments are invalid (i.e. if maxTime < minTime, or maxBitmaps < 1).\n* If delay times have not previously been set for this window, prev values are -1.\n",
        "body": "${1:local }${2:integer retval},${3:number prevMinTime},${4:number prevMaxTime},${5:number prevBitmaps} = reaper.JS_Composite_Delay(${6:identifier windowHWND},${7:number minTime},${8:number maxTime},${9:integer numBitmapsWhenMax})$0"
    },
    "JS_COMPOSITE_DELAY_WR python": {
        "prefix": "WR_JS_Composite_Delay",
        "scope": "python",
        "description": "On WindowsOS, flickering of composited images can be improved\nconsiderably by slowing the refresh rate of the window.  The optimal\nrefresh rate may depend on the number of composited bitmaps.\nminTime is the minimum refresh delay, in seconds, when only one bitmap\nis composited onto the window.  The delay time will increase linearly\nwith the number of bitmaps, up to a maximum of maxTime when\nnumBitmapsWhenMax is reached.\nReturns:\n* retval = 1 if successful, 0 if arguments are invalid (i.e. if maxTime < minTime, or maxBitmaps < 1).\n* If delay times have not previously been set for this window, prev values are -1.\n",
        "body": "${1:Int retval},${2:void windowHWND},${3:Float minTime},${4:Float maxTime},${5:Int numBitmapsWhenMax},${6:Float prevMinTimeOut},${7:Float prevMaxTimeOut},${8:Int prevBitmapsOut} = JS_Composite_Delay(${9:windowHWND},${10:minTime},${11:maxTime},${12:numBitmapsWhenMax},${13:prevMinTimeOut},${14:prevMaxTimeOut},${15:prevBitmapsOut})$0"
    },
    "JS_COMPOSITE_LISTBITMAPS_WR c": {
        "prefix": "WR_JS_Composite_ListBitmaps",
        "scope": "c",
        "description": "Returns all bitmaps composited to the given window.\nThe list is formatted as a comma-separated string of hexadecimal values, each representing a LICE_IBitmap* pointer.\nretval is the number of linked bitmaps found, or negative if an error occured.\n",
        "body": "${1:int} = JS_Composite_ListBitmaps(${2:void* windowHWND},${3:char* listOutNeedBig},${4:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_COMPOSITE_LISTBITMAPS_WR lua": {
        "prefix": "reaperwr.JS_Composite_ListBitmaps",
        "scope": "lua",
        "description": "Returns all bitmaps composited to the given window.\nThe list is formatted as a comma-separated string of hexadecimal values, each representing a LICE_IBitmap* pointer.\nretval is the number of linked bitmaps found, or negative if an error occured.\n",
        "body": "${1:local }${2:integer retval},${3:string list} = reaper.JS_Composite_ListBitmaps(${4:identifier windowHWND})$0"
    },
    "JS_COMPOSITE_LISTBITMAPS_WR python": {
        "prefix": "WR_JS_Composite_ListBitmaps",
        "scope": "python",
        "description": "Returns all bitmaps composited to the given window.\nThe list is formatted as a comma-separated string of hexadecimal values, each representing a LICE_IBitmap* pointer.\nretval is the number of linked bitmaps found, or negative if an error occured.\n",
        "body": "${1:Int retval},${2:void windowHWND},${3:String listOutNeedBig},${4:Int listOutNeedBig_sz} = JS_Composite_ListBitmaps(${5:windowHWND},${6:listOutNeedBig},${7:listOutNeedBig_sz})$0"
    },
    "JS_COMPOSITE_UNLINK_WR c": {
        "prefix": "WR_JS_Composite_Unlink",
        "scope": "c",
        "description": "Unlinks the window and bitmap.\n* autoUpdate is an optional parameter. If unlinking a single bitmap and\nautoUpdate is true, the function will automatically re-draw the window\nto remove the blitted image.\nIf no bitmap is specified, all bitmaps composited to the window will be unlinked -- even those by other scripts.\n",
        "body": "${1:void} = JS_Composite_Unlink(${2:void* windowHWND},${3:void* bitmapOptional},${4:bool* autoUpdateOptional})$0"
    },
    "JS_COMPOSITE_UNLINK_WR python": {
        "prefix": "WR_JS_Composite_Unlink",
        "scope": "python",
        "description": "Unlinks the window and bitmap.\n* autoUpdate is an optional parameter. If unlinking a single bitmap and\nautoUpdate is true, the function will automatically re-draw the window\nto remove the blitted image.\nIf no bitmap is specified, all bitmaps composited to the window will be unlinked -- even those by other scripts.\n",
        "body": "${1:void windowHWND},${2:void bitmapOptional},${3:Boolean autoUpdateOptional} = JS_Composite_Unlink(${4:windowHWND},${5:bitmapOptional},${6:autoUpdateOptional})$0"
    },
    "JS_DIALOG_BROWSEFORFOLDER_WR c": {
        "prefix": "WR_JS_Dialog_BrowseForFolder",
        "scope": "c",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, and -1 if an error occurred.\n",
        "body": "${1:int} = JS_Dialog_BrowseForFolder(${2:const char* caption},${3:const char* initialFolder},${4:char* folderOutNeedBig},${5:int folderOutNeedBig_sz})$0"
    },
    "REAPER.JS_DIALOG_BROWSEFORFOLDER_WR lua": {
        "prefix": "reaperwr.JS_Dialog_BrowseForFolder",
        "scope": "lua",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, and -1 if an error occurred.\n",
        "body": "${1:local }${2:integer retval},${3:string folder} = reaper.JS_Dialog_BrowseForFolder(${4:string caption},${5:string initialFolder})$0"
    },
    "JS_DIALOG_BROWSEFORFOLDER_WR python": {
        "prefix": "WR_JS_Dialog_BrowseForFolder",
        "scope": "python",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, and -1 if an error occurred.\n",
        "body": "${1:Int retval},${2:String caption},${3:String initialFolder},${4:String folderOutNeedBig},${5:Int folderOutNeedBig_sz} = JS_Dialog_BrowseForFolder(${6:caption},${7:initialFolder},${8:folderOutNeedBig},${9:folderOutNeedBig_sz})$0"
    },
    "JS_DIALOG_BROWSEFOROPENFILES_WR c": {
        "prefix": "WR_JS_Dialog_BrowseForOpenFiles",
        "scope": "c",
        "description": "If allowMultiple is true, multiple files may be selected. The returned\nstring is \\0-separated, with the first substring containing the folder\npath and subsequent substrings containing the file names.\n* On macOS, the first substring may be empty, and each file name will then contain its entire path.\n* This function only allows selection of existing files, and does not allow creation of new files.\nextensionList is a string containing pairs of \\0-terminated substrings.\nThe last substring must be terminated by two \\0 characters. Each pair\ndefines one filter pattern:\n* The first substring in each pair describes the filter in\nuser-readable form (for example, \"Lua script files (*.lua)\") and will be\ndisplayed in the dialog box.\n* The second substring specifies the filter that the operating system\nmust use to search for the files (for example, \"*.txt\"; the wildcard\nshould not be omitted). To specify multiple extensions for a single\ndisplay string, use a semicolon to separate the patterns (for example,\n\"*.lua;*.eel\").\nAn example of an extensionList string:\n\"ReaScript files\\0*.lua;*.eel\\0Lua files (.lua)\\0*.lua\\0EEL files (.eel)\\0*.eel\\0\\0\".\nOn macOS, file dialogs do not accept empty extensionLists, nor wildcard\nextensions (such as \"All files\\0*.*\\0\\0\"), so each acceptable extension\nmust be listed explicitly. On Linux and Windows, wildcard extensions are\nacceptable, and if the extensionList string is empty, the dialog will\ndisplay a default \"All files (*.*)\" filter.\nretval is 1 if one or more files were selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nDisplaying \\0-separated strings:\n* REAPER's IDE and ShowConsoleMsg only display strings up to the first\n\\0 byte. If multiple files were selected, only the first substring\ncontaining the path will be displayed. This is not a problem for Lua or\nEEL, which can access the full string beyond the first \\0 byte as usual.\n",
        "body": "${1:int} = JS_Dialog_BrowseForOpenFiles(${2:const char* windowTitle},${3:const char* initialFolder},${4:const char* initialFile},${5:const char* extensionList},${6:bool allowMultiple},${7:char* fileNamesOutNeedBig},${8:int fileNamesOutNeedBig_sz})$0"
    },
    "REAPER.JS_DIALOG_BROWSEFOROPENFILES_WR lua": {
        "prefix": "reaperwr.JS_Dialog_BrowseForOpenFiles",
        "scope": "lua",
        "description": "If allowMultiple is true, multiple files may be selected. The returned\nstring is \\0-separated, with the first substring containing the folder\npath and subsequent substrings containing the file names.\n* On macOS, the first substring may be empty, and each file name will then contain its entire path.\n* This function only allows selection of existing files, and does not allow creation of new files.\nextensionList is a string containing pairs of \\0-terminated substrings.\nThe last substring must be terminated by two \\0 characters. Each pair\ndefines one filter pattern:\n* The first substring in each pair describes the filter in\nuser-readable form (for example, \"Lua script files (*.lua)\") and will be\ndisplayed in the dialog box.\n* The second substring specifies the filter that the operating system\nmust use to search for the files (for example, \"*.txt\"; the wildcard\nshould not be omitted). To specify multiple extensions for a single\ndisplay string, use a semicolon to separate the patterns (for example,\n\"*.lua;*.eel\").\nAn example of an extensionList string:\n\"ReaScript files\\0*.lua;*.eel\\0Lua files (.lua)\\0*.lua\\0EEL files (.eel)\\0*.eel\\0\\0\".\nOn macOS, file dialogs do not accept empty extensionLists, nor wildcard\nextensions (such as \"All files\\0*.*\\0\\0\"), so each acceptable extension\nmust be listed explicitly. On Linux and Windows, wildcard extensions are\nacceptable, and if the extensionList string is empty, the dialog will\ndisplay a default \"All files (*.*)\" filter.\nretval is 1 if one or more files were selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nDisplaying \\0-separated strings:\n* REAPER's IDE and ShowConsoleMsg only display strings up to the first\n\\0 byte. If multiple files were selected, only the first substring\ncontaining the path will be displayed. This is not a problem for Lua or\nEEL, which can access the full string beyond the first \\0 byte as usual.\n",
        "body": "${1:local }${2:integer retval},${3:string fileNames} = reaper.JS_Dialog_BrowseForOpenFiles(${4:string windowTitle},${5:string initialFolder},${6:string initialFile},${7:string extensionList},${8:boolean allowMultiple})$0"
    },
    "JS_DIALOG_BROWSEFOROPENFILES_WR python": {
        "prefix": "WR_JS_Dialog_BrowseForOpenFiles",
        "scope": "python",
        "description": "If allowMultiple is true, multiple files may be selected. The returned\nstring is \\0-separated, with the first substring containing the folder\npath and subsequent substrings containing the file names.\n* On macOS, the first substring may be empty, and each file name will then contain its entire path.\n* This function only allows selection of existing files, and does not allow creation of new files.\nextensionList is a string containing pairs of \\0-terminated substrings.\nThe last substring must be terminated by two \\0 characters. Each pair\ndefines one filter pattern:\n* The first substring in each pair describes the filter in\nuser-readable form (for example, \"Lua script files (*.lua)\") and will be\ndisplayed in the dialog box.\n* The second substring specifies the filter that the operating system\nmust use to search for the files (for example, \"*.txt\"; the wildcard\nshould not be omitted). To specify multiple extensions for a single\ndisplay string, use a semicolon to separate the patterns (for example,\n\"*.lua;*.eel\").\nAn example of an extensionList string:\n\"ReaScript files\\0*.lua;*.eel\\0Lua files (.lua)\\0*.lua\\0EEL files (.eel)\\0*.eel\\0\\0\".\nOn macOS, file dialogs do not accept empty extensionLists, nor wildcard\nextensions (such as \"All files\\0*.*\\0\\0\"), so each acceptable extension\nmust be listed explicitly. On Linux and Windows, wildcard extensions are\nacceptable, and if the extensionList string is empty, the dialog will\ndisplay a default \"All files (*.*)\" filter.\nretval is 1 if one or more files were selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nDisplaying \\0-separated strings:\n* REAPER's IDE and ShowConsoleMsg only display strings up to the first\n\\0 byte. If multiple files were selected, only the first substring\ncontaining the path will be displayed. This is not a problem for Lua or\nEEL, which can access the full string beyond the first \\0 byte as usual.\n",
        "body": "${1:Int retval},${2:String windowTitle},${3:String initialFolder},${4:String initialFile},${5:String extensionList},${6:Boolean allowMultiple},${7:String fileNamesOutNeedBig},${8:Int fileNamesOutNeedBig_sz} = JS_Dialog_BrowseForOpenFiles(${9:windowTitle},${10:initialFolder},${11:initialFile},${12:extensionList},${13:allowMultiple},${14:fileNamesOutNeedBig},${15:fileNamesOutNeedBig_sz})$0"
    },
    "JS_DIALOG_BROWSEFORSAVEFILE_WR c": {
        "prefix": "WR_JS_Dialog_BrowseForSaveFile",
        "scope": "c",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nextensionList is as described for JS_Dialog_BrowseForOpenFiles.\n",
        "body": "${1:int} = JS_Dialog_BrowseForSaveFile(${2:const char* windowTitle},${3:const char* initialFolder},${4:const char* initialFile},${5:const char* extensionList},${6:char* fileNameOutNeedBig},${7:int fileNameOutNeedBig_sz})$0"
    },
    "REAPER.JS_DIALOG_BROWSEFORSAVEFILE_WR lua": {
        "prefix": "reaperwr.JS_Dialog_BrowseForSaveFile",
        "scope": "lua",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nextensionList is as described for JS_Dialog_BrowseForOpenFiles.\n",
        "body": "${1:local }${2:integer retval},${3:string fileName} = reaper.JS_Dialog_BrowseForSaveFile(${4:string windowTitle},${5:string initialFolder},${6:string initialFile},${7:string extensionList})$0"
    },
    "JS_DIALOG_BROWSEFORSAVEFILE_WR python": {
        "prefix": "WR_JS_Dialog_BrowseForSaveFile",
        "scope": "python",
        "description": "retval is 1 if a file was selected, 0 if the user cancelled the dialog, or negative if an error occurred.\nextensionList is as described for JS_Dialog_BrowseForOpenFiles.\n",
        "body": "${1:Int retval},${2:String windowTitle},${3:String initialFolder},${4:String initialFile},${5:String extensionList},${6:String fileNameOutNeedBig},${7:Int fileNameOutNeedBig_sz} = JS_Dialog_BrowseForSaveFile(${8:windowTitle},${9:initialFolder},${10:initialFile},${11:extensionList},${12:fileNameOutNeedBig},${13:fileNameOutNeedBig_sz})$0"
    },
    "JS_DOUBLE_WR c": {
        "prefix": "WR_JS_Double",
        "scope": "c",
        "description": "Returns the 8-byte floating point value at address[offset]. Offset is added as steps of 8 bytes each.\n",
        "body": "${1:void} = JS_Double(${2:void* pointer},${3:int offset},${4:double* doubleOut})$0"
    },
    "REAPER.JS_DOUBLE_WR lua": {
        "prefix": "reaperwr.JS_Double",
        "scope": "lua",
        "description": "Returns the 8-byte floating point value at address[offset]. Offset is added as steps of 8 bytes each.\n",
        "body": "${1:local }${2:number double} = reaper.JS_Double(${3:identifier pointer},${4:integer offset})$0"
    },
    "JS_DOUBLE_WR python": {
        "prefix": "WR_JS_Double",
        "scope": "python",
        "description": "Returns the 8-byte floating point value at address[offset]. Offset is added as steps of 8 bytes each.\n",
        "body": "${1:void pointer},${2:Int offset},${3:Float doubleOut} = JS_Double(${4:pointer},${5:offset},${6:doubleOut})$0"
    },
    "JS_GDI_BLIT_WR c": {
        "prefix": "WR_JS_GDI_Blit",
        "scope": "c",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmode: Optional parameter. \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "${1:void} = JS_GDI_Blit(${2:void* destHDC},${3:int dstx},${4:int dsty},${5:void* sourceHDC},${6:int srcx},${7:int srxy},${8:int width},${9:int height},${10:const char* modeOptional})$0"
    },
    "JS_GDI_CREATEFILLBRUSH_WR c": {
        "prefix": "WR_JS_GDI_CreateFillBrush",
        "scope": "c",
        "description": "\n",
        "body": "${1:void*} = JS_GDI_CreateFillBrush(${2:int color})$0"
    },
    "REAPER.JS_GDI_CREATEFILLBRUSH_WR lua": {
        "prefix": "reaperwr.JS_GDI_CreateFillBrush",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:identifier} = reaper.JS_GDI_CreateFillBrush(${3:integer color})$0"
    },
    "JS_GDI_CREATEFILLBRUSH_WR python": {
        "prefix": "WR_JS_GDI_CreateFillBrush",
        "scope": "python",
        "description": "\n",
        "body": "${1:void} = JS_GDI_CreateFillBrush(${2:Int color})$0"
    },
    "JS_GDI_CREATEFONT_WR c": {
        "prefix": "WR_JS_GDI_CreateFont",
        "scope": "c",
        "description": "Parameters:\n* weight: 0 - 1000, with 0 = auto, 400 = normal and 700 = bold.\n* angle: the angle, in tenths of degrees, between the text and the x-axis of the device.\n* fontName: If empty string \"\", uses first font that matches the other specified attributes.\nNote: Text color must be set separately.\n",
        "body": "${1:void*} = JS_GDI_CreateFont(${2:int height},${3:int weight},${4:int angle},${5:bool italic},${6:bool underline},${7:bool strikeOut},${8:const char* fontName})$0"
    },
    "REAPER.JS_GDI_CREATEFONT_WR lua": {
        "prefix": "reaperwr.JS_GDI_CreateFont",
        "scope": "lua",
        "description": "Parameters:\n* weight: 0 - 1000, with 0 = auto, 400 = normal and 700 = bold.\n* angle: the angle, in tenths of degrees, between the text and the x-axis of the device.\n* fontName: If empty string \"\", uses first font that matches the other specified attributes.\nNote: Text color must be set separately.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_GDI_CreateFont(${3:integer height},${4:integer weight},${5:integer angle},${6:boolean italic},${7:boolean underline},${8:boolean strike},${9:string fontName})$0"
    },
    "JS_GDI_CREATEFONT_WR python": {
        "prefix": "WR_JS_GDI_CreateFont",
        "scope": "python",
        "description": "Parameters:\n* weight: 0 - 1000, with 0 = auto, 400 = normal and 700 = bold.\n* angle: the angle, in tenths of degrees, between the text and the x-axis of the device.\n* fontName: If empty string \"\", uses first font that matches the other specified attributes.\nNote: Text color must be set separately.\n",
        "body": "${1:void} = JS_GDI_CreateFont(${2:Int height},${3:Int weight},${4:Int angle},${5:Boolean italic},${6:Boolean underline},${7:Boolean strikeOut},${8:String fontName})$0"
    },
    "JS_GDI_CREATEPEN_WR c": {
        "prefix": "WR_JS_GDI_CreatePen",
        "scope": "c",
        "description": "\n",
        "body": "${1:void*} = JS_GDI_CreatePen(${2:int width},${3:int color})$0"
    },
    "REAPER.JS_GDI_CREATEPEN_WR lua": {
        "prefix": "reaperwr.JS_GDI_CreatePen",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:identifier} = reaper.JS_GDI_CreatePen(${3:integer width},${4:integer color})$0"
    },
    "JS_GDI_CREATEPEN_WR python": {
        "prefix": "WR_JS_GDI_CreatePen",
        "scope": "python",
        "description": "\n",
        "body": "${1:void} = JS_GDI_CreatePen(${2:Int width},${3:Int color})$0"
    },
    "JS_GDI_DELETEOBJECT_WR c": {
        "prefix": "WR_JS_GDI_DeleteObject",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_DeleteObject(${2:void* GDIObject})$0"
    },
    "JS_GDI_DRAWTEXT_WR c": {
        "prefix": "WR_JS_GDI_DrawText",
        "scope": "c",
        "description": "Parameters:\n* align: Combination of: \"TOP\", \"VCENTER\", \"LEFT\", \"HCENTER\", \"RIGHT\",\n\"BOTTOM\", \"WORDBREAK\", \"SINGLELINE\", \"NOCLIP\", \"CALCRECT\", \"NOPREFIX\" or\n\"ELLIPSIS\"\n",
        "body": "${1:int} = JS_GDI_DrawText(${2:void* deviceHDC},${3:const char* text},${4:int len},${5:int left},${6:int top},${7:int right},${8:int bottom},${9:const char* align})$0"
    },
    "REAPER.JS_GDI_DRAWTEXT_WR lua": {
        "prefix": "reaperwr.JS_GDI_DrawText",
        "scope": "lua",
        "description": "Parameters:\n* align: Combination of: \"TOP\", \"VCENTER\", \"LEFT\", \"HCENTER\", \"RIGHT\",\n\"BOTTOM\", \"WORDBREAK\", \"SINGLELINE\", \"NOCLIP\", \"CALCRECT\", \"NOPREFIX\" or\n\"ELLIPSIS\"\n",
        "body": "${1:local }${2:integer} = reaper.JS_GDI_DrawText(${3:identifier deviceHDC},${4:string text},${5:integer len},${6:integer left},${7:integer top},${8:integer right},${9:integer bottom},${10:string align})$0"
    },
    "JS_GDI_DRAWTEXT_WR python": {
        "prefix": "WR_JS_GDI_DrawText",
        "scope": "python",
        "description": "Parameters:\n* align: Combination of: \"TOP\", \"VCENTER\", \"LEFT\", \"HCENTER\", \"RIGHT\",\n\"BOTTOM\", \"WORDBREAK\", \"SINGLELINE\", \"NOCLIP\", \"CALCRECT\", \"NOPREFIX\" or\n\"ELLIPSIS\"\n",
        "body": "${1:Int} = JS_GDI_DrawText(${2:void deviceHDC},${3:String text},${4:Int len},${5:Int left},${6:Int top},${7:Int right},${8:Int bottom},${9:String align})$0"
    },
    "JS_GDI_FILLELLIPSE_WR c": {
        "prefix": "WR_JS_GDI_FillEllipse",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_FillEllipse(${2:void* deviceHDC},${3:int left},${4:int top},${5:int right},${6:int bottom})$0"
    },
    "JS_GDI_FILLPOLYGON_WR c": {
        "prefix": "WR_JS_GDI_FillPolygon",
        "scope": "c",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "${1:void} = JS_GDI_FillPolygon(${2:void* deviceHDC},${3:const char* packedX},${4:const char* packedY},${5:int numPoints})$0"
    },
    "JS_GDI_FILLRECT_WR c": {
        "prefix": "WR_JS_GDI_FillRect",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_FillRect(${2:void* deviceHDC},${3:int left},${4:int top},${5:int right},${6:int bottom})$0"
    },
    "JS_GDI_FILLROUNDRECT_WR c": {
        "prefix": "WR_JS_GDI_FillRoundRect",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_FillRoundRect(${2:void* deviceHDC},${3:int left},${4:int top},${5:int right},${6:int bottom},${7:int xrnd},${8:int yrnd})$0"
    },
    "JS_GDI_GETCLIENTDC_WR c": {
        "prefix": "WR_JS_GDI_GetClientDC",
        "scope": "c",
        "description": "Returns the device context for the client area of the specified window.\n",
        "body": "${1:void*} = JS_GDI_GetClientDC(${2:void* windowHWND})$0"
    },
    "REAPER.JS_GDI_GETCLIENTDC_WR lua": {
        "prefix": "reaperwr.JS_GDI_GetClientDC",
        "scope": "lua",
        "description": "Returns the device context for the client area of the specified window.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_GDI_GetClientDC(${3:identifier windowHWND})$0"
    },
    "JS_GDI_GETCLIENTDC_WR python": {
        "prefix": "WR_JS_GDI_GetClientDC",
        "scope": "python",
        "description": "Returns the device context for the client area of the specified window.\n",
        "body": "${1:void} = JS_GDI_GetClientDC(${2:void windowHWND})$0"
    },
    "JS_GDI_GETSCREENDC_WR c": {
        "prefix": "WR_JS_GDI_GetScreenDC",
        "scope": "c",
        "description": "Returns a device context for the entire screen.\nWARNING: Only available on Windows, not Linux or macOS.\n",
        "body": "${1:void*} = JS_GDI_GetScreenDC()$0"
    },
    "REAPER.JS_GDI_GETSCREENDC_WR lua": {
        "prefix": "reaperwr.JS_GDI_GetScreenDC",
        "scope": "lua",
        "description": "Returns a device context for the entire screen.\nWARNING: Only available on Windows, not Linux or macOS.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_GDI_GetScreenDC()$0"
    },
    "JS_GDI_GETSCREENDC_WR python": {
        "prefix": "WR_JS_GDI_GetScreenDC",
        "scope": "python",
        "description": "Returns a device context for the entire screen.\nWARNING: Only available on Windows, not Linux or macOS.\n",
        "body": "${1:void} = JS_GDI_GetScreenDC()$0"
    },
    "JS_GDI_GETSYSCOLOR_WR c": {
        "prefix": "WR_JS_GDI_GetSysColor",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_GDI_GetSysColor(${2:const char* GUIElement})$0"
    },
    "REAPER.JS_GDI_GETSYSCOLOR_WR lua": {
        "prefix": "reaperwr.JS_GDI_GetSysColor",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_GDI_GetSysColor(${3:string GUIElement})$0"
    },
    "JS_GDI_GETSYSCOLOR_WR python": {
        "prefix": "WR_JS_GDI_GetSysColor",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_GDI_GetSysColor(${2:String GUIElement})$0"
    },
    "JS_GDI_GETTEXTCOLOR_WR c": {
        "prefix": "WR_JS_GDI_GetTextColor",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_GDI_GetTextColor(${2:void* deviceHDC})$0"
    },
    "REAPER.JS_GDI_GETTEXTCOLOR_WR lua": {
        "prefix": "reaperwr.JS_GDI_GetTextColor",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_GDI_GetTextColor(${3:identifier deviceHDC})$0"
    },
    "JS_GDI_GETTEXTCOLOR_WR python": {
        "prefix": "WR_JS_GDI_GetTextColor",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_GDI_GetTextColor(${2:void deviceHDC})$0"
    },
    "JS_GDI_GETWINDOWDC_WR c": {
        "prefix": "WR_JS_GDI_GetWindowDC",
        "scope": "c",
        "description": "Returns the device context for the entire window, including title bar and frame.\n",
        "body": "${1:void*} = JS_GDI_GetWindowDC(${2:void* windowHWND})$0"
    },
    "REAPER.JS_GDI_GETWINDOWDC_WR lua": {
        "prefix": "reaperwr.JS_GDI_GetWindowDC",
        "scope": "lua",
        "description": "Returns the device context for the entire window, including title bar and frame.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_GDI_GetWindowDC(${3:identifier windowHWND})$0"
    },
    "JS_GDI_GETWINDOWDC_WR python": {
        "prefix": "WR_JS_GDI_GetWindowDC",
        "scope": "python",
        "description": "Returns the device context for the entire window, including title bar and frame.\n",
        "body": "${1:void} = JS_GDI_GetWindowDC(${2:void windowHWND})$0"
    },
    "JS_GDI_LINE_WR c": {
        "prefix": "WR_JS_GDI_Line",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_Line(${2:void* deviceHDC},${3:int x1},${4:int y1},${5:int x2},${6:int y2})$0"
    },
    "JS_GDI_POLYLINE_WR c": {
        "prefix": "WR_JS_GDI_Polyline",
        "scope": "c",
        "description": "packedX and packedY are strings of points, each packed as \"<i4\".\n",
        "body": "${1:void} = JS_GDI_Polyline(${2:void* deviceHDC},${3:const char* packedX},${4:const char* packedY},${5:int numPoints})$0"
    },
    "JS_GDI_RELEASEDC_WR c": {
        "prefix": "WR_JS_GDI_ReleaseDC",
        "scope": "c",
        "description": "To release a window HDC, both arguments must be supplied: the HWND as\nwell as the HDC.  To release a screen DC, only the HDC needs to be\nsupplied.\nFor compatibility with previous versions, the HWND and HDC can be supplied in any order.\nNOTE: Any GDI HDC should be released immediately after drawing, and\ndeferred scripts should get and release new DCs in each cycle.\n",
        "body": "${1:int} = JS_GDI_ReleaseDC(${2:void* deviceHDC},${3:void*  windowHWNDOptional})$0"
    },
    "REAPER.JS_GDI_RELEASEDC_WR lua": {
        "prefix": "reaperwr.JS_GDI_ReleaseDC",
        "scope": "lua",
        "description": "To release a window HDC, both arguments must be supplied: the HWND as\nwell as the HDC.  To release a screen DC, only the HDC needs to be\nsupplied.\nFor compatibility with previous versions, the HWND and HDC can be supplied in any order.\nNOTE: Any GDI HDC should be released immediately after drawing, and\ndeferred scripts should get and release new DCs in each cycle.\n",
        "body": "${1:local }${2:integer} = reaper.JS_GDI_ReleaseDC(${3:identifier deviceHDC},${4:identifier  windowHWND})$0"
    },
    "JS_GDI_RELEASEDC_WR python": {
        "prefix": "WR_JS_GDI_ReleaseDC",
        "scope": "python",
        "description": "To release a window HDC, both arguments must be supplied: the HWND as\nwell as the HDC.  To release a screen DC, only the HDC needs to be\nsupplied.\nFor compatibility with previous versions, the HWND and HDC can be supplied in any order.\nNOTE: Any GDI HDC should be released immediately after drawing, and\ndeferred scripts should get and release new DCs in each cycle.\n",
        "body": "${1:Int} = JS_GDI_ReleaseDC(${2:void deviceHDC},${3:void  windowHWNDOptional})$0"
    },
    "JS_GDI_SELECTOBJECT_WR c": {
        "prefix": "WR_JS_GDI_SelectObject",
        "scope": "c",
        "description": "Activates a font, pen, or fill brush for subsequent drawing in the specified device context.\n",
        "body": "${1:void*} = JS_GDI_SelectObject(${2:void* deviceHDC},${3:void* GDIObject})$0"
    },
    "REAPER.JS_GDI_SELECTOBJECT_WR lua": {
        "prefix": "reaperwr.JS_GDI_SelectObject",
        "scope": "lua",
        "description": "Activates a font, pen, or fill brush for subsequent drawing in the specified device context.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_GDI_SelectObject(${3:identifier deviceHDC},${4:identifier GDIObject})$0"
    },
    "JS_GDI_SELECTOBJECT_WR python": {
        "prefix": "WR_JS_GDI_SelectObject",
        "scope": "python",
        "description": "Activates a font, pen, or fill brush for subsequent drawing in the specified device context.\n",
        "body": "${1:void} = JS_GDI_SelectObject(${2:void deviceHDC},${3:void GDIObject})$0"
    },
    "JS_GDI_SETPIXEL_WR c": {
        "prefix": "WR_JS_GDI_SetPixel",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_SetPixel(${2:void* deviceHDC},${3:int x},${4:int y},${5:int color})$0"
    },
    "JS_GDI_SETTEXTBKCOLOR_WR c": {
        "prefix": "WR_JS_GDI_SetTextBkColor",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_SetTextBkColor(${2:void* deviceHDC},${3:int color})$0"
    },
    "JS_GDI_SETTEXTBKMODE_WR c": {
        "prefix": "WR_JS_GDI_SetTextBkMode",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_SetTextBkMode(${2:void* deviceHDC},${3:int mode})$0"
    },
    "JS_GDI_SETTEXTCOLOR_WR c": {
        "prefix": "WR_JS_GDI_SetTextColor",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_GDI_SetTextColor(${2:void* deviceHDC},${3:int color})$0"
    },
    "JS_GDI_STRETCHBLIT_WR c": {
        "prefix": "WR_JS_GDI_StretchBlit",
        "scope": "c",
        "description": "Blits between two device contexts, which may include LICE \"system bitmaps\".\nmodeOptional: \"SRCCOPY\" by default, or specify \"ALPHA\" to enable per-pixel alpha blending.\nWARNING: On WindowsOS, GDI_Blit does not perform alpha multiplication of\nthe source bitmap. For proper color rendering, a separate\npre-multiplication step is therefore required, using either LICE_Blit or\nLICE_ProcessRect.\n",
        "body": "${1:void} = JS_GDI_StretchBlit(${2:void* destHDC},${3:int dstx},${4:int dsty},${5:int dstw},${6:int dsth},${7:void* sourceHDC},${8:int srcx},${9:int srxy},${10:int srcw},${11:int srch},${12:const char* modeOptional})$0"
    },
    "JS_INT_WR c": {
        "prefix": "WR_JS_Int",
        "scope": "c",
        "description": "Returns the 4-byte signed integer at address[offset]. Offset is added as steps of 4 bytes each.\n",
        "body": "${1:void} = JS_Int(${2:void* pointer},${3:int offset},${4:int* intOut})$0"
    },
    "REAPER.JS_INT_WR lua": {
        "prefix": "reaperwr.JS_Int",
        "scope": "lua",
        "description": "Returns the 4-byte signed integer at address[offset]. Offset is added as steps of 4 bytes each.\n",
        "body": "${1:local }${2:number int} = reaper.JS_Int(${3:identifier pointer},${4:integer offset})$0"
    },
    "JS_INT_WR python": {
        "prefix": "WR_JS_Int",
        "scope": "python",
        "description": "Returns the 4-byte signed integer at address[offset]. Offset is added as steps of 4 bytes each.\n",
        "body": "${1:void pointer},${2:Int offset},${3:Int intOut} = JS_Int(${4:pointer},${5:offset},${6:intOut})$0"
    },
    "JS_LICE_ALTERBITMAPHSV_WR c": {
        "prefix": "WR_JS_LICE_AlterBitmapHSV",
        "scope": "c",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "${1:void} = JS_LICE_AlterBitmapHSV(${2:void* bitmap},${3:double hue},${4:double saturation},${5:double value})$0"
    },
    "JS_LICE_ALTERRECTHSV_WR c": {
        "prefix": "WR_JS_LICE_AlterRectHSV",
        "scope": "c",
        "description": "Hue is rolled over, saturation and value are clamped, all 0..1. (Alpha remains unchanged.)\n",
        "body": "${1:void} = JS_LICE_AlterRectHSV(${2:void* bitmap},${3:int x},${4:int y},${5:int w},${6:int h},${7:double hue},${8:double saturation},${9:double value})$0"
    },
    "JS_LICE_ARC_WR c": {
        "prefix": "WR_JS_LICE_Arc",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_Arc(${2:void* bitmap},${3:double cx},${4:double cy},${5:double r},${6:double minAngle},${7:double maxAngle},${8:int color},${9:double alpha},${10:const char* mode},${11:bool antialias})$0"
    },
    "JS_LICE_ARRAYALLBITMAPS_WR c": {
        "prefix": "WR_JS_LICE_ArrayAllBitmaps",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_LICE_ArrayAllBitmaps(${2:void* reaperarray})$0"
    },
    "REAPER.JS_LICE_ARRAYALLBITMAPS_WR lua": {
        "prefix": "reaperwr.JS_LICE_ArrayAllBitmaps",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_LICE_ArrayAllBitmaps(${3:identifier reaperarray})$0"
    },
    "JS_LICE_ARRAYALLBITMAPS_WR python": {
        "prefix": "WR_JS_LICE_ArrayAllBitmaps",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_LICE_ArrayAllBitmaps(${2:void reaperarray})$0"
    },
    "JS_LICE_BEZIER_WR c": {
        "prefix": "WR_JS_LICE_Bezier",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_Bezier(${2:void* bitmap},${3:double xstart},${4:double ystart},${5:double xctl1},${6:double yctl1},${7:double xctl2},${8:double yctl2},${9:double xend},${10:double yend},${11:double tol},${12:int color},${13:double alpha},${14:const char* mode},${15:bool antialias})$0"
    },
    "JS_LICE_BLIT_WR c": {
        "prefix": "WR_JS_LICE_Blit",
        "scope": "c",
        "description": "Standard LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\",\n\"DODGE\", \"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with\n\"ALPHA\" to enable per-pixel alpha blending.\nIn addition to the standard LICE modes, LICE_Blit also offers:\n* \"CHANCOPY_XTOY\", with X and Y any of the four channels, A, R, G or B. (CHANCOPY_ATOA is similar to MASK mode.)\n* \"BLUR\"\n* \"ALPHAMUL\", which overwrites the destination with a per-pixel\nalpha-multiplied copy of the source. (Similar to first clearing the\ndestination with 0x00000000 and then blitting with \"COPY,ALPHA\".)\n",
        "body": "${1:void} = JS_LICE_Blit(${2:void* destBitmap},${3:int dstx},${4:int dsty},${5:void* sourceBitmap},${6:int srcx},${7:int srcy},${8:int width},${9:int height},${10:double alpha},${11:const char* mode})$0"
    },
    "JS_LICE_CIRCLE_WR c": {
        "prefix": "WR_JS_LICE_Circle",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_Circle(${2:void* bitmap},${3:double cx},${4:double cy},${5:double r},${6:int color},${7:double alpha},${8:const char* mode},${9:bool antialias})$0"
    },
    "JS_LICE_CLEAR_WR c": {
        "prefix": "WR_JS_LICE_Clear",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_Clear(${2:void* bitmap},${3:int color})$0"
    },
    "JS_LICE_CREATEBITMAP_WR c": {
        "prefix": "WR_JS_LICE_CreateBitmap",
        "scope": "c",
        "description": "\n",
        "body": "${1:void*} = JS_LICE_CreateBitmap(${2:bool isSysBitmap},${3:int width},${4:int height})$0"
    },
    "REAPER.JS_LICE_CREATEBITMAP_WR lua": {
        "prefix": "reaperwr.JS_LICE_CreateBitmap",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:identifier} = reaper.JS_LICE_CreateBitmap(${3:boolean isSysBitmap},${4:integer width},${5:integer height})$0"
    },
    "JS_LICE_CREATEBITMAP_WR python": {
        "prefix": "WR_JS_LICE_CreateBitmap",
        "scope": "python",
        "description": "\n",
        "body": "${1:void} = JS_LICE_CreateBitmap(${2:Boolean isSysBitmap},${3:Int width},${4:Int height})$0"
    },
    "JS_LICE_CREATEFONT_WR c": {
        "prefix": "WR_JS_LICE_CreateFont",
        "scope": "c",
        "description": "\n",
        "body": "${1:void*} = JS_LICE_CreateFont()$0"
    },
    "REAPER.JS_LICE_CREATEFONT_WR lua": {
        "prefix": "reaperwr.JS_LICE_CreateFont",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:identifier} = reaper.JS_LICE_CreateFont()$0"
    },
    "JS_LICE_CREATEFONT_WR python": {
        "prefix": "WR_JS_LICE_CreateFont",
        "scope": "python",
        "description": "\n",
        "body": "${1:void} = JS_LICE_CreateFont()$0"
    },
    "JS_LICE_DESTROYBITMAP_WR c": {
        "prefix": "WR_JS_LICE_DestroyBitmap",
        "scope": "c",
        "description": "Deletes the bitmap, and also unlinks bitmap from any composited window.\n",
        "body": "${1:void} = JS_LICE_DestroyBitmap(${2:void* bitmap})$0"
    },
    "JS_LICE_DESTROYFONT_WR c": {
        "prefix": "WR_JS_LICE_DestroyFont",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_DestroyFont(${2:void* LICEFont})$0"
    },
    "JS_LICE_DRAWCHAR_WR c": {
        "prefix": "WR_JS_LICE_DrawChar",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_DrawChar(${2:void* bitmap},${3:int x},${4:int y},${5:char c},${6:int color},${7:double alpha},${8:int mode})$0"
    },
    "JS_LICE_DRAWTEXT_WR c": {
        "prefix": "WR_JS_LICE_DrawText",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_LICE_DrawText(${2:void* bitmap},${3:void* LICEFont},${4:const char* text},${5:int textLen},${6:int x1},${7:int y1},${8:int x2},${9:int y2})$0"
    },
    "REAPER.JS_LICE_DRAWTEXT_WR lua": {
        "prefix": "reaperwr.JS_LICE_DrawText",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_LICE_DrawText(${3:identifier bitmap},${4:identifier LICEFont},${5:string text},${6:integer textLen},${7:integer x1},${8:integer y1},${9:integer x2},${10:integer y2})$0"
    },
    "JS_LICE_DRAWTEXT_WR python": {
        "prefix": "WR_JS_LICE_DrawText",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_LICE_DrawText(${2:void bitmap},${3:void LICEFont},${4:String text},${5:Int textLen},${6:Int x1},${7:Int y1},${8:Int x2},${9:Int y2})$0"
    },
    "JS_LICE_FILLCIRCLE_WR c": {
        "prefix": "WR_JS_LICE_FillCircle",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_FillCircle(${2:void* bitmap},${3:double cx},${4:double cy},${5:double r},${6:int color},${7:double alpha},${8:const char* mode},${9:bool antialias})$0"
    },
    "JS_LICE_FILLPOLYGON_WR c": {
        "prefix": "WR_JS_LICE_FillPolygon",
        "scope": "c",
        "description": "packedX and packedY are two strings of coordinates, each packed as \"<i4\".\nLICE modes : \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_FillPolygon(${2:void* bitmap},${3:const char* packedX},${4:const char* packedY},${5:int numPoints},${6:int color},${7:double alpha},${8:const char* mode})$0"
    },
    "JS_LICE_FILLRECT_WR c": {
        "prefix": "WR_JS_LICE_FillRect",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_FillRect(${2:void* bitmap},${3:int x},${4:int y},${5:int w},${6:int h},${7:int color},${8:double alpha},${9:const char* mode})$0"
    },
    "JS_LICE_FILLTRIANGLE_WR c": {
        "prefix": "WR_JS_LICE_FillTriangle",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_FillTriangle(${2:void* bitmap},${3:int x1},${4:int y1},${5:int x2},${6:int y2},${7:int x3},${8:int y3},${9:int color},${10:double alpha},${11:const char* mode})$0"
    },
    "JS_LICE_GETDC_WR c": {
        "prefix": "WR_JS_LICE_GetDC",
        "scope": "c",
        "description": "\n",
        "body": "${1:void*} = JS_LICE_GetDC(${2:void* bitmap})$0"
    },
    "REAPER.JS_LICE_GETDC_WR lua": {
        "prefix": "reaperwr.JS_LICE_GetDC",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:identifier} = reaper.JS_LICE_GetDC(${3:identifier bitmap})$0"
    },
    "JS_LICE_GETDC_WR python": {
        "prefix": "WR_JS_LICE_GetDC",
        "scope": "python",
        "description": "\n",
        "body": "${1:void} = JS_LICE_GetDC(${2:void bitmap})$0"
    },
    "JS_LICE_GETHEIGHT_WR c": {
        "prefix": "WR_JS_LICE_GetHeight",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_LICE_GetHeight(${2:void* bitmap})$0"
    },
    "REAPER.JS_LICE_GETHEIGHT_WR lua": {
        "prefix": "reaperwr.JS_LICE_GetHeight",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_LICE_GetHeight(${3:identifier bitmap})$0"
    },
    "JS_LICE_GETHEIGHT_WR python": {
        "prefix": "WR_JS_LICE_GetHeight",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_LICE_GetHeight(${2:void bitmap})$0"
    },
    "JS_LICE_GETPIXEL_WR c": {
        "prefix": "WR_JS_LICE_GetPixel",
        "scope": "c",
        "description": "Returns the color of the specified pixel.\n",
        "body": "${1:void} = JS_LICE_GetPixel(${2:void* bitmap},${3:int x},${4:int y},${5:double* colorOut})$0"
    },
    "REAPER.JS_LICE_GETPIXEL_WR lua": {
        "prefix": "reaperwr.JS_LICE_GetPixel",
        "scope": "lua",
        "description": "Returns the color of the specified pixel.\n",
        "body": "${1:local }${2:number color} = reaper.JS_LICE_GetPixel(${3:identifier bitmap},${4:integer x},${5:integer y})$0"
    },
    "JS_LICE_GETPIXEL_WR python": {
        "prefix": "WR_JS_LICE_GetPixel",
        "scope": "python",
        "description": "Returns the color of the specified pixel.\n",
        "body": "${1:void bitmap},${2:Int x},${3:Int y},${4:Float colorOut} = JS_LICE_GetPixel(${5:bitmap},${6:x},${7:y},${8:colorOut})$0"
    },
    "JS_LICE_GETWIDTH_WR c": {
        "prefix": "WR_JS_LICE_GetWidth",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_LICE_GetWidth(${2:void* bitmap})$0"
    },
    "REAPER.JS_LICE_GETWIDTH_WR lua": {
        "prefix": "reaperwr.JS_LICE_GetWidth",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_LICE_GetWidth(${3:identifier bitmap})$0"
    },
    "JS_LICE_GETWIDTH_WR python": {
        "prefix": "WR_JS_LICE_GetWidth",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_LICE_GetWidth(${2:void bitmap})$0"
    },
    "JS_LICE_GRADRECT_WR c": {
        "prefix": "WR_JS_LICE_GradRect",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_GradRect(${2:void* bitmap},${3:int dstx},${4:int dsty},${5:int dstw},${6:int dsth},${7:double ir},${8:double ig},${9:double ib},${10:double ia},${11:double drdx},${12:double dgdx},${13:double dbdx},${14:double dadx},${15:double drdy},${16:double dgdy},${17:double dbdy},${18:double dady},${19:const char* mode})$0"
    },
    "JS_LICE_ISFLIPPED_WR c": {
        "prefix": "WR_JS_LICE_IsFlipped",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = JS_LICE_IsFlipped(${2:void* bitmap})$0"
    },
    "REAPER.JS_LICE_ISFLIPPED_WR lua": {
        "prefix": "reaperwr.JS_LICE_IsFlipped",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.JS_LICE_IsFlipped(${3:identifier bitmap})$0"
    },
    "JS_LICE_ISFLIPPED_WR python": {
        "prefix": "WR_JS_LICE_IsFlipped",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = JS_LICE_IsFlipped(${2:void bitmap})$0"
    },
    "JS_LICE_LINE_WR c": {
        "prefix": "WR_JS_LICE_Line",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_Line(${2:void* bitmap},${3:double x1},${4:double y1},${5:double x2},${6:double y2},${7:int color},${8:double alpha},${9:const char* mode},${10:bool antialias})$0"
    },
    "JS_LICE_LISTALLBITMAPS_WR c": {
        "prefix": "WR_JS_LICE_ListAllBitmaps",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_LICE_ListAllBitmaps(${2:char* listOutNeedBig},${3:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_LICE_LISTALLBITMAPS_WR lua": {
        "prefix": "reaperwr.JS_LICE_ListAllBitmaps",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer retval},${3:string list} = reaper.JS_LICE_ListAllBitmaps()$0"
    },
    "JS_LICE_LISTALLBITMAPS_WR python": {
        "prefix": "WR_JS_LICE_ListAllBitmaps",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int retval},${2:String listOutNeedBig},${3:Int listOutNeedBig_sz} = JS_LICE_ListAllBitmaps(${4:listOutNeedBig},${5:listOutNeedBig_sz})$0"
    },
    "JS_LICE_LOADPNG_WR c": {
        "prefix": "WR_JS_LICE_LoadPNG",
        "scope": "c",
        "description": "Returns a system LICE bitmap containing the PNG.\n",
        "body": "${1:void*} = JS_LICE_LoadPNG(${2:const char* filename})$0"
    },
    "REAPER.JS_LICE_LOADPNG_WR lua": {
        "prefix": "reaperwr.JS_LICE_LoadPNG",
        "scope": "lua",
        "description": "Returns a system LICE bitmap containing the PNG.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_LICE_LoadPNG(${3:string filename})$0"
    },
    "JS_LICE_LOADPNG_WR python": {
        "prefix": "WR_JS_LICE_LoadPNG",
        "scope": "python",
        "description": "Returns a system LICE bitmap containing the PNG.\n",
        "body": "${1:void} = JS_LICE_LoadPNG(${2:String filename})$0"
    },
    "JS_LICE_MEASURETEXT_WR c": {
        "prefix": "WR_JS_LICE_MeasureText",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_MeasureText(${2:const char* text},${3:int* widthOut},${4:int* HeightOut})$0"
    },
    "REAPER.JS_LICE_MEASURETEXT_WR lua": {
        "prefix": "reaperwr.JS_LICE_MeasureText",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number width},${3:number Height} = reaper.JS_LICE_MeasureText(${4:string text})$0"
    },
    "JS_LICE_MEASURETEXT_WR python": {
        "prefix": "WR_JS_LICE_MeasureText",
        "scope": "python",
        "description": "\n",
        "body": "${1:String text},${2:Int widthOut},${3:Int HeightOut} = JS_LICE_MeasureText(${4:text},${5:widthOut},${6:HeightOut})$0"
    },
    "JS_LICE_PROCESSRECT_WR c": {
        "prefix": "WR_JS_LICE_ProcessRect",
        "scope": "c",
        "description": "Applies bitwise operations to each pixel in the target rectangle.\noperand: a color in 0xAARRGGBB format.\nmodes:\n* \"XOR\", \"OR\" or \"AND\".\n* \"SET_XYZ\", with XYZ any combination of A, R, G, and B: copies the\nspecified channels from operand to the bitmap. (Useful for setting the\nalpha values of a bitmap.)\n* \"ALPHAMUL\": Performs alpha pre-multiplication on each pixel in the\nrect. operand is ignored in this mode. (On WindowsOS, GDI_Blit does not\nperform alpha multiplication on the fly, and a separate alpha\npre-multiplication step is therefore required.)\nNOTE:\nLICE_Blit and LICE_ScaledBlit are also useful for processing bitmap colors. For example, to multiply all channel values by 1.5:\nreaper.JS_LICE_Blit(bitmap, x, y, bitmap, x, y, w, h, 0.5, \"ADD\").\n",
        "body": "${1:bool} = JS_LICE_ProcessRect(${2:void* bitmap},${3:int x},${4:int y},${5:int w},${6:int h},${7:const char* mode},${8:double operand})$0"
    },
    "REAPER.JS_LICE_PROCESSRECT_WR lua": {
        "prefix": "reaperwr.JS_LICE_ProcessRect",
        "scope": "lua",
        "description": "Applies bitwise operations to each pixel in the target rectangle.\noperand: a color in 0xAARRGGBB format.\nmodes:\n* \"XOR\", \"OR\" or \"AND\".\n* \"SET_XYZ\", with XYZ any combination of A, R, G, and B: copies the\nspecified channels from operand to the bitmap. (Useful for setting the\nalpha values of a bitmap.)\n* \"ALPHAMUL\": Performs alpha pre-multiplication on each pixel in the\nrect. operand is ignored in this mode. (On WindowsOS, GDI_Blit does not\nperform alpha multiplication on the fly, and a separate alpha\npre-multiplication step is therefore required.)\nNOTE:\nLICE_Blit and LICE_ScaledBlit are also useful for processing bitmap colors. For example, to multiply all channel values by 1.5:\nreaper.JS_LICE_Blit(bitmap, x, y, bitmap, x, y, w, h, 0.5, \"ADD\").\n",
        "body": "${1:local }${2:boolean} = reaper.JS_LICE_ProcessRect(${3:identifier bitmap},${4:integer x},${5:integer y},${6:integer w},${7:integer h},${8:string mode},${9:number operand})$0"
    },
    "JS_LICE_PROCESSRECT_WR python": {
        "prefix": "WR_JS_LICE_ProcessRect",
        "scope": "python",
        "description": "Applies bitwise operations to each pixel in the target rectangle.\noperand: a color in 0xAARRGGBB format.\nmodes:\n* \"XOR\", \"OR\" or \"AND\".\n* \"SET_XYZ\", with XYZ any combination of A, R, G, and B: copies the\nspecified channels from operand to the bitmap. (Useful for setting the\nalpha values of a bitmap.)\n* \"ALPHAMUL\": Performs alpha pre-multiplication on each pixel in the\nrect. operand is ignored in this mode. (On WindowsOS, GDI_Blit does not\nperform alpha multiplication on the fly, and a separate alpha\npre-multiplication step is therefore required.)\nNOTE:\nLICE_Blit and LICE_ScaledBlit are also useful for processing bitmap colors. For example, to multiply all channel values by 1.5:\nreaper.JS_LICE_Blit(bitmap, x, y, bitmap, x, y, w, h, 0.5, \"ADD\").\n",
        "body": "${1:Boolean} = JS_LICE_ProcessRect(${2:void bitmap},${3:Int x},${4:Int y},${5:Int w},${6:Int h},${7:String mode},${8:Float operand})$0"
    },
    "JS_LICE_PUTPIXEL_WR c": {
        "prefix": "WR_JS_LICE_PutPixel",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_PutPixel(${2:void* bitmap},${3:int x},${4:int y},${5:double color},${6:double alpha},${7:const char* mode})$0"
    },
    "JS_LICE_RESIZE_WR c": {
        "prefix": "WR_JS_LICE_Resize",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_Resize(${2:void* bitmap},${3:int width},${4:int height})$0"
    },
    "JS_LICE_ROTATEDBLIT_WR c": {
        "prefix": "WR_JS_LICE_RotatedBlit",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "${1:void} = JS_LICE_RotatedBlit(${2:void* destBitmap},${3:int dstx},${4:int dsty},${5:int dstw},${6:int dsth},${7:void* sourceBitmap},${8:double srcx},${9:double srcy},${10:double srcw},${11:double srch},${12:double angle},${13:double rotxcent},${14:double rotycent},${15:bool cliptosourcerect},${16:double alpha},${17:const char* mode})$0"
    },
    "JS_LICE_ROUNDRECT_WR c": {
        "prefix": "WR_JS_LICE_RoundRect",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\".\nLICE color format: 0xAARRGGBB (AA is only used in ALPHA mode).\n",
        "body": "${1:void} = JS_LICE_RoundRect(${2:void* bitmap},${3:double x},${4:double y},${5:double w},${6:double h},${7:int cornerradius},${8:int color},${9:double alpha},${10:const char* mode},${11:bool antialias})$0"
    },
    "JS_LICE_SCALEDBLIT_WR c": {
        "prefix": "WR_JS_LICE_ScaledBlit",
        "scope": "c",
        "description": "LICE modes: \"COPY\" (default if empty string), \"MASK\", \"ADD\", \"DODGE\",\n\"MUL\", \"OVERLAY\" or \"HSVADJ\", any of which may be combined with \"ALPHA\"\nto enable per-pixel alpha blending.\n",
        "body": "${1:void} = JS_LICE_ScaledBlit(${2:void* destBitmap},${3:int dstx},${4:int dsty},${5:int dstw},${6:int dsth},${7:void* srcBitmap},${8:double srcx},${9:double srcy},${10:double srcw},${11:double srch},${12:double alpha},${13:const char* mode})$0"
    },
    "JS_LICE_SETALPHAFROMCOLORMASK_WR c": {
        "prefix": "WR_JS_LICE_SetAlphaFromColorMask",
        "scope": "c",
        "description": "Sets all pixels that match the given color's RGB values to fully\ntransparent, and all other pixels to fully opaque.  (All pixels' RGB\nvalues remain unchanged.)\n",
        "body": "${1:void} = JS_LICE_SetAlphaFromColorMask(${2:void* bitmap},${3:int colorRGB})$0"
    },
    "JS_LICE_SETFONTBKCOLOR_WR c": {
        "prefix": "WR_JS_LICE_SetFontBkColor",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_SetFontBkColor(${2:void* LICEFont},${3:int color})$0"
    },
    "JS_LICE_SETFONTCOLOR_WR c": {
        "prefix": "WR_JS_LICE_SetFontColor",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_LICE_SetFontColor(${2:void* LICEFont},${3:int color})$0"
    },
    "JS_LICE_SETFONTFROMGDI_WR c": {
        "prefix": "WR_JS_LICE_SetFontFromGDI",
        "scope": "c",
        "description": "Converts a GDI font into a LICE font.\nThe font can be modified by the following flags, in a comma-separated list:\n\"VERTICAL\", \"BOTTOMUP\", \"NATIVE\", \"BLUR\", \"INVERT\", \"MONO\", \"SHADOW\" or \"OUTLINE\".\n",
        "body": "${1:void} = JS_LICE_SetFontFromGDI(${2:void* LICEFont},${3:void* GDIFont},${4:const char* moreFormats})$0"
    },
    "JS_LICE_WRITEPNG_WR c": {
        "prefix": "WR_JS_LICE_WritePNG",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = JS_LICE_WritePNG(${2:const char* filename},${3:void* bitmap},${4:bool wantAlpha})$0"
    },
    "REAPER.JS_LICE_WRITEPNG_WR lua": {
        "prefix": "reaperwr.JS_LICE_WritePNG",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean} = reaper.JS_LICE_WritePNG(${3:string filename},${4:identifier bitmap},${5:boolean wantAlpha})$0"
    },
    "JS_LICE_WRITEPNG_WR python": {
        "prefix": "WR_JS_LICE_WritePNG",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean} = JS_LICE_WritePNG(${2:String filename},${3:void bitmap},${4:Boolean wantAlpha})$0"
    },
    "JS_LISTVIEW_ENSUREVISIBLE_WR c": {
        "prefix": "WR_JS_ListView_EnsureVisible",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_ListView_EnsureVisible(${2:void* listviewHWND},${3:int index},${4:bool partialOK})$0"
    },
    "JS_LISTVIEW_ENUMSELITEMS_WR c": {
        "prefix": "WR_JS_ListView_EnumSelItems",
        "scope": "c",
        "description": "Returns the index of the next selected list item with index greater that\nthe specified number. Returns -1 if no selected items left.\n",
        "body": "${1:int} = JS_ListView_EnumSelItems(${2:void* listviewHWND},${3:int index})$0"
    },
    "REAPER.JS_LISTVIEW_ENUMSELITEMS_WR lua": {
        "prefix": "reaperwr.JS_ListView_EnumSelItems",
        "scope": "lua",
        "description": "Returns the index of the next selected list item with index greater that\nthe specified number. Returns -1 if no selected items left.\n",
        "body": "${1:local }${2:integer} = reaper.JS_ListView_EnumSelItems(${3:identifier listviewHWND},${4:integer index})$0"
    },
    "JS_LISTVIEW_ENUMSELITEMS_WR python": {
        "prefix": "WR_JS_ListView_EnumSelItems",
        "scope": "python",
        "description": "Returns the index of the next selected list item with index greater that\nthe specified number. Returns -1 if no selected items left.\n",
        "body": "${1:Int} = JS_ListView_EnumSelItems(${2:void listviewHWND},${3:Int index})$0"
    },
    "JS_LISTVIEW_GETFOCUSEDITEM_WR c": {
        "prefix": "WR_JS_ListView_GetFocusedItem",
        "scope": "c",
        "description": "Returns the index and text of the focused item, if any.\n",
        "body": "${1:int} = JS_ListView_GetFocusedItem(${2:void* listviewHWND},${3:char* textOut},${4:int textOut_sz})$0"
    },
    "REAPER.JS_LISTVIEW_GETFOCUSEDITEM_WR lua": {
        "prefix": "reaperwr.JS_ListView_GetFocusedItem",
        "scope": "lua",
        "description": "Returns the index and text of the focused item, if any.\n",
        "body": "${1:local }${2:integer retval},${3:string text} = reaper.JS_ListView_GetFocusedItem(${4:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_GETFOCUSEDITEM_WR python": {
        "prefix": "WR_JS_ListView_GetFocusedItem",
        "scope": "python",
        "description": "Returns the index and text of the focused item, if any.\n",
        "body": "${1:Int retval},${2:void listviewHWND},${3:String textOut},${4:Int textOut_sz} = JS_ListView_GetFocusedItem(${5:listviewHWND},${6:textOut},${7:textOut_sz})$0"
    },
    "JS_LISTVIEW_GETITEM_WR c": {
        "prefix": "WR_JS_ListView_GetItem",
        "scope": "c",
        "description": "Returns the text and state of specified item.\n",
        "body": "${1:void} = JS_ListView_GetItem(${2:void* listviewHWND},${3:int index},${4:int subItem},${5:char* textOut},${6:int textOut_sz},${7:int* stateOut})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEM_WR lua": {
        "prefix": "reaperwr.JS_ListView_GetItem",
        "scope": "lua",
        "description": "Returns the text and state of specified item.\n",
        "body": "${1:local }${2:string text},${3:number state} = reaper.JS_ListView_GetItem(${4:identifier listviewHWND},${5:integer index},${6:integer subItem})$0"
    },
    "JS_LISTVIEW_GETITEM_WR python": {
        "prefix": "WR_JS_ListView_GetItem",
        "scope": "python",
        "description": "Returns the text and state of specified item.\n",
        "body": "${1:void listviewHWND},${2:Int index},${3:Int subItem},${4:String textOut},${5:Int textOut_sz},${6:Int stateOut} = JS_ListView_GetItem(${7:listviewHWND},${8:index},${9:subItem},${10:textOut},${11:textOut_sz},${12:stateOut})$0"
    },
    "JS_LISTVIEW_GETITEMCOUNT_WR c": {
        "prefix": "WR_JS_ListView_GetItemCount",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_ListView_GetItemCount(${2:void* listviewHWND})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEMCOUNT_WR lua": {
        "prefix": "reaperwr.JS_ListView_GetItemCount",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_ListView_GetItemCount(${3:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_GETITEMCOUNT_WR python": {
        "prefix": "WR_JS_ListView_GetItemCount",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_ListView_GetItemCount(${2:void listviewHWND})$0"
    },
    "JS_LISTVIEW_GETITEMSTATE_WR c": {
        "prefix": "WR_JS_ListView_GetItemState",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_ListView_GetItemState(${2:void* listviewHWND},${3:int index})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEMSTATE_WR lua": {
        "prefix": "reaperwr.JS_ListView_GetItemState",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_ListView_GetItemState(${3:identifier listviewHWND},${4:integer index})$0"
    },
    "JS_LISTVIEW_GETITEMSTATE_WR python": {
        "prefix": "WR_JS_ListView_GetItemState",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_ListView_GetItemState(${2:void listviewHWND},${3:Int index})$0"
    },
    "JS_LISTVIEW_GETITEMTEXT_WR c": {
        "prefix": "WR_JS_ListView_GetItemText",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_ListView_GetItemText(${2:void* listviewHWND},${3:int index},${4:int subItem},${5:char* textOut},${6:int textOut_sz})$0"
    },
    "REAPER.JS_LISTVIEW_GETITEMTEXT_WR lua": {
        "prefix": "reaperwr.JS_ListView_GetItemText",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string text} = reaper.JS_ListView_GetItemText(${3:identifier listviewHWND},${4:integer index},${5:integer subItem})$0"
    },
    "JS_LISTVIEW_GETITEMTEXT_WR python": {
        "prefix": "WR_JS_ListView_GetItemText",
        "scope": "python",
        "description": "\n",
        "body": "${1:void listviewHWND},${2:Int index},${3:Int subItem},${4:String textOut},${5:Int textOut_sz} = JS_ListView_GetItemText(${6:listviewHWND},${7:index},${8:subItem},${9:textOut},${10:textOut_sz})$0"
    },
    "JS_LISTVIEW_GETSELECTEDCOUNT_WR c": {
        "prefix": "WR_JS_ListView_GetSelectedCount",
        "scope": "c",
        "description": "\n",
        "body": "${1:int} = JS_ListView_GetSelectedCount(${2:void* listviewHWND})$0"
    },
    "REAPER.JS_LISTVIEW_GETSELECTEDCOUNT_WR lua": {
        "prefix": "reaperwr.JS_ListView_GetSelectedCount",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:integer} = reaper.JS_ListView_GetSelectedCount(${3:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_GETSELECTEDCOUNT_WR python": {
        "prefix": "WR_JS_ListView_GetSelectedCount",
        "scope": "python",
        "description": "\n",
        "body": "${1:Int} = JS_ListView_GetSelectedCount(${2:void listviewHWND})$0"
    },
    "JS_LISTVIEW_LISTALLSELITEMS_WR c": {
        "prefix": "WR_JS_ListView_ListAllSelItems",
        "scope": "c",
        "description": "Returns the indices of all selected items as a comma-separated list.\n* retval: Number of selected items found; negative or zero if an error occured.\n",
        "body": "${1:int} = JS_ListView_ListAllSelItems(${2:void* listviewHWND},${3:char* itemsOutNeedBig},${4:int itemsOutNeedBig_sz})$0"
    },
    "REAPER.JS_LISTVIEW_LISTALLSELITEMS_WR lua": {
        "prefix": "reaperwr.JS_ListView_ListAllSelItems",
        "scope": "lua",
        "description": "Returns the indices of all selected items as a comma-separated list.\n* retval: Number of selected items found; negative or zero if an error occured.\n",
        "body": "${1:local }${2:integer retval},${3:string items} = reaper.JS_ListView_ListAllSelItems(${4:identifier listviewHWND})$0"
    },
    "JS_LISTVIEW_LISTALLSELITEMS_WR python": {
        "prefix": "WR_JS_ListView_ListAllSelItems",
        "scope": "python",
        "description": "Returns the indices of all selected items as a comma-separated list.\n* retval: Number of selected items found; negative or zero if an error occured.\n",
        "body": "${1:Int retval},${2:void listviewHWND},${3:String itemsOutNeedBig},${4:Int itemsOutNeedBig_sz} = JS_ListView_ListAllSelItems(${5:listviewHWND},${6:itemsOutNeedBig},${7:itemsOutNeedBig_sz})$0"
    },
    "JS_LOCALIZE_WR c": {
        "prefix": "WR_JS_Localize",
        "scope": "c",
        "description": "Returns the translation of the given US English text, according to the currently loaded Language Pack.\nParameters:\n* LangPackSection: Language Packs are divided into sections such as \"common\" or \"DLG_102\".\n* In Lua, by default, text of up to 1024 chars can be returned. To\nincrease (or reduce) the default buffer size, a string and size can be\nincluded as optional 3rd and 4th arguments.\nExample: reaper.JS_Localize(\"Actions\", \"common\", \"\", 20)\n",
        "body": "${1:void} = JS_Localize(${2:const char* USEnglish},${3:const char* LangPackSection},${4:char* translationOut},${5:int translationOut_sz})$0"
    },
    "REAPER.JS_LOCALIZE_WR lua": {
        "prefix": "reaperwr.JS_Localize",
        "scope": "lua",
        "description": "Returns the translation of the given US English text, according to the currently loaded Language Pack.\nParameters:\n* LangPackSection: Language Packs are divided into sections such as \"common\" or \"DLG_102\".\n* In Lua, by default, text of up to 1024 chars can be returned. To\nincrease (or reduce) the default buffer size, a string and size can be\nincluded as optional 3rd and 4th arguments.\nExample: reaper.JS_Localize(\"Actions\", \"common\", \"\", 20)\n",
        "body": "${1:local }${2:string translation} = reaper.JS_Localize(${3:string USEnglish},${4:string LangPackSection})$0"
    },
    "JS_LOCALIZE_WR python": {
        "prefix": "WR_JS_Localize",
        "scope": "python",
        "description": "Returns the translation of the given US English text, according to the currently loaded Language Pack.\nParameters:\n* LangPackSection: Language Packs are divided into sections such as \"common\" or \"DLG_102\".\n* In Lua, by default, text of up to 1024 chars can be returned. To\nincrease (or reduce) the default buffer size, a string and size can be\nincluded as optional 3rd and 4th arguments.\nExample: reaper.JS_Localize(\"Actions\", \"common\", \"\", 20)\n",
        "body": "${1:String USEnglish},${2:String LangPackSection},${3:String translationOut},${4:Int translationOut_sz} = JS_Localize(${5:USEnglish},${6:LangPackSection},${7:translationOut},${8:translationOut_sz})$0"
    },
    "JS_MIDIEDITOR_ARRAYALL_WR c": {
        "prefix": "WR_JS_MIDIEditor_ArrayAll",
        "scope": "c",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* The address of each MIDI editor window is stored in the provided\nreaper.array. Each address can be converted to a REAPER object (HWND) by\nthe function JS_Window_HandleFromAddress.\n",
        "body": "${1:int} = JS_MIDIEditor_ArrayAll(${2:void* reaperarray})$0"
    },
    "REAPER.JS_MIDIEDITOR_ARRAYALL_WR lua": {
        "prefix": "reaperwr.JS_MIDIEditor_ArrayAll",
        "scope": "lua",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* The address of each MIDI editor window is stored in the provided\nreaper.array. Each address can be converted to a REAPER object (HWND) by\nthe function JS_Window_HandleFromAddress.\n",
        "body": "${1:local }${2:integer} = reaper.JS_MIDIEditor_ArrayAll(${3:identifier reaperarray})$0"
    },
    "JS_MIDIEDITOR_ARRAYALL_WR python": {
        "prefix": "WR_JS_MIDIEditor_ArrayAll",
        "scope": "python",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* The address of each MIDI editor window is stored in the provided\nreaper.array. Each address can be converted to a REAPER object (HWND) by\nthe function JS_Window_HandleFromAddress.\n",
        "body": "${1:Int} = JS_MIDIEditor_ArrayAll(${2:void reaperarray})$0"
    },
    "JS_MIDIEDITOR_LISTALL_WR c": {
        "prefix": "WR_JS_MIDIEditor_ListAll",
        "scope": "c",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* list: Comma-separated string of hexadecimal values. Each value is an\naddress that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "${1:int} = JS_MIDIEditor_ListAll(${2:char* listOutNeedBig},${3:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_MIDIEDITOR_LISTALL_WR lua": {
        "prefix": "reaperwr.JS_MIDIEditor_ListAll",
        "scope": "lua",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* list: Comma-separated string of hexadecimal values. Each value is an\naddress that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "${1:local }${2:integer retval},${3:string list} = reaper.JS_MIDIEditor_ListAll()$0"
    },
    "JS_MIDIEDITOR_LISTALL_WR python": {
        "prefix": "WR_JS_MIDIEditor_ListAll",
        "scope": "python",
        "description": "Finds all open MIDI windows (whether docked or not).\n* retval: The number of MIDI editor windows found; negative if an error occurred.\n* list: Comma-separated string of hexadecimal values. Each value is an\naddress that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "${1:Int retval},${2:String listOutNeedBig},${3:Int listOutNeedBig_sz} = JS_MIDIEditor_ListAll(${4:listOutNeedBig},${5:listOutNeedBig_sz})$0"
    },
    "JS_MEM_ALLOC_WR c": {
        "prefix": "WR_JS_Mem_Alloc",
        "scope": "c",
        "description": "Allocates memory for general use by functions that require memory buffers.\n",
        "body": "${1:void*} = JS_Mem_Alloc(${2:int sizeBytes})$0"
    },
    "REAPER.JS_MEM_ALLOC_WR lua": {
        "prefix": "reaperwr.JS_Mem_Alloc",
        "scope": "lua",
        "description": "Allocates memory for general use by functions that require memory buffers.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Mem_Alloc(${3:integer sizeBytes})$0"
    },
    "JS_MEM_ALLOC_WR python": {
        "prefix": "WR_JS_Mem_Alloc",
        "scope": "python",
        "description": "Allocates memory for general use by functions that require memory buffers.\n",
        "body": "${1:void} = JS_Mem_Alloc(${2:Int sizeBytes})$0"
    },
    "JS_MEM_FREE_WR c": {
        "prefix": "WR_JS_Mem_Free",
        "scope": "c",
        "description": "Frees memory that was previously allocated by JS_Mem_Alloc.\n",
        "body": "${1:bool} = JS_Mem_Free(${2:void* mallocPointer})$0"
    },
    "REAPER.JS_MEM_FREE_WR lua": {
        "prefix": "reaperwr.JS_Mem_Free",
        "scope": "lua",
        "description": "Frees memory that was previously allocated by JS_Mem_Alloc.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Mem_Free(${3:identifier mallocPointer})$0"
    },
    "JS_MEM_FREE_WR python": {
        "prefix": "WR_JS_Mem_Free",
        "scope": "python",
        "description": "Frees memory that was previously allocated by JS_Mem_Alloc.\n",
        "body": "${1:Boolean} = JS_Mem_Free(${2:void mallocPointer})$0"
    },
    "JS_MEM_FROMSTRING_WR c": {
        "prefix": "WR_JS_Mem_FromString",
        "scope": "c",
        "description": "Copies a packed string into a memory buffer.\n",
        "body": "${1:bool} = JS_Mem_FromString(${2:void* mallocPointer},${3:int offset},${4:const char* packedString},${5:int stringLength})$0"
    },
    "REAPER.JS_MEM_FROMSTRING_WR lua": {
        "prefix": "reaperwr.JS_Mem_FromString",
        "scope": "lua",
        "description": "Copies a packed string into a memory buffer.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Mem_FromString(${3:identifier mallocPointer},${4:integer offset},${5:string packedString},${6:integer stringLength})$0"
    },
    "JS_MEM_FROMSTRING_WR python": {
        "prefix": "WR_JS_Mem_FromString",
        "scope": "python",
        "description": "Copies a packed string into a memory buffer.\n",
        "body": "${1:Boolean} = JS_Mem_FromString(${2:void mallocPointer},${3:Int offset},${4:String packedString},${5:Int stringLength})$0"
    },
    "JS_MOUSE_GETCURSOR_WR c": {
        "prefix": "WR_JS_Mouse_GetCursor",
        "scope": "c",
        "description": "On Windows, retrieves a handle to the current mouse cursor.\nOn Linux and macOS, retrieves a handle to the last cursor set by REAPER or its extensions via SWELL.\n",
        "body": "${1:void*} = JS_Mouse_GetCursor()$0"
    },
    "REAPER.JS_MOUSE_GETCURSOR_WR lua": {
        "prefix": "reaperwr.JS_Mouse_GetCursor",
        "scope": "lua",
        "description": "On Windows, retrieves a handle to the current mouse cursor.\nOn Linux and macOS, retrieves a handle to the last cursor set by REAPER or its extensions via SWELL.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Mouse_GetCursor()$0"
    },
    "JS_MOUSE_GETCURSOR_WR python": {
        "prefix": "WR_JS_Mouse_GetCursor",
        "scope": "python",
        "description": "On Windows, retrieves a handle to the current mouse cursor.\nOn Linux and macOS, retrieves a handle to the last cursor set by REAPER or its extensions via SWELL.\n",
        "body": "${1:void} = JS_Mouse_GetCursor()$0"
    },
    "JS_MOUSE_GETSTATE_WR c": {
        "prefix": "WR_JS_Mouse_GetState",
        "scope": "c",
        "description": "Retrieves the states of mouse buttons and modifiers keys.\nParameters:\n* flags, state: The parameter and the return value both use the same\nformat as gfx.mouse_cap. For example, to get the states of the left\nmouse button and the ctrl key, use flags = 0b00000101.\n",
        "body": "${1:int} = JS_Mouse_GetState(${2:int flags})$0"
    },
    "REAPER.JS_MOUSE_GETSTATE_WR lua": {
        "prefix": "reaperwr.JS_Mouse_GetState",
        "scope": "lua",
        "description": "Retrieves the states of mouse buttons and modifiers keys.\nParameters:\n* flags, state: The parameter and the return value both use the same\nformat as gfx.mouse_cap. For example, to get the states of the left\nmouse button and the ctrl key, use flags = 0b00000101.\n",
        "body": "${1:local }${2:integer} = reaper.JS_Mouse_GetState(${3:integer flags})$0"
    },
    "JS_MOUSE_GETSTATE_WR python": {
        "prefix": "WR_JS_Mouse_GetState",
        "scope": "python",
        "description": "Retrieves the states of mouse buttons and modifiers keys.\nParameters:\n* flags, state: The parameter and the return value both use the same\nformat as gfx.mouse_cap. For example, to get the states of the left\nmouse button and the ctrl key, use flags = 0b00000101.\n",
        "body": "${1:Int} = JS_Mouse_GetState(${2:Int flags})$0"
    },
    "JS_MOUSE_LOADCURSOR_WR c": {
        "prefix": "WR_JS_Mouse_LoadCursor",
        "scope": "c",
        "description": "Loads a cursor by number.\ncursorNumber: Same as used for gfx.setcursor, and includes some of\nWindows' predefined cursors (with numbers > 32000; refer to\ndocumentation for the Win32 C++ function LoadCursor), and REAPER's own\ncursors (with numbers < 2000).\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "${1:void*} = JS_Mouse_LoadCursor(${2:int cursorNumber})$0"
    },
    "REAPER.JS_MOUSE_LOADCURSOR_WR lua": {
        "prefix": "reaperwr.JS_Mouse_LoadCursor",
        "scope": "lua",
        "description": "Loads a cursor by number.\ncursorNumber: Same as used for gfx.setcursor, and includes some of\nWindows' predefined cursors (with numbers > 32000; refer to\ndocumentation for the Win32 C++ function LoadCursor), and REAPER's own\ncursors (with numbers < 2000).\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Mouse_LoadCursor(${3:integer cursorNumber})$0"
    },
    "JS_MOUSE_LOADCURSOR_WR python": {
        "prefix": "WR_JS_Mouse_LoadCursor",
        "scope": "python",
        "description": "Loads a cursor by number.\ncursorNumber: Same as used for gfx.setcursor, and includes some of\nWindows' predefined cursors (with numbers > 32000; refer to\ndocumentation for the Win32 C++ function LoadCursor), and REAPER's own\ncursors (with numbers < 2000).\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "${1:void} = JS_Mouse_LoadCursor(${2:Int cursorNumber})$0"
    },
    "JS_MOUSE_LOADCURSORFROMFILE_WR c": {
        "prefix": "WR_JS_Mouse_LoadCursorFromFile",
        "scope": "c",
        "description": "Loads a cursor from a .cur file.\nforceNewLoad is an optional boolean parameter:\n* If omitted or false, and if the .cur file has already been loaded\npreviously during the REAPER session, the file will not be re-loaded,\nand the previous handle will be returned, thereby (slightly) improving\nspeed and (slighty) lowering memory usage.\n* If true, the file will be re-loaded and a new handle will be returned.\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "${1:void*} = JS_Mouse_LoadCursorFromFile(${2:const char* pathAndFileName},${3:bool* forceNewLoadOptional})$0"
    },
    "REAPER.JS_MOUSE_LOADCURSORFROMFILE_WR lua": {
        "prefix": "reaperwr.JS_Mouse_LoadCursorFromFile",
        "scope": "lua",
        "description": "Loads a cursor from a .cur file.\nforceNewLoad is an optional boolean parameter:\n* If omitted or false, and if the .cur file has already been loaded\npreviously during the REAPER session, the file will not be re-loaded,\nand the previous handle will be returned, thereby (slightly) improving\nspeed and (slighty) lowering memory usage.\n* If true, the file will be re-loaded and a new handle will be returned.\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Mouse_LoadCursorFromFile(${3:string pathAndFileName},${4:unsupported forceNewLoad})$0"
    },
    "JS_MOUSE_LOADCURSORFROMFILE_WR python": {
        "prefix": "WR_JS_Mouse_LoadCursorFromFile",
        "scope": "python",
        "description": "Loads a cursor from a .cur file.\nforceNewLoad is an optional boolean parameter:\n* If omitted or false, and if the .cur file has already been loaded\npreviously during the REAPER session, the file will not be re-loaded,\nand the previous handle will be returned, thereby (slightly) improving\nspeed and (slighty) lowering memory usage.\n* If true, the file will be re-loaded and a new handle will be returned.\nIf successful, returns a handle to the cursor, which can be used in JS_Mouse_SetCursor.\n",
        "body": "${1:void retval},${2:String pathAndFileName},${3:Boolean forceNewLoadOptional} = JS_Mouse_LoadCursorFromFile(${4:pathAndFileName},${5:forceNewLoadOptional})$0"
    },
    "JS_MOUSE_SETCURSOR_WR c": {
        "prefix": "WR_JS_Mouse_SetCursor",
        "scope": "c",
        "description": "Sets the mouse cursor.  (Only lasts while script is running, and for a single \"defer\" cycle.)\n",
        "body": "${1:void} = JS_Mouse_SetCursor(${2:void* cursorHandle})$0"
    },
    "JS_MOUSE_SETPOSITION_WR c": {
        "prefix": "WR_JS_Mouse_SetPosition",
        "scope": "c",
        "description": "Moves the mouse cursor to the specified screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:bool} = JS_Mouse_SetPosition(${2:int x},${3:int y})$0"
    },
    "REAPER.JS_MOUSE_SETPOSITION_WR lua": {
        "prefix": "reaperwr.JS_Mouse_SetPosition",
        "scope": "lua",
        "description": "Moves the mouse cursor to the specified screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Mouse_SetPosition(${3:integer x},${4:integer y})$0"
    },
    "JS_MOUSE_SETPOSITION_WR python": {
        "prefix": "WR_JS_Mouse_SetPosition",
        "scope": "python",
        "description": "Moves the mouse cursor to the specified screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:Boolean} = JS_Mouse_SetPosition(${2:Int x},${3:Int y})$0"
    },
    "JS_REASCRIPTAPI_VERSION_WR c": {
        "prefix": "WR_JS_ReaScriptAPI_Version",
        "scope": "c",
        "description": "Returns the version of the js_ReaScriptAPI extension.\n",
        "body": "${1:void} = JS_ReaScriptAPI_Version(${2:double* versionOut})$0"
    },
    "REAPER.JS_REASCRIPTAPI_VERSION_WR lua": {
        "prefix": "reaperwr.JS_ReaScriptAPI_Version",
        "scope": "lua",
        "description": "Returns the version of the js_ReaScriptAPI extension.\n",
        "body": "${1:local }${2:number version} = reaper.JS_ReaScriptAPI_Version()$0"
    },
    "JS_REASCRIPTAPI_VERSION_WR python": {
        "prefix": "WR_JS_ReaScriptAPI_Version",
        "scope": "python",
        "description": "Returns the version of the js_ReaScriptAPI extension.\n",
        "body": "${1:Float versionOut} = JS_ReaScriptAPI_Version(${2:versionOut})$0"
    },
    "JS_STRING_WR c": {
        "prefix": "WR_JS_String",
        "scope": "c",
        "description": "Returns the memory contents starting at address[offset] as a packed string. Offset is added as steps of 1 byte (char) each.\n",
        "body": "${1:bool} = JS_String(${2:void* pointer},${3:int offset},${4:int lengthChars},${5:char* bufOutNeedBig},${6:int bufOutNeedBig_sz})$0"
    },
    "REAPER.JS_STRING_WR lua": {
        "prefix": "reaperwr.JS_String",
        "scope": "lua",
        "description": "Returns the memory contents starting at address[offset] as a packed string. Offset is added as steps of 1 byte (char) each.\n",
        "body": "${1:local }${2:boolean retval},${3:string buf} = reaper.JS_String(${4:identifier pointer},${5:integer offset},${6:integer lengthChars})$0"
    },
    "JS_STRING_WR python": {
        "prefix": "WR_JS_String",
        "scope": "python",
        "description": "Returns the memory contents starting at address[offset] as a packed string. Offset is added as steps of 1 byte (char) each.\n",
        "body": "${1:Boolean retval},${2:void pointer},${3:Int offset},${4:Int lengthChars},${5:String bufOutNeedBig},${6:Int bufOutNeedBig_sz} = JS_String(${7:pointer},${8:offset},${9:lengthChars},${10:bufOutNeedBig},${11:bufOutNeedBig_sz})$0"
    },
    "JS_VKEYS_GETDOWN_WR c": {
        "prefix": "WR_JS_VKeys_GetDown",
        "scope": "c",
        "description": "Returns a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYDOWN messages since cutoffTime.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "${1:void} = JS_VKeys_GetDown(${2:double cutoffTime},${3:char* stateOutNeedBig},${4:int* stateOutNeedBig_sz})$0"
    },
    "REAPER.JS_VKEYS_GETDOWN_WR lua": {
        "prefix": "reaperwr.JS_VKeys_GetDown",
        "scope": "lua",
        "description": "Returns a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYDOWN messages since cutoffTime.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "${1:local }${2:string state} = reaper.JS_VKeys_GetDown(${3:number cutoffTime})$0"
    },
    "JS_VKEYS_GETDOWN_WR python": {
        "prefix": "WR_JS_VKeys_GetDown",
        "scope": "python",
        "description": "Returns a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYDOWN messages since cutoffTime.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "${1:Float cutoffTime},${2:String stateOutNeedBig},${3:Int stateOutNeedBig_sz} = JS_VKeys_GetDown(${4:cutoffTime},${5:stateOutNeedBig},${6:stateOutNeedBig_sz})$0"
    },
    "JS_VKEYS_GETSTATE_WR c": {
        "prefix": "WR_JS_VKeys_GetState",
        "scope": "c",
        "description": "Retrieves the current states (0 or 1) of all virtual keys, from 0x01 to 0xFF, in a 255-byte array.\ncutoffTime: A key is only regarded as down if it sent a KEYDOWN message\nafter the cut-off time, not followed by KEYUP. (This is useful for\nexcluding old KEYDOWN messages that weren't properly followed by KEYUP.)\nIf cutoffTime is positive, is it interpreted as absolute time in similar format as time_precise().\nIf cutoffTime is negative, it is relative to the current time.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "${1:void} = JS_VKeys_GetState(${2:double cutoffTime},${3:char* stateOutNeedBig},${4:int* stateOutNeedBig_sz})$0"
    },
    "REAPER.JS_VKEYS_GETSTATE_WR lua": {
        "prefix": "reaperwr.JS_VKeys_GetState",
        "scope": "lua",
        "description": "Retrieves the current states (0 or 1) of all virtual keys, from 0x01 to 0xFF, in a 255-byte array.\ncutoffTime: A key is only regarded as down if it sent a KEYDOWN message\nafter the cut-off time, not followed by KEYUP. (This is useful for\nexcluding old KEYDOWN messages that weren't properly followed by KEYUP.)\nIf cutoffTime is positive, is it interpreted as absolute time in similar format as time_precise().\nIf cutoffTime is negative, it is relative to the current time.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "${1:local }${2:string state} = reaper.JS_VKeys_GetState(${3:number cutoffTime})$0"
    },
    "JS_VKEYS_GETSTATE_WR python": {
        "prefix": "WR_JS_VKeys_GetState",
        "scope": "python",
        "description": "Retrieves the current states (0 or 1) of all virtual keys, from 0x01 to 0xFF, in a 255-byte array.\ncutoffTime: A key is only regarded as down if it sent a KEYDOWN message\nafter the cut-off time, not followed by KEYUP. (This is useful for\nexcluding old KEYDOWN messages that weren't properly followed by KEYUP.)\nIf cutoffTime is positive, is it interpreted as absolute time in similar format as time_precise().\nIf cutoffTime is negative, it is relative to the current time.\nNotes:\n* Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n* Auto-repeated KEYDOWN messages are ignored.\n",
        "body": "${1:Float cutoffTime},${2:String stateOutNeedBig},${3:Int stateOutNeedBig_sz} = JS_VKeys_GetState(${4:cutoffTime},${5:stateOutNeedBig},${6:stateOutNeedBig_sz})$0"
    },
    "JS_VKEYS_GETUP_WR c": {
        "prefix": "WR_JS_VKeys_GetUp",
        "scope": "c",
        "description": "Return a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYUP messages since cutoffTime.\nNote: Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n",
        "body": "${1:void} = JS_VKeys_GetUp(${2:double cutoffTime},${3:char* stateOutNeedBig},${4:int* stateOutNeedBig_sz})$0"
    },
    "REAPER.JS_VKEYS_GETUP_WR lua": {
        "prefix": "reaperwr.JS_VKeys_GetUp",
        "scope": "lua",
        "description": "Return a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYUP messages since cutoffTime.\nNote: Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n",
        "body": "${1:local }${2:string state} = reaper.JS_VKeys_GetUp(${3:number cutoffTime})$0"
    },
    "JS_VKEYS_GETUP_WR python": {
        "prefix": "WR_JS_VKeys_GetUp",
        "scope": "python",
        "description": "Return a 255-byte array that specifies which virtual keys, from 0x01 to 0xFF, have sent KEYUP messages since cutoffTime.\nNote: Mouse buttons and modifier keys are not (currently) reliably detected, and JS_Mouse_GetState can be used instead.\n",
        "body": "${1:Float cutoffTime},${2:String stateOutNeedBig},${3:Int stateOutNeedBig_sz} = JS_VKeys_GetUp(${4:cutoffTime},${5:stateOutNeedBig},${6:stateOutNeedBig_sz})$0"
    },
    "JS_VKEYS_INTERCEPT_WR c": {
        "prefix": "WR_JS_VKeys_Intercept",
        "scope": "c",
        "description": "Intercepting (blocking) virtual keys work similar to the native function\nPreventUIRefresh:  Each key has a (non-negative) intercept state, and\nthe key is passed through as usual if the state equals 0, or blocked if\nthe state is greater than 0.\nkeyCode: The virtual key code of the key, or -1 to change the state of all keys.\nintercept: A script can increase the intercept state by passing +1, or\nlower the state by passing -1.  Multiple scripts can block the same key,\nand the intercept state may reach up to 255. If zero is passed, the\nintercept state is not changed, but the current state is returned.\nReturns: If keyCode refers to a single key, the intercept state of that\nkey is returned.  If keyCode = -1, the state of the key that is most\nstrongly blocked (highest intercept state) is returned.\n",
        "body": "${1:int} = JS_VKeys_Intercept(${2:int keyCode},${3:int intercept})$0"
    },
    "REAPER.JS_VKEYS_INTERCEPT_WR lua": {
        "prefix": "reaperwr.JS_VKeys_Intercept",
        "scope": "lua",
        "description": "Intercepting (blocking) virtual keys work similar to the native function\nPreventUIRefresh:  Each key has a (non-negative) intercept state, and\nthe key is passed through as usual if the state equals 0, or blocked if\nthe state is greater than 0.\nkeyCode: The virtual key code of the key, or -1 to change the state of all keys.\nintercept: A script can increase the intercept state by passing +1, or\nlower the state by passing -1.  Multiple scripts can block the same key,\nand the intercept state may reach up to 255. If zero is passed, the\nintercept state is not changed, but the current state is returned.\nReturns: If keyCode refers to a single key, the intercept state of that\nkey is returned.  If keyCode = -1, the state of the key that is most\nstrongly blocked (highest intercept state) is returned.\n",
        "body": "${1:local }${2:integer} = reaper.JS_VKeys_Intercept(${3:integer keyCode},${4:integer intercept})$0"
    },
    "JS_VKEYS_INTERCEPT_WR python": {
        "prefix": "WR_JS_VKeys_Intercept",
        "scope": "python",
        "description": "Intercepting (blocking) virtual keys work similar to the native function\nPreventUIRefresh:  Each key has a (non-negative) intercept state, and\nthe key is passed through as usual if the state equals 0, or blocked if\nthe state is greater than 0.\nkeyCode: The virtual key code of the key, or -1 to change the state of all keys.\nintercept: A script can increase the intercept state by passing +1, or\nlower the state by passing -1.  Multiple scripts can block the same key,\nand the intercept state may reach up to 255. If zero is passed, the\nintercept state is not changed, but the current state is returned.\nReturns: If keyCode refers to a single key, the intercept state of that\nkey is returned.  If keyCode = -1, the state of the key that is most\nstrongly blocked (highest intercept state) is returned.\n",
        "body": "${1:Int} = JS_VKeys_Intercept(${2:Int keyCode},${3:Int intercept})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPT_WR c": {
        "prefix": "WR_JS_WindowMessage_Intercept",
        "scope": "c",
        "description": "Begins intercepting a window message type to specified window.\nParameters:\n* message: a single message type to be intercepted, either in WM_ or\nhexadecimal format. For example \"WM_SETCURSOR\" or \"0x0020\".\n* passThrough: Whether message should be blocked (false) or passed through (true) to the window.\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process / window not valid.\n* -6: Could not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n* Mouse events are typically received by the child window under the mouse, not the parent window.\nKeyboard events are usually *not* received by any individual window. To intercept keyboard events, use the VKey functions.\n",
        "body": "${1:int} = JS_WindowMessage_Intercept(${2:void* windowHWND},${3:const char* message},${4:bool passThrough})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_INTERCEPT_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_Intercept",
        "scope": "lua",
        "description": "Begins intercepting a window message type to specified window.\nParameters:\n* message: a single message type to be intercepted, either in WM_ or\nhexadecimal format. For example \"WM_SETCURSOR\" or \"0x0020\".\n* passThrough: Whether message should be blocked (false) or passed through (true) to the window.\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process / window not valid.\n* -6: Could not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n* Mouse events are typically received by the child window under the mouse, not the parent window.\nKeyboard events are usually *not* received by any individual window. To intercept keyboard events, use the VKey functions.\n",
        "body": "${1:local }${2:integer} = reaper.JS_WindowMessage_Intercept(${3:identifier windowHWND},${4:string message},${5:boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPT_WR python": {
        "prefix": "WR_JS_WindowMessage_Intercept",
        "scope": "python",
        "description": "Begins intercepting a window message type to specified window.\nParameters:\n* message: a single message type to be intercepted, either in WM_ or\nhexadecimal format. For example \"WM_SETCURSOR\" or \"0x0020\".\n* passThrough: Whether message should be blocked (false) or passed through (true) to the window.\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process / window not valid.\n* -6: Could not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n* Mouse events are typically received by the child window under the mouse, not the parent window.\nKeyboard events are usually *not* received by any individual window. To intercept keyboard events, use the VKey functions.\n",
        "body": "${1:Int} = JS_WindowMessage_Intercept(${2:void windowHWND},${3:String message},${4:Boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPTLIST_WR c": {
        "prefix": "WR_JS_WindowMessage_InterceptList",
        "scope": "c",
        "description": "Begins intercepting window messages to specified window.\nParameters:\n* messages: comma-separated string of message types to be intercepted\n(either in WM_ or hexadecimal format), each with a \"block\" or\n\"passthrough\" modifier to specify whether the message should be blocked\nor passed through to the window. For example \"WM_SETCURSOR:block,\n0x0201:passthrough\".\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -1: windowHWND is not a valid window.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process.\n* -6: COuld not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n",
        "body": "${1:int} = JS_WindowMessage_InterceptList(${2:void* windowHWND},${3:const char* messages})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_INTERCEPTLIST_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_InterceptList",
        "scope": "lua",
        "description": "Begins intercepting window messages to specified window.\nParameters:\n* messages: comma-separated string of message types to be intercepted\n(either in WM_ or hexadecimal format), each with a \"block\" or\n\"passthrough\" modifier to specify whether the message should be blocked\nor passed through to the window. For example \"WM_SETCURSOR:block,\n0x0201:passthrough\".\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -1: windowHWND is not a valid window.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process.\n* -6: COuld not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n",
        "body": "${1:local }${2:integer} = reaper.JS_WindowMessage_InterceptList(${3:identifier windowHWND},${4:string messages})$0"
    },
    "JS_WINDOWMESSAGE_INTERCEPTLIST_WR python": {
        "prefix": "WR_JS_WindowMessage_InterceptList",
        "scope": "python",
        "description": "Begins intercepting window messages to specified window.\nParameters:\n* messages: comma-separated string of message types to be intercepted\n(either in WM_ or hexadecimal format), each with a \"block\" or\n\"passthrough\" modifier to specify whether the message should be blocked\nor passed through to the window. For example \"WM_SETCURSOR:block,\n0x0201:passthrough\".\nFor more information on message codes, refer to the Win32 C++ API documentation.\nAll WM_ and CB_ message types listed in swell-types.h should be\nvalid cross-platform, and the function can recognize all of these by\nname. Other messages can be specified by their hex code.\nReturns:\n* 1: Success.\n* 0: The message type is already being intercepted by another script.\n* -1: windowHWND is not a valid window.\n* -2: message string could not be parsed.\n* -3: Failure getting original window process.\n* -6: COuld not obtain the window client HDC.\nNotes:\n* Intercepted messages can be polled using JS_WindowMessage_Peek.\n* Intercepted messages can be edited, if necessary, and then forwarded\nto their original destination using JS_WindowMessage_Post or\nJS_WindowMessage_Send.\n* To check whether a message type is being blocked or passed through,\nPeek the message type, or retrieve the entire List of intercepts.\n",
        "body": "${1:Int} = JS_WindowMessage_InterceptList(${2:void windowHWND},${3:String messages})$0"
    },
    "JS_WINDOWMESSAGE_LISTINTERCEPTS_WR c": {
        "prefix": "WR_JS_WindowMessage_ListIntercepts",
        "scope": "c",
        "description": "Returns a string with a list of all message types currently being intercepted for the specified window.\n",
        "body": "${1:bool} = JS_WindowMessage_ListIntercepts(${2:void* windowHWND},${3:char* listOutNeedBig},${4:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_LISTINTERCEPTS_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_ListIntercepts",
        "scope": "lua",
        "description": "Returns a string with a list of all message types currently being intercepted for the specified window.\n",
        "body": "${1:local }${2:boolean retval},${3:string list} = reaper.JS_WindowMessage_ListIntercepts(${4:identifier windowHWND})$0"
    },
    "JS_WINDOWMESSAGE_LISTINTERCEPTS_WR python": {
        "prefix": "WR_JS_WindowMessage_ListIntercepts",
        "scope": "python",
        "description": "Returns a string with a list of all message types currently being intercepted for the specified window.\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:String listOutNeedBig},${4:Int listOutNeedBig_sz} = JS_WindowMessage_ListIntercepts(${5:windowHWND},${6:listOutNeedBig},${7:listOutNeedBig_sz})$0"
    },
    "JS_WINDOWMESSAGE_PASSTHROUGH_WR c": {
        "prefix": "WR_JS_WindowMessage_PassThrough",
        "scope": "c",
        "description": "Changes the passthrough setting of a message type that is already being intercepted.\nReturns 1 if successful, 0 if the message type is not yet being intercepted, or -2 if the argument could not be parsed.\n",
        "body": "${1:int} = JS_WindowMessage_PassThrough(${2:void* windowHWND},${3:const char* message},${4:bool passThrough})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_PASSTHROUGH_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_PassThrough",
        "scope": "lua",
        "description": "Changes the passthrough setting of a message type that is already being intercepted.\nReturns 1 if successful, 0 if the message type is not yet being intercepted, or -2 if the argument could not be parsed.\n",
        "body": "${1:local }${2:integer} = reaper.JS_WindowMessage_PassThrough(${3:identifier windowHWND},${4:string message},${5:boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_PASSTHROUGH_WR python": {
        "prefix": "WR_JS_WindowMessage_PassThrough",
        "scope": "python",
        "description": "Changes the passthrough setting of a message type that is already being intercepted.\nReturns 1 if successful, 0 if the message type is not yet being intercepted, or -2 if the argument could not be parsed.\n",
        "body": "${1:Int} = JS_WindowMessage_PassThrough(${2:void windowHWND},${3:String message},${4:Boolean passThrough})$0"
    },
    "JS_WINDOWMESSAGE_PEEK_WR c": {
        "prefix": "WR_JS_WindowMessage_Peek",
        "scope": "c",
        "description": "Polls the state of an intercepted message.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\nReturns:\n* A retval of false indicates that the message type is not being intercepted in the specified window.\n* All messages are timestamped. A time of 0 indicates that no message if this type has been intercepted yet.\n* For more information about wParam and lParam for different message types, refer to Win32 C++ documentation.\n* For example, in the case of mousewheel, returns mousewheel delta, modifier keys, x position and y position.\n* wParamHigh, lParamLow and lParamHigh are signed, whereas wParamLow is unsigned.\n",
        "body": "${1:bool} = JS_WindowMessage_Peek(${2:void* windowHWND},${3:const char* message},${4:bool* passedThroughOut},${5:double* timeOut},${6:int* wParamLowOut},${7:int* wParamHighOut},${8:int* lParamLowOut},${9:int* lParamHighOut})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_PEEK_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_Peek",
        "scope": "lua",
        "description": "Polls the state of an intercepted message.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\nReturns:\n* A retval of false indicates that the message type is not being intercepted in the specified window.\n* All messages are timestamped. A time of 0 indicates that no message if this type has been intercepted yet.\n* For more information about wParam and lParam for different message types, refer to Win32 C++ documentation.\n* For example, in the case of mousewheel, returns mousewheel delta, modifier keys, x position and y position.\n* wParamHigh, lParamLow and lParamHigh are signed, whereas wParamLow is unsigned.\n",
        "body": "${1:local }${2:boolean retval},${3:boolean passedThrough},${4:number time},${5:number wParamLow},${6:number wParamHigh},${7:number lParamLow},${8:number lParamHigh} = reaper.JS_WindowMessage_Peek(${9:identifier windowHWND},${10:string message})$0"
    },
    "JS_WINDOWMESSAGE_PEEK_WR python": {
        "prefix": "WR_JS_WindowMessage_Peek",
        "scope": "python",
        "description": "Polls the state of an intercepted message.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\nReturns:\n* A retval of false indicates that the message type is not being intercepted in the specified window.\n* All messages are timestamped. A time of 0 indicates that no message if this type has been intercepted yet.\n* For more information about wParam and lParam for different message types, refer to Win32 C++ documentation.\n* For example, in the case of mousewheel, returns mousewheel delta, modifier keys, x position and y position.\n* wParamHigh, lParamLow and lParamHigh are signed, whereas wParamLow is unsigned.\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:String message},${4:Boolean passedThroughOut},${5:Float timeOut},${6:Int wParamLowOut},${7:Int wParamHighOut},${8:Int lParamLowOut},${9:Int lParamHighOut} = JS_WindowMessage_Peek(${10:windowHWND},${11:message},${12:passedThroughOut},${13:timeOut},${14:wParamLowOut},${15:wParamHighOut},${16:lParamLowOut},${17:lParamHighOut})$0"
    },
    "JS_WINDOWMESSAGE_POST_WR c": {
        "prefix": "WR_JS_WindowMessage_Post",
        "scope": "c",
        "description": "If the specified window and message type are not currently being\nintercepted by a script, this function will post the message in the\nmessage queue of the specified window, and return without waiting.\nIf the window and message type are currently being intercepted, the\nmessage will be sent directly to the original window process, similar to\nWindowMessage_Send, thereby skipping any intercepts.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter values, refer to documentation for the Win32 C++ function PostMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "${1:bool} = JS_WindowMessage_Post(${2:void* windowHWND},${3:const char* message},${4:double wParam},${5:int wParamHighWord},${6:double lParam},${7:int lParamHighWord})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_POST_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_Post",
        "scope": "lua",
        "description": "If the specified window and message type are not currently being\nintercepted by a script, this function will post the message in the\nmessage queue of the specified window, and return without waiting.\nIf the window and message type are currently being intercepted, the\nmessage will be sent directly to the original window process, similar to\nWindowMessage_Send, thereby skipping any intercepts.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter values, refer to documentation for the Win32 C++ function PostMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_WindowMessage_Post(${3:identifier windowHWND},${4:string message},${5:number wParam},${6:integer wParamHighWord},${7:number lParam},${8:integer lParamHighWord})$0"
    },
    "JS_WINDOWMESSAGE_POST_WR python": {
        "prefix": "WR_JS_WindowMessage_Post",
        "scope": "python",
        "description": "If the specified window and message type are not currently being\nintercepted by a script, this function will post the message in the\nmessage queue of the specified window, and return without waiting.\nIf the window and message type are currently being intercepted, the\nmessage will be sent directly to the original window process, similar to\nWindowMessage_Send, thereby skipping any intercepts.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter values, refer to documentation for the Win32 C++ function PostMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "${1:Boolean} = JS_WindowMessage_Post(${2:void windowHWND},${3:String message},${4:Float wParam},${5:Int wParamHighWord},${6:Float lParam},${7:Int lParamHighWord})$0"
    },
    "JS_WINDOWMESSAGE_RELEASE_WR c": {
        "prefix": "WR_JS_WindowMessage_Release",
        "scope": "c",
        "description": "Release intercepts of specified message types.\nParameters:\n* messages: \"WM_SETCURSOR,WM_MOUSEHWHEEL\" or \"0x0020,0x020E\", for example.\n",
        "body": "${1:int} = JS_WindowMessage_Release(${2:void* windowHWND},${3:const char* messages})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_RELEASE_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_Release",
        "scope": "lua",
        "description": "Release intercepts of specified message types.\nParameters:\n* messages: \"WM_SETCURSOR,WM_MOUSEHWHEEL\" or \"0x0020,0x020E\", for example.\n",
        "body": "${1:local }${2:integer} = reaper.JS_WindowMessage_Release(${3:identifier windowHWND},${4:string messages})$0"
    },
    "JS_WINDOWMESSAGE_RELEASE_WR python": {
        "prefix": "WR_JS_WindowMessage_Release",
        "scope": "python",
        "description": "Release intercepts of specified message types.\nParameters:\n* messages: \"WM_SETCURSOR,WM_MOUSEHWHEEL\" or \"0x0020,0x020E\", for example.\n",
        "body": "${1:Int} = JS_WindowMessage_Release(${2:void windowHWND},${3:String messages})$0"
    },
    "JS_WINDOWMESSAGE_RELEASEALL_WR c": {
        "prefix": "WR_JS_WindowMessage_ReleaseAll",
        "scope": "c",
        "description": "Release script intercepts of window messages for all windows.\n",
        "body": "${1:void} = JS_WindowMessage_ReleaseAll()$0"
    },
    "JS_WINDOWMESSAGE_RELEASEWINDOW_WR c": {
        "prefix": "WR_JS_WindowMessage_ReleaseWindow",
        "scope": "c",
        "description": "Release script intercepts of window messages for specified window.\n",
        "body": "${1:void} = JS_WindowMessage_ReleaseWindow(${2:void* windowHWND})$0"
    },
    "JS_WINDOWMESSAGE_SEND_WR c": {
        "prefix": "WR_JS_WindowMessage_Send",
        "scope": "c",
        "description": "Sends a message to the specified window by calling the window process\ndirectly, and only returns after the message has been processed. Any\nintercepts of the message by scripts will be skipped, and the message\ncan therefore not be blocked.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter and return values, refer to documentation for the Win32 C++ function SendMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "${1:int} = JS_WindowMessage_Send(${2:void* windowHWND},${3:const char* message},${4:double wParam},${5:int wParamHighWord},${6:double lParam},${7:int lParamHighWord})$0"
    },
    "REAPER.JS_WINDOWMESSAGE_SEND_WR lua": {
        "prefix": "reaperwr.JS_WindowMessage_Send",
        "scope": "lua",
        "description": "Sends a message to the specified window by calling the window process\ndirectly, and only returns after the message has been processed. Any\nintercepts of the message by scripts will be skipped, and the message\ncan therefore not be blocked.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter and return values, refer to documentation for the Win32 C++ function SendMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "${1:local }${2:integer} = reaper.JS_WindowMessage_Send(${3:identifier windowHWND},${4:string message},${5:number wParam},${6:integer wParamHighWord},${7:number lParam},${8:integer lParamHighWord})$0"
    },
    "JS_WINDOWMESSAGE_SEND_WR python": {
        "prefix": "WR_JS_WindowMessage_Send",
        "scope": "python",
        "description": "Sends a message to the specified window by calling the window process\ndirectly, and only returns after the message has been processed. Any\nintercepts of the message by scripts will be skipped, and the message\ncan therefore not be blocked.\nParameters:\n* message: String containing a single message name, such as \"WM_SETCURSOR\", or in hexadecimal format, \"0x0020\".\n(For a list of WM_ and CB_ message types that are valid cross-platform,\nrefer to swell-types.h. Only these will be recognized by WM_ or CB_\nname.)\n* wParam, wParamHigh, lParam and lParamHigh: Low and high 16-bit WORDs of the WPARAM and LPARAM parameters.\n(Most window messages encode separate information into the two WORDs.\nHowever, for those rare cases in which the entire WPARAM and LPARAM must\nbe used to post a large pointer, the script can store this address in\nwParam or lParam, and keep wParamHigh and lParamHigh zero.)\nNotes:\n* For more information about parameter and return values, refer to documentation for the Win32 C++ function SendMessage.\n* Messages should only be sent to windows that were created from the main thread.\n* Useful for simulating mouse clicks and calling mouse modifier actions from scripts.\n",
        "body": "${1:Int} = JS_WindowMessage_Send(${2:void windowHWND},${3:String message},${4:Float wParam},${5:Int wParamHighWord},${6:Float lParam},${7:Int lParamHighWord})$0"
    },
    "JS_WINDOW_ADDRESSFROMHANDLE_WR c": {
        "prefix": "WR_JS_Window_AddressFromHandle",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_Window_AddressFromHandle(${2:void* handle},${3:double* addressOut})$0"
    },
    "REAPER.JS_WINDOW_ADDRESSFROMHANDLE_WR lua": {
        "prefix": "reaperwr.JS_Window_AddressFromHandle",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:number address} = reaper.JS_Window_AddressFromHandle(${3:identifier handle})$0"
    },
    "JS_WINDOW_ADDRESSFROMHANDLE_WR python": {
        "prefix": "WR_JS_Window_AddressFromHandle",
        "scope": "python",
        "description": "\n",
        "body": "${1:void handle},${2:Float addressOut} = JS_Window_AddressFromHandle(${3:handle},${4:addressOut})$0"
    },
    "JS_WINDOW_ARRAYALLCHILD_WR c": {
        "prefix": "WR_JS_Window_ArrayAllChild",
        "scope": "c",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "${1:int} = JS_Window_ArrayAllChild(${2:void* parentHWND},${3:void* reaperarray})$0"
    },
    "REAPER.JS_WINDOW_ARRAYALLCHILD_WR lua": {
        "prefix": "reaperwr.JS_Window_ArrayAllChild",
        "scope": "lua",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "${1:local }${2:integer} = reaper.JS_Window_ArrayAllChild(${3:identifier parentHWND},${4:identifier reaperarray})$0"
    },
    "JS_WINDOW_ARRAYALLCHILD_WR python": {
        "prefix": "WR_JS_Window_ArrayAllChild",
        "scope": "python",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "${1:Int} = JS_Window_ArrayAllChild(${2:void parentHWND},${3:void reaperarray})$0"
    },
    "JS_WINDOW_ARRAYALLTOP_WR c": {
        "prefix": "WR_JS_Window_ArrayAllTop",
        "scope": "c",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "${1:int} = JS_Window_ArrayAllTop(${2:void* reaperarray})$0"
    },
    "REAPER.JS_WINDOW_ARRAYALLTOP_WR lua": {
        "prefix": "reaperwr.JS_Window_ArrayAllTop",
        "scope": "lua",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "${1:local }${2:integer} = reaper.JS_Window_ArrayAllTop(${3:identifier reaperarray})$0"
    },
    "JS_WINDOW_ARRAYALLTOP_WR python": {
        "prefix": "WR_JS_Window_ArrayAllTop",
        "scope": "python",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\n",
        "body": "${1:Int} = JS_Window_ArrayAllTop(${2:void reaperarray})$0"
    },
    "JS_WINDOW_ARRAYFIND_WR c": {
        "prefix": "WR_JS_Window_ArrayFind",
        "scope": "c",
        "description": "Finds all windows, whether top-level or child, whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "${1:int} = JS_Window_ArrayFind(${2:const char* title},${3:bool exact},${4:void* reaperarray})$0"
    },
    "REAPER.JS_WINDOW_ARRAYFIND_WR lua": {
        "prefix": "reaperwr.JS_Window_ArrayFind",
        "scope": "lua",
        "description": "Finds all windows, whether top-level or child, whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "${1:local }${2:integer} = reaper.JS_Window_ArrayFind(${3:string title},${4:boolean exact},${5:identifier reaperarray})$0"
    },
    "JS_WINDOW_ARRAYFIND_WR python": {
        "prefix": "WR_JS_Window_ArrayFind",
        "scope": "python",
        "description": "Finds all windows, whether top-level or child, whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* The addresses are stored in the provided reaper.array, and can be\nconverted to REAPER objects (HWNDs) by the function\nJS_Window_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "${1:Int} = JS_Window_ArrayFind(${2:String title},${3:Boolean exact},${4:void reaperarray})$0"
    },
    "JS_WINDOW_ATTACHRESIZEGRIP_WR c": {
        "prefix": "WR_JS_Window_AttachResizeGrip",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = JS_Window_AttachResizeGrip(${2:void* windowHWND})$0"
    },
    "JS_WINDOW_ATTACHTOPMOSTPIN_WR c": {
        "prefix": "WR_JS_Window_AttachTopmostPin",
        "scope": "c",
        "description": "Attaches a \"pin on top\" button to the window frame. The button should remember its state when closing and re-opening the window.\nWARNING: This function does not yet work on Linux.\n",
        "body": "${1:void} = JS_Window_AttachTopmostPin(${2:void* windowHWND})$0"
    },
    "JS_WINDOW_CLIENTTOSCREEN_WR c": {
        "prefix": "WR_JS_Window_ClientToScreen",
        "scope": "c",
        "description": "Converts the client-area coordinates of a specified point to screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "${1:void} = JS_Window_ClientToScreen(${2:void* windowHWND},${3:int x},${4:int y},${5:int* xOut},${6:int* yOut})$0"
    },
    "REAPER.JS_WINDOW_CLIENTTOSCREEN_WR lua": {
        "prefix": "reaperwr.JS_Window_ClientToScreen",
        "scope": "lua",
        "description": "Converts the client-area coordinates of a specified point to screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "${1:local }${2:number x},${3:number y} = reaper.JS_Window_ClientToScreen(${4:identifier windowHWND},${5:integer x},${6:integer y})$0"
    },
    "JS_WINDOW_CLIENTTOSCREEN_WR python": {
        "prefix": "WR_JS_Window_ClientToScreen",
        "scope": "python",
        "description": "Converts the client-area coordinates of a specified point to screen coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "${1:void windowHWND},${2:Int x},${3:Int y},${4:Int xOut},${5:Int yOut} = JS_Window_ClientToScreen(${6:windowHWND},${7:x},${8:y},${9:xOut},${10:yOut})$0"
    },
    "JS_WINDOW_CREATE_WR c": {
        "prefix": "WR_JS_Window_Create",
        "scope": "c",
        "description": "Creates a modeless window with WS_OVERLAPPEDWINDOW style and only\nrudimentary features. Scripts can paint into the window using GDI or\nLICE/Composite functions (and JS_Window_InvalidateRect to trigger\nre-painting).\nstyle: An optional parameter that overrides the default style. The\nstring may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implemented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\nclassName: On Windows, only standard ANSI characters are supported.\nownerHWND: Optional parameter, only available on WindowsOS.  Usually\neither the REAPER main window or another script window, and useful for\nensuring that the created window automatically closes when the owner is\nclosed.\nNOTE: On Linux and macOS, the window contents are only updated *between*\ndefer cycles, so the window cannot be animated by for/while loops\nwithin a single defer cycle.\n",
        "body": "${1:void*} = JS_Window_Create(${2:const char* title},${3:const char* className},${4:int x},${5:int y},${6:int w},${7:int h},${8:char* styleOptional},${9:void* ownerHWNDOptional})$0"
    },
    "REAPER.JS_WINDOW_CREATE_WR lua": {
        "prefix": "reaperwr.JS_Window_Create",
        "scope": "lua",
        "description": "Creates a modeless window with WS_OVERLAPPEDWINDOW style and only\nrudimentary features. Scripts can paint into the window using GDI or\nLICE/Composite functions (and JS_Window_InvalidateRect to trigger\nre-painting).\nstyle: An optional parameter that overrides the default style. The\nstring may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implemented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\nclassName: On Windows, only standard ANSI characters are supported.\nownerHWND: Optional parameter, only available on WindowsOS.  Usually\neither the REAPER main window or another script window, and useful for\nensuring that the created window automatically closes when the owner is\nclosed.\nNOTE: On Linux and macOS, the window contents are only updated *between*\ndefer cycles, so the window cannot be animated by for/while loops\nwithin a single defer cycle.\n",
        "body": "${1:local }${2:identifier retval},${3:optional string style} = reaper.JS_Window_Create(${4:string title},${5:string className},${6:integer x},${7:integer y},${8:integer w},${9:integer h},${10:optional string style},${11:identifier ownerHWND})$0"
    },
    "JS_WINDOW_CREATE_WR python": {
        "prefix": "WR_JS_Window_Create",
        "scope": "python",
        "description": "Creates a modeless window with WS_OVERLAPPEDWINDOW style and only\nrudimentary features. Scripts can paint into the window using GDI or\nLICE/Composite functions (and JS_Window_InvalidateRect to trigger\nre-painting).\nstyle: An optional parameter that overrides the default style. The\nstring may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implemented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\nclassName: On Windows, only standard ANSI characters are supported.\nownerHWND: Optional parameter, only available on WindowsOS.  Usually\neither the REAPER main window or another script window, and useful for\nensuring that the created window automatically closes when the owner is\nclosed.\nNOTE: On Linux and macOS, the window contents are only updated *between*\ndefer cycles, so the window cannot be animated by for/while loops\nwithin a single defer cycle.\n",
        "body": "${1:void retval},${2:String title},${3:String className},${4:Int x},${5:Int y},${6:Int w},${7:Int h},${8:String styleOptional},${9:void ownerHWNDOptional} = JS_Window_Create(${10:title},${11:className},${12:x},${13:y},${14:w},${15:h},${16:styleOptional},${17:ownerHWNDOptional})$0"
    },
    "JS_WINDOW_DESTROY_WR c": {
        "prefix": "WR_JS_Window_Destroy",
        "scope": "c",
        "description": "Destroys the specified window.\n",
        "body": "${1:void} = JS_Window_Destroy(${2:void* windowHWND})$0"
    },
    "JS_WINDOW_ENABLE_WR c": {
        "prefix": "WR_JS_Window_Enable",
        "scope": "c",
        "description": "Enables or disables mouse and keyboard input to the specified window or control.\n",
        "body": "${1:void} = JS_Window_Enable(${2:void* windowHWND},${3:bool enable})$0"
    },
    "JS_WINDOW_ENABLEMETAL_WR c": {
        "prefix": "WR_JS_Window_EnableMetal",
        "scope": "c",
        "description": "On macOS, returns the Metal graphics setting:\n2 = Metal enabled and support GetDC()/ReleaseDC() for drawing (more overhead).\n1 = Metal enabled.\n0 = N/A (Windows and Linux).\n-1 = non-metal async layered mode.\n-2 = non-metal non-async layered mode.\nWARNING: If using mode -1, any BitBlt()/StretchBlt() MUST have the\nsource bitmap persist. If it is resized after Blit it could cause\ncrashes.\n",
        "body": "${1:int} = JS_Window_EnableMetal(${2:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ENABLEMETAL_WR lua": {
        "prefix": "reaperwr.JS_Window_EnableMetal",
        "scope": "lua",
        "description": "On macOS, returns the Metal graphics setting:\n2 = Metal enabled and support GetDC()/ReleaseDC() for drawing (more overhead).\n1 = Metal enabled.\n0 = N/A (Windows and Linux).\n-1 = non-metal async layered mode.\n-2 = non-metal non-async layered mode.\nWARNING: If using mode -1, any BitBlt()/StretchBlt() MUST have the\nsource bitmap persist. If it is resized after Blit it could cause\ncrashes.\n",
        "body": "${1:local }${2:integer} = reaper.JS_Window_EnableMetal(${3:identifier windowHWND})$0"
    },
    "JS_WINDOW_ENABLEMETAL_WR python": {
        "prefix": "WR_JS_Window_EnableMetal",
        "scope": "python",
        "description": "On macOS, returns the Metal graphics setting:\n2 = Metal enabled and support GetDC()/ReleaseDC() for drawing (more overhead).\n1 = Metal enabled.\n0 = N/A (Windows and Linux).\n-1 = non-metal async layered mode.\n-2 = non-metal non-async layered mode.\nWARNING: If using mode -1, any BitBlt()/StretchBlt() MUST have the\nsource bitmap persist. If it is resized after Blit it could cause\ncrashes.\n",
        "body": "${1:Int} = JS_Window_EnableMetal(${2:void windowHWND})$0"
    },
    "JS_WINDOW_FIND_WR c": {
        "prefix": "WR_JS_Window_Find",
        "scope": "c",
        "description": "Returns a HWND to a window whose title matches the specified string.\n* Unlike the Win32 function FindWindow, this function searches\ntop-level as well as child windows, so that the target window can be\nfound irrespective of docked state.\n* In addition, the function can optionally match substrings of the title.\n* Matching is not case sensitive.\nParameters:\n* exact: Match entire title, or match substring of title.\n",
        "body": "${1:void*} = JS_Window_Find(${2:const char* title},${3:bool exact})$0"
    },
    "REAPER.JS_WINDOW_FIND_WR lua": {
        "prefix": "reaperwr.JS_Window_Find",
        "scope": "lua",
        "description": "Returns a HWND to a window whose title matches the specified string.\n* Unlike the Win32 function FindWindow, this function searches\ntop-level as well as child windows, so that the target window can be\nfound irrespective of docked state.\n* In addition, the function can optionally match substrings of the title.\n* Matching is not case sensitive.\nParameters:\n* exact: Match entire title, or match substring of title.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_Find(${3:string title},${4:boolean exact})$0"
    },
    "JS_WINDOW_FIND_WR python": {
        "prefix": "WR_JS_Window_Find",
        "scope": "python",
        "description": "Returns a HWND to a window whose title matches the specified string.\n* Unlike the Win32 function FindWindow, this function searches\ntop-level as well as child windows, so that the target window can be\nfound irrespective of docked state.\n* In addition, the function can optionally match substrings of the title.\n* Matching is not case sensitive.\nParameters:\n* exact: Match entire title, or match substring of title.\n",
        "body": "${1:void} = JS_Window_Find(${2:String title},${3:Boolean exact})$0"
    },
    "JS_WINDOW_FINDCHILD_WR c": {
        "prefix": "WR_JS_Window_FindChild",
        "scope": "c",
        "description": "Returns a HWND to a child window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "${1:void*} = JS_Window_FindChild(${2:void* parentHWND},${3:const char* title},${4:bool exact})$0"
    },
    "REAPER.JS_WINDOW_FINDCHILD_WR lua": {
        "prefix": "reaperwr.JS_Window_FindChild",
        "scope": "lua",
        "description": "Returns a HWND to a child window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_FindChild(${3:identifier parentHWND},${4:string title},${5:boolean exact})$0"
    },
    "JS_WINDOW_FINDCHILD_WR python": {
        "prefix": "WR_JS_Window_FindChild",
        "scope": "python",
        "description": "Returns a HWND to a child window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "${1:void} = JS_Window_FindChild(${2:void parentHWND},${3:String title},${4:Boolean exact})$0"
    },
    "JS_WINDOW_FINDCHILDBYID_WR c": {
        "prefix": "WR_JS_Window_FindChildByID",
        "scope": "c",
        "description": "Similar to the C++ WIN32 function GetDlgItem, this function finds child windows by ID.\n(The ID of a window may be retrieved by JS_Window_GetLongPtr.)\n",
        "body": "${1:void*} = JS_Window_FindChildByID(${2:void* parentHWND},${3:int ID})$0"
    },
    "REAPER.JS_WINDOW_FINDCHILDBYID_WR lua": {
        "prefix": "reaperwr.JS_Window_FindChildByID",
        "scope": "lua",
        "description": "Similar to the C++ WIN32 function GetDlgItem, this function finds child windows by ID.\n(The ID of a window may be retrieved by JS_Window_GetLongPtr.)\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_FindChildByID(${3:identifier parentHWND},${4:integer ID})$0"
    },
    "JS_WINDOW_FINDCHILDBYID_WR python": {
        "prefix": "WR_JS_Window_FindChildByID",
        "scope": "python",
        "description": "Similar to the C++ WIN32 function GetDlgItem, this function finds child windows by ID.\n(The ID of a window may be retrieved by JS_Window_GetLongPtr.)\n",
        "body": "${1:void} = JS_Window_FindChildByID(${2:void parentHWND},${3:Int ID})$0"
    },
    "JS_WINDOW_FINDEX_WR c": {
        "prefix": "WR_JS_Window_FindEx",
        "scope": "c",
        "description": "Returns a handle to a child window whose class and title match the specified strings.\nParameters: * childWindow: The function searches child windows,\nbeginning with the window *after* the specified child window. If\nchildHWND is equal to parentHWND, the search begins with the first child\nwindow of parentHWND.\n* title: An empty string, \"\", will match all windows. (Search is not case sensitive.)\n",
        "body": "${1:void*} = JS_Window_FindEx(${2:void* parentHWND},${3:void* childHWND},${4:const char* className},${5:const char* title})$0"
    },
    "REAPER.JS_WINDOW_FINDEX_WR lua": {
        "prefix": "reaperwr.JS_Window_FindEx",
        "scope": "lua",
        "description": "Returns a handle to a child window whose class and title match the specified strings.\nParameters: * childWindow: The function searches child windows,\nbeginning with the window *after* the specified child window. If\nchildHWND is equal to parentHWND, the search begins with the first child\nwindow of parentHWND.\n* title: An empty string, \"\", will match all windows. (Search is not case sensitive.)\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_FindEx(${3:identifier parentHWND},${4:identifier childHWND},${5:string className},${6:string title})$0"
    },
    "JS_WINDOW_FINDEX_WR python": {
        "prefix": "WR_JS_Window_FindEx",
        "scope": "python",
        "description": "Returns a handle to a child window whose class and title match the specified strings.\nParameters: * childWindow: The function searches child windows,\nbeginning with the window *after* the specified child window. If\nchildHWND is equal to parentHWND, the search begins with the first child\nwindow of parentHWND.\n* title: An empty string, \"\", will match all windows. (Search is not case sensitive.)\n",
        "body": "${1:void} = JS_Window_FindEx(${2:void parentHWND},${3:void childHWND},${4:String className},${5:String title})$0"
    },
    "JS_WINDOW_FINDTOP_WR c": {
        "prefix": "WR_JS_Window_FindTop",
        "scope": "c",
        "description": "Returns a HWND to a top-level window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "${1:void*} = JS_Window_FindTop(${2:const char* title},${3:bool exact})$0"
    },
    "REAPER.JS_WINDOW_FINDTOP_WR lua": {
        "prefix": "reaperwr.JS_Window_FindTop",
        "scope": "lua",
        "description": "Returns a HWND to a top-level window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_FindTop(${3:string title},${4:boolean exact})$0"
    },
    "JS_WINDOW_FINDTOP_WR python": {
        "prefix": "WR_JS_Window_FindTop",
        "scope": "python",
        "description": "Returns a HWND to a top-level window whose title matches the specified string.\nParameters:\n* exact: Match entire title length, or match substring of title. In both cases, matching is not case sensitive.\n",
        "body": "${1:void} = JS_Window_FindTop(${2:String title},${3:Boolean exact})$0"
    },
    "JS_WINDOW_FROMPOINT_WR c": {
        "prefix": "WR_JS_Window_FromPoint",
        "scope": "c",
        "description": "Retrieves a HWND to the window that contains the specified point.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:void*} = JS_Window_FromPoint(${2:int x},${3:int y})$0"
    },
    "REAPER.JS_WINDOW_FROMPOINT_WR lua": {
        "prefix": "reaperwr.JS_Window_FromPoint",
        "scope": "lua",
        "description": "Retrieves a HWND to the window that contains the specified point.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_FromPoint(${3:integer x},${4:integer y})$0"
    },
    "JS_WINDOW_FROMPOINT_WR python": {
        "prefix": "WR_JS_Window_FromPoint",
        "scope": "python",
        "description": "Retrieves a HWND to the window that contains the specified point.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:void} = JS_Window_FromPoint(${2:Int x},${3:Int y})$0"
    },
    "JS_WINDOW_GETCLASSNAME_WR c": {
        "prefix": "WR_JS_Window_GetClassName",
        "scope": "c",
        "description": "WARNING: May not be fully implemented on macOS and Linux.\n",
        "body": "${1:void} = JS_Window_GetClassName(${2:void* windowHWND},${3:char* classOut},${4:int classOut_sz})$0"
    },
    "REAPER.JS_WINDOW_GETCLASSNAME_WR lua": {
        "prefix": "reaperwr.JS_Window_GetClassName",
        "scope": "lua",
        "description": "WARNING: May not be fully implemented on macOS and Linux.\n",
        "body": "${1:local }${2:string class} = reaper.JS_Window_GetClassName(${3:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETCLASSNAME_WR python": {
        "prefix": "WR_JS_Window_GetClassName",
        "scope": "python",
        "description": "WARNING: May not be fully implemented on macOS and Linux.\n",
        "body": "${1:void windowHWND},${2:String classOut},${3:Int classOut_sz} = JS_Window_GetClassName(${4:windowHWND},${5:classOut},${6:classOut_sz})$0"
    },
    "JS_WINDOW_GETCLIENTRECT_WR c": {
        "prefix": "WR_JS_Window_GetClientRect",
        "scope": "c",
        "description": "Retrieves the screen coordinates of the client area rectangle of the specified window.\nNOTES:\n* Unlike the C++ function GetClientRect, this function returns the\nscreen coordinates, not the width and height. To get the client size,\nuse GetClientSize.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:bool} = JS_Window_GetClientRect(${2:void* windowHWND},${3:int* leftOut},${4:int* topOut},${5:int* rightOut},${6:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_GETCLIENTRECT_WR lua": {
        "prefix": "reaperwr.JS_Window_GetClientRect",
        "scope": "lua",
        "description": "Retrieves the screen coordinates of the client area rectangle of the specified window.\nNOTES:\n* Unlike the C++ function GetClientRect, this function returns the\nscreen coordinates, not the width and height. To get the client size,\nuse GetClientSize.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:local }${2:boolean retval},${3:number left},${4:number top},${5:number right},${6:number bottom} = reaper.JS_Window_GetClientRect(${7:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETCLIENTRECT_WR python": {
        "prefix": "WR_JS_Window_GetClientRect",
        "scope": "python",
        "description": "Retrieves the screen coordinates of the client area rectangle of the specified window.\nNOTES:\n* Unlike the C++ function GetClientRect, this function returns the\nscreen coordinates, not the width and height. To get the client size,\nuse GetClientSize.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:Int leftOut},${4:Int topOut},${5:Int rightOut},${6:Int bottomOut} = JS_Window_GetClientRect(${7:windowHWND},${8:leftOut},${9:topOut},${10:rightOut},${11:bottomOut})$0"
    },
    "JS_WINDOW_GETCLIENTSIZE_WR c": {
        "prefix": "WR_JS_Window_GetClientSize",
        "scope": "c",
        "description": "\n",
        "body": "${1:bool} = JS_Window_GetClientSize(${2:void* windowHWND},${3:int* widthOut},${4:int* heightOut})$0"
    },
    "REAPER.JS_WINDOW_GETCLIENTSIZE_WR lua": {
        "prefix": "reaperwr.JS_Window_GetClientSize",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:boolean retval},${3:number width},${4:number height} = reaper.JS_Window_GetClientSize(${5:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETCLIENTSIZE_WR python": {
        "prefix": "WR_JS_Window_GetClientSize",
        "scope": "python",
        "description": "\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:Int widthOut},${4:Int heightOut} = JS_Window_GetClientSize(${5:windowHWND},${6:widthOut},${7:heightOut})$0"
    },
    "JS_WINDOW_GETFOCUS_WR c": {
        "prefix": "WR_JS_Window_GetFocus",
        "scope": "c",
        "description": "Retrieves a HWND to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.\n",
        "body": "${1:void*} = JS_Window_GetFocus()$0"
    },
    "REAPER.JS_WINDOW_GETFOCUS_WR lua": {
        "prefix": "reaperwr.JS_Window_GetFocus",
        "scope": "lua",
        "description": "Retrieves a HWND to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_GetFocus()$0"
    },
    "JS_WINDOW_GETFOCUS_WR python": {
        "prefix": "WR_JS_Window_GetFocus",
        "scope": "python",
        "description": "Retrieves a HWND to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.\n",
        "body": "${1:void} = JS_Window_GetFocus()$0"
    },
    "JS_WINDOW_GETFOREGROUND_WR c": {
        "prefix": "WR_JS_Window_GetForeground",
        "scope": "c",
        "description": "Retrieves a HWND to the top-level foreground window (the window with which the user is currently working).\n",
        "body": "${1:void*} = JS_Window_GetForeground()$0"
    },
    "REAPER.JS_WINDOW_GETFOREGROUND_WR lua": {
        "prefix": "reaperwr.JS_Window_GetForeground",
        "scope": "lua",
        "description": "Retrieves a HWND to the top-level foreground window (the window with which the user is currently working).\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_GetForeground()$0"
    },
    "JS_WINDOW_GETFOREGROUND_WR python": {
        "prefix": "WR_JS_Window_GetForeground",
        "scope": "python",
        "description": "Retrieves a HWND to the top-level foreground window (the window with which the user is currently working).\n",
        "body": "${1:void} = JS_Window_GetForeground()$0"
    },
    "JS_WINDOW_GETLONG_WR c": {
        "prefix": "WR_JS_Window_GetLong",
        "scope": "c",
        "description": "Similar to JS_Window_GetLongPtr, but returns the information as a number instead of a pointer.\nIn the case of \"DLGPROC\" and \"WINPROC\", the return values can be converted to pointers by JS_Window_HandleFromAddress.\nIf the function fails, the return value is 0.\n",
        "body": "${1:void} = JS_Window_GetLong(${2:void* windowHWND},${3:const char* info},${4:double* retvalOut})$0"
    },
    "REAPER.JS_WINDOW_GETLONG_WR lua": {
        "prefix": "reaperwr.JS_Window_GetLong",
        "scope": "lua",
        "description": "Similar to JS_Window_GetLongPtr, but returns the information as a number instead of a pointer.\nIn the case of \"DLGPROC\" and \"WINPROC\", the return values can be converted to pointers by JS_Window_HandleFromAddress.\nIf the function fails, the return value is 0.\n",
        "body": "${1:local }${2:number retval} = reaper.JS_Window_GetLong(${3:identifier windowHWND},${4:string info})$0"
    },
    "JS_WINDOW_GETLONG_WR python": {
        "prefix": "WR_JS_Window_GetLong",
        "scope": "python",
        "description": "Similar to JS_Window_GetLongPtr, but returns the information as a number instead of a pointer.\nIn the case of \"DLGPROC\" and \"WINPROC\", the return values can be converted to pointers by JS_Window_HandleFromAddress.\nIf the function fails, the return value is 0.\n",
        "body": "${1:void windowHWND},${2:String info},${3:Float retvalOut} = JS_Window_GetLong(${4:windowHWND},${5:info},${6:retvalOut})$0"
    },
    "JS_WINDOW_GETLONGPTR_WR c": {
        "prefix": "WR_JS_Window_GetLongPtr",
        "scope": "c",
        "description": "Returns information about the specified window.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\".\nFor documentation about the types of information returned, refer to the Win32 function GetWindowLongPtr.\nThe values returned by \"DLGPROC\" and \"WINPROC\" are typically used as-is,\nas pointers, whereas the others should first be converted to integers.\nIf the function fails, a null pointer is returned.\n",
        "body": "${1:void*} = JS_Window_GetLongPtr(${2:void* windowHWND},${3:const char* info})$0"
    },
    "REAPER.JS_WINDOW_GETLONGPTR_WR lua": {
        "prefix": "reaperwr.JS_Window_GetLongPtr",
        "scope": "lua",
        "description": "Returns information about the specified window.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\".\nFor documentation about the types of information returned, refer to the Win32 function GetWindowLongPtr.\nThe values returned by \"DLGPROC\" and \"WINPROC\" are typically used as-is,\nas pointers, whereas the others should first be converted to integers.\nIf the function fails, a null pointer is returned.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_GetLongPtr(${3:identifier windowHWND},${4:string info})$0"
    },
    "JS_WINDOW_GETLONGPTR_WR python": {
        "prefix": "WR_JS_Window_GetLongPtr",
        "scope": "python",
        "description": "Returns information about the specified window.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\".\nFor documentation about the types of information returned, refer to the Win32 function GetWindowLongPtr.\nThe values returned by \"DLGPROC\" and \"WINPROC\" are typically used as-is,\nas pointers, whereas the others should first be converted to integers.\nIf the function fails, a null pointer is returned.\n",
        "body": "${1:void} = JS_Window_GetLongPtr(${2:void windowHWND},${3:String info})$0"
    },
    "JS_WINDOW_GETPARENT_WR c": {
        "prefix": "WR_JS_Window_GetParent",
        "scope": "c",
        "description": "Retrieves a HWND to the specified window's parent or owner.\nReturns NULL if the window is unowned or if the function otherwise fails.\n",
        "body": "${1:void*} = JS_Window_GetParent(${2:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_GETPARENT_WR lua": {
        "prefix": "reaperwr.JS_Window_GetParent",
        "scope": "lua",
        "description": "Retrieves a HWND to the specified window's parent or owner.\nReturns NULL if the window is unowned or if the function otherwise fails.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_GetParent(${3:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETPARENT_WR python": {
        "prefix": "WR_JS_Window_GetParent",
        "scope": "python",
        "description": "Retrieves a HWND to the specified window's parent or owner.\nReturns NULL if the window is unowned or if the function otherwise fails.\n",
        "body": "${1:void} = JS_Window_GetParent(${2:void windowHWND})$0"
    },
    "JS_WINDOW_GETRECT_WR c": {
        "prefix": "WR_JS_Window_GetRect",
        "scope": "c",
        "description": "Retrieves the screen coordinates of the bounding rectangle of the specified window.\nNOTES:\n* On Windows and Linux, coordinates are relative to *upper* left corner\nof the primary display, and the positive Y-axis points downward.\n* On macOS, coordinates are relative to the *bottom* left corner of the primary display, and the positive Y-axis points upward.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n",
        "body": "${1:bool} = JS_Window_GetRect(${2:void* windowHWND},${3:int* leftOut},${4:int* topOut},${5:int* rightOut},${6:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_GETRECT_WR lua": {
        "prefix": "reaperwr.JS_Window_GetRect",
        "scope": "lua",
        "description": "Retrieves the screen coordinates of the bounding rectangle of the specified window.\nNOTES:\n* On Windows and Linux, coordinates are relative to *upper* left corner\nof the primary display, and the positive Y-axis points downward.\n* On macOS, coordinates are relative to the *bottom* left corner of the primary display, and the positive Y-axis points upward.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n",
        "body": "${1:local }${2:boolean retval},${3:number left},${4:number top},${5:number right},${6:number bottom} = reaper.JS_Window_GetRect(${7:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETRECT_WR python": {
        "prefix": "WR_JS_Window_GetRect",
        "scope": "python",
        "description": "Retrieves the screen coordinates of the bounding rectangle of the specified window.\nNOTES:\n* On Windows and Linux, coordinates are relative to *upper* left corner\nof the primary display, and the positive Y-axis points downward.\n* On macOS, coordinates are relative to the *bottom* left corner of the primary display, and the positive Y-axis points upward.\n* The pixel at (right, bottom) lies immediately outside the rectangle.\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:Int leftOut},${4:Int topOut},${5:Int rightOut},${6:Int bottomOut} = JS_Window_GetRect(${7:windowHWND},${8:leftOut},${9:topOut},${10:rightOut},${11:bottomOut})$0"
    },
    "JS_WINDOW_GETRELATED_WR c": {
        "prefix": "WR_JS_Window_GetRelated",
        "scope": "c",
        "description": "Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.\nrelation: \"LAST\", \"NEXT\", \"PREV\", \"OWNER\" or \"CHILD\".\n(Refer to documentation for Win32 C++ function GetWindow.)\n",
        "body": "${1:void*} = JS_Window_GetRelated(${2:void* windowHWND},${3:const char* relation})$0"
    },
    "REAPER.JS_WINDOW_GETRELATED_WR lua": {
        "prefix": "reaperwr.JS_Window_GetRelated",
        "scope": "lua",
        "description": "Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.\nrelation: \"LAST\", \"NEXT\", \"PREV\", \"OWNER\" or \"CHILD\".\n(Refer to documentation for Win32 C++ function GetWindow.)\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_GetRelated(${3:identifier windowHWND},${4:string relation})$0"
    },
    "JS_WINDOW_GETRELATED_WR python": {
        "prefix": "WR_JS_Window_GetRelated",
        "scope": "python",
        "description": "Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.\nrelation: \"LAST\", \"NEXT\", \"PREV\", \"OWNER\" or \"CHILD\".\n(Refer to documentation for Win32 C++ function GetWindow.)\n",
        "body": "${1:void} = JS_Window_GetRelated(${2:void windowHWND},${3:String relation})$0"
    },
    "JS_WINDOW_GETSCROLLINFO_WR c": {
        "prefix": "WR_JS_Window_GetScrollInfo",
        "scope": "c",
        "description": "Retrieves the scroll information of a window.\nParameters:\n* windowHWND: The window that contains the scrollbar. This is usually a child window, not a top-level, framed window.\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nReturns:\n* Leftmost or topmost visible pixel position, as well as the visible\npage size, the range minimum and maximum, and scroll box tracking\nposition.\n",
        "body": "${1:bool} = JS_Window_GetScrollInfo(${2:void* windowHWND},${3:const char* scrollbar},${4:int* positionOut},${5:int* pageSizeOut},${6:int* minOut},${7:int* maxOut},${8:int* trackPosOut})$0"
    },
    "REAPER.JS_WINDOW_GETSCROLLINFO_WR lua": {
        "prefix": "reaperwr.JS_Window_GetScrollInfo",
        "scope": "lua",
        "description": "Retrieves the scroll information of a window.\nParameters:\n* windowHWND: The window that contains the scrollbar. This is usually a child window, not a top-level, framed window.\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nReturns:\n* Leftmost or topmost visible pixel position, as well as the visible\npage size, the range minimum and maximum, and scroll box tracking\nposition.\n",
        "body": "${1:local }${2:boolean retval},${3:number position},${4:number pageSize},${5:number min},${6:number max},${7:number trackPos} = reaper.JS_Window_GetScrollInfo(${8:identifier windowHWND},${9:string scrollbar})$0"
    },
    "JS_WINDOW_GETSCROLLINFO_WR python": {
        "prefix": "WR_JS_Window_GetScrollInfo",
        "scope": "python",
        "description": "Retrieves the scroll information of a window.\nParameters:\n* windowHWND: The window that contains the scrollbar. This is usually a child window, not a top-level, framed window.\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nReturns:\n* Leftmost or topmost visible pixel position, as well as the visible\npage size, the range minimum and maximum, and scroll box tracking\nposition.\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:String scrollbar},${4:Int positionOut},${5:Int pageSizeOut},${6:Int minOut},${7:Int maxOut},${8:Int trackPosOut} = JS_Window_GetScrollInfo(${9:windowHWND},${10:scrollbar},${11:positionOut},${12:pageSizeOut},${13:minOut},${14:maxOut},${15:trackPosOut})$0"
    },
    "JS_WINDOW_GETTITLE_WR c": {
        "prefix": "WR_JS_Window_GetTitle",
        "scope": "c",
        "description": "Returns the title (if any) of the specified window.\n",
        "body": "${1:void} = JS_Window_GetTitle(${2:void* windowHWND},${3:char* titleOutNeedBig},${4:int titleOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_GETTITLE_WR lua": {
        "prefix": "reaperwr.JS_Window_GetTitle",
        "scope": "lua",
        "description": "Returns the title (if any) of the specified window.\n",
        "body": "${1:local }${2:string title} = reaper.JS_Window_GetTitle(${3:identifier windowHWND})$0"
    },
    "JS_WINDOW_GETTITLE_WR python": {
        "prefix": "WR_JS_Window_GetTitle",
        "scope": "python",
        "description": "Returns the title (if any) of the specified window.\n",
        "body": "${1:void windowHWND},${2:String titleOutNeedBig},${3:Int titleOutNeedBig_sz} = JS_Window_GetTitle(${4:windowHWND},${5:titleOutNeedBig},${6:titleOutNeedBig_sz})$0"
    },
    "JS_WINDOW_GETVIEWPORTFROMRECT_WR c": {
        "prefix": "WR_JS_Window_GetViewportFromRect",
        "scope": "c",
        "description": "Retrieves the dimensions of the display monitor that has the largest area of intersection with the specified rectangle.\nIf the monitor is not the primary display, some of the rectangle's coordinates may be negative.\nwantWork: Returns the work area of the display, which excludes the system taskbar or application desktop toolbars.\n",
        "body": "${1:void} = JS_Window_GetViewportFromRect(${2:int x1},${3:int y1},${4:int x2},${5:int y2},${6:bool wantWork},${7:int* leftOut},${8:int* topOut},${9:int* rightOut},${10:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_GETVIEWPORTFROMRECT_WR lua": {
        "prefix": "reaperwr.JS_Window_GetViewportFromRect",
        "scope": "lua",
        "description": "Retrieves the dimensions of the display monitor that has the largest area of intersection with the specified rectangle.\nIf the monitor is not the primary display, some of the rectangle's coordinates may be negative.\nwantWork: Returns the work area of the display, which excludes the system taskbar or application desktop toolbars.\n",
        "body": "${1:local }${2:number left},${3:number top},${4:number right},${5:number bottom} = reaper.JS_Window_GetViewportFromRect(${6:integer x1},${7:integer y1},${8:integer x2},${9:integer y2},${10:boolean wantWork})$0"
    },
    "JS_WINDOW_GETVIEWPORTFROMRECT_WR python": {
        "prefix": "WR_JS_Window_GetViewportFromRect",
        "scope": "python",
        "description": "Retrieves the dimensions of the display monitor that has the largest area of intersection with the specified rectangle.\nIf the monitor is not the primary display, some of the rectangle's coordinates may be negative.\nwantWork: Returns the work area of the display, which excludes the system taskbar or application desktop toolbars.\n",
        "body": "${1:Int x1},${2:Int y1},${3:Int x2},${4:Int y2},${5:Boolean wantWork},${6:Int leftOut},${7:Int topOut},${8:Int rightOut},${9:Int bottomOut} = JS_Window_GetViewportFromRect(${10:x1},${11:y1},${12:x2},${13:y2},${14:wantWork},${15:leftOut},${16:topOut},${17:rightOut},${18:bottomOut})$0"
    },
    "JS_WINDOW_HANDLEFROMADDRESS_WR c": {
        "prefix": "WR_JS_Window_HandleFromAddress",
        "scope": "c",
        "description": "Converts an address to a handle (such as a HWND) that can be utilized by REAPER and other API functions.\n",
        "body": "${1:void*} = JS_Window_HandleFromAddress(${2:double address})$0"
    },
    "REAPER.JS_WINDOW_HANDLEFROMADDRESS_WR lua": {
        "prefix": "reaperwr.JS_Window_HandleFromAddress",
        "scope": "lua",
        "description": "Converts an address to a handle (such as a HWND) that can be utilized by REAPER and other API functions.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_HandleFromAddress(${3:number address})$0"
    },
    "JS_WINDOW_HANDLEFROMADDRESS_WR python": {
        "prefix": "WR_JS_Window_HandleFromAddress",
        "scope": "python",
        "description": "Converts an address to a handle (such as a HWND) that can be utilized by REAPER and other API functions.\n",
        "body": "${1:void} = JS_Window_HandleFromAddress(${2:Float address})$0"
    },
    "JS_WINDOW_INVALIDATERECT_WR c": {
        "prefix": "WR_JS_Window_InvalidateRect",
        "scope": "c",
        "description": "Similar to the Win32 function InvalidateRect.\n",
        "body": "${1:bool} = JS_Window_InvalidateRect(${2:void* windowHWND},${3:int left},${4:int top},${5:int right},${6:int bottom},${7:bool eraseBackground})$0"
    },
    "REAPER.JS_WINDOW_INVALIDATERECT_WR lua": {
        "prefix": "reaperwr.JS_Window_InvalidateRect",
        "scope": "lua",
        "description": "Similar to the Win32 function InvalidateRect.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_InvalidateRect(${3:identifier windowHWND},${4:integer left},${5:integer top},${6:integer right},${7:integer bottom},${8:boolean eraseBackground})$0"
    },
    "JS_WINDOW_INVALIDATERECT_WR python": {
        "prefix": "WR_JS_Window_InvalidateRect",
        "scope": "python",
        "description": "Similar to the Win32 function InvalidateRect.\n",
        "body": "${1:Boolean} = JS_Window_InvalidateRect(${2:void windowHWND},${3:Int left},${4:Int top},${5:Int right},${6:Int bottom},${7:Boolean eraseBackground})$0"
    },
    "JS_WINDOW_ISCHILD_WR c": {
        "prefix": "WR_JS_Window_IsChild",
        "scope": "c",
        "description": "Determines whether a window is a child window or descendant window of a specified parent window.\n",
        "body": "${1:bool} = JS_Window_IsChild(${2:void* parentHWND},${3:void* childHWND})$0"
    },
    "REAPER.JS_WINDOW_ISCHILD_WR lua": {
        "prefix": "reaperwr.JS_Window_IsChild",
        "scope": "lua",
        "description": "Determines whether a window is a child window or descendant window of a specified parent window.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_IsChild(${3:identifier parentHWND},${4:identifier childHWND})$0"
    },
    "JS_WINDOW_ISCHILD_WR python": {
        "prefix": "WR_JS_Window_IsChild",
        "scope": "python",
        "description": "Determines whether a window is a child window or descendant window of a specified parent window.\n",
        "body": "${1:Boolean} = JS_Window_IsChild(${2:void parentHWND},${3:void childHWND})$0"
    },
    "JS_WINDOW_ISVISIBLE_WR c": {
        "prefix": "WR_JS_Window_IsVisible",
        "scope": "c",
        "description": "Determines the visibility state of the window.\n",
        "body": "${1:bool} = JS_Window_IsVisible(${2:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ISVISIBLE_WR lua": {
        "prefix": "reaperwr.JS_Window_IsVisible",
        "scope": "lua",
        "description": "Determines the visibility state of the window.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_IsVisible(${3:identifier windowHWND})$0"
    },
    "JS_WINDOW_ISVISIBLE_WR python": {
        "prefix": "WR_JS_Window_IsVisible",
        "scope": "python",
        "description": "Determines the visibility state of the window.\n",
        "body": "${1:Boolean} = JS_Window_IsVisible(${2:void windowHWND})$0"
    },
    "JS_WINDOW_ISWINDOW_WR c": {
        "prefix": "WR_JS_Window_IsWindow",
        "scope": "c",
        "description": "Determines whether the specified window handle identifies an existing window.\nOn macOS and Linux, only windows that were created by WDL/swell will be\nidentified (and only such windows should be acted on by scripts).\nNOTE: Since REAPER v5.974, windows can be checked using the native function ValidatePtr(windowHWND, \"HWND\").\n",
        "body": "${1:bool} = JS_Window_IsWindow(${2:void* windowHWND})$0"
    },
    "REAPER.JS_WINDOW_ISWINDOW_WR lua": {
        "prefix": "reaperwr.JS_Window_IsWindow",
        "scope": "lua",
        "description": "Determines whether the specified window handle identifies an existing window.\nOn macOS and Linux, only windows that were created by WDL/swell will be\nidentified (and only such windows should be acted on by scripts).\nNOTE: Since REAPER v5.974, windows can be checked using the native function ValidatePtr(windowHWND, \"HWND\").\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_IsWindow(${3:identifier windowHWND})$0"
    },
    "JS_WINDOW_ISWINDOW_WR python": {
        "prefix": "WR_JS_Window_IsWindow",
        "scope": "python",
        "description": "Determines whether the specified window handle identifies an existing window.\nOn macOS and Linux, only windows that were created by WDL/swell will be\nidentified (and only such windows should be acted on by scripts).\nNOTE: Since REAPER v5.974, windows can be checked using the native function ValidatePtr(windowHWND, \"HWND\").\n",
        "body": "${1:Boolean} = JS_Window_IsWindow(${2:void windowHWND})$0"
    },
    "JS_WINDOW_LISTALLCHILD_WR c": {
        "prefix": "WR_JS_Window_ListAllChild",
        "scope": "c",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values.\nEach value is an address that can be converted to a HWND by the function Window_HandleFromAddress.\n",
        "body": "${1:int} = JS_Window_ListAllChild(${2:void* parentHWND},${3:char* listOutNeedBig},${4:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_LISTALLCHILD_WR lua": {
        "prefix": "reaperwr.JS_Window_ListAllChild",
        "scope": "lua",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values.\nEach value is an address that can be converted to a HWND by the function Window_HandleFromAddress.\n",
        "body": "${1:local }${2:integer retval},${3:string list} = reaper.JS_Window_ListAllChild(${4:identifier parentHWND})$0"
    },
    "JS_WINDOW_LISTALLCHILD_WR python": {
        "prefix": "WR_JS_Window_ListAllChild",
        "scope": "python",
        "description": "Finds all child windows of the specified parent.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values.\nEach value is an address that can be converted to a HWND by the function Window_HandleFromAddress.\n",
        "body": "${1:Int retval},${2:void parentHWND},${3:String listOutNeedBig},${4:Int listOutNeedBig_sz} = JS_Window_ListAllChild(${5:parentHWND},${6:listOutNeedBig},${7:listOutNeedBig_sz})$0"
    },
    "JS_WINDOW_LISTALLTOP_WR c": {
        "prefix": "WR_JS_Window_ListAllTop",
        "scope": "c",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "${1:int} = JS_Window_ListAllTop(${2:char* listOutNeedBig},${3:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_LISTALLTOP_WR lua": {
        "prefix": "reaperwr.JS_Window_ListAllTop",
        "scope": "lua",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "${1:local }${2:integer retval},${3:string list} = reaper.JS_Window_ListAllTop()$0"
    },
    "JS_WINDOW_LISTALLTOP_WR python": {
        "prefix": "WR_JS_Window_ListAllTop",
        "scope": "python",
        "description": "Finds all top-level windows.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\n",
        "body": "${1:Int retval},${2:String listOutNeedBig},${3:Int listOutNeedBig_sz} = JS_Window_ListAllTop(${4:listOutNeedBig},${5:listOutNeedBig_sz})$0"
    },
    "JS_WINDOW_LISTFIND_WR c": {
        "prefix": "WR_JS_Window_ListFind",
        "scope": "c",
        "description": "Finds all windows (whether top-level or child) whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "${1:int} = JS_Window_ListFind(${2:const char* title},${3:bool exact},${4:char* listOutNeedBig},${5:int listOutNeedBig_sz})$0"
    },
    "REAPER.JS_WINDOW_LISTFIND_WR lua": {
        "prefix": "reaperwr.JS_Window_ListFind",
        "scope": "lua",
        "description": "Finds all windows (whether top-level or child) whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "${1:local }${2:integer retval},${3:string list} = reaper.JS_Window_ListFind(${4:string title},${5:boolean exact})$0"
    },
    "JS_WINDOW_LISTFIND_WR python": {
        "prefix": "WR_JS_Window_ListFind",
        "scope": "python",
        "description": "Finds all windows (whether top-level or child) whose titles match the specified string.\nReturns:\n* retval: The number of windows found; negative if an error occurred.\n* list: A comma-separated string of hexadecimal values. Each value is\nan address that can be converted to a HWND by the function\nWindow_HandleFromAddress.\nParameters:\n* exact: Match entire title exactly, or match substring of title.\n",
        "body": "${1:Int retval},${2:String title},${3:Boolean exact},${4:String listOutNeedBig},${5:Int listOutNeedBig_sz} = JS_Window_ListFind(${6:title},${7:exact},${8:listOutNeedBig},${9:listOutNeedBig_sz})$0"
    },
    "JS_WINDOW_MONITORFROMRECT_WR c": {
        "prefix": "WR_JS_Window_MonitorFromRect",
        "scope": "c",
        "description": "Deprecated - use GetViewportFromRect instead.\n",
        "body": "${1:void} = JS_Window_MonitorFromRect(${2:int x1},${3:int y1},${4:int x2},${5:int y2},${6:bool wantWork},${7:int* leftOut},${8:int* topOut},${9:int* rightOut},${10:int* bottomOut})$0"
    },
    "REAPER.JS_WINDOW_MONITORFROMRECT_WR lua": {
        "prefix": "reaperwr.JS_Window_MonitorFromRect",
        "scope": "lua",
        "description": "Deprecated - use GetViewportFromRect instead.\n",
        "body": "${1:local }${2:number left},${3:number top},${4:number right},${5:number bottom} = reaper.JS_Window_MonitorFromRect(${6:integer x1},${7:integer y1},${8:integer x2},${9:integer y2},${10:boolean wantWork})$0"
    },
    "JS_WINDOW_MONITORFROMRECT_WR python": {
        "prefix": "WR_JS_Window_MonitorFromRect",
        "scope": "python",
        "description": "Deprecated - use GetViewportFromRect instead.\n",
        "body": "${1:Int x1},${2:Int y1},${3:Int x2},${4:Int y2},${5:Boolean wantWork},${6:Int leftOut},${7:Int topOut},${8:Int rightOut},${9:Int bottomOut} = JS_Window_MonitorFromRect(${10:x1},${11:y1},${12:x2},${13:y2},${14:wantWork},${15:leftOut},${16:topOut},${17:rightOut},${18:bottomOut})$0"
    },
    "JS_WINDOW_MOVE_WR c": {
        "prefix": "WR_JS_Window_Move",
        "scope": "c",
        "description": "Changes the position of the specified window, keeping its size constant.\nNOTES:\n* For top-level windows, position is relative to the primary display.\n* On Windows and Linux, position is calculated as the coordinates of\nthe upper left corner of the window, relative to upper left corner of\nthe primary display, and the positive Y-axis points downward.\n* On macOS, position is calculated as the coordinates of the bottom\nleft corner of the window, relative to bottom left corner of the\ndisplay, and the positive Y-axis points upward.\n* For a child window, on all platforms, position is relative to the upper-left corner of the parent window's client area.\n* Equivalent to calling JS_Window_SetPosition with NOSIZE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "${1:void} = JS_Window_Move(${2:void* windowHWND},${3:int left},${4:int top})$0"
    },
    "JS_WINDOW_ONCOMMAND_WR c": {
        "prefix": "WR_JS_Window_OnCommand",
        "scope": "c",
        "description": "Sends a \"WM_COMMAND\" message to the specified window, which simulates a user selecting a command in the window menu.\nThis function is similar to Main_OnCommand and MIDIEditor_OnCommand, but can send commands to any window that has a menu.\nIn the case of windows that are listed among the Action list's contexts\n(such as the Media Explorer), the commandIDs of the actions in the\nActions list may be used.\n",
        "body": "${1:bool} = JS_Window_OnCommand(${2:void* windowHWND},${3:int commandID})$0"
    },
    "REAPER.JS_WINDOW_ONCOMMAND_WR lua": {
        "prefix": "reaperwr.JS_Window_OnCommand",
        "scope": "lua",
        "description": "Sends a \"WM_COMMAND\" message to the specified window, which simulates a user selecting a command in the window menu.\nThis function is similar to Main_OnCommand and MIDIEditor_OnCommand, but can send commands to any window that has a menu.\nIn the case of windows that are listed among the Action list's contexts\n(such as the Media Explorer), the commandIDs of the actions in the\nActions list may be used.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_OnCommand(${3:identifier windowHWND},${4:integer commandID})$0"
    },
    "JS_WINDOW_ONCOMMAND_WR python": {
        "prefix": "WR_JS_Window_OnCommand",
        "scope": "python",
        "description": "Sends a \"WM_COMMAND\" message to the specified window, which simulates a user selecting a command in the window menu.\nThis function is similar to Main_OnCommand and MIDIEditor_OnCommand, but can send commands to any window that has a menu.\nIn the case of windows that are listed among the Action list's contexts\n(such as the Media Explorer), the commandIDs of the actions in the\nActions list may be used.\n",
        "body": "${1:Boolean} = JS_Window_OnCommand(${2:void windowHWND},${3:Int commandID})$0"
    },
    "JS_WINDOW_RESIZE_WR c": {
        "prefix": "WR_JS_Window_Resize",
        "scope": "c",
        "description": "Changes the dimensions of the specified window, keeping the top left corner position constant.\n* If resizing script GUIs, call gfx.update() after resizing.\n* Equivalent to calling JS_Window_SetPosition with NOMOVE, NOZORDER, NOACTIVATE and NOOWNERZORDER flags set.\n",
        "body": "${1:void} = JS_Window_Resize(${2:void* windowHWND},${3:int width},${4:int height})$0"
    },
    "JS_WINDOW_SCREENTOCLIENT_WR c": {
        "prefix": "WR_JS_Window_ScreenToClient",
        "scope": "c",
        "description": "Converts the screen coordinates of a specified point on the screen to client-area coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "${1:void} = JS_Window_ScreenToClient(${2:void* windowHWND},${3:int x},${4:int y},${5:int* xOut},${6:int* yOut})$0"
    },
    "REAPER.JS_WINDOW_SCREENTOCLIENT_WR lua": {
        "prefix": "reaperwr.JS_Window_ScreenToClient",
        "scope": "lua",
        "description": "Converts the screen coordinates of a specified point on the screen to client-area coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "${1:local }${2:number x},${3:number y} = reaper.JS_Window_ScreenToClient(${4:identifier windowHWND},${5:integer x},${6:integer y})$0"
    },
    "JS_WINDOW_SCREENTOCLIENT_WR python": {
        "prefix": "WR_JS_Window_ScreenToClient",
        "scope": "python",
        "description": "Converts the screen coordinates of a specified point on the screen to client-area coordinates.\nNOTES:\n* On Windows and Linux, screen coordinates are relative to *upper* left\ncorner of the primary display, and the positive Y-axis points downward.\n* On macOS, screen coordinates are relative to the *bottom* left corner\nof the primary display, and the positive Y-axis points upward.\n* On all platforms, client coordinates are relative to the upper left corner of the client area.\n",
        "body": "${1:void windowHWND},${2:Int x},${3:Int y},${4:Int xOut},${5:Int yOut} = JS_Window_ScreenToClient(${6:windowHWND},${7:x},${8:y},${9:xOut},${10:yOut})$0"
    },
    "JS_WINDOW_SETFOCUS_WR c": {
        "prefix": "WR_JS_Window_SetFocus",
        "scope": "c",
        "description": "Sets the keyboard focus to the specified window.\n",
        "body": "${1:void} = JS_Window_SetFocus(${2:void* windowHWND})$0"
    },
    "JS_WINDOW_SETFOREGROUND_WR c": {
        "prefix": "WR_JS_Window_SetForeground",
        "scope": "c",
        "description": "Brings the specified window into the foreground, activates the window, and directs keyboard input to it.\n",
        "body": "${1:void} = JS_Window_SetForeground(${2:void* windowHWND})$0"
    },
    "JS_WINDOW_SETLONG_WR c": {
        "prefix": "WR_JS_Window_SetLong",
        "scope": "c",
        "description": "Similar to the Win32 function SetWindowLongPtr.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\", and only on WindowOS, \"INSTANCE\" and \"PARENT\".\n",
        "body": "${1:void} = JS_Window_SetLong(${2:void* windowHWND},${3:const char* info},${4:double value},${5:double* retvalOut})$0"
    },
    "REAPER.JS_WINDOW_SETLONG_WR lua": {
        "prefix": "reaperwr.JS_Window_SetLong",
        "scope": "lua",
        "description": "Similar to the Win32 function SetWindowLongPtr.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\", and only on WindowOS, \"INSTANCE\" and \"PARENT\".\n",
        "body": "${1:local }${2:number retval} = reaper.JS_Window_SetLong(${3:identifier windowHWND},${4:string info},${5:number value})$0"
    },
    "JS_WINDOW_SETLONG_WR python": {
        "prefix": "WR_JS_Window_SetLong",
        "scope": "python",
        "description": "Similar to the Win32 function SetWindowLongPtr.\ninfo: \"USERDATA\", \"WNDPROC\", \"DLGPROC\", \"ID\", \"EXSTYLE\" or \"STYLE\", and only on WindowOS, \"INSTANCE\" and \"PARENT\".\n",
        "body": "${1:void windowHWND},${2:String info},${3:Float value},${4:Float retvalOut} = JS_Window_SetLong(${5:windowHWND},${6:info},${7:value},${8:retvalOut})$0"
    },
    "JS_WINDOW_SETOPACITY_WR c": {
        "prefix": "WR_JS_Window_SetOpacity",
        "scope": "c",
        "description": "Sets the window opacity.\nParameters:\nmode: either \"ALPHA\" or \"COLOR\".\nvalue: If ALPHA, the specified value may range from zero to one, and will apply to the entire window, frame included.\nIf COLOR, value specifies a 0xRRGGBB color, and all pixels of this color\nwill be made transparent. (All mouse clicks over transparent pixels\nwill pass through, too).  WARNING:\nCOLOR mode is only available in Windows, not Linux or macOS.\nTransparency can only be applied to top-level windows. If windowHWND\nrefers to a child window, the entire top-level window that contains\nwindowHWND will be made transparent.\n",
        "body": "${1:bool} = JS_Window_SetOpacity(${2:void* windowHWND},${3:const char* mode},${4:double value})$0"
    },
    "REAPER.JS_WINDOW_SETOPACITY_WR lua": {
        "prefix": "reaperwr.JS_Window_SetOpacity",
        "scope": "lua",
        "description": "Sets the window opacity.\nParameters:\nmode: either \"ALPHA\" or \"COLOR\".\nvalue: If ALPHA, the specified value may range from zero to one, and will apply to the entire window, frame included.\nIf COLOR, value specifies a 0xRRGGBB color, and all pixels of this color\nwill be made transparent. (All mouse clicks over transparent pixels\nwill pass through, too).  WARNING:\nCOLOR mode is only available in Windows, not Linux or macOS.\nTransparency can only be applied to top-level windows. If windowHWND\nrefers to a child window, the entire top-level window that contains\nwindowHWND will be made transparent.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_SetOpacity(${3:identifier windowHWND},${4:string mode},${5:number value})$0"
    },
    "JS_WINDOW_SETOPACITY_WR python": {
        "prefix": "WR_JS_Window_SetOpacity",
        "scope": "python",
        "description": "Sets the window opacity.\nParameters:\nmode: either \"ALPHA\" or \"COLOR\".\nvalue: If ALPHA, the specified value may range from zero to one, and will apply to the entire window, frame included.\nIf COLOR, value specifies a 0xRRGGBB color, and all pixels of this color\nwill be made transparent. (All mouse clicks over transparent pixels\nwill pass through, too).  WARNING:\nCOLOR mode is only available in Windows, not Linux or macOS.\nTransparency can only be applied to top-level windows. If windowHWND\nrefers to a child window, the entire top-level window that contains\nwindowHWND will be made transparent.\n",
        "body": "${1:Boolean} = JS_Window_SetOpacity(${2:void windowHWND},${3:String mode},${4:Float value})$0"
    },
    "JS_WINDOW_SETPARENT_WR c": {
        "prefix": "WR_JS_Window_SetParent",
        "scope": "c",
        "description": "If successful, returns a handle to the previous parent window.\n",
        "body": "${1:void*} = JS_Window_SetParent(${2:void* childHWND},${3:void* parentHWND})$0"
    },
    "REAPER.JS_WINDOW_SETPARENT_WR lua": {
        "prefix": "reaperwr.JS_Window_SetParent",
        "scope": "lua",
        "description": "If successful, returns a handle to the previous parent window.\n",
        "body": "${1:local }${2:identifier} = reaper.JS_Window_SetParent(${3:identifier childHWND},${4:identifier parentHWND})$0"
    },
    "JS_WINDOW_SETPARENT_WR python": {
        "prefix": "WR_JS_Window_SetParent",
        "scope": "python",
        "description": "If successful, returns a handle to the previous parent window.\n",
        "body": "${1:void} = JS_Window_SetParent(${2:void childHWND},${3:void parentHWND})$0"
    },
    "JS_WINDOW_SETPOSITION_WR c": {
        "prefix": "WR_JS_Window_SetPosition",
        "scope": "c",
        "description": "Interface to the Win32/swell function SetWindowPos, with which window\nposition, size, Z-order and visibility can be set, and new frame styles\ncan be applied.\nZOrder and flags are optional parameters. If no arguments are supplied,\nthe window will simply be moved and resized, as if the NOACTIVATE,\nNOZORDER, NOOWNERZORDER flags were set.\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\" or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* flags: Any combination of the standard flags, of which \"NOMOVE\",\n\"NOSIZE\", \"NOZORDER\", \"NOACTIVATE\", \"SHOWWINDOW\", \"FRAMECHANGED\" and\n\"NOCOPYBITS\" should be valid cross-platform.\n",
        "body": "${1:bool} = JS_Window_SetPosition(${2:void* windowHWND},${3:int left},${4:int top},${5:int width},${6:int height},${7:char* ZOrderOptional},${8:char* flagsOptional})$0"
    },
    "REAPER.JS_WINDOW_SETPOSITION_WR lua": {
        "prefix": "reaperwr.JS_Window_SetPosition",
        "scope": "lua",
        "description": "Interface to the Win32/swell function SetWindowPos, with which window\nposition, size, Z-order and visibility can be set, and new frame styles\ncan be applied.\nZOrder and flags are optional parameters. If no arguments are supplied,\nthe window will simply be moved and resized, as if the NOACTIVATE,\nNOZORDER, NOOWNERZORDER flags were set.\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\" or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* flags: Any combination of the standard flags, of which \"NOMOVE\",\n\"NOSIZE\", \"NOZORDER\", \"NOACTIVATE\", \"SHOWWINDOW\", \"FRAMECHANGED\" and\n\"NOCOPYBITS\" should be valid cross-platform.\n",
        "body": "${1:local }${2:boolean retval},${3:optional string ZOrder},${4:optional string flags} = reaper.JS_Window_SetPosition(${5:identifier windowHWND},${6:integer left},${7:integer top},${8:integer width},${9:integer height},${10:optional string ZOrder},${11:optional string flags})$0"
    },
    "JS_WINDOW_SETPOSITION_WR python": {
        "prefix": "WR_JS_Window_SetPosition",
        "scope": "python",
        "description": "Interface to the Win32/swell function SetWindowPos, with which window\nposition, size, Z-order and visibility can be set, and new frame styles\ncan be applied.\nZOrder and flags are optional parameters. If no arguments are supplied,\nthe window will simply be moved and resized, as if the NOACTIVATE,\nNOZORDER, NOOWNERZORDER flags were set.\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\" or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* flags: Any combination of the standard flags, of which \"NOMOVE\",\n\"NOSIZE\", \"NOZORDER\", \"NOACTIVATE\", \"SHOWWINDOW\", \"FRAMECHANGED\" and\n\"NOCOPYBITS\" should be valid cross-platform.\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:Int left},${4:Int top},${5:Int width},${6:Int height},${7:String ZOrderOptional},${8:String flagsOptional} = JS_Window_SetPosition(${9:windowHWND},${10:left},${11:top},${12:width},${13:height},${14:ZOrderOptional},${15:flagsOptional})$0"
    },
    "JS_WINDOW_SETSCROLLPOS_WR c": {
        "prefix": "WR_JS_Window_SetScrollPos",
        "scope": "c",
        "description": "Parameters:\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nNOTE: API functions can scroll REAPER's windows, but cannot zoom them.\nInstead, use actions such as \"View: Zoom to one loop iteration\".\n",
        "body": "${1:bool} = JS_Window_SetScrollPos(${2:void* windowHWND},${3:const char* scrollbar},${4:int position})$0"
    },
    "REAPER.JS_WINDOW_SETSCROLLPOS_WR lua": {
        "prefix": "reaperwr.JS_Window_SetScrollPos",
        "scope": "lua",
        "description": "Parameters:\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nNOTE: API functions can scroll REAPER's windows, but cannot zoom them.\nInstead, use actions such as \"View: Zoom to one loop iteration\".\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_SetScrollPos(${3:identifier windowHWND},${4:string scrollbar},${5:integer position})$0"
    },
    "JS_WINDOW_SETSCROLLPOS_WR python": {
        "prefix": "WR_JS_Window_SetScrollPos",
        "scope": "python",
        "description": "Parameters:\n* scrollbar: \"v\" (or \"SB_VERT\", or \"VERT\") for vertical scroll, \"h\" (or \"SB_HORZ\" or \"HORZ\") for horizontal.\nNOTE: API functions can scroll REAPER's windows, but cannot zoom them.\nInstead, use actions such as \"View: Zoom to one loop iteration\".\n",
        "body": "${1:Boolean} = JS_Window_SetScrollPos(${2:void windowHWND},${3:String scrollbar},${4:Int position})$0"
    },
    "JS_WINDOW_SETSTYLE_WR c": {
        "prefix": "WR_JS_Window_SetStyle",
        "scope": "c",
        "description": "Sets and applies a window style.\nstyle may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implmented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\n",
        "body": "${1:bool} = JS_Window_SetStyle(${2:void* windowHWND},${3:char* style})$0"
    },
    "REAPER.JS_WINDOW_SETSTYLE_WR lua": {
        "prefix": "reaperwr.JS_Window_SetStyle",
        "scope": "lua",
        "description": "Sets and applies a window style.\nstyle may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implmented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\n",
        "body": "${1:local }${2:boolean retval},${3:string style} = reaper.JS_Window_SetStyle(${4:identifier windowHWND},${5:string style})$0"
    },
    "JS_WINDOW_SETSTYLE_WR python": {
        "prefix": "WR_JS_Window_SetStyle",
        "scope": "python",
        "description": "Sets and applies a window style.\nstyle may include any combination of standard window styles, such as\n\"POPUP\" for a frameless window, or \"CAPTION,SIZEBOX,SYSMENU\" for a\nstandard framed window.\nOn Linux and macOS, \"MAXIMIZE\" has not yet been implmented, and the\nremaining styles may appear slightly different from their WindowsOS\ncounterparts.\n",
        "body": "${1:Boolean retval},${2:void windowHWND},${3:String style} = JS_Window_SetStyle(${4:windowHWND},${5:style})$0"
    },
    "JS_WINDOW_SETTITLE_WR c": {
        "prefix": "WR_JS_Window_SetTitle",
        "scope": "c",
        "description": "Changes the title of the specified window. Returns true if successful.\n",
        "body": "${1:bool} = JS_Window_SetTitle(${2:void* windowHWND},${3:const char* title})$0"
    },
    "REAPER.JS_WINDOW_SETTITLE_WR lua": {
        "prefix": "reaperwr.JS_Window_SetTitle",
        "scope": "lua",
        "description": "Changes the title of the specified window. Returns true if successful.\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_SetTitle(${3:identifier windowHWND},${4:string title})$0"
    },
    "JS_WINDOW_SETTITLE_WR python": {
        "prefix": "WR_JS_Window_SetTitle",
        "scope": "python",
        "description": "Changes the title of the specified window. Returns true if successful.\n",
        "body": "${1:Boolean} = JS_Window_SetTitle(${2:void windowHWND},${3:String title})$0"
    },
    "JS_WINDOW_SETZORDER_WR c": {
        "prefix": "WR_JS_Window_SetZOrder",
        "scope": "c",
        "description": "Sets the window Z order.\n* Equivalent to calling JS_Window_SetPos with flags NOMOVE | NOSIZE.\n* Not all the Z orders have been implemented in Linux yet.\nParameters:\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\", or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* InsertAfterHWND: For compatibility with older versions, this parameter\nis still available, and is optional. If ZOrder is \"INSERTAFTER\",\ninsertAfterHWND must be a handle to the window behind which windowHWND\nwill be placed in the Z order, equivalent to setting ZOrder to this\nHWND; otherwise, insertAfterHWND is ignored and can be left out (or it\ncan simply be set to the same value as windowHWND).\n",
        "body": "${1:bool} = JS_Window_SetZOrder(${2:void* windowHWND},${3:const char* ZOrder},${4:void* insertAfterHWNDOptional})$0"
    },
    "REAPER.JS_WINDOW_SETZORDER_WR lua": {
        "prefix": "reaperwr.JS_Window_SetZOrder",
        "scope": "lua",
        "description": "Sets the window Z order.\n* Equivalent to calling JS_Window_SetPos with flags NOMOVE | NOSIZE.\n* Not all the Z orders have been implemented in Linux yet.\nParameters:\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\", or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* InsertAfterHWND: For compatibility with older versions, this parameter\nis still available, and is optional. If ZOrder is \"INSERTAFTER\",\ninsertAfterHWND must be a handle to the window behind which windowHWND\nwill be placed in the Z order, equivalent to setting ZOrder to this\nHWND; otherwise, insertAfterHWND is ignored and can be left out (or it\ncan simply be set to the same value as windowHWND).\n",
        "body": "${1:local }${2:boolean} = reaper.JS_Window_SetZOrder(${3:identifier windowHWND},${4:string ZOrder},${5:identifier insertAfterHWND})$0"
    },
    "JS_WINDOW_SETZORDER_WR python": {
        "prefix": "WR_JS_Window_SetZOrder",
        "scope": "python",
        "description": "Sets the window Z order.\n* Equivalent to calling JS_Window_SetPos with flags NOMOVE | NOSIZE.\n* Not all the Z orders have been implemented in Linux yet.\nParameters:\n* ZOrder: \"BOTTOM\", \"TOPMOST\", \"NOTOPMOST\", \"TOP\", or a window HWND\nconverted to a string, for example by the Lua function tostring.\n* InsertAfterHWND: For compatibility with older versions, this parameter\nis still available, and is optional. If ZOrder is \"INSERTAFTER\",\ninsertAfterHWND must be a handle to the window behind which windowHWND\nwill be placed in the Z order, equivalent to setting ZOrder to this\nHWND; otherwise, insertAfterHWND is ignored and can be left out (or it\ncan simply be set to the same value as windowHWND).\n",
        "body": "${1:Boolean} = JS_Window_SetZOrder(${2:void windowHWND},${3:String ZOrder},${4:void insertAfterHWNDOptional})$0"
    },
    "JS_WINDOW_SHOW_WR c": {
        "prefix": "WR_JS_Window_Show",
        "scope": "c",
        "description": "Sets the specified window's show state.\nParameters:\n* state: One of the following options: \"SHOW\", \"SHOWNA\" (or\n\"SHOWNOACTIVATE\"), \"SHOWMINIMIZED\", \"HIDE\", \"NORMAL\", \"SHOWNORMAL\",\n\"SHOWMAXIMIZED\", \"SHOWDEFAULT\" or \"RESTORE\". On Linux and macOS, only\nthe first four options are fully implemented.\n",
        "body": "${1:void} = JS_Window_Show(${2:void* windowHWND},${3:const char* state})$0"
    },
    "JS_WINDOW_UPDATE_WR c": {
        "prefix": "WR_JS_Window_Update",
        "scope": "c",
        "description": "Similar to the Win32 function UpdateWindow.\n",
        "body": "${1:void} = JS_Window_Update(${2:void* windowHWND})$0"
    },
    "NF_ANALYZEMEDIAITEMPEAKANDRMS_WR c": {
        "prefix": "WR_NF_AnalyzeMediaItemPeakAndRMS",
        "scope": "c",
        "description": "This function combines all other NF_Peak/RMS functions in a single one\nand additionally returns peak RMS positions. Lua example code here.\nNote: It's recommended to use this function with ReaScript/Lua as it\nprovides reaper.array objects. If using this function with other\nscripting languages, you must provide arrays in the reaper.array format.\n",
        "body": "${1:bool} = NF_AnalyzeMediaItemPeakAndRMS(${2:MediaItem* item},${3:double windowSize},${4:void* reaper_array_peaks},${5:void* reaper_array_peakpositions},${6:void* reaper_array_RMSs},${7:void* reaper_array_RMSpositions})$0"
    },
    "REAPER.NF_ANALYZEMEDIAITEMPEAKANDRMS_WR lua": {
        "prefix": "reaperwr.NF_AnalyzeMediaItemPeakAndRMS",
        "scope": "lua",
        "description": "This function combines all other NF_Peak/RMS functions in a single one\nand additionally returns peak RMS positions. Lua example code here.\nNote: It's recommended to use this function with ReaScript/Lua as it\nprovides reaper.array objects. If using this function with other\nscripting languages, you must provide arrays in the reaper.array format.\n",
        "body": "${1:local }${2:boolean} = reaper.NF_AnalyzeMediaItemPeakAndRMS(${3:MediaItem item},${4:number windowSize},${5:identifier reaper_array_peaks},${6:identifier reaper_array_peakpositions},${7:identifier reaper_array_RMSs},${8:identifier reaper_array_RMSpositions})$0"
    },
    "NF_ANALYZEMEDIAITEMPEAKANDRMS_WR python": {
        "prefix": "WR_NF_AnalyzeMediaItemPeakAndRMS",
        "scope": "python",
        "description": "This function combines all other NF_Peak/RMS functions in a single one\nand additionally returns peak RMS positions. Lua example code here.\nNote: It's recommended to use this function with ReaScript/Lua as it\nprovides reaper.array objects. If using this function with other\nscripting languages, you must provide arrays in the reaper.array format.\n",
        "body": "${1:Boolean} = NF_AnalyzeMediaItemPeakAndRMS(${2:MediaItem item},${3:Float windowSize},${4:void reaper_array_peaks},${5:void reaper_array_peakpositions},${6:void reaper_array_RMSs},${7:void reaper_array_RMSpositions})$0"
    },
    "NF_ANALYZETAKELOUDNESS_WR c": {
        "prefix": "WR_NF_AnalyzeTakeLoudness",
        "scope": "c",
        "description": "Full loudness analysis. retval: returns true on successful analysis,\nfalse on MIDI take or when analysis failed for some reason.\nanalyzeTruePeak=true: Also do true peak analysis. Returns true peak\nvalue and true peak position (relative to item position). Considerably\nslower than without true peak analysis (since it uses oversampling).\nNote: Short term uses a time window of 3 sec. for calculation. So for\nitems shorter than this shortTermMaxOut can't be calculated correctly.\nMomentary uses a time window of 0.4 sec.\n",
        "body": "${1:bool} = NF_AnalyzeTakeLoudness(${2:MediaItem_Take* take},${3:bool analyzeTruePeak},${4:double* lufsIntegratedOut},${5:double* rangeOut},${6:double*  truePeakOut},${7:double* truePeakPosOut},${8:double* shortTermMaxOut},${9:double* momentaryMaxOut})$0"
    },
    "REAPER.NF_ANALYZETAKELOUDNESS_WR lua": {
        "prefix": "reaperwr.NF_AnalyzeTakeLoudness",
        "scope": "lua",
        "description": "Full loudness analysis. retval: returns true on successful analysis,\nfalse on MIDI take or when analysis failed for some reason.\nanalyzeTruePeak=true: Also do true peak analysis. Returns true peak\nvalue and true peak position (relative to item position). Considerably\nslower than without true peak analysis (since it uses oversampling).\nNote: Short term uses a time window of 3 sec. for calculation. So for\nitems shorter than this shortTermMaxOut can't be calculated correctly.\nMomentary uses a time window of 0.4 sec.\n",
        "body": "${1:local }${2:boolean retval},${3:number lufsIntegrated},${4:number range},${5:number  truePeak},${6:number truePeakPos},${7:number shortTermMax},${8:number momentaryMax} = reaper.NF_AnalyzeTakeLoudness(${9:MediaItem_Take take},${10:boolean analyzeTruePeak})$0"
    },
    "NF_ANALYZETAKELOUDNESS_WR python": {
        "prefix": "WR_NF_AnalyzeTakeLoudness",
        "scope": "python",
        "description": "Full loudness analysis. retval: returns true on successful analysis,\nfalse on MIDI take or when analysis failed for some reason.\nanalyzeTruePeak=true: Also do true peak analysis. Returns true peak\nvalue and true peak position (relative to item position). Considerably\nslower than without true peak analysis (since it uses oversampling).\nNote: Short term uses a time window of 3 sec. for calculation. So for\nitems shorter than this shortTermMaxOut can't be calculated correctly.\nMomentary uses a time window of 0.4 sec.\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Boolean analyzeTruePeak},${4:Float lufsIntegratedOut},${5:Float rangeOut},${6:Float  truePeakOut},${7:Float truePeakPosOut},${8:Float shortTermMaxOut},${9:Float momentaryMaxOut} = NF_AnalyzeTakeLoudness(${10:take},${11:analyzeTruePeak},${12:lufsIntegratedOut},${13:rangeOut},${14: truePeakOut},${15:truePeakPosOut},${16:shortTermMaxOut},${17:momentaryMaxOut})$0"
    },
    "NF_ANALYZETAKELOUDNESS2_WR c": {
        "prefix": "WR_NF_AnalyzeTakeLoudness2",
        "scope": "c",
        "description": "Same as NF_AnalyzeTakeLoudness but\nadditionally returns shortTermMaxPos and momentaryMaxPos (in absolute\nproject time). Note: shortTermMaxPos and momentaryMaxPos actaully\nindicate the beginning of time intervalls, (3 sec. and 0.4 sec. resp.).\n",
        "body": "${1:bool} = NF_AnalyzeTakeLoudness2(${2:MediaItem_Take* take},${3:bool analyzeTruePeak},${4:double* lufsIntegratedOut},${5:double* rangeOut},${6:double*  truePeakOut},${7:double* truePeakPosOut},${8:double* shortTermMaxOut},${9:double* momentaryMaxOut},${10:double* shortTermMaxPosOut},${11:double* momentaryMaxPosOut})$0"
    },
    "REAPER.NF_ANALYZETAKELOUDNESS2_WR lua": {
        "prefix": "reaperwr.NF_AnalyzeTakeLoudness2",
        "scope": "lua",
        "description": "Same as NF_AnalyzeTakeLoudness but\nadditionally returns shortTermMaxPos and momentaryMaxPos (in absolute\nproject time). Note: shortTermMaxPos and momentaryMaxPos actaully\nindicate the beginning of time intervalls, (3 sec. and 0.4 sec. resp.).\n",
        "body": "${1:local }${2:boolean retval},${3:number lufsIntegrated},${4:number range},${5:number  truePeak},${6:number truePeakPos},${7:number shortTermMax},${8:number momentaryMax},${9:number shortTermMaxPos},${10:number momentaryMaxPos} = reaper.NF_AnalyzeTakeLoudness2(${11:MediaItem_Take take},${12:boolean analyzeTruePeak})$0"
    },
    "NF_ANALYZETAKELOUDNESS2_WR python": {
        "prefix": "WR_NF_AnalyzeTakeLoudness2",
        "scope": "python",
        "description": "Same as NF_AnalyzeTakeLoudness but\nadditionally returns shortTermMaxPos and momentaryMaxPos (in absolute\nproject time). Note: shortTermMaxPos and momentaryMaxPos actaully\nindicate the beginning of time intervalls, (3 sec. and 0.4 sec. resp.).\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Boolean analyzeTruePeak},${4:Float lufsIntegratedOut},${5:Float rangeOut},${6:Float  truePeakOut},${7:Float truePeakPosOut},${8:Float shortTermMaxOut},${9:Float momentaryMaxOut},${10:Float shortTermMaxPosOut},${11:Float momentaryMaxPosOut} = NF_AnalyzeTakeLoudness2(${12:take},${13:analyzeTruePeak},${14:lufsIntegratedOut},${15:rangeOut},${16: truePeakOut},${17:truePeakPosOut},${18:shortTermMaxOut},${19:momentaryMaxOut},${20:shortTermMaxPosOut},${21:momentaryMaxPosOut})$0"
    },
    "NF_ANALYZETAKELOUDNESS_INTEGRATEDONLY_WR c": {
        "prefix": "WR_NF_AnalyzeTakeLoudness_IntegratedOnly",
        "scope": "c",
        "description": "Does LUFS integrated analysis only. Faster than full loudness analysis (NF_AnalyzeTakeLoudness) . Use this if only LUFS integrated is required. Take vol. env. is taken into account. See: Signal flow\n",
        "body": "${1:bool} = NF_AnalyzeTakeLoudness_IntegratedOnly(${2:MediaItem_Take* take},${3:double* lufsIntegratedOut})$0"
    },
    "REAPER.NF_ANALYZETAKELOUDNESS_INTEGRATEDONLY_WR lua": {
        "prefix": "reaperwr.NF_AnalyzeTakeLoudness_IntegratedOnly",
        "scope": "lua",
        "description": "Does LUFS integrated analysis only. Faster than full loudness analysis (NF_AnalyzeTakeLoudness) . Use this if only LUFS integrated is required. Take vol. env. is taken into account. See: Signal flow\n",
        "body": "${1:local }${2:boolean retval},${3:number lufsIntegrated} = reaper.NF_AnalyzeTakeLoudness_IntegratedOnly(${4:MediaItem_Take take})$0"
    },
    "NF_ANALYZETAKELOUDNESS_INTEGRATEDONLY_WR python": {
        "prefix": "WR_NF_AnalyzeTakeLoudness_IntegratedOnly",
        "scope": "python",
        "description": "Does LUFS integrated analysis only. Faster than full loudness analysis (NF_AnalyzeTakeLoudness) . Use this if only LUFS integrated is required. Take vol. env. is taken into account. See: Signal flow\n",
        "body": "${1:Boolean retval},${2:MediaItem_Take take},${3:Float lufsIntegratedOut} = NF_AnalyzeTakeLoudness_IntegratedOnly(${4:take},${5:lufsIntegratedOut})$0"
    },
    "NF_GETMEDIAITEMAVERAGERMS_WR c": {
        "prefix": "WR_NF_GetMediaItemAverageRMS",
        "scope": "c",
        "description": "Returns the average overall (non-windowed) RMS level of active channels\nof an audio item active take, post item gain, post take volume envelope,\npost-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:double} = NF_GetMediaItemAverageRMS(${2:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMAVERAGERMS_WR lua": {
        "prefix": "reaperwr.NF_GetMediaItemAverageRMS",
        "scope": "lua",
        "description": "Returns the average overall (non-windowed) RMS level of active channels\nof an audio item active take, post item gain, post take volume envelope,\npost-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:local }${2:number} = reaper.NF_GetMediaItemAverageRMS(${3:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMAVERAGERMS_WR python": {
        "prefix": "WR_NF_GetMediaItemAverageRMS",
        "scope": "python",
        "description": "Returns the average overall (non-windowed) RMS level of active channels\nof an audio item active take, post item gain, post take volume envelope,\npost-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:Float} = NF_GetMediaItemAverageRMS(${2:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAK_WR c": {
        "prefix": "WR_NF_GetMediaItemMaxPeak",
        "scope": "c",
        "description": "Returns the greatest max. peak value of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:double} = NF_GetMediaItemMaxPeak(${2:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMMAXPEAK_WR lua": {
        "prefix": "reaperwr.NF_GetMediaItemMaxPeak",
        "scope": "lua",
        "description": "Returns the greatest max. peak value of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:local }${2:number} = reaper.NF_GetMediaItemMaxPeak(${3:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAK_WR python": {
        "prefix": "WR_NF_GetMediaItemMaxPeak",
        "scope": "python",
        "description": "Returns the greatest max. peak value of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:Float} = NF_GetMediaItemMaxPeak(${2:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAKANDMAXPEAKPOS_WR c": {
        "prefix": "WR_NF_GetMediaItemMaxPeakAndMaxPeakPos",
        "scope": "c",
        "description": "See NF_GetMediaItemMaxPeak, additionally returns maxPeakPos (relative to item position).\n",
        "body": "${1:double} = NF_GetMediaItemMaxPeakAndMaxPeakPos(${2:MediaItem* item},${3:double* maxPeakPosOut})$0"
    },
    "REAPER.NF_GETMEDIAITEMMAXPEAKANDMAXPEAKPOS_WR lua": {
        "prefix": "reaperwr.NF_GetMediaItemMaxPeakAndMaxPeakPos",
        "scope": "lua",
        "description": "See NF_GetMediaItemMaxPeak, additionally returns maxPeakPos (relative to item position).\n",
        "body": "${1:local }${2:number retval},${3:number maxPeakPos} = reaper.NF_GetMediaItemMaxPeakAndMaxPeakPos(${4:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMMAXPEAKANDMAXPEAKPOS_WR python": {
        "prefix": "WR_NF_GetMediaItemMaxPeakAndMaxPeakPos",
        "scope": "python",
        "description": "See NF_GetMediaItemMaxPeak, additionally returns maxPeakPos (relative to item position).\n",
        "body": "${1:Float retval},${2:MediaItem item},${3:Float maxPeakPosOut} = NF_GetMediaItemMaxPeakAndMaxPeakPos(${4:item},${5:maxPeakPosOut})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_NONWINDOWED_WR c": {
        "prefix": "WR_NF_GetMediaItemPeakRMS_NonWindowed",
        "scope": "c",
        "description": "Returns the greatest overall (non-windowed) RMS peak level of all active\nchannels of an audio item active take, post item gain, post take volume\nenvelope, post-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:double} = NF_GetMediaItemPeakRMS_NonWindowed(${2:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMPEAKRMS_NONWINDOWED_WR lua": {
        "prefix": "reaperwr.NF_GetMediaItemPeakRMS_NonWindowed",
        "scope": "lua",
        "description": "Returns the greatest overall (non-windowed) RMS peak level of all active\nchannels of an audio item active take, post item gain, post take volume\nenvelope, post-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:local }${2:number} = reaper.NF_GetMediaItemPeakRMS_NonWindowed(${3:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_NONWINDOWED_WR python": {
        "prefix": "WR_NF_GetMediaItemPeakRMS_NonWindowed",
        "scope": "python",
        "description": "Returns the greatest overall (non-windowed) RMS peak level of all active\nchannels of an audio item active take, post item gain, post take volume\nenvelope, post-fade, pre fader, pre item FX.\nReturns -150.0 if MIDI take or empty item.\n",
        "body": "${1:Float} = NF_GetMediaItemPeakRMS_NonWindowed(${2:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_WINDOWED_WR c": {
        "prefix": "WR_NF_GetMediaItemPeakRMS_Windowed",
        "scope": "c",
        "description": "Returns the average RMS peak level of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nObeys 'Window size for peak RMS' setting in 'SWS: Set RMS\nanalysis/normalize options' for calculation. Returns -150.0 if MIDI take\nor empty item.\n",
        "body": "${1:double} = NF_GetMediaItemPeakRMS_Windowed(${2:MediaItem* item})$0"
    },
    "REAPER.NF_GETMEDIAITEMPEAKRMS_WINDOWED_WR lua": {
        "prefix": "reaperwr.NF_GetMediaItemPeakRMS_Windowed",
        "scope": "lua",
        "description": "Returns the average RMS peak level of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nObeys 'Window size for peak RMS' setting in 'SWS: Set RMS\nanalysis/normalize options' for calculation. Returns -150.0 if MIDI take\nor empty item.\n",
        "body": "${1:local }${2:number} = reaper.NF_GetMediaItemPeakRMS_Windowed(${3:MediaItem item})$0"
    },
    "NF_GETMEDIAITEMPEAKRMS_WINDOWED_WR python": {
        "prefix": "WR_NF_GetMediaItemPeakRMS_Windowed",
        "scope": "python",
        "description": "Returns the average RMS peak level of all active channels of an audio\nitem active take, post item gain, post take volume envelope, post-fade,\npre fader, pre item FX.\nObeys 'Window size for peak RMS' setting in 'SWS: Set RMS\nanalysis/normalize options' for calculation. Returns -150.0 if MIDI take\nor empty item.\n",
        "body": "${1:Float} = NF_GetMediaItemPeakRMS_Windowed(${2:MediaItem item})$0"
    },
    "NF_GETSWSMARKERREGIONSUB_WR c": {
        "prefix": "WR_NF_GetSWSMarkerRegionSub",
        "scope": "c",
        "description": "Returns SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns empty string if\nmarker/region with specified index not found or marker/region subtitle\nnot set. Lua code example here.\n",
        "body": "${1:const char*} = NF_GetSWSMarkerRegionSub(${2:int markerRegionIdx})$0"
    },
    "REAPER.NF_GETSWSMARKERREGIONSUB_WR lua": {
        "prefix": "reaperwr.NF_GetSWSMarkerRegionSub",
        "scope": "lua",
        "description": "Returns SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns empty string if\nmarker/region with specified index not found or marker/region subtitle\nnot set. Lua code example here.\n",
        "body": "${1:local }${2:string} = reaper.NF_GetSWSMarkerRegionSub(${3:integer markerRegionIdx})$0"
    },
    "NF_GETSWSMARKERREGIONSUB_WR python": {
        "prefix": "WR_NF_GetSWSMarkerRegionSub",
        "scope": "python",
        "description": "Returns SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns empty string if\nmarker/region with specified index not found or marker/region subtitle\nnot set. Lua code example here.\n",
        "body": "${1:String} = NF_GetSWSMarkerRegionSub(${2:Int markerRegionIdx})$0"
    },
    "NF_GETSWSTRACKNOTES_WR c": {
        "prefix": "WR_NF_GetSWSTrackNotes",
        "scope": "c",
        "description": "\n",
        "body": "${1:const char*} = NF_GetSWSTrackNotes(${2:MediaTrack* track})$0"
    },
    "REAPER.NF_GETSWSTRACKNOTES_WR lua": {
        "prefix": "reaperwr.NF_GetSWSTrackNotes",
        "scope": "lua",
        "description": "\n",
        "body": "${1:local }${2:string} = reaper.NF_GetSWSTrackNotes(${3:MediaTrack track})$0"
    },
    "NF_GETSWSTRACKNOTES_WR python": {
        "prefix": "WR_NF_GetSWSTrackNotes",
        "scope": "python",
        "description": "\n",
        "body": "${1:String} = NF_GetSWSTrackNotes(${2:MediaTrack track})$0"
    },
    "NF_SETSWSMARKERREGIONSUB_WR c": {
        "prefix": "WR_NF_SetSWSMarkerRegionSub",
        "scope": "c",
        "description": "Set SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns true if subtitle is set\nsuccessfully (i.e. marker/region with specified index is present in\nproject). Lua code example here.\n",
        "body": "${1:bool} = NF_SetSWSMarkerRegionSub(${2:const char* markerRegionSub},${3:int markerRegionIdx})$0"
    },
    "REAPER.NF_SETSWSMARKERREGIONSUB_WR lua": {
        "prefix": "reaperwr.NF_SetSWSMarkerRegionSub",
        "scope": "lua",
        "description": "Set SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns true if subtitle is set\nsuccessfully (i.e. marker/region with specified index is present in\nproject). Lua code example here.\n",
        "body": "${1:local }${2:boolean} = reaper.NF_SetSWSMarkerRegionSub(${3:string markerRegionSub},${4:integer markerRegionIdx})$0"
    },
    "NF_SETSWSMARKERREGIONSUB_WR python": {
        "prefix": "WR_NF_SetSWSMarkerRegionSub",
        "scope": "python",
        "description": "Set SWS/S&M marker/region subtitle. markerRegionIdx: Refers to index that can be passed to EnumProjectMarkers\n(not displayed marker/region index). Returns true if subtitle is set\nsuccessfully (i.e. marker/region with specified index is present in\nproject). Lua code example here.\n",
        "body": "${1:Boolean} = NF_SetSWSMarkerRegionSub(${2:String markerRegionSub},${3:Int markerRegionIdx})$0"
    },
    "NF_SETSWSTRACKNOTES_WR c": {
        "prefix": "WR_NF_SetSWSTrackNotes",
        "scope": "c",
        "description": "\n",
        "body": "${1:void} = NF_SetSWSTrackNotes(${2:MediaTrack* track},${3:const char* str})$0"
    },
    "NF_UPDATESWSMARKERREGIONSUBWINDOW_WR c": {
        "prefix": "WR_NF_UpdateSWSMarkerRegionSubWindow",
        "scope": "c",
        "description": "Redraw the Notes window (call if you've changed a subtitle via NF_SetSWSMarkerRegionSub which is currently displayed in the Notes window and you want to appear the new subtitle immediately.)\n",
        "body": "${1:void} = NF_UpdateSWSMarkerRegionSubWindow()$0"
    },
    "REAPACK_ABOUTINSTALLEDPACKAGE_WR c": {
        "prefix": "WR_ReaPack_AboutInstalledPackage",
        "scope": "c",
        "description": "Show the about dialog of the given package entry.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "${1:bool} = ReaPack_AboutInstalledPackage(${2:PackageEntry* entry})$0"
    },
    "REAPER.REAPACK_ABOUTINSTALLEDPACKAGE_WR lua": {
        "prefix": "reaperwr.ReaPack_AboutInstalledPackage",
        "scope": "lua",
        "description": "Show the about dialog of the given package entry.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "${1:local }${2:boolean} = reaper.ReaPack_AboutInstalledPackage(${3:PackageEntry entry})$0"
    },
    "REAPACK_ABOUTINSTALLEDPACKAGE_WR python": {
        "prefix": "WR_ReaPack_AboutInstalledPackage",
        "scope": "python",
        "description": "Show the about dialog of the given package entry.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "${1:Boolean} = ReaPack_AboutInstalledPackage(${2:PackageEntry entry})$0"
    },
    "REAPACK_ABOUTREPOSITORY_WR c": {
        "prefix": "WR_ReaPack_AboutRepository",
        "scope": "c",
        "description": "Show the about dialog of the given repository. Returns true if the repository exists in the user configuration.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "${1:bool} = ReaPack_AboutRepository(${2:const char* repoName})$0"
    },
    "REAPER.REAPACK_ABOUTREPOSITORY_WR lua": {
        "prefix": "reaperwr.ReaPack_AboutRepository",
        "scope": "lua",
        "description": "Show the about dialog of the given repository. Returns true if the repository exists in the user configuration.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "${1:local }${2:boolean} = reaper.ReaPack_AboutRepository(${3:string repoName})$0"
    },
    "REAPACK_ABOUTREPOSITORY_WR python": {
        "prefix": "WR_ReaPack_AboutRepository",
        "scope": "python",
        "description": "Show the about dialog of the given repository. Returns true if the repository exists in the user configuration.\nThe repository index is downloaded asynchronously if the cached copy doesn't exist or is older than one week.\n",
        "body": "${1:Boolean} = ReaPack_AboutRepository(${2:String repoName})$0"
    },
    "REAPACK_ADDSETREPOSITORY_WR c": {
        "prefix": "WR_ReaPack_AddSetRepository",
        "scope": "c",
        "description": "Add or modify a repository. Set url to nullptr (or empty string in Lua) to keep the existing URL. Call ReaPack_ProcessQueue(true) when done to process the new list and update the GUI.\nautoInstall: usually set to 2 (obey user setting).\n",
        "body": "${1:bool} = ReaPack_AddSetRepository(${2:const char* name},${3:const char* url},${4:bool enable},${5:int autoInstall},${6:char* errorOut},${7:int errorOut_sz})$0"
    },
    "REAPER.REAPACK_ADDSETREPOSITORY_WR lua": {
        "prefix": "reaperwr.ReaPack_AddSetRepository",
        "scope": "lua",
        "description": "Add or modify a repository. Set url to nullptr (or empty string in Lua) to keep the existing URL. Call ReaPack_ProcessQueue(true) when done to process the new list and update the GUI.\nautoInstall: usually set to 2 (obey user setting).\n",
        "body": "${1:local }${2:boolean retval},${3:string error} = reaper.ReaPack_AddSetRepository(${4:string name},${5:string url},${6:boolean enable},${7:integer autoInstall})$0"
    },
    "REAPACK_ADDSETREPOSITORY_WR python": {
        "prefix": "WR_ReaPack_AddSetRepository",
        "scope": "python",
        "description": "Add or modify a repository. Set url to nullptr (or empty string in Lua) to keep the existing URL. Call ReaPack_ProcessQueue(true) when done to process the new list and update the GUI.\nautoInstall: usually set to 2 (obey user setting).\n",
        "body": "${1:Boolean retval},${2:String name},${3:String url},${4:Boolean enable},${5:Int autoInstall},${6:String errorOut},${7:Int errorOut_sz} = ReaPack_AddSetRepository(${8:name},${9:url},${10:enable},${11:autoInstall},${12:errorOut},${13:errorOut_sz})$0"
    },
    "REAPACK_BROWSEPACKAGES_WR c": {
        "prefix": "WR_ReaPack_BrowsePackages",
        "scope": "c",
        "description": "Opens the package browser with the given filter string.\n",
        "body": "${1:void} = ReaPack_BrowsePackages(${2:const char* filter})$0"
    },
    "REAPACK_COMPAREVERSIONS_WR c": {
        "prefix": "WR_ReaPack_CompareVersions",
        "scope": "c",
        "description": "Returns 0 if both versions are equal, a positive value if ver1 is higher than ver2 and a negative value otherwise.\n",
        "body": "${1:int} = ReaPack_CompareVersions(${2:const char* ver1},${3:const char* ver2},${4:char* errorOut},${5:int errorOut_sz})$0"
    },
    "REAPER.REAPACK_COMPAREVERSIONS_WR lua": {
        "prefix": "reaperwr.ReaPack_CompareVersions",
        "scope": "lua",
        "description": "Returns 0 if both versions are equal, a positive value if ver1 is higher than ver2 and a negative value otherwise.\n",
        "body": "${1:local }${2:integer retval},${3:string error} = reaper.ReaPack_CompareVersions(${4:string ver1},${5:string ver2})$0"
    },
    "REAPACK_COMPAREVERSIONS_WR python": {
        "prefix": "WR_ReaPack_CompareVersions",
        "scope": "python",
        "description": "Returns 0 if both versions are equal, a positive value if ver1 is higher than ver2 and a negative value otherwise.\n",
        "body": "${1:Int retval},${2:String ver1},${3:String ver2},${4:String errorOut},${5:Int errorOut_sz} = ReaPack_CompareVersions(${6:ver1},${7:ver2},${8:errorOut},${9:errorOut_sz})$0"
    },
    "REAPACK_ENUMOWNEDFILES_WR c": {
        "prefix": "WR_ReaPack_EnumOwnedFiles",
        "scope": "c",
        "description": "Enumerate the files owned by the given package. Returns false when there is no more data.\nsections: 0=not in action list, &1=main, &2=midi editor, &4=midi inline editor\ntype: see ReaPack_GetEntryInfo.\n",
        "body": "${1:bool} = ReaPack_EnumOwnedFiles(${2:PackageEntry* entry},${3:int index},${4:char* pathOut},${5:int pathOut_sz},${6:int* sectionsOut},${7:int* typeOut})$0"
    },
    "REAPER.REAPACK_ENUMOWNEDFILES_WR lua": {
        "prefix": "reaperwr.ReaPack_EnumOwnedFiles",
        "scope": "lua",
        "description": "Enumerate the files owned by the given package. Returns false when there is no more data.\nsections: 0=not in action list, &1=main, &2=midi editor, &4=midi inline editor\ntype: see ReaPack_GetEntryInfo.\n",
        "body": "${1:local }${2:boolean retval},${3:string path},${4:number sections},${5:number type} = reaper.ReaPack_EnumOwnedFiles(${6:PackageEntry entry},${7:integer index})$0"
    },
    "REAPACK_ENUMOWNEDFILES_WR python": {
        "prefix": "WR_ReaPack_EnumOwnedFiles",
        "scope": "python",
        "description": "Enumerate the files owned by the given package. Returns false when there is no more data.\nsections: 0=not in action list, &1=main, &2=midi editor, &4=midi inline editor\ntype: see ReaPack_GetEntryInfo.\n",
        "body": "${1:Boolean retval},${2:PackageEntry entry},${3:Int index},${4:String pathOut},${5:Int pathOut_sz},${6:Int sectionsOut},${7:Int typeOut} = ReaPack_EnumOwnedFiles(${8:entry},${9:index},${10:pathOut},${11:pathOut_sz},${12:sectionsOut},${13:typeOut})$0"
    },
    "REAPACK_FREEENTRY_WR c": {
        "prefix": "WR_ReaPack_FreeEntry",
        "scope": "c",
        "description": "Free resources allocated for the given package entry.\n",
        "body": "${1:bool} = ReaPack_FreeEntry(${2:PackageEntry* entry})$0"
    },
    "REAPER.REAPACK_FREEENTRY_WR lua": {
        "prefix": "reaperwr.ReaPack_FreeEntry",
        "scope": "lua",
        "description": "Free resources allocated for the given package entry.\n",
        "body": "${1:local }${2:boolean} = reaper.ReaPack_FreeEntry(${3:PackageEntry entry})$0"
    },
    "REAPACK_FREEENTRY_WR python": {
        "prefix": "WR_ReaPack_FreeEntry",
        "scope": "python",
        "description": "Free resources allocated for the given package entry.\n",
        "body": "${1:Boolean} = ReaPack_FreeEntry(${2:PackageEntry entry})$0"
    },
    "REAPACK_GETENTRYINFO_WR c": {
        "prefix": "WR_ReaPack_GetEntryInfo",
        "scope": "c",
        "description": "Get the repository name, category, package name, package description,\npackage type, the currently installed version, author name, pinned\nstatus and how many files are owned by the given package entry.\ntype: 1=script, 2=extension, 3=effect, 4=data, 5=theme, 6=langpack, 7=webinterface\n",
        "body": "${1:bool} = ReaPack_GetEntryInfo(${2:PackageEntry* entry},${3:char* repoOut},${4:int repoOut_sz},${5:char* catOut},${6:int catOut_sz},${7:char* pkgOut},${8:int pkgOut_sz},${9:char* descOut},${10:int descOut_sz},${11:int* typeOut},${12:char* verOut},${13:int verOut_sz},${14:char* authorOut},${15:int authorOut_sz},${16:bool* pinnedOut},${17:int* fileCountOut})$0"
    },
    "REAPER.REAPACK_GETENTRYINFO_WR lua": {
        "prefix": "reaperwr.ReaPack_GetEntryInfo",
        "scope": "lua",
        "description": "Get the repository name, category, package name, package description,\npackage type, the currently installed version, author name, pinned\nstatus and how many files are owned by the given package entry.\ntype: 1=script, 2=extension, 3=effect, 4=data, 5=theme, 6=langpack, 7=webinterface\n",
        "body": "${1:local }${2:boolean retval},${3:string repo},${4:string cat},${5:string pkg},${6:string desc},${7:number type},${8:string ver},${9:string author},${10:boolean pinned},${11:number fileCount} = reaper.ReaPack_GetEntryInfo(${12:PackageEntry entry})$0"
    },
    "REAPACK_GETENTRYINFO_WR python": {
        "prefix": "WR_ReaPack_GetEntryInfo",
        "scope": "python",
        "description": "Get the repository name, category, package name, package description,\npackage type, the currently installed version, author name, pinned\nstatus and how many files are owned by the given package entry.\ntype: 1=script, 2=extension, 3=effect, 4=data, 5=theme, 6=langpack, 7=webinterface\n",
        "body": "${1:Boolean retval},${2:PackageEntry entry},${3:String repoOut},${4:Int repoOut_sz},${5:String catOut},${6:Int catOut_sz},${7:String pkgOut},${8:Int pkgOut_sz},${9:String descOut},${10:Int descOut_sz},${11:Int typeOut},${12:String verOut},${13:Int verOut_sz},${14:String authorOut},${15:Int authorOut_sz},${16:Boolean pinnedOut},${17:Int fileCountOut} = ReaPack_GetEntryInfo(${18:entry},${19:repoOut},${20:repoOut_sz},${21:catOut},${22:catOut_sz},${23:pkgOut},${24:pkgOut_sz},${25:descOut},${26:descOut_sz},${27:typeOut},${28:verOut},${29:verOut_sz},${30:authorOut},${31:authorOut_sz},${32:pinnedOut},${33:fileCountOut})$0"
    },
    "REAPACK_GETOWNER_WR c": {
        "prefix": "WR_ReaPack_GetOwner",
        "scope": "c",
        "description": "Returns the package entry owning the given file.\nDelete the returned object from memory after use with ReaPack_FreeEntry.\n",
        "body": "${1:PackageEntry*} = ReaPack_GetOwner(${2:const char* fn},${3:char* errorOut},${4:int errorOut_sz})$0"
    },
    "REAPER.REAPACK_GETOWNER_WR lua": {
        "prefix": "reaperwr.ReaPack_GetOwner",
        "scope": "lua",
        "description": "Returns the package entry owning the given file.\nDelete the returned object from memory after use with ReaPack_FreeEntry.\n",
        "body": "${1:local }${2:PackageEntry retval},${3:string error} = reaper.ReaPack_GetOwner(${4:string fn})$0"
    },
    "REAPACK_GETOWNER_WR python": {
        "prefix": "WR_ReaPack_GetOwner",
        "scope": "python",
        "description": "Returns the package entry owning the given file.\nDelete the returned object from memory after use with ReaPack_FreeEntry.\n",
        "body": "${1:PackageEntry retval},${2:String fn},${3:String errorOut},${4:Int errorOut_sz} = ReaPack_GetOwner(${5:fn},${6:errorOut},${7:errorOut_sz})$0"
    },
    "REAPACK_GETREPOSITORYINFO_WR c": {
        "prefix": "WR_ReaPack_GetRepositoryInfo",
        "scope": "c",
        "description": "Get the infos of the given repository.\nautoInstall: 0=manual, 1=when sychronizing, 2=obey user setting\n",
        "body": "${1:bool} = ReaPack_GetRepositoryInfo(${2:const char* name},${3:char* urlOut},${4:int urlOut_sz},${5:bool* enabledOut},${6:int* autoInstallOut})$0"
    },
    "REAPER.REAPACK_GETREPOSITORYINFO_WR lua": {
        "prefix": "reaperwr.ReaPack_GetRepositoryInfo",
        "scope": "lua",
        "description": "Get the infos of the given repository.\nautoInstall: 0=manual, 1=when sychronizing, 2=obey user setting\n",
        "body": "${1:local }${2:boolean retval},${3:string url},${4:boolean enabled},${5:number autoInstall} = reaper.ReaPack_GetRepositoryInfo(${6:string name})$0"
    },
    "REAPACK_GETREPOSITORYINFO_WR python": {
        "prefix": "WR_ReaPack_GetRepositoryInfo",
        "scope": "python",
        "description": "Get the infos of the given repository.\nautoInstall: 0=manual, 1=when sychronizing, 2=obey user setting\n",
        "body": "${1:Boolean retval},${2:String name},${3:String urlOut},${4:Int urlOut_sz},${5:Boolean enabledOut},${6:Int autoInstallOut} = ReaPack_GetRepositoryInfo(${7:name},${8:urlOut},${9:urlOut_sz},${10:enabledOut},${11:autoInstallOut})$0"
    },
    "REAPACK_PROCESSQUEUE_WR c": {
        "prefix": "WR_ReaPack_ProcessQueue",
        "scope": "c",
        "description": "Run pending operations and save the configuration file. If refreshUI is\ntrue the browser and manager windows are guaranteed to be refreshed\n(otherwise it depends on which operations are in the queue).\n",
        "body": "${1:void} = ReaPack_ProcessQueue(${2:bool refreshUI})$0"
    },
    "SNM_ADDRECEIVE_WR c": {
        "prefix": "WR_SNM_AddReceive",
        "scope": "c",
        "description": "[S&M] Deprecated, see CreateTrackSend (v5.15pre1+). Adds a receive. Returns false if nothing updated.\ntype -1=Default type (user preferences), 0=Post-Fader (Post-Pan), 1=Pre-FX, 2=deprecated, 3=Pre-Fader (Post-FX).\nNote: obeys default sends preferences, supports frozen tracks, etc..\n",
        "body": "${1:bool} = SNM_AddReceive(${2:MediaTrack* src},${3:MediaTrack* dest},${4:int type})$0"
    },
    "REAPER.SNM_ADDRECEIVE_WR lua": {
        "prefix": "reaperwr.SNM_AddReceive",
        "scope": "lua",
        "description": "[S&M] Deprecated, see CreateTrackSend (v5.15pre1+). Adds a receive. Returns false if nothing updated.\ntype -1=Default type (user preferences), 0=Post-Fader (Post-Pan), 1=Pre-FX, 2=deprecated, 3=Pre-Fader (Post-FX).\nNote: obeys default sends preferences, supports frozen tracks, etc..\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_AddReceive(${3:MediaTrack src},${4:MediaTrack dest},${5:integer type})$0"
    },
    "SNM_ADDRECEIVE_WR python": {
        "prefix": "WR_SNM_AddReceive",
        "scope": "python",
        "description": "[S&M] Deprecated, see CreateTrackSend (v5.15pre1+). Adds a receive. Returns false if nothing updated.\ntype -1=Default type (user preferences), 0=Post-Fader (Post-Pan), 1=Pre-FX, 2=deprecated, 3=Pre-Fader (Post-FX).\nNote: obeys default sends preferences, supports frozen tracks, etc..\n",
        "body": "${1:Boolean} = SNM_AddReceive(${2:MediaTrack src},${3:MediaTrack dest},${4:Int type})$0"
    },
    "SNM_ADDTCPFXPARM_WR c": {
        "prefix": "WR_SNM_AddTCPFXParm",
        "scope": "c",
        "description": "[S&M] Add an FX parameter knob in the TCP. Returns false if nothing\nupdated (invalid parameters, knob already present, etc..)\n",
        "body": "${1:bool} = SNM_AddTCPFXParm(${2:MediaTrack* tr},${3:int fxId},${4:int prmId})$0"
    },
    "REAPER.SNM_ADDTCPFXPARM_WR lua": {
        "prefix": "reaperwr.SNM_AddTCPFXParm",
        "scope": "lua",
        "description": "[S&M] Add an FX parameter knob in the TCP. Returns false if nothing\nupdated (invalid parameters, knob already present, etc..)\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_AddTCPFXParm(${3:MediaTrack tr},${4:integer fxId},${5:integer prmId})$0"
    },
    "SNM_ADDTCPFXPARM_WR python": {
        "prefix": "WR_SNM_AddTCPFXParm",
        "scope": "python",
        "description": "[S&M] Add an FX parameter knob in the TCP. Returns false if nothing\nupdated (invalid parameters, knob already present, etc..)\n",
        "body": "${1:Boolean} = SNM_AddTCPFXParm(${2:MediaTrack tr},${3:Int fxId},${4:Int prmId})$0"
    },
    "SNM_CREATEFASTSTRING_WR c": {
        "prefix": "WR_SNM_CreateFastString",
        "scope": "c",
        "description": "[S&M] Instantiates a new \"fast string\". You must delete this string, see SNM_DeleteFastString.\n",
        "body": "${1:WDL_FastString*} = SNM_CreateFastString(${2:const char* str})$0"
    },
    "REAPER.SNM_CREATEFASTSTRING_WR lua": {
        "prefix": "reaperwr.SNM_CreateFastString",
        "scope": "lua",
        "description": "[S&M] Instantiates a new \"fast string\". You must delete this string, see SNM_DeleteFastString.\n",
        "body": "${1:local }${2:WDL_FastString} = reaper.SNM_CreateFastString(${3:string str})$0"
    },
    "SNM_CREATEFASTSTRING_WR python": {
        "prefix": "WR_SNM_CreateFastString",
        "scope": "python",
        "description": "[S&M] Instantiates a new \"fast string\". You must delete this string, see SNM_DeleteFastString.\n",
        "body": "${1:WDL_FastString} = SNM_CreateFastString(${2:String str})$0"
    },
    "SNM_DELETEFASTSTRING_WR c": {
        "prefix": "WR_SNM_DeleteFastString",
        "scope": "c",
        "description": "[S&M] Deletes a \"fast string\" instance.\n",
        "body": "${1:void} = SNM_DeleteFastString(${2:WDL_FastString* str})$0"
    },
    "SNM_GETDOUBLECONFIGVAR_WR c": {
        "prefix": "WR_SNM_GetDoubleConfigVar",
        "scope": "c",
        "description": "[S&M] Returns a double preference (look in project prefs first, then\nin general prefs). Returns errvalue if failed (e.g. varname not found).\n",
        "body": "${1:double} = SNM_GetDoubleConfigVar(${2:const char* varname},${3:double errvalue})$0"
    },
    "REAPER.SNM_GETDOUBLECONFIGVAR_WR lua": {
        "prefix": "reaperwr.SNM_GetDoubleConfigVar",
        "scope": "lua",
        "description": "[S&M] Returns a double preference (look in project prefs first, then\nin general prefs). Returns errvalue if failed (e.g. varname not found).\n",
        "body": "${1:local }${2:number} = reaper.SNM_GetDoubleConfigVar(${3:string varname},${4:number errvalue})$0"
    },
    "SNM_GETDOUBLECONFIGVAR_WR python": {
        "prefix": "WR_SNM_GetDoubleConfigVar",
        "scope": "python",
        "description": "[S&M] Returns a double preference (look in project prefs first, then\nin general prefs). Returns errvalue if failed (e.g. varname not found).\n",
        "body": "${1:Float} = SNM_GetDoubleConfigVar(${2:String varname},${3:Float errvalue})$0"
    },
    "SNM_GETFASTSTRING_WR c": {
        "prefix": "WR_SNM_GetFastString",
        "scope": "c",
        "description": "[S&M] Gets the \"fast string\" content.\n",
        "body": "${1:const char*} = SNM_GetFastString(${2:WDL_FastString* str})$0"
    },
    "REAPER.SNM_GETFASTSTRING_WR lua": {
        "prefix": "reaperwr.SNM_GetFastString",
        "scope": "lua",
        "description": "[S&M] Gets the \"fast string\" content.\n",
        "body": "${1:local }${2:string} = reaper.SNM_GetFastString(${3:WDL_FastString str})$0"
    },
    "SNM_GETFASTSTRING_WR python": {
        "prefix": "WR_SNM_GetFastString",
        "scope": "python",
        "description": "[S&M] Gets the \"fast string\" content.\n",
        "body": "${1:String} = SNM_GetFastString(${2:WDL_FastString str})$0"
    },
    "SNM_GETFASTSTRINGLENGTH_WR c": {
        "prefix": "WR_SNM_GetFastStringLength",
        "scope": "c",
        "description": "[S&M] Gets the \"fast string\" length.\n",
        "body": "${1:int} = SNM_GetFastStringLength(${2:WDL_FastString* str})$0"
    },
    "REAPER.SNM_GETFASTSTRINGLENGTH_WR lua": {
        "prefix": "reaperwr.SNM_GetFastStringLength",
        "scope": "lua",
        "description": "[S&M] Gets the \"fast string\" length.\n",
        "body": "${1:local }${2:integer} = reaper.SNM_GetFastStringLength(${3:WDL_FastString str})$0"
    },
    "SNM_GETFASTSTRINGLENGTH_WR python": {
        "prefix": "WR_SNM_GetFastStringLength",
        "scope": "python",
        "description": "[S&M] Gets the \"fast string\" length.\n",
        "body": "${1:Int} = SNM_GetFastStringLength(${2:WDL_FastString str})$0"
    },
    "SNM_GETINTCONFIGVAR_WR c": {
        "prefix": "WR_SNM_GetIntConfigVar",
        "scope": "c",
        "description": "[S&M] Returns an integer preference (look in project prefs first,\nthen in general prefs). Returns errvalue if failed (e.g. varname not\nfound).\n",
        "body": "${1:int} = SNM_GetIntConfigVar(${2:const char* varname},${3:int errvalue})$0"
    },
    "REAPER.SNM_GETINTCONFIGVAR_WR lua": {
        "prefix": "reaperwr.SNM_GetIntConfigVar",
        "scope": "lua",
        "description": "[S&M] Returns an integer preference (look in project prefs first,\nthen in general prefs). Returns errvalue if failed (e.g. varname not\nfound).\n",
        "body": "${1:local }${2:integer} = reaper.SNM_GetIntConfigVar(${3:string varname},${4:integer errvalue})$0"
    },
    "SNM_GETINTCONFIGVAR_WR python": {
        "prefix": "WR_SNM_GetIntConfigVar",
        "scope": "python",
        "description": "[S&M] Returns an integer preference (look in project prefs first,\nthen in general prefs). Returns errvalue if failed (e.g. varname not\nfound).\n",
        "body": "${1:Int} = SNM_GetIntConfigVar(${2:String varname},${3:Int errvalue})$0"
    },
    "SNM_GETMEDIAITEMTAKEBYGUID_WR c": {
        "prefix": "WR_SNM_GetMediaItemTakeByGUID",
        "scope": "c",
        "description": "[S&M] Gets a take by GUID as string. The GUID must be enclosed in braces {}. To get take GUID as string, see BR_GetMediaItemTakeGUID\n",
        "body": "${1:MediaItem_Take*} = SNM_GetMediaItemTakeByGUID(${2:ReaProject* project},${3:const char* guid})$0"
    },
    "REAPER.SNM_GETMEDIAITEMTAKEBYGUID_WR lua": {
        "prefix": "reaperwr.SNM_GetMediaItemTakeByGUID",
        "scope": "lua",
        "description": "[S&M] Gets a take by GUID as string. The GUID must be enclosed in braces {}. To get take GUID as string, see BR_GetMediaItemTakeGUID\n",
        "body": "${1:local }${2:MediaItem_Take} = reaper.SNM_GetMediaItemTakeByGUID(${3:ReaProject project},${4:string guid})$0"
    },
    "SNM_GETMEDIAITEMTAKEBYGUID_WR python": {
        "prefix": "WR_SNM_GetMediaItemTakeByGUID",
        "scope": "python",
        "description": "[S&M] Gets a take by GUID as string. The GUID must be enclosed in braces {}. To get take GUID as string, see BR_GetMediaItemTakeGUID\n",
        "body": "${1:MediaItem_Take} = SNM_GetMediaItemTakeByGUID(${2:ReaProject project},${3:String guid})$0"
    },
    "SNM_GETPROJECTMARKERNAME_WR c": {
        "prefix": "WR_SNM_GetProjectMarkerName",
        "scope": "c",
        "description": "[S&M] Gets a marker/region name. Returns true if marker/region found.\n",
        "body": "${1:bool} = SNM_GetProjectMarkerName(${2:ReaProject* proj},${3:int num},${4:bool isrgn},${5:WDL_FastString* name})$0"
    },
    "REAPER.SNM_GETPROJECTMARKERNAME_WR lua": {
        "prefix": "reaperwr.SNM_GetProjectMarkerName",
        "scope": "lua",
        "description": "[S&M] Gets a marker/region name. Returns true if marker/region found.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_GetProjectMarkerName(${3:ReaProject proj},${4:integer num},${5:boolean isrgnWDL_FastString name})$0"
    },
    "SNM_GETPROJECTMARKERNAME_WR python": {
        "prefix": "WR_SNM_GetProjectMarkerName",
        "scope": "python",
        "description": "[S&M] Gets a marker/region name. Returns true if marker/region found.\n",
        "body": "${1:Boolean} = SNM_GetProjectMarkerName(${2:ReaProject proj},${3:Int num},${4:Boolean isrgn},${5:WDL_FastString name})$0"
    },
    "SNM_GETSETOBJECTSTATE_WR c": {
        "prefix": "WR_SNM_GetSetObjectState",
        "scope": "c",
        "description": "[S&M] Gets or sets the state of a track, an item or an envelope. The state chunk size is unlimited. Returns false if failed.\nWhen getting a track state (and when you are not interested in FX data),\nyou can use wantminimalstate=true to radically reduce the length of the\nstate. Do not set such minimal states back though, this is for\nread-only applications!\nNote: unlike the native GetSetObjectState, calling to FreeHeapPtr() is not required.\n",
        "body": "${1:bool} = SNM_GetSetObjectState(${2:void* obj},${3:WDL_FastString* state},${4:bool setnewvalue},${5:bool wantminimalstate})$0"
    },
    "REAPER.SNM_GETSETOBJECTSTATE_WR lua": {
        "prefix": "reaperwr.SNM_GetSetObjectState",
        "scope": "lua",
        "description": "[S&M] Gets or sets the state of a track, an item or an envelope. The state chunk size is unlimited. Returns false if failed.\nWhen getting a track state (and when you are not interested in FX data),\nyou can use wantminimalstate=true to radically reduce the length of the\nstate. Do not set such minimal states back though, this is for\nread-only applications!\nNote: unlike the native GetSetObjectState, calling to FreeHeapPtr() is not required.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_GetSetObjectState(${3:identifier objWDL_FastString state},${4:boolean setnewvalue},${5:boolean wantminimalstate})$0"
    },
    "SNM_GETSETOBJECTSTATE_WR python": {
        "prefix": "WR_SNM_GetSetObjectState",
        "scope": "python",
        "description": "[S&M] Gets or sets the state of a track, an item or an envelope. The state chunk size is unlimited. Returns false if failed.\nWhen getting a track state (and when you are not interested in FX data),\nyou can use wantminimalstate=true to radically reduce the length of the\nstate. Do not set such minimal states back though, this is for\nread-only applications!\nNote: unlike the native GetSetObjectState, calling to FreeHeapPtr() is not required.\n",
        "body": "${1:Boolean} = SNM_GetSetObjectState(${2:void obj},${3:WDL_FastString state},${4:Boolean setnewvalue},${5:Boolean wantminimalstate})$0"
    },
    "SNM_GETSETSOURCESTATE_WR c": {
        "prefix": "WR_SNM_GetSetSourceState",
        "scope": "c",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed. Use takeidx=-1 to get/alter the active take.\nNote: this function does not use a MediaItem_Take* param in order to\nmanage empty takes (i.e. takes with MediaItem_Take*==NULL), see SNM_GetSetSourceState2.\n",
        "body": "${1:bool} = SNM_GetSetSourceState(${2:MediaItem* item},${3:int takeidx},${4:WDL_FastString* state},${5:bool setnewvalue})$0"
    },
    "REAPER.SNM_GETSETSOURCESTATE_WR lua": {
        "prefix": "reaperwr.SNM_GetSetSourceState",
        "scope": "lua",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed. Use takeidx=-1 to get/alter the active take.\nNote: this function does not use a MediaItem_Take* param in order to\nmanage empty takes (i.e. takes with MediaItem_Take*==NULL), see SNM_GetSetSourceState2.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_GetSetSourceState(${3:MediaItem item},${4:integer takeidxWDL_FastString state},${5:boolean setnewvalue})$0"
    },
    "SNM_GETSETSOURCESTATE_WR python": {
        "prefix": "WR_SNM_GetSetSourceState",
        "scope": "python",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed. Use takeidx=-1 to get/alter the active take.\nNote: this function does not use a MediaItem_Take* param in order to\nmanage empty takes (i.e. takes with MediaItem_Take*==NULL), see SNM_GetSetSourceState2.\n",
        "body": "${1:Boolean} = SNM_GetSetSourceState(${2:MediaItem item},${3:Int takeidx},${4:WDL_FastString state},${5:Boolean setnewvalue})$0"
    },
    "SNM_GETSETSOURCESTATE2_WR c": {
        "prefix": "WR_SNM_GetSetSourceState2",
        "scope": "c",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed.\nNote: this function cannot deal with empty takes, see SNM_GetSetSourceState.\n",
        "body": "${1:bool} = SNM_GetSetSourceState2(${2:MediaItem_Take* take},${3:WDL_FastString* state},${4:bool setnewvalue})$0"
    },
    "REAPER.SNM_GETSETSOURCESTATE2_WR lua": {
        "prefix": "reaperwr.SNM_GetSetSourceState2",
        "scope": "lua",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed.\nNote: this function cannot deal with empty takes, see SNM_GetSetSourceState.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_GetSetSourceState2(${3:MediaItem_Take takeWDL_FastString state},${4:boolean setnewvalue})$0"
    },
    "SNM_GETSETSOURCESTATE2_WR python": {
        "prefix": "WR_SNM_GetSetSourceState2",
        "scope": "python",
        "description": "[S&M] Gets or sets a take source state. Returns false if failed.\nNote: this function cannot deal with empty takes, see SNM_GetSetSourceState.\n",
        "body": "${1:Boolean} = SNM_GetSetSourceState2(${2:MediaItem_Take take},${3:WDL_FastString state},${4:Boolean setnewvalue})$0"
    },
    "SNM_GETSOURCETYPE_WR c": {
        "prefix": "WR_SNM_GetSourceType",
        "scope": "c",
        "description": "[S&M] Gets the source type of a take. Returns false if failed (e.g. take with empty source, etc..)\n",
        "body": "${1:bool} = SNM_GetSourceType(${2:MediaItem_Take* take},${3:WDL_FastString* type})$0"
    },
    "REAPER.SNM_GETSOURCETYPE_WR lua": {
        "prefix": "reaperwr.SNM_GetSourceType",
        "scope": "lua",
        "description": "[S&M] Gets the source type of a take. Returns false if failed (e.g. take with empty source, etc..)\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_GetSourceType(${3:MediaItem_Take takeWDL_FastString type})$0"
    },
    "SNM_GETSOURCETYPE_WR python": {
        "prefix": "WR_SNM_GetSourceType",
        "scope": "python",
        "description": "[S&M] Gets the source type of a take. Returns false if failed (e.g. take with empty source, etc..)\n",
        "body": "${1:Boolean} = SNM_GetSourceType(${2:MediaItem_Take take},${3:WDL_FastString type})$0"
    },
    "SNM_MOVEORREMOVETRACKFX_WR c": {
        "prefix": "WR_SNM_MoveOrRemoveTrackFX",
        "scope": "c",
        "description": "[S&M] Deprecated, see TakeFX_/TrackFX_ CopyToTrack/Take,\nTrackFX/TakeFX _Delete (v5.95pre2+). Move or removes a track FX. Returns\ntrue if tr has been updated.\nfxId: fx index in chain or -1 for the selected fx. what: 0 to remove, -1 to move fx up in chain, 1 to move fx down in chain.\n",
        "body": "${1:bool} = SNM_MoveOrRemoveTrackFX(${2:MediaTrack* tr},${3:int fxId},${4:int what})$0"
    },
    "REAPER.SNM_MOVEORREMOVETRACKFX_WR lua": {
        "prefix": "reaperwr.SNM_MoveOrRemoveTrackFX",
        "scope": "lua",
        "description": "[S&M] Deprecated, see TakeFX_/TrackFX_ CopyToTrack/Take,\nTrackFX/TakeFX _Delete (v5.95pre2+). Move or removes a track FX. Returns\ntrue if tr has been updated.\nfxId: fx index in chain or -1 for the selected fx. what: 0 to remove, -1 to move fx up in chain, 1 to move fx down in chain.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_MoveOrRemoveTrackFX(${3:MediaTrack tr},${4:integer fxId},${5:integer what})$0"
    },
    "SNM_MOVEORREMOVETRACKFX_WR python": {
        "prefix": "WR_SNM_MoveOrRemoveTrackFX",
        "scope": "python",
        "description": "[S&M] Deprecated, see TakeFX_/TrackFX_ CopyToTrack/Take,\nTrackFX/TakeFX _Delete (v5.95pre2+). Move or removes a track FX. Returns\ntrue if tr has been updated.\nfxId: fx index in chain or -1 for the selected fx. what: 0 to remove, -1 to move fx up in chain, 1 to move fx down in chain.\n",
        "body": "${1:Boolean} = SNM_MoveOrRemoveTrackFX(${2:MediaTrack tr},${3:Int fxId},${4:Int what})$0"
    },
    "SNM_READMEDIAFILETAG_WR c": {
        "prefix": "WR_SNM_ReadMediaFileTag",
        "scope": "c",
        "description": "[S&M] Reads a media file tag. Supported tags: \"artist\", \"album\",\n\"genre\", \"comment\", \"title\", or \"year\". Returns false if tag was not\nfound. See SNM_TagMediaFile.\n",
        "body": "${1:bool} = SNM_ReadMediaFileTag(${2:const char* fn},${3:const char* tag},${4:char* tagval},${5:int tagval_sz})$0"
    },
    "REAPER.SNM_READMEDIAFILETAG_WR lua": {
        "prefix": "reaperwr.SNM_ReadMediaFileTag",
        "scope": "lua",
        "description": "[S&M] Reads a media file tag. Supported tags: \"artist\", \"album\",\n\"genre\", \"comment\", \"title\", or \"year\". Returns false if tag was not\nfound. See SNM_TagMediaFile.\n",
        "body": "${1:local }${2:boolean retval},${3:string tagval} = reaper.SNM_ReadMediaFileTag(${4:string fn},${5:string tag},${6:string tagval})$0"
    },
    "SNM_READMEDIAFILETAG_WR python": {
        "prefix": "WR_SNM_ReadMediaFileTag",
        "scope": "python",
        "description": "[S&M] Reads a media file tag. Supported tags: \"artist\", \"album\",\n\"genre\", \"comment\", \"title\", or \"year\". Returns false if tag was not\nfound. See SNM_TagMediaFile.\n",
        "body": "${1:Boolean retval},${2:String fn},${3:String tag},${4:String tagval},${5:Int tagval_sz} = SNM_ReadMediaFileTag(${6:fn},${7:tag},${8:tagval},${9:tagval_sz})$0"
    },
    "SNM_REMOVERECEIVE_WR c": {
        "prefix": "WR_SNM_RemoveReceive",
        "scope": "c",
        "description": "[S&M] Deprecated, see RemoveTrackSend (v5.15pre1+). Removes a receive. Returns false if nothing updated.\n",
        "body": "${1:bool} = SNM_RemoveReceive(${2:MediaTrack* tr},${3:int rcvidx})$0"
    },
    "REAPER.SNM_REMOVERECEIVE_WR lua": {
        "prefix": "reaperwr.SNM_RemoveReceive",
        "scope": "lua",
        "description": "[S&M] Deprecated, see RemoveTrackSend (v5.15pre1+). Removes a receive. Returns false if nothing updated.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_RemoveReceive(${3:MediaTrack tr},${4:integer rcvidx})$0"
    },
    "SNM_REMOVERECEIVE_WR python": {
        "prefix": "WR_SNM_RemoveReceive",
        "scope": "python",
        "description": "[S&M] Deprecated, see RemoveTrackSend (v5.15pre1+). Removes a receive. Returns false if nothing updated.\n",
        "body": "${1:Boolean} = SNM_RemoveReceive(${2:MediaTrack tr},${3:Int rcvidx})$0"
    },
    "SNM_REMOVERECEIVESFROM_WR c": {
        "prefix": "WR_SNM_RemoveReceivesFrom",
        "scope": "c",
        "description": "[S&M] Removes all receives from srctr. Returns false if nothing updated.\n",
        "body": "${1:bool} = SNM_RemoveReceivesFrom(${2:MediaTrack* tr},${3:MediaTrack* srctr})$0"
    },
    "REAPER.SNM_REMOVERECEIVESFROM_WR lua": {
        "prefix": "reaperwr.SNM_RemoveReceivesFrom",
        "scope": "lua",
        "description": "[S&M] Removes all receives from srctr. Returns false if nothing updated.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_RemoveReceivesFrom(${3:MediaTrack tr},${4:MediaTrack srctr})$0"
    },
    "SNM_REMOVERECEIVESFROM_WR python": {
        "prefix": "WR_SNM_RemoveReceivesFrom",
        "scope": "python",
        "description": "[S&M] Removes all receives from srctr. Returns false if nothing updated.\n",
        "body": "${1:Boolean} = SNM_RemoveReceivesFrom(${2:MediaTrack tr},${3:MediaTrack srctr})$0"
    },
    "SNM_SELECTRESOURCEBOOKMARK_WR c": {
        "prefix": "WR_SNM_SelectResourceBookmark",
        "scope": "c",
        "description": "[S&M] Select a bookmark of the Resources window. Returns the related bookmark id (or -1 if failed).\n",
        "body": "${1:int} = SNM_SelectResourceBookmark(${2:const char* name})$0"
    },
    "REAPER.SNM_SELECTRESOURCEBOOKMARK_WR lua": {
        "prefix": "reaperwr.SNM_SelectResourceBookmark",
        "scope": "lua",
        "description": "[S&M] Select a bookmark of the Resources window. Returns the related bookmark id (or -1 if failed).\n",
        "body": "${1:local }${2:integer} = reaper.SNM_SelectResourceBookmark(${3:string name})$0"
    },
    "SNM_SELECTRESOURCEBOOKMARK_WR python": {
        "prefix": "WR_SNM_SelectResourceBookmark",
        "scope": "python",
        "description": "[S&M] Select a bookmark of the Resources window. Returns the related bookmark id (or -1 if failed).\n",
        "body": "${1:Int} = SNM_SelectResourceBookmark(${2:String name})$0"
    },
    "SNM_SETDOUBLECONFIGVAR_WR c": {
        "prefix": "WR_SNM_SetDoubleConfigVar",
        "scope": "c",
        "description": "[S&M] Sets a double preference (look in project prefs first, then in\ngeneral prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "${1:bool} = SNM_SetDoubleConfigVar(${2:const char* varname},${3:double newvalue})$0"
    },
    "REAPER.SNM_SETDOUBLECONFIGVAR_WR lua": {
        "prefix": "reaperwr.SNM_SetDoubleConfigVar",
        "scope": "lua",
        "description": "[S&M] Sets a double preference (look in project prefs first, then in\ngeneral prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_SetDoubleConfigVar(${3:string varname},${4:number newvalue})$0"
    },
    "SNM_SETDOUBLECONFIGVAR_WR python": {
        "prefix": "WR_SNM_SetDoubleConfigVar",
        "scope": "python",
        "description": "[S&M] Sets a double preference (look in project prefs first, then in\ngeneral prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "${1:Boolean} = SNM_SetDoubleConfigVar(${2:String varname},${3:Float newvalue})$0"
    },
    "SNM_SETFASTSTRING_WR c": {
        "prefix": "WR_SNM_SetFastString",
        "scope": "c",
        "description": "[S&M] Sets the \"fast string\" content. Returns str for facility.\n",
        "body": "${1:WDL_FastString*} = SNM_SetFastString(${2:WDL_FastString* str},${3:const char* newstr})$0"
    },
    "REAPER.SNM_SETFASTSTRING_WR lua": {
        "prefix": "reaperwr.SNM_SetFastString",
        "scope": "lua",
        "description": "[S&M] Sets the \"fast string\" content. Returns str for facility.\n",
        "body": "${1:local }${2:WDL_FastString} = reaper.SNM_SetFastString(${3:WDL_FastString str},${4:string newstr})$0"
    },
    "SNM_SETFASTSTRING_WR python": {
        "prefix": "WR_SNM_SetFastString",
        "scope": "python",
        "description": "[S&M] Sets the \"fast string\" content. Returns str for facility.\n",
        "body": "${1:WDL_FastString} = SNM_SetFastString(${2:WDL_FastString str},${3:String newstr})$0"
    },
    "SNM_SETINTCONFIGVAR_WR c": {
        "prefix": "WR_SNM_SetIntConfigVar",
        "scope": "c",
        "description": "[S&M] Sets an integer preference (look in project prefs first, then\nin general prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "${1:bool} = SNM_SetIntConfigVar(${2:const char* varname},${3:int newvalue})$0"
    },
    "REAPER.SNM_SETINTCONFIGVAR_WR lua": {
        "prefix": "reaperwr.SNM_SetIntConfigVar",
        "scope": "lua",
        "description": "[S&M] Sets an integer preference (look in project prefs first, then\nin general prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_SetIntConfigVar(${3:string varname},${4:integer newvalue})$0"
    },
    "SNM_SETINTCONFIGVAR_WR python": {
        "prefix": "WR_SNM_SetIntConfigVar",
        "scope": "python",
        "description": "[S&M] Sets an integer preference (look in project prefs first, then\nin general prefs). Returns false if failed (e.g. varname not found).\n",
        "body": "${1:Boolean} = SNM_SetIntConfigVar(${2:String varname},${3:Int newvalue})$0"
    },
    "SNM_SETPROJECTMARKER_WR c": {
        "prefix": "WR_SNM_SetProjectMarker",
        "scope": "c",
        "description": "[S&M] Deprecated, see SetProjectMarker4 -- Same function as SetProjectMarker3() except it can set empty names \"\".\n",
        "body": "${1:bool} = SNM_SetProjectMarker(${2:ReaProject* proj},${3:int num},${4:bool isrgn},${5:double pos},${6:double rgnend},${7:const char* name},${8:int color})$0"
    },
    "REAPER.SNM_SETPROJECTMARKER_WR lua": {
        "prefix": "reaperwr.SNM_SetProjectMarker",
        "scope": "lua",
        "description": "[S&M] Deprecated, see SetProjectMarker4 -- Same function as SetProjectMarker3() except it can set empty names \"\".\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_SetProjectMarker(${3:ReaProject proj},${4:integer num},${5:boolean isrgn},${6:number pos},${7:number rgnend},${8:string name},${9:integer color})$0"
    },
    "SNM_SETPROJECTMARKER_WR python": {
        "prefix": "WR_SNM_SetProjectMarker",
        "scope": "python",
        "description": "[S&M] Deprecated, see SetProjectMarker4 -- Same function as SetProjectMarker3() except it can set empty names \"\".\n",
        "body": "${1:Boolean} = SNM_SetProjectMarker(${2:ReaProject proj},${3:Int num},${4:Boolean isrgn},${5:Float pos},${6:Float rgnend},${7:String name},${8:Int color})$0"
    },
    "SNM_TAGMEDIAFILE_WR c": {
        "prefix": "WR_SNM_TagMediaFile",
        "scope": "c",
        "description": "[S&M] Tags a media file thanks to TagLib.\nSupported tags: \"artist\", \"album\", \"genre\", \"comment\", \"title\", or\n\"year\". Use an empty tagval to clear a tag. When a file is opened in\nREAPER, turn it offline before using this function. Returns false if\nnothing updated. See SNM_ReadMediaFileTag.\n",
        "body": "${1:bool} = SNM_TagMediaFile(${2:const char* fn},${3:const char* tag},${4:const char* tagval})$0"
    },
    "REAPER.SNM_TAGMEDIAFILE_WR lua": {
        "prefix": "reaperwr.SNM_TagMediaFile",
        "scope": "lua",
        "description": "[S&M] Tags a media file thanks to TagLib.\nSupported tags: \"artist\", \"album\", \"genre\", \"comment\", \"title\", or\n\"year\". Use an empty tagval to clear a tag. When a file is opened in\nREAPER, turn it offline before using this function. Returns false if\nnothing updated. See SNM_ReadMediaFileTag.\n",
        "body": "${1:local }${2:boolean} = reaper.SNM_TagMediaFile(${3:string fn},${4:string tag},${5:string tagval})$0"
    },
    "SNM_TAGMEDIAFILE_WR python": {
        "prefix": "WR_SNM_TagMediaFile",
        "scope": "python",
        "description": "[S&M] Tags a media file thanks to TagLib.\nSupported tags: \"artist\", \"album\", \"genre\", \"comment\", \"title\", or\n\"year\". Use an empty tagval to clear a tag. When a file is opened in\nREAPER, turn it offline before using this function. Returns false if\nnothing updated. See SNM_ReadMediaFileTag.\n",
        "body": "${1:Boolean} = SNM_TagMediaFile(${2:String fn},${3:String tag},${4:String tagval})$0"
    },
    "SNM_TIERESOURCESLOTACTIONS_WR c": {
        "prefix": "WR_SNM_TieResourceSlotActions",
        "scope": "c",
        "description": "[S&M] Attach Resources slot actions to a given bookmark.\n",
        "body": "${1:void} = SNM_TieResourceSlotActions(${2:int bookmarkId})$0"
    },
    "SN_FOCUSMIDIEDITOR_WR c": {
        "prefix": "WR_SN_FocusMIDIEditor",
        "scope": "c",
        "description": "Focuses the active/open MIDI editor.\n",
        "body": "${1:void} = SN_FocusMIDIEditor()$0"
    },
    "ULT_GETMEDIAITEMNOTE_WR c": {
        "prefix": "WR_ULT_GetMediaItemNote",
        "scope": "c",
        "description": "[ULT] Get item notes.\n",
        "body": "${1:const char*} = ULT_GetMediaItemNote(${2:MediaItem* item})$0"
    },
    "REAPER.ULT_GETMEDIAITEMNOTE_WR lua": {
        "prefix": "reaperwr.ULT_GetMediaItemNote",
        "scope": "lua",
        "description": "[ULT] Get item notes.\n",
        "body": "${1:local }${2:string} = reaper.ULT_GetMediaItemNote(${3:MediaItem item})$0"
    },
    "ULT_GETMEDIAITEMNOTE_WR python": {
        "prefix": "WR_ULT_GetMediaItemNote",
        "scope": "python",
        "description": "[ULT] Get item notes.\n",
        "body": "${1:String} = ULT_GetMediaItemNote(${2:MediaItem item})$0"
    },
    "ULT_SETMEDIAITEMNOTE_WR c": {
        "prefix": "WR_ULT_SetMediaItemNote",
        "scope": "c",
        "description": "[ULT] Set item notes.\n",
        "body": "${1:void} = ULT_SetMediaItemNote(${2:MediaItem* item},${3:const char* note})$0"
    },
    "XEN_AUDIOWRITER_CREATE_WR c": {
        "prefix": "WR_Xen_AudioWriter_Create",
        "scope": "c",
        "description": "Creates writer for 32 bit floating point WAV\n",
        "body": "${1:AudioWriter*} = Xen_AudioWriter_Create(${2:const char* filename},${3:int numchans},${4:int samplerate})$0"
    },
    "REAPER.XEN_AUDIOWRITER_CREATE_WR lua": {
        "prefix": "reaperwr.Xen_AudioWriter_Create",
        "scope": "lua",
        "description": "Creates writer for 32 bit floating point WAV\n",
        "body": "${1:local }${2:AudioWriter} = reaper.Xen_AudioWriter_Create(${3:string filename},${4:integer numchans},${5:integer samplerate})$0"
    },
    "XEN_AUDIOWRITER_CREATE_WR python": {
        "prefix": "WR_Xen_AudioWriter_Create",
        "scope": "python",
        "description": "Creates writer for 32 bit floating point WAV\n",
        "body": "${1:AudioWriter} = Xen_AudioWriter_Create(${2:String filename},${3:Int numchans},${4:Int samplerate})$0"
    },
    "XEN_AUDIOWRITER_DESTROY_WR c": {
        "prefix": "WR_Xen_AudioWriter_Destroy",
        "scope": "c",
        "description": "Destroys writer\n",
        "body": "${1:void} = Xen_AudioWriter_Destroy(${2:AudioWriter* writer})$0"
    },
    "XEN_AUDIOWRITER_WRITE_WR c": {
        "prefix": "WR_Xen_AudioWriter_Write",
        "scope": "c",
        "description": "Write interleaved audio data to disk\n",
        "body": "${1:int} = Xen_AudioWriter_Write(${2:AudioWriter* writer},${3:int numframes},${4:void* data},${5:int offset})$0"
    },
    "REAPER.XEN_AUDIOWRITER_WRITE_WR lua": {
        "prefix": "reaperwr.Xen_AudioWriter_Write",
        "scope": "lua",
        "description": "Write interleaved audio data to disk\n",
        "body": "${1:local }${2:integer} = reaper.Xen_AudioWriter_Write(${3:AudioWriter writer},${4:integer numframes},${5:identifier data},${6:integer offset})$0"
    },
    "XEN_AUDIOWRITER_WRITE_WR python": {
        "prefix": "WR_Xen_AudioWriter_Write",
        "scope": "python",
        "description": "Write interleaved audio data to disk\n",
        "body": "${1:Int} = Xen_AudioWriter_Write(${2:AudioWriter writer},${3:Int numframes},${4:void data},${5:Int offset})$0"
    },
    "XEN_GETMEDIASOURCESAMPLES_WR c": {
        "prefix": "WR_Xen_GetMediaSourceSamples",
        "scope": "c",
        "description": "Get interleaved audio data from media source\n",
        "body": "${1:int} = Xen_GetMediaSourceSamples(${2:PCM_source* src},${3:void* destbuf},${4:int destbufoffset},${5:int numframes},${6:int numchans},${7:double samplerate},${8:double sourceposition})$0"
    },
    "REAPER.XEN_GETMEDIASOURCESAMPLES_WR lua": {
        "prefix": "reaperwr.Xen_GetMediaSourceSamples",
        "scope": "lua",
        "description": "Get interleaved audio data from media source\n",
        "body": "${1:local }${2:integer} = reaper.Xen_GetMediaSourceSamples(${3:PCM_source src},${4:identifier destbuf},${5:integer destbufoffset},${6:integer numframes},${7:integer numchans},${8:number samplerate},${9:number sourceposition})$0"
    },
    "XEN_GETMEDIASOURCESAMPLES_WR python": {
        "prefix": "WR_Xen_GetMediaSourceSamples",
        "scope": "python",
        "description": "Get interleaved audio data from media source\n",
        "body": "${1:Int} = Xen_GetMediaSourceSamples(${2:PCM_source src},${3:void destbuf},${4:Int destbufoffset},${5:Int numframes},${6:Int numchans},${7:Float samplerate},${8:Float sourceposition})$0"
    },
    "XEN_STARTSOURCEPREVIEW_WR c": {
        "prefix": "WR_Xen_StartSourcePreview",
        "scope": "c",
        "description": "Start audio preview of a PCM_source. Returns id of a preview handle that can be provided to Xen_StopSourcePreview.\nIf the given PCM_source does not belong to an existing MediaItem/Take,\nit will be deleted by the preview system when the preview is stopped.\n",
        "body": "${1:int} = Xen_StartSourcePreview(${2:PCM_source* source},${3:double gain},${4:bool loop},${5:int* outputchanindexInOptional})$0"
    },
    "REAPER.XEN_STARTSOURCEPREVIEW_WR lua": {
        "prefix": "reaperwr.Xen_StartSourcePreview",
        "scope": "lua",
        "description": "Start audio preview of a PCM_source. Returns id of a preview handle that can be provided to Xen_StopSourcePreview.\nIf the given PCM_source does not belong to an existing MediaItem/Take,\nit will be deleted by the preview system when the preview is stopped.\n",
        "body": "${1:local }${2:integer} = reaper.Xen_StartSourcePreview(${3:PCM_source source},${4:number gain},${5:boolean loop},${6:optional number outputchanindexIn})$0"
    },
    "XEN_STARTSOURCEPREVIEW_WR python": {
        "prefix": "WR_Xen_StartSourcePreview",
        "scope": "python",
        "description": "Start audio preview of a PCM_source. Returns id of a preview handle that can be provided to Xen_StopSourcePreview.\nIf the given PCM_source does not belong to an existing MediaItem/Take,\nit will be deleted by the preview system when the preview is stopped.\n",
        "body": "${1:Int retval},${2:PCM_source source},${3:Float gain},${4:Boolean loop},${5:Int outputchanindexInOptional} = Xen_StartSourcePreview(${6:source},${7:gain},${8:loop},${9:outputchanindexInOptional})$0"
    },
    "XEN_STOPSOURCEPREVIEW_WR c": {
        "prefix": "WR_Xen_StopSourcePreview",
        "scope": "c",
        "description": "Stop audio preview. id -1 stops all.\n",
        "body": "${1:int} = Xen_StopSourcePreview(${2:int preview_id})$0"
    },
    "REAPER.XEN_STOPSOURCEPREVIEW_WR lua": {
        "prefix": "reaperwr.Xen_StopSourcePreview",
        "scope": "lua",
        "description": "Stop audio preview. id -1 stops all.\n",
        "body": "${1:local }${2:integer} = reaper.Xen_StopSourcePreview(${3:integer preview_id})$0"
    },
    "XEN_STOPSOURCEPREVIEW_WR python": {
        "prefix": "WR_Xen_StopSourcePreview",
        "scope": "python",
        "description": "Stop audio preview. id -1 stops all.\n",
        "body": "${1:Int} = Xen_StopSourcePreview(${2:Int preview_id})$0"
    },
    "REAPER.GET_ACTION_CONTEXT_WR lua": {
        "prefix": "reaperwr.get_action_context",
        "scope": "lua",
        "description": "is_new_value,filename,sectionID,cmdID,mode,resolution,val = reaper.get_action_context()\nReturns contextual information about the script, typically MIDI/OSC input values.\nval\nwill be set to a relative or absolute value depending on mode (=0:\nabsolute mode, >0: relative modes). resolution=127 for 7-bit\nresolution, =16383 for 14-bit resolution.\nNotes: sectionID, and cmdID\nwill be set to -1 if the script is not part of the action list. mode,\nresolution and val will be set to -1 if the script was not triggered via\nMIDI/OSC.\n",
        "body": "${1:local }${2:is_new_value},${3:filename},${4:sectionID},${5:cmdID},${6:mode},${7:resolution},${8:val} = reaper.get_action_context()$0"
    },
    "I_TCPY": {
        "prefix": "I_TCPY",
        "body": "I_TCPY",
        "description": "int *, Y offset of envelope relative to parent track (may be  separate lane or overlap with track contents) / int * : current TCP window Y-position in pixels relative to top of arrange view (read-only)\n"
    },
    "I_TCPH": {
        "prefix": "I_TCPH",
        "body": "I_TCPH",
        "description": "int *, visible  height of envelope / int * : current TCP window height in pixels not including envelopes (read-only)\n"
    },
    "I_TCPY_USED": {
        "prefix": "I_TCPY_USED",
        "body": "I_TCPY_USED",
        "description": "int *, Y offset of envelope relative to  parent track, exclusive of padding\n"
    },
    "I_TCPH_USED": {
        "prefix": "I_TCPH_USED",
        "body": "I_TCPH_USED",
        "description": "int *, visible height of  envelope, exclusive of padding\n"
    },
    "P_TRACK": {
        "prefix": "P_TRACK",
        "body": "P_TRACK",
        "description": "MediaTrack *, parent track  pointer (if any) / MediaTrack * (read-only) / pointer to MediaTrack (read-only)\n"
    },
    "P_ITEM": {
        "prefix": "P_ITEM",
        "body": "P_ITEM",
        "description": "MediaItem *, parent item pointer (if any) / pointer to MediaItem (read-only)\n"
    },
    "P_TAKE": {
        "prefix": "P_TAKE",
        "body": "P_TAKE",
        "description": "MediaItem_Take *, parent take pointer (if any)\n"
    },
    "B_MUTE": {
        "prefix": "B_MUTE",
        "body": "B_MUTE",
        "description": "bool * : muted / send mute state (1.0 if muted, otherwise 0.0)\n"
    },
    "B_LOOPSRC": {
        "prefix": "B_LOOPSRC",
        "body": "B_LOOPSRC",
        "description": "bool * : loop source\n"
    },
    "B_ALLTAKESPLAY": {
        "prefix": "B_ALLTAKESPLAY",
        "body": "B_ALLTAKESPLAY",
        "description": "bool * : all takes play\n"
    },
    "B_UISEL": {
        "prefix": "B_UISEL",
        "body": "B_UISEL",
        "description": "bool * : selected in arrange view\n"
    },
    "C_BEATATTACHMODE": {
        "prefix": "C_BEATATTACHMODE",
        "body": "C_BEATATTACHMODE",
        "description": "char * : item timebase, -1=track or project default,  1=beats (position, length, rate), 2=beats (position only). for  auto-stretch timebase: C_BEATATTACHMODE=1, C_AUTOSTRETCH=1 / char * : track timebase, -1=project default, 0=time,  1=beats (position, length, rate), 2=beats (position only)\n"
    },
    "C_AUTOSTRETCH": {
        "prefix": "C_AUTOSTRETCH",
        "body": "C_AUTOSTRETCH",
        "description": ": char * : auto-stretch at project tempo changes, 1=enabled, requires C_BEATATTACHMODE=1\n"
    },
    "C_LOCK": {
        "prefix": "C_LOCK",
        "body": "C_LOCK",
        "description": "char * : locked, &1=locked\n"
    },
    "D_VOL": {
        "prefix": "D_VOL",
        "body": "D_VOL",
        "description": "double * : item volume,  0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc / double * : take volume, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc, negative if take polarity is flipped / double * : trim volume of track, 0=-inf, 0.5=-6dB, 1=+0dB, 2=+6dB, etc / double *, 1.0 = +0dB etc / send volume (1.0=+0dB etc...)\n"
    },
    "D_POSITION": {
        "prefix": "D_POSITION",
        "body": "D_POSITION",
        "description": "double * : item position in seconds / double * : automation item timeline position in seconds\n"
    },
    "D_LENGTH": {
        "prefix": "D_LENGTH",
        "body": "D_LENGTH",
        "description": "double * : item length in seconds / double * : automation item length in seconds\n"
    },
    "D_SNAPOFFSET": {
        "prefix": "D_SNAPOFFSET",
        "body": "D_SNAPOFFSET",
        "description": "double * : item snap offset in seconds\n"
    },
    "D_FADEINLEN": {
        "prefix": "D_FADEINLEN",
        "body": "D_FADEINLEN",
        "description": "double * : item manual fadein length in seconds\n"
    },
    "D_FADEOUTLEN": {
        "prefix": "D_FADEOUTLEN",
        "body": "D_FADEOUTLEN",
        "description": "double * : item manual fadeout length in seconds\n"
    },
    "D_FADEINDIR": {
        "prefix": "D_FADEINDIR",
        "body": "D_FADEINDIR",
        "description": "double * : item fadein curvature, -1..1\n"
    },
    "D_FADEOUTDIR": {
        "prefix": "D_FADEOUTDIR",
        "body": "D_FADEOUTDIR",
        "description": "double * : item fadeout curvature, -1..1\n"
    },
    "D_FADEINLEN_AUTO": {
        "prefix": "D_FADEINLEN_AUTO",
        "body": "D_FADEINLEN_AUTO",
        "description": "double * : item auto-fadein length in seconds, -1=no auto-fadein\n"
    },
    "D_FADEOUTLEN_AUTO": {
        "prefix": "D_FADEOUTLEN_AUTO",
        "body": "D_FADEOUTLEN_AUTO",
        "description": "double * : item auto-fadeout length in seconds, -1=no auto-fadeout\n"
    },
    "C_FADEINSHAPE": {
        "prefix": "C_FADEINSHAPE",
        "body": "C_FADEINSHAPE",
        "description": "int * : fadein shape, 0..6, 0=linear\n"
    },
    "C_FADEOUTSHAPE": {
        "prefix": "C_FADEOUTSHAPE",
        "body": "C_FADEOUTSHAPE",
        "description": "int * : fadeout shape, 0..6, 0=linear\n"
    },
    "I_GROUPID": {
        "prefix": "I_GROUPID",
        "body": "I_GROUPID",
        "description": "int * : group ID, 0=no group\n"
    },
    "I_LASTY": {
        "prefix": "I_LASTY",
        "body": "I_LASTY",
        "description": "int * : Y-position of track in pixels (read-only)\n"
    },
    "I_LASTH": {
        "prefix": "I_LASTH",
        "body": "I_LASTH",
        "description": "int * : height in track in pixels (read-only)\n"
    },
    "I_CUSTOMCOLOR": {
        "prefix": "I_CUSTOMCOLOR",
        "body": "I_CUSTOMCOLOR",
        "description": "int * : custom color, OS dependent color|0x100000 (i.e.  ColorToNative(r,g,b)|0x100000). If you do not |0x100000, then it will  not be used, but will store the color anyway)\n"
    },
    "I_CURTAKE": {
        "prefix": "I_CURTAKE",
        "body": "I_CURTAKE",
        "description": "int * : active take number\n"
    },
    "IP_ITEMNUMBER": {
        "prefix": "IP_ITEMNUMBER",
        "body": "IP_ITEMNUMBER",
        "description": "int, item number on this track (read-only, returns the item number directly)\n"
    },
    "F_FREEMODE_Y": {
        "prefix": "F_FREEMODE_Y",
        "body": "F_FREEMODE_Y",
        "description": "float * : free item positioning Y-position, 0=top of track, 1=bottom of track (will never be 1)\n"
    },
    "F_FREEMODE_H": {
        "prefix": "F_FREEMODE_H",
        "body": "F_FREEMODE_H",
        "description": "float * : free item positioning height, 0=no height, 1=full height of track (will never be 0)\n"
    },
    "D_STARTOFFS": {
        "prefix": "D_STARTOFFS",
        "body": "D_STARTOFFS",
        "description": "double * : start offset in source media, in seconds / double * : automation item start offset in seconds\n"
    },
    "D_PAN": {
        "prefix": "D_PAN",
        "body": "D_PAN",
        "description": "double * : take pan, -1..1 / double * : trim pan of track, -1..1 / double *, -1..+1 / send pan (-1.0=100%L, 0=center, 1.0=100%R)\n"
    },
    "D_PANLAW": {
        "prefix": "D_PANLAW",
        "body": "D_PANLAW",
        "description": "double * : take pan law, -1=default, 0.5=-6dB, 1.0=+0dB, etc / double * : pan law of track, <0=project default, 1=+0dB, etc / double *,1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc / send pan law (1.0=+0.0db, 0.5=-6dB, -1.0=project default etc...)\n"
    },
    "D_PLAYRATE": {
        "prefix": "D_PLAYRATE",
        "body": "D_PLAYRATE",
        "description": "double * : take playback rate, 0.5=half speed, 1=normal, 2=double speed, etc / double * : automation item playback rate\n"
    },
    "D_PITCH": {
        "prefix": "D_PITCH",
        "body": "D_PITCH",
        "description": "double * : take pitch adjustment in semitones, -12=one octave down, 0=normal, +12=one octave up, etc\n"
    },
    "B_PPITCH": {
        "prefix": "B_PPITCH",
        "body": "B_PPITCH",
        "description": "bool * : preserve pitch when changing playback rate\n"
    },
    "I_CHANMODE": {
        "prefix": "I_CHANMODE",
        "body": "I_CHANMODE",
        "description": "int * : channel mode, 0=normal, 1=reverse stereo, 2=downmix, 3=left, 4=right\n"
    },
    "I_PITCHMODE": {
        "prefix": "I_PITCHMODE",
        "body": "I_PITCHMODE",
        "description": "int * : pitch shifter mode, -1=projext default, otherwise high 2 bytes=shifter, low 2 bytes=parameter\n"
    },
    "IP_TAKENUMBER": {
        "prefix": "IP_TAKENUMBER",
        "body": "IP_TAKENUMBER",
        "description": "int : take number (read-only, returns the take number directly)\n"
    },
    "P_SOURCE": {
        "prefix": "P_SOURCE",
        "body": "P_SOURCE",
        "description": "PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.\n"
    },
    "B_PHASE": {
        "prefix": "B_PHASE",
        "body": "B_PHASE",
        "description": "bool * : track phase inverted / bool *, true to flip phase / send phase state (1.0 if phase is inverted, otherwise 0.0)\n"
    },
    "IP_TRACKNUMBER": {
        "prefix": "IP_TRACKNUMBER",
        "body": "IP_TRACKNUMBER",
        "description": "int : track number 1-based, 0=not found, -1=master track (read-only, returns the int directly)\n"
    },
    "I_SOLO": {
        "prefix": "I_SOLO",
        "body": "I_SOLO",
        "description": "int * : soloed, 0=not soloed, 1=soloed, 2=soloed in place, 5=safe soloed, 6=safe soloed in place\n"
    },
    "I_FXEN": {
        "prefix": "I_FXEN",
        "body": "I_FXEN",
        "description": "int * : fx enabled, 0=bypassed, !0=fx active\n"
    },
    "I_RECARM": {
        "prefix": "I_RECARM",
        "body": "I_RECARM",
        "description": "int * : record armed, 0=not record armed, 1=record armed\n"
    },
    "I_RECINPUT": {
        "prefix": "I_RECINPUT",
        "body": "I_RECINPUT",
        "description": "int * : record input, <0=no input, 0..n=mono hardware  input, 512+n=rearoute input, &1024=stereo input pair. &4096=MIDI  input, if set then low 5 bits represent channel (0=all, 1-16=only  chan), next 6 bits represent physical input (63=all, 62=VKB)\n"
    },
    "I_RECMODE": {
        "prefix": "I_RECMODE",
        "body": "I_RECMODE",
        "description": "int * : record mode, 0=input, 1=stereo out, 2=none, 3=stereo  out w/latency compensation, 4=midi output, 5=mono out, 6=mono out w/  latency compensation, 7=midi overdub, 8=midi replace\n"
    },
    "I_RECMON": {
        "prefix": "I_RECMON",
        "body": "I_RECMON",
        "description": "int * : record monitoring, 0=off, 1=normal, 2=not when playing (tape style)\n"
    },
    "I_RECMONITEMS": {
        "prefix": "I_RECMONITEMS",
        "body": "I_RECMONITEMS",
        "description": "int * : monitor items while recording, 0=off, 1=on\n"
    },
    "I_AUTOMODE": {
        "prefix": "I_AUTOMODE",
        "body": "I_AUTOMODE",
        "description": "int * : track automation mode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch / int * : automation mode (-1=use track automode, 0=trim/off, 1=read, 2=touch, 3=write, 4=latch)\n"
    },
    "I_NCHAN": {
        "prefix": "I_NCHAN",
        "body": "I_NCHAN",
        "description": "int * : number of track channels, 2-64, even numbers only\n"
    },
    "I_SELECTED": {
        "prefix": "I_SELECTED",
        "body": "I_SELECTED",
        "description": "int * : track selected, 0=unselected, 1=selected\n"
    },
    "I_WNDH": {
        "prefix": "I_WNDH",
        "body": "I_WNDH",
        "description": "int * : current TCP window height in pixels including envelopes (read-only)\n"
    },
    "I_MCPX": {
        "prefix": "I_MCPX",
        "body": "I_MCPX",
        "description": "int * : current MCP X-position in pixels relative to mixer container\n"
    },
    "I_MCPY": {
        "prefix": "I_MCPY",
        "body": "I_MCPY",
        "description": "int * : current MCP Y-position in pixels relative to mixer container\n"
    },
    "I_MCPW": {
        "prefix": "I_MCPW",
        "body": "I_MCPW",
        "description": "int * : current MCP width in pixels\n"
    },
    "I_MCPH": {
        "prefix": "I_MCPH",
        "body": "I_MCPH",
        "description": "int * : current MCP height in pixels\n"
    },
    "I_FOLDERDEPTH": {
        "prefix": "I_FOLDERDEPTH",
        "body": "I_FOLDERDEPTH",
        "description": "int * : folder depth change, 0=normal, 1=track is a  folder parent, -1=track is the last in the innermost folder, -2=track is  the last in the innermost and next-innermost folders, etc\n"
    },
    "I_FOLDERCOMPACT": {
        "prefix": "I_FOLDERCOMPACT",
        "body": "I_FOLDERCOMPACT",
        "description": "int * : folder compacted state (only valid on folders), 0=normal, 1=small, 2=tiny children\n"
    },
    "I_MIDIHWOUT": {
        "prefix": "I_MIDIHWOUT",
        "body": "I_MIDIHWOUT",
        "description": "int * : track midi hardware output index, <0=disabled,  low 5 bits are which channels (0=all, 1-16), next 5 bits are output  device index (0-31)\n"
    },
    "I_PERFFLAGS": {
        "prefix": "I_PERFFLAGS",
        "body": "I_PERFFLAGS",
        "description": "int * : track performance flags, &1=no media buffering, &2=no anticipative FX\n"
    },
    "I_HEIGHTOVERRIDE": {
        "prefix": "I_HEIGHTOVERRIDE",
        "body": "I_HEIGHTOVERRIDE",
        "description": "int * : custom height override for TCP window, 0 for none, otherwise size in pixels\n"
    },
    "B_HEIGHTLOCK": {
        "prefix": "B_HEIGHTLOCK",
        "body": "B_HEIGHTLOCK",
        "description": "bool * : track height lock (must set I_HEIGHTOVERRIDE before locking)\n"
    },
    "D_WIDTH": {
        "prefix": "D_WIDTH",
        "body": "D_WIDTH",
        "description": "double * : width of track, -1..1\n"
    },
    "D_DUALPANL": {
        "prefix": "D_DUALPANL",
        "body": "D_DUALPANL",
        "description": "double * : dualpan position 1, -1..1, only if I_PANMODE==6\n"
    },
    "D_DUALPANR": {
        "prefix": "D_DUALPANR",
        "body": "D_DUALPANR",
        "description": "double * : dualpan position 2, -1..1, only if I_PANMODE==6\n"
    },
    "I_PANMODE": {
        "prefix": "I_PANMODE",
        "body": "I_PANMODE",
        "description": "int * : pan mode, 0=classic 3.x, 3=new balance, 5=stereo pan, 6=dual pan\n"
    },
    "P_ENV:<ENVCHUNKNAME": {
        "prefix": "P_ENV:<envchunkname",
        "body": "P_ENV:<envchunkname",
        "description": "TrackEnvelope*, read only. Call with :<VOLENV, :<PANENV, etc appended. / read only, returns TrackEnvelope *. Call with :<VOLENV, :<PANENV, etc appended.\n"
    },
    "B_SHOWINMIXER": {
        "prefix": "B_SHOWINMIXER",
        "body": "B_SHOWINMIXER",
        "description": "bool * : track control panel visible in mixer (do not use on master track)\n"
    },
    "B_SHOWINTCP": {
        "prefix": "B_SHOWINTCP",
        "body": "B_SHOWINTCP",
        "description": "bool * : track control panel visible in arrange view (do not use on master track)\n"
    },
    "B_MAINSEND": {
        "prefix": "B_MAINSEND",
        "body": "B_MAINSEND",
        "description": "bool * : track sends audio to parent\n"
    },
    "C_MAINSEND_OFFS": {
        "prefix": "C_MAINSEND_OFFS",
        "body": "C_MAINSEND_OFFS",
        "description": "char * : channel offset of track send to parent\n"
    },
    "B_FREEMODE": {
        "prefix": "B_FREEMODE",
        "body": "B_FREEMODE",
        "description": "bool * : track free item positioning enabled (call UpdateTimeline() after changing)\n"
    },
    "F_MCP_FXSEND_SCALE": {
        "prefix": "F_MCP_FXSEND_SCALE",
        "body": "F_MCP_FXSEND_SCALE",
        "description": "float * : scale of fx+send area in MCP (0=minimum allowed, 1=maximum allowed)\n"
    },
    "F_MCP_SENDRGN_SCALE": {
        "prefix": "F_MCP_SENDRGN_SCALE",
        "body": "F_MCP_SENDRGN_SCALE",
        "description": "float * : scale of send area as proportion of the  fx+send total area (0=minimum allowed, 1=maximum allowed)\n"
    },
    "I_PLAY_OFFSET_FLAG": {
        "prefix": "I_PLAY_OFFSET_FLAG",
        "body": "I_PLAY_OFFSET_FLAG",
        "description": "int * : track playback offset state,  &1=bypassed, &2=offset value is measured in samples (otherwise  measured in seconds)\n"
    },
    "D_PLAY_OFFSET": {
        "prefix": "D_PLAY_OFFSET",
        "body": "D_PLAY_OFFSET",
        "description": "double * : track playback offset, units depend on I_PLAY_OFFSET_FLAG\n"
    },
    "P_PARTRACK": {
        "prefix": "P_PARTRACK",
        "body": "P_PARTRACK",
        "description": "MediaTrack * : parent track (read-only)\n"
    },
    "P_PROJECT": {
        "prefix": "P_PROJECT",
        "body": "P_PROJECT",
        "description": "ReaProject * : parent project (read-only)\n"
    },
    "D_POOL_ID": {
        "prefix": "D_POOL_ID",
        "body": "D_POOL_ID",
        "description": "double * : automation item pool ID (as an integer); edits  are propagated to all other automation items that share a pool ID\n"
    },
    "D_BASELINE": {
        "prefix": "D_BASELINE",
        "body": "D_BASELINE",
        "description": "double * : automation item baseline value in the range [0,1]\n"
    },
    "D_AMPLITUDE": {
        "prefix": "D_AMPLITUDE",
        "body": "D_AMPLITUDE",
        "description": "double * : automation item amplitude in the range [-1,1]\n"
    },
    "D_LOOPSRC": {
        "prefix": "D_LOOPSRC",
        "body": "D_LOOPSRC",
        "description": "double * : nonzero if the automation item contents are looped\n"
    },
    "D_UISEL": {
        "prefix": "D_UISEL",
        "body": "D_UISEL",
        "description": "double * : nonzero if the automation item is selected in the arrange view\n"
    },
    "D_POOL_QNLEN": {
        "prefix": "D_POOL_QNLEN",
        "body": "D_POOL_QNLEN",
        "description": "double * : automation item pooled source length in quarter notes (setting will affect all pooled instances)\n"
    },
    "P_POOL_NAME": {
        "prefix": "P_POOL_NAME",
        "body": "P_POOL_NAME",
        "description": "char *, name of the underlying automation item pool\n"
    },
    "P_POOL_EXT:XYZ": {
        "prefix": "P_POOL_EXT:xyz",
        "body": "P_POOL_EXT:xyz",
        "description": "char *, extension-specific persistent data\n"
    },
    "P_EXT:XYZ": {
        "prefix": "P_EXT:xyz",
        "body": "P_EXT:xyz",
        "description": "char * : extension-specific persistent data\n"
    },
    "P_NOTES": {
        "prefix": "P_NOTES",
        "body": "P_NOTES",
        "description": "char * : item note text (do not write to returned pointer, use setNewValue to update)\n"
    },
    "GUID": {
        "prefix": "GUID",
        "body": "GUID",
        "description": "GUID * : 16-byte GUID, can query or update. If using a _String() function, GUID is a string {xyz-...}.\n"
    },
    "P_NAME": {
        "prefix": "P_NAME",
        "body": "P_NAME",
        "description": "char * to take name / char * : track name (on master returns NULL)\n"
    },
    "P_ICON": {
        "prefix": "P_ICON",
        "body": "P_ICON",
        "description": "const char * : track icon (full filename, or relative to resource_path/data/track_icons)\n"
    },
    "P_MCP_LAYOUT": {
        "prefix": "P_MCP_LAYOUT",
        "body": "P_MCP_LAYOUT",
        "description": "const char * : layout name\n"
    },
    "P_TCP_LAYOUT": {
        "prefix": "P_TCP_LAYOUT",
        "body": "P_TCP_LAYOUT",
        "description": "const char * : layout name\n"
    },
    "RENDER_SETTINGS": {
        "prefix": "RENDER_SETTINGS",
        "body": "RENDER_SETTINGS",
        "description": "&(1|2)=0:master mix, &1=stems+master mix,  &2=stems only, &4=multichannel tracks to multichannel files,  &8=use render matrix, &16=tracks with only mono media to mono  files, &32=selected media items, &64=selected media items via  master\n"
    },
    "RENDER_BOUNDSFLAG": {
        "prefix": "RENDER_BOUNDSFLAG",
        "body": "RENDER_BOUNDSFLAG",
        "description": "0=custom time bounds, 1=entire project, 2=time  selection, 3=all project regions, 4=selected media items, 5=selected  project regions\n"
    },
    "RENDER_CHANNELS": {
        "prefix": "RENDER_CHANNELS",
        "body": "RENDER_CHANNELS",
        "description": "number of channels in rendered file\n"
    },
    "RENDER_SRATE": {
        "prefix": "RENDER_SRATE",
        "body": "RENDER_SRATE",
        "description": "sample rate of rendered file (or 0 for project sample rate)\n"
    },
    "RENDER_STARTPOS": {
        "prefix": "RENDER_STARTPOS",
        "body": "RENDER_STARTPOS",
        "description": "render start time when RENDER_BOUNDSFLAG=0\n"
    },
    "RENDER_ENDPOS": {
        "prefix": "RENDER_ENDPOS",
        "body": "RENDER_ENDPOS",
        "description": "render end time when RENDER_BOUNDSFLAG=0\n"
    },
    "RENDER_TAILFLAG": {
        "prefix": "RENDER_TAILFLAG",
        "body": "RENDER_TAILFLAG",
        "description": "apply render tail setting when rendering:  &1=custom time bounds, &2=entire project, &4=time selection,  &8=all project regions, &16=selected media items,  &32=selected project regions\n"
    },
    "RENDER_TAILMS": {
        "prefix": "RENDER_TAILMS",
        "body": "RENDER_TAILMS",
        "description": "tail length in ms to render (only used if RENDER_BOUNDSFLAG and RENDER_TAILFLAG are set)\n"
    },
    "RENDER_ADDTOPROJ": {
        "prefix": "RENDER_ADDTOPROJ",
        "body": "RENDER_ADDTOPROJ",
        "description": "1=add rendered files to project\n"
    },
    "RENDER_DITHER": {
        "prefix": "RENDER_DITHER",
        "body": "RENDER_DITHER",
        "description": "&1=dither, &2=noise shaping, &4=dither stems, &8=noise shaping on stems\n"
    },
    "PROJECT_SRATE": {
        "prefix": "PROJECT_SRATE",
        "body": "PROJECT_SRATE",
        "description": "samplerate (ignored unless PROJECT_SRATE_USE set)\n"
    },
    "PROJECT_SRATE_USE": {
        "prefix": "PROJECT_SRATE_USE",
        "body": "PROJECT_SRATE_USE",
        "description": "set to 1 if project samplerate is used\n"
    },
    "MARKER_GUID:X": {
        "prefix": "MARKER_GUID:X",
        "body": "MARKER_GUID:X",
        "description": "get the GUID (unique ID) of the marker or region with  index X, where X is the index passed to EnumProjectMarkers, not  necessarily the displayed number\n"
    },
    "RECORD_PATH": {
        "prefix": "RECORD_PATH",
        "body": "RECORD_PATH",
        "description": "recording directory -- may be blank or a relative path, to get the effective path see GetProjectPathEx()\n"
    },
    "RENDER_FILE": {
        "prefix": "RENDER_FILE",
        "body": "RENDER_FILE",
        "description": "render directory\n"
    },
    "RENDER_PATTERN": {
        "prefix": "RENDER_PATTERN",
        "body": "RENDER_PATTERN",
        "description": "render file name (may contain wildcards)\n"
    },
    "RENDER_FORMAT": {
        "prefix": "RENDER_FORMAT",
        "body": "RENDER_FORMAT",
        "description": "base64-encoded sink configuration (see project files,  etc). Callers can also pass a simple 4-byte string (non-base64-encoded),  e.g. \"evaw\" or \"l3pm\", to use default settings for that sink type.\n"
    },
    "RENDER_FORMAT2": {
        "prefix": "RENDER_FORMAT2",
        "body": "RENDER_FORMAT2",
        "description": "base64-encoded secondary sink configuration. Callers  can also pass a simple 4-byte string (non-base64-encoded), e.g. \"evaw\"  or \"l3pm\", to use default settings for that sink type, or \"\" to disable  secondary render.\n"
    },
    "B_MONO": {
        "prefix": "B_MONO",
        "body": "B_MONO",
        "description": "bool * / send mono state (1.0 if send is set to mono, otherwise 0.0)\n"
    },
    "I_SENDMODE": {
        "prefix": "I_SENDMODE",
        "body": "I_SENDMODE",
        "description": "int *, 0=post-fader, 1=pre-fx, 2=post-fx (deprecated), 3=post-fx / send mode (0=post-fader, 1=pre-fx, 2=post-fx(deprecated), 3=post-fx)\n"
    },
    "I_SRCCHAN": {
        "prefix": "I_SRCCHAN",
        "body": "I_SRCCHAN",
        "description": "int *, index,&1024=mono, -1 for none / audio source starting channel index or -1 if audio send is  disabled (&1024=mono...note that in that case, when reading index,  you should do (index XOR 1024) to get starting channel index)\n"
    },
    "I_DSTCHAN": {
        "prefix": "I_DSTCHAN",
        "body": "I_DSTCHAN",
        "description": "int *, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute / audio destination starting channel index (&1024=mono  (and in case of hardware output &512=rearoute)...note that in that  case, when reading index, you should do (index XOR (1024 OR 512)) to get  starting channel index)\n"
    },
    "I_MIDIFLAGS": {
        "prefix": "I_MIDIFLAGS",
        "body": "I_MIDIFLAGS",
        "description": "int *, low 5 bits=source channel 0=all, 1-16, next 5  bits=dest channel, 0=orig, 1-16=chan / int *, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chanSee CreateTrackSend, RemoveTrackSend, GetTrackNumSends.\n"
    },
    "P_DESTTRACK": {
        "prefix": "P_DESTTRACK",
        "body": "P_DESTTRACK",
        "description": "read only, returns  MediaTrack *, destination track, only applies for sends/recvs\n"
    },
    "P_SRCTRACK": {
        "prefix": "P_SRCTRACK",
        "body": "P_SRCTRACK",
        "description": "read only, returns MediaTrack *, source track, only applies for sends/recvs\n"
    },
    "I_MIDI_SRCCHAN": {
        "prefix": "I_MIDI_SRCCHAN",
        "body": "I_MIDI_SRCCHAN",
        "description": "source MIDI channel, -1 if MIDI send is disabled (0=all, 1-16)\n"
    },
    "I_MIDI_DSTCHAN": {
        "prefix": "I_MIDI_DSTCHAN",
        "body": "I_MIDI_DSTCHAN",
        "description": "destination MIDI channel, -1 if MIDI send is disabled (0=original, 1-16)\n"
    },
    "I_MIDI_SRCBUS": {
        "prefix": "I_MIDI_SRCBUS",
        "body": "I_MIDI_SRCBUS",
        "description": "source MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\n"
    },
    "I_MIDI_DSTBUS": {
        "prefix": "I_MIDI_DSTBUS",
        "body": "I_MIDI_DSTBUS",
        "description": "receive MIDI bus, -1 if MIDI send is disabled (0=all, otherwise bus index)\n"
    },
    "I_MIDI_LINK_VOLPAN": {
        "prefix": "I_MIDI_LINK_VOLPAN",
        "body": "I_MIDI_LINK_VOLPAN",
        "description": "link volume/pan controls to MIDI\n"
    },
    "GFX_R eel2": {
        "prefix": "gfx_r",
        "scope": "eel2",
        "body": "gfx_r",
        "description": "These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). gfx_a2 is the value written to the alpha channel when writing solid colors (normally ignored but useful when creating transparent images)\n\n"
    },
    "GFX_G eel2": {
        "prefix": "gfx_g",
        "scope": "eel2",
        "body": "gfx_g",
        "description": "These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). gfx_a2 is the value written to the alpha channel when writing solid colors (normally ignored but useful when creating transparent images)\n\n"
    },
    "GFX_B eel2": {
        "prefix": "gfx_b",
        "scope": "eel2",
        "body": "gfx_b",
        "description": "These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). gfx_a2 is the value written to the alpha channel when writing solid colors (normally ignored but useful when creating transparent images)\n\n"
    },
    "GFX_A2 eel2": {
        "prefix": "gfx_a2",
        "scope": "eel2",
        "body": "gfx_a2",
        "description": "Alpha and blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit(). \n\n"
    },
    "GFX_A eel2": {
        "prefix": "gfx_a",
        "scope": "eel2",
        "body": "gfx_a",
        "description": "These are set to the current width and height of the UI framebuffer. \n\n"
    },
    "GFX_MODE eel2": {
        "prefix": "gfx_mode",
        "scope": "eel2",
        "body": "gfx_mode",
        "description": "These are set to the current width and height of the UI framebuffer. \n\n"
    },
    "GFX_W eel2": {
        "prefix": "gfx_w",
        "scope": "eel2",
        "body": "gfx_w",
        "description": "mouse_x and mouse_y are set to the coordinates of the mouse relative to the graphics window.\n\n"
    },
    "GFX_H eel2": {
        "prefix": "gfx_h",
        "scope": "eel2",
        "body": "gfx_h",
        "description": "mouse_x and mouse_y are set to the coordinates of the mouse relative to the graphics window.\n\n"
    },
    "GFX_X eel2": {
        "prefix": "gfx_x",
        "scope": "eel2",
        "body": "gfx_x",
        "description": "These set the \"current\" graphics position in x,y. You can set these yourselves, and many of the drawing functions update them as well. \n\n"
    },
    "GFX_Y eel2": {
        "prefix": "gfx_y",
        "scope": "eel2",
        "body": "gfx_y",
        "description": "These set the \"current\" graphics position in x,y. You can set these yourselves, and many of the drawing functions update them as well. \n\n"
    },
    "GFX_CLEAR eel2": {
        "prefix": "gfx_clear",
        "scope": "eel2",
        "body": "gfx_clear",
        "description": "If set to a value greater than -1.0, this will result in the framebuffer being cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black). \n\n"
    },
    "GFX_DEST eel2": {
        "prefix": "gfx_dest",
        "scope": "eel2",
        "body": "gfx_dest",
        "description": "Defaults to -1, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n\n"
    },
    "GFX_TEXTH eel2": {
        "prefix": "gfx_texth",
        "scope": "eel2",
        "body": "gfx_texth",
        "description": "Set to the height of a line of text in the current font. Do not modify this variable.\n\n"
    },
    "GFX_EXT_RETINA eel2": {
        "prefix": "gfx_ext_retina",
        "scope": "eel2",
        "body": "gfx_ext_retina",
        "description": "If set to 1.0 on initialization, will be updated to 2.0 if high resolution display is supported, and if so gfx_w/gfx_h/etc will be doubled.\n\n"
    },
    "GFX.R lua": {
        "prefix": "gfx.r",
        "scope": "lua",
        "body": "gfx.r",
        "description": "These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). gfx.a2 is the value written to the alpha channel when writing solid colors (normally ignored but useful when creating transparent images)\n\n"
    },
    "GFX.G lua": {
        "prefix": "gfx.g",
        "scope": "lua",
        "body": "gfx.g",
        "description": "These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). gfx.a2 is the value written to the alpha channel when writing solid colors (normally ignored but useful when creating transparent images)\n\n"
    },
    "GFX.B lua": {
        "prefix": "gfx.b",
        "scope": "lua",
        "body": "gfx.b",
        "description": "These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). gfx.a2 is the value written to the alpha channel when writing solid colors (normally ignored but useful when creating transparent images)\n\n"
    },
    "GFX.A2 lua": {
        "prefix": "gfx.a2",
        "scope": "lua",
        "body": "gfx.a2",
        "description": "Alpha and blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx.a to negative and use gfx.mode as additive). Add 2.0 to disable source alpha for gfx.blit(). Add 4.0 to disable filtering for gfx.blit(). \n\n"
    },
    "GFX.A lua": {
        "prefix": "gfx.a",
        "scope": "lua",
        "body": "gfx.a",
        "description": "These are set to the current width and height of the UI framebuffer. \n\n"
    },
    "GFX.MODE lua": {
        "prefix": "gfx.mode",
        "scope": "lua",
        "body": "gfx.mode",
        "description": "These are set to the current width and height of the UI framebuffer. \n\n"
    },
    "GFX.W lua": {
        "prefix": "gfx.w",
        "scope": "lua",
        "body": "gfx.w",
        "description": "gfx.mouse_x and gfx.mouse_y are set to the coordinates of the mouse relative to the graphics window.\n\n"
    },
    "GFX.H lua": {
        "prefix": "gfx.h",
        "scope": "lua",
        "body": "gfx.h",
        "description": "gfx.mouse_x and gfx.mouse_y are set to the coordinates of the mouse relative to the graphics window.\n\n"
    },
    "GFX.X lua": {
        "prefix": "gfx.x",
        "scope": "lua",
        "body": "gfx.x",
        "description": "These set the \"current\" graphics position in x,y. You can set these yourselves, and many of the drawing functions update them as well. \n\n"
    },
    "GFX.Y lua": {
        "prefix": "gfx.y",
        "scope": "lua",
        "body": "gfx.y",
        "description": "These set the \"current\" graphics position in x,y. You can set these yourselves, and many of the drawing functions update them as well. \n\n"
    },
    "GFX.CLEAR lua": {
        "prefix": "gfx.clear",
        "scope": "lua",
        "body": "gfx.clear",
        "description": "If set to a value greater than -1.0, this will result in the framebuffer being cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black). \n\n"
    },
    "GFX.DEST lua": {
        "prefix": "gfx.dest",
        "scope": "lua",
        "body": "gfx.dest",
        "description": "Defaults to -1, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n\n"
    },
    "GFX.TEXTH lua": {
        "prefix": "gfx.texth",
        "scope": "lua",
        "body": "gfx.texth",
        "description": "Set to the height of a line of text in the current font. Do not modify this variable.\n\n"
    },
    "GFX.EXT_RETINA lua": {
        "prefix": "gfx.ext_retina",
        "scope": "lua",
        "body": "gfx.ext_retina",
        "description": "If set to 1.0 on initialization, will be updated to 2.0 if high resolution display is supported, and if so gfx.w/gfx.h/etc will be doubled.\n\n"
    },
    "GFX.MOUSE_X lua": {
        "prefix": "gfx.mouse_x",
        "scope": "lua",
        "body": "gfx.mouse_x",
        "description": "mouse wheel (and horizontal wheel) positions. These will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n\n"
    },
    "GFX.MOUSE_Y lua": {
        "prefix": "gfx.mouse_y",
        "scope": "lua",
        "body": "gfx.mouse_y",
        "description": "mouse wheel (and horizontal wheel) positions. These will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n\n"
    },
    "GFX.MOUSE_WHEEL lua": {
        "prefix": "gfx.mouse_wheel",
        "scope": "lua",
        "body": "gfx.mouse_wheel",
        "description": "mouse wheel (and horizontal wheel) positions. These will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n\n"
    },
    "GFX.MOUSE_HWHEEL lua": {
        "prefix": "gfx.mouse_hwheel",
        "scope": "lua",
        "body": "gfx.mouse_hwheel",
        "description": "mouse wheel (and horizontal wheel) positions. These will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n\n"
    },
    "GFX.MOUSE_CAP lua": {
        "prefix": "gfx.mouse_cap",
        "scope": "lua",
        "body": "gfx.mouse_cap",
        "description": " is a bitfield of mouse and keyboard modifier state.1: left mouse button2: right mouse button4: Control key8: Shift key16: Alt key32: Windows key64: middle mouse button\n\n\n"
    }
}